// Copyright 2023 cloudeng llc. All rights reserved.
// Use of this source code is governed by the Apache-2.0
// license that can be found in the LICENSE file.

package operations

import (
	"context"
	"net/http"
)

// Paginator represents the ability to generate the next request (URL with optional
// body) given the response from the previous request. Paginators
// are typically used with Scanners to iterate over a paginated API.
type Paginator[T any] interface {
	// Next is called with the returned type and response for that operation.
	// The first URL to use in a scan is generated by calling Next with an empty
	// payload and nil *http.Response
	Next(t T, r *http.Response) (req *http.Request, done bool, err error)

	// Save allows for checkpointing of the Paginator's state. Save is called
	// whenever a response is successfully received from the server. The
	// implementation of the Paginator is responsible for loading checkpoints
	// when the Paginator is created.
	Save()
}

type response[T any] struct {
	response T
	body     []byte
	last     bool
	nextURL  string
	nextReq  *http.Request
	err      error
}

// Scanner provides the ability to iterate over a paginated API a page at a time.
type Scanner[T any] struct {
	err       error
	done      bool
	paginator Paginator[T]
	ep        *Endpoint[T]
	ch        chan response[T]
	resp      response[T]
	opts      []Option
}

// NewScanner creates a new Scanner using the supplied paginator. The
// options are used to create the underlying Endpoint.
func NewScanner[T any](paginator Paginator[T], opts ...Option) *Scanner[T] {
	return &Scanner[T]{
		paginator: paginator,
		ch:        make(chan response[T], 1),
		opts:      opts,
	}
}

func (sc *Scanner[T]) first(ctx context.Context) (bool, error) {
	var empty T
	req, done, err := sc.paginator.Next(empty, nil)
	if err != nil || done {
		return done, err
	}
	sc.ep = NewEndpoint[T](sc.opts...)
	go sc.get(ctx, req)
	return false, nil
}

// Scan iterates over the paginated API. It returns true if there is another
// page to scan, false otherwise.
func (sc *Scanner[T]) Scan(ctx context.Context) bool {
	if sc.done || sc.err != nil {
		return false
	}
	if sc.ep == nil {
		sc.done, sc.err = sc.first(ctx)
		if sc.err != nil || sc.done {
			return false
		}
	}
	resp := <-sc.ch
	if err := resp.err; err != nil {
		sc.err = err
		return false
	}
	if resp.last {
		sc.done = true
	}
	sc.resp = resp
	go sc.get(ctx, resp.nextReq)
	return true
}

// Response returns the response for the current page.
func (sc *Scanner[T]) Response() T {
	return sc.resp.response
}

// Body returns the body for the current page.
func (sc *Scanner[T]) Body() []byte {
	return sc.resp.body
}

func (sc *Scanner[T]) get(ctx context.Context, req *http.Request) {
	payload, resp, body, err := sc.ep.getWithResp(ctx, req)
	if err != nil {
		sc.ch <- response[T]{response: payload, body: body, last: true, err: err}
		return
	}
	sc.paginator.Save()
	req, last, err := sc.paginator.Next(payload, resp)
	if err != nil {
		sc.ch <- response[T]{response: payload, body: body, last: true, err: err}
		return
	}
	sc.ch <- response[T]{
		response: payload,
		body:     body,
		last:     last,
		err:      nil,
		nextReq:  req,
	}
}

// Err returns the first error encountered during scanning.
func (sc *Scanner[T]) Err() error {
	return sc.err
}

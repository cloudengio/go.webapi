// Package benchlingsdk provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.2 DO NOT EDIT.
package benchlingsdk

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BasicApiKeyAuthScopes         = "basicApiKeyAuth.Scopes"
	BasicClientIdSecretAuthScopes = "basicClientIdSecretAuth.Scopes"
	OAuthScopes                   = "oAuth.Scopes"
)

// Defines values for AIGGenerateInputAsyncTaskStatus.
const (
	AIGGenerateInputAsyncTaskStatusFAILED    AIGGenerateInputAsyncTaskStatus = "FAILED"
	AIGGenerateInputAsyncTaskStatusRUNNING   AIGGenerateInputAsyncTaskStatus = "RUNNING"
	AIGGenerateInputAsyncTaskStatusSUCCEEDED AIGGenerateInputAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for AOPProcessOutputAsyncTaskStatus.
const (
	AOPProcessOutputAsyncTaskStatusFAILED    AOPProcessOutputAsyncTaskStatus = "FAILED"
	AOPProcessOutputAsyncTaskStatusRUNNING   AOPProcessOutputAsyncTaskStatus = "RUNNING"
	AOPProcessOutputAsyncTaskStatusSUCCEEDED AOPProcessOutputAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for AaSequenceSummaryEntityType.
const (
	AaSequenceSummaryEntityTypeAaSequence AaSequenceSummaryEntityType = "aa_sequence"
)

// Defines values for AaSequenceWithEntityTypeEntityType.
const (
	AaSequenceWithEntityTypeEntityTypeAaSequence AaSequenceWithEntityTypeEntityType = "aa_sequence"
)

// Defines values for AppCanvasesArchiveReason.
const (
	AppCanvasesArchiveReasonOther AppCanvasesArchiveReason = "Other"
)

// Defines values for AppConfigItemBooleanBulkUpdateType.
const (
	AppConfigItemBooleanBulkUpdateTypeBoolean AppConfigItemBooleanBulkUpdateType = "boolean"
)

// Defines values for AppConfigItemBooleanCreateType.
const (
	AppConfigItemBooleanCreateTypeBoolean AppConfigItemBooleanCreateType = "boolean"
)

// Defines values for AppConfigItemBooleanUpdateType.
const (
	AppConfigItemBooleanUpdateTypeBoolean AppConfigItemBooleanUpdateType = "boolean"
)

// Defines values for AppConfigItemDateBulkUpdateType.
const (
	AppConfigItemDateBulkUpdateTypeDate AppConfigItemDateBulkUpdateType = "date"
)

// Defines values for AppConfigItemDateCreateType.
const (
	AppConfigItemDateCreateTypeDate AppConfigItemDateCreateType = "date"
)

// Defines values for AppConfigItemDateUpdateType.
const (
	AppConfigItemDateUpdateTypeDate AppConfigItemDateUpdateType = "date"
)

// Defines values for AppConfigItemDatetimeBulkUpdateType.
const (
	AppConfigItemDatetimeBulkUpdateTypeDatetime AppConfigItemDatetimeBulkUpdateType = "datetime"
)

// Defines values for AppConfigItemDatetimeCreateType.
const (
	AppConfigItemDatetimeCreateTypeDatetime AppConfigItemDatetimeCreateType = "datetime"
)

// Defines values for AppConfigItemDatetimeUpdateType.
const (
	AppConfigItemDatetimeUpdateTypeDatetime AppConfigItemDatetimeUpdateType = "datetime"
)

// Defines values for AppConfigItemFloatBulkUpdateType.
const (
	AppConfigItemFloatBulkUpdateTypeFloat AppConfigItemFloatBulkUpdateType = "float"
)

// Defines values for AppConfigItemFloatCreateType.
const (
	AppConfigItemFloatCreateTypeFloat AppConfigItemFloatCreateType = "float"
)

// Defines values for AppConfigItemFloatUpdateType.
const (
	AppConfigItemFloatUpdateTypeFloat AppConfigItemFloatUpdateType = "float"
)

// Defines values for AppConfigItemGenericBulkUpdateType.
const (
	AppConfigItemGenericBulkUpdateTypeAaSequence         AppConfigItemGenericBulkUpdateType = "aa_sequence"
	AppConfigItemGenericBulkUpdateTypeBox                AppConfigItemGenericBulkUpdateType = "box"
	AppConfigItemGenericBulkUpdateTypeBoxSchema          AppConfigItemGenericBulkUpdateType = "box_schema"
	AppConfigItemGenericBulkUpdateTypeContainer          AppConfigItemGenericBulkUpdateType = "container"
	AppConfigItemGenericBulkUpdateTypeContainerSchema    AppConfigItemGenericBulkUpdateType = "container_schema"
	AppConfigItemGenericBulkUpdateTypeCustomEntity       AppConfigItemGenericBulkUpdateType = "custom_entity"
	AppConfigItemGenericBulkUpdateTypeDate               AppConfigItemGenericBulkUpdateType = "date"
	AppConfigItemGenericBulkUpdateTypeDatetime           AppConfigItemGenericBulkUpdateType = "datetime"
	AppConfigItemGenericBulkUpdateTypeDnaOligo           AppConfigItemGenericBulkUpdateType = "dna_oligo"
	AppConfigItemGenericBulkUpdateTypeDnaSequence        AppConfigItemGenericBulkUpdateType = "dna_sequence"
	AppConfigItemGenericBulkUpdateTypeDropdown           AppConfigItemGenericBulkUpdateType = "dropdown"
	AppConfigItemGenericBulkUpdateTypeDropdownOption     AppConfigItemGenericBulkUpdateType = "dropdown_option"
	AppConfigItemGenericBulkUpdateTypeEntitySchema       AppConfigItemGenericBulkUpdateType = "entity_schema"
	AppConfigItemGenericBulkUpdateTypeEntry              AppConfigItemGenericBulkUpdateType = "entry"
	AppConfigItemGenericBulkUpdateTypeEntrySchema        AppConfigItemGenericBulkUpdateType = "entry_schema"
	AppConfigItemGenericBulkUpdateTypeField              AppConfigItemGenericBulkUpdateType = "field"
	AppConfigItemGenericBulkUpdateTypeFolder             AppConfigItemGenericBulkUpdateType = "folder"
	AppConfigItemGenericBulkUpdateTypeJson               AppConfigItemGenericBulkUpdateType = "json"
	AppConfigItemGenericBulkUpdateTypeLocation           AppConfigItemGenericBulkUpdateType = "location"
	AppConfigItemGenericBulkUpdateTypeLocationSchema     AppConfigItemGenericBulkUpdateType = "location_schema"
	AppConfigItemGenericBulkUpdateTypeMixture            AppConfigItemGenericBulkUpdateType = "mixture"
	AppConfigItemGenericBulkUpdateTypeMolecule           AppConfigItemGenericBulkUpdateType = "molecule"
	AppConfigItemGenericBulkUpdateTypePlate              AppConfigItemGenericBulkUpdateType = "plate"
	AppConfigItemGenericBulkUpdateTypePlateSchema        AppConfigItemGenericBulkUpdateType = "plate_schema"
	AppConfigItemGenericBulkUpdateTypeProject            AppConfigItemGenericBulkUpdateType = "project"
	AppConfigItemGenericBulkUpdateTypeRegistry           AppConfigItemGenericBulkUpdateType = "registry"
	AppConfigItemGenericBulkUpdateTypeRequestSchema      AppConfigItemGenericBulkUpdateType = "request_schema"
	AppConfigItemGenericBulkUpdateTypeResultSchema       AppConfigItemGenericBulkUpdateType = "result_schema"
	AppConfigItemGenericBulkUpdateTypeRnaOligo           AppConfigItemGenericBulkUpdateType = "rna_oligo"
	AppConfigItemGenericBulkUpdateTypeRnaSequence        AppConfigItemGenericBulkUpdateType = "rna_sequence"
	AppConfigItemGenericBulkUpdateTypeRunSchema          AppConfigItemGenericBulkUpdateType = "run_schema"
	AppConfigItemGenericBulkUpdateTypeSecureText         AppConfigItemGenericBulkUpdateType = "secure_text"
	AppConfigItemGenericBulkUpdateTypeText               AppConfigItemGenericBulkUpdateType = "text"
	AppConfigItemGenericBulkUpdateTypeWorkflowTaskSchema AppConfigItemGenericBulkUpdateType = "workflow_task_schema"
	AppConfigItemGenericBulkUpdateTypeWorkflowTaskStatus AppConfigItemGenericBulkUpdateType = "workflow_task_status"
	AppConfigItemGenericBulkUpdateTypeWorklist           AppConfigItemGenericBulkUpdateType = "worklist"
)

// Defines values for AppConfigItemGenericCreateType.
const (
	AppConfigItemGenericCreateTypeAaSequence         AppConfigItemGenericCreateType = "aa_sequence"
	AppConfigItemGenericCreateTypeBox                AppConfigItemGenericCreateType = "box"
	AppConfigItemGenericCreateTypeBoxSchema          AppConfigItemGenericCreateType = "box_schema"
	AppConfigItemGenericCreateTypeContainer          AppConfigItemGenericCreateType = "container"
	AppConfigItemGenericCreateTypeContainerSchema    AppConfigItemGenericCreateType = "container_schema"
	AppConfigItemGenericCreateTypeCustomEntity       AppConfigItemGenericCreateType = "custom_entity"
	AppConfigItemGenericCreateTypeDate               AppConfigItemGenericCreateType = "date"
	AppConfigItemGenericCreateTypeDatetime           AppConfigItemGenericCreateType = "datetime"
	AppConfigItemGenericCreateTypeDnaOligo           AppConfigItemGenericCreateType = "dna_oligo"
	AppConfigItemGenericCreateTypeDnaSequence        AppConfigItemGenericCreateType = "dna_sequence"
	AppConfigItemGenericCreateTypeDropdown           AppConfigItemGenericCreateType = "dropdown"
	AppConfigItemGenericCreateTypeDropdownOption     AppConfigItemGenericCreateType = "dropdown_option"
	AppConfigItemGenericCreateTypeEntitySchema       AppConfigItemGenericCreateType = "entity_schema"
	AppConfigItemGenericCreateTypeEntry              AppConfigItemGenericCreateType = "entry"
	AppConfigItemGenericCreateTypeEntrySchema        AppConfigItemGenericCreateType = "entry_schema"
	AppConfigItemGenericCreateTypeField              AppConfigItemGenericCreateType = "field"
	AppConfigItemGenericCreateTypeFolder             AppConfigItemGenericCreateType = "folder"
	AppConfigItemGenericCreateTypeJson               AppConfigItemGenericCreateType = "json"
	AppConfigItemGenericCreateTypeLocation           AppConfigItemGenericCreateType = "location"
	AppConfigItemGenericCreateTypeLocationSchema     AppConfigItemGenericCreateType = "location_schema"
	AppConfigItemGenericCreateTypeMixture            AppConfigItemGenericCreateType = "mixture"
	AppConfigItemGenericCreateTypeMolecule           AppConfigItemGenericCreateType = "molecule"
	AppConfigItemGenericCreateTypePlate              AppConfigItemGenericCreateType = "plate"
	AppConfigItemGenericCreateTypePlateSchema        AppConfigItemGenericCreateType = "plate_schema"
	AppConfigItemGenericCreateTypeProject            AppConfigItemGenericCreateType = "project"
	AppConfigItemGenericCreateTypeRegistry           AppConfigItemGenericCreateType = "registry"
	AppConfigItemGenericCreateTypeRequestSchema      AppConfigItemGenericCreateType = "request_schema"
	AppConfigItemGenericCreateTypeResultSchema       AppConfigItemGenericCreateType = "result_schema"
	AppConfigItemGenericCreateTypeRnaOligo           AppConfigItemGenericCreateType = "rna_oligo"
	AppConfigItemGenericCreateTypeRnaSequence        AppConfigItemGenericCreateType = "rna_sequence"
	AppConfigItemGenericCreateTypeRunSchema          AppConfigItemGenericCreateType = "run_schema"
	AppConfigItemGenericCreateTypeSecureText         AppConfigItemGenericCreateType = "secure_text"
	AppConfigItemGenericCreateTypeText               AppConfigItemGenericCreateType = "text"
	AppConfigItemGenericCreateTypeWorkflowTaskSchema AppConfigItemGenericCreateType = "workflow_task_schema"
	AppConfigItemGenericCreateTypeWorkflowTaskStatus AppConfigItemGenericCreateType = "workflow_task_status"
	AppConfigItemGenericCreateTypeWorklist           AppConfigItemGenericCreateType = "worklist"
)

// Defines values for AppConfigItemGenericUpdateType.
const (
	AppConfigItemGenericUpdateTypeAaSequence         AppConfigItemGenericUpdateType = "aa_sequence"
	AppConfigItemGenericUpdateTypeBox                AppConfigItemGenericUpdateType = "box"
	AppConfigItemGenericUpdateTypeBoxSchema          AppConfigItemGenericUpdateType = "box_schema"
	AppConfigItemGenericUpdateTypeContainer          AppConfigItemGenericUpdateType = "container"
	AppConfigItemGenericUpdateTypeContainerSchema    AppConfigItemGenericUpdateType = "container_schema"
	AppConfigItemGenericUpdateTypeCustomEntity       AppConfigItemGenericUpdateType = "custom_entity"
	AppConfigItemGenericUpdateTypeDate               AppConfigItemGenericUpdateType = "date"
	AppConfigItemGenericUpdateTypeDatetime           AppConfigItemGenericUpdateType = "datetime"
	AppConfigItemGenericUpdateTypeDnaOligo           AppConfigItemGenericUpdateType = "dna_oligo"
	AppConfigItemGenericUpdateTypeDnaSequence        AppConfigItemGenericUpdateType = "dna_sequence"
	AppConfigItemGenericUpdateTypeDropdown           AppConfigItemGenericUpdateType = "dropdown"
	AppConfigItemGenericUpdateTypeDropdownOption     AppConfigItemGenericUpdateType = "dropdown_option"
	AppConfigItemGenericUpdateTypeEntitySchema       AppConfigItemGenericUpdateType = "entity_schema"
	AppConfigItemGenericUpdateTypeEntry              AppConfigItemGenericUpdateType = "entry"
	AppConfigItemGenericUpdateTypeEntrySchema        AppConfigItemGenericUpdateType = "entry_schema"
	AppConfigItemGenericUpdateTypeField              AppConfigItemGenericUpdateType = "field"
	AppConfigItemGenericUpdateTypeFolder             AppConfigItemGenericUpdateType = "folder"
	AppConfigItemGenericUpdateTypeJson               AppConfigItemGenericUpdateType = "json"
	AppConfigItemGenericUpdateTypeLocation           AppConfigItemGenericUpdateType = "location"
	AppConfigItemGenericUpdateTypeLocationSchema     AppConfigItemGenericUpdateType = "location_schema"
	AppConfigItemGenericUpdateTypeMixture            AppConfigItemGenericUpdateType = "mixture"
	AppConfigItemGenericUpdateTypeMolecule           AppConfigItemGenericUpdateType = "molecule"
	AppConfigItemGenericUpdateTypePlate              AppConfigItemGenericUpdateType = "plate"
	AppConfigItemGenericUpdateTypePlateSchema        AppConfigItemGenericUpdateType = "plate_schema"
	AppConfigItemGenericUpdateTypeProject            AppConfigItemGenericUpdateType = "project"
	AppConfigItemGenericUpdateTypeRegistry           AppConfigItemGenericUpdateType = "registry"
	AppConfigItemGenericUpdateTypeRequestSchema      AppConfigItemGenericUpdateType = "request_schema"
	AppConfigItemGenericUpdateTypeResultSchema       AppConfigItemGenericUpdateType = "result_schema"
	AppConfigItemGenericUpdateTypeRnaOligo           AppConfigItemGenericUpdateType = "rna_oligo"
	AppConfigItemGenericUpdateTypeRnaSequence        AppConfigItemGenericUpdateType = "rna_sequence"
	AppConfigItemGenericUpdateTypeRunSchema          AppConfigItemGenericUpdateType = "run_schema"
	AppConfigItemGenericUpdateTypeSecureText         AppConfigItemGenericUpdateType = "secure_text"
	AppConfigItemGenericUpdateTypeText               AppConfigItemGenericUpdateType = "text"
	AppConfigItemGenericUpdateTypeWorkflowTaskSchema AppConfigItemGenericUpdateType = "workflow_task_schema"
	AppConfigItemGenericUpdateTypeWorkflowTaskStatus AppConfigItemGenericUpdateType = "workflow_task_status"
	AppConfigItemGenericUpdateTypeWorklist           AppConfigItemGenericUpdateType = "worklist"
)

// Defines values for AppConfigItemIntegerBulkUpdateType.
const (
	AppConfigItemIntegerBulkUpdateTypeInteger AppConfigItemIntegerBulkUpdateType = "integer"
)

// Defines values for AppConfigItemIntegerCreateType.
const (
	AppConfigItemIntegerCreateTypeInteger AppConfigItemIntegerCreateType = "integer"
)

// Defines values for AppConfigItemIntegerUpdateType.
const (
	AppConfigItemIntegerUpdateTypeInteger AppConfigItemIntegerUpdateType = "integer"
)

// Defines values for AppConfigItemJsonBulkUpdateType.
const (
	AppConfigItemJsonBulkUpdateTypeJson AppConfigItemJsonBulkUpdateType = "json"
)

// Defines values for AppConfigItemJsonCreateType.
const (
	AppConfigItemJsonCreateTypeJson AppConfigItemJsonCreateType = "json"
)

// Defines values for AppConfigItemJsonUpdateType.
const (
	AppConfigItemJsonUpdateTypeJson AppConfigItemJsonUpdateType = "json"
)

// Defines values for AppSessionMessageStyle.
const (
	AppSessionMessageStyleERROR   AppSessionMessageStyle = "ERROR"
	AppSessionMessageStyleINFO    AppSessionMessageStyle = "INFO"
	AppSessionMessageStyleNONE    AppSessionMessageStyle = "NONE"
	AppSessionMessageStyleSUCCESS AppSessionMessageStyle = "SUCCESS"
	AppSessionMessageStyleWARNING AppSessionMessageStyle = "WARNING"
)

// Defines values for AppSessionStatus.
const (
	AppSessionStatusCOMPLETEDWITHWARNINGS AppSessionStatus = "COMPLETED_WITH_WARNINGS"
	AppSessionStatusFAILED                AppSessionStatus = "FAILED"
	AppSessionStatusRUNNING               AppSessionStatus = "RUNNING"
	AppSessionStatusSUCCEEDED             AppSessionStatus = "SUCCEEDED"
	AppSessionStatusTIMEOUT               AppSessionStatus = "TIMEOUT"
)

// Defines values for AppSessionUpdateStatus.
const (
	AppSessionUpdateStatusCOMPLETEDWITHWARNINGS AppSessionUpdateStatus = "COMPLETED_WITH_WARNINGS"
	AppSessionUpdateStatusFAILED                AppSessionUpdateStatus = "FAILED"
	AppSessionUpdateStatusSUCCEEDED             AppSessionUpdateStatus = "SUCCEEDED"
)

// Defines values for AssayResultSchemaType.
const (
	AssayResultSchemaTypeAssayResult AssayResultSchemaType = "assay_result"
)

// Defines values for AssayResultsArchiveReason.
const (
	AssayResultsArchiveReasonArchived    AssayResultsArchiveReason = "Archived"
	AssayResultsArchiveReasonMadeInError AssayResultsArchiveReason = "Made in error"
	AssayResultsArchiveReasonOther       AssayResultsArchiveReason = "Other"
)

// Defines values for AssayRunCreatedEventEventType.
const (
	V2AssayRunCreated AssayRunCreatedEventEventType = "v2.assayRun.created"
)

// Defines values for AssayRunNotePartType.
const (
	AssayRunNotePartTypeAssayRun AssayRunNotePartType = "assay_run"
)

// Defines values for AssayRunSchemaType.
const (
	AssayRunSchemaTypeAssayRun AssayRunSchemaType = "assay_run"
)

// Defines values for AssayRunUpdatedFieldsEventEventType.
const (
	V2AssayRunUpdatedFields AssayRunUpdatedFieldsEventEventType = "v2.assayRun.updated.fields"
)

// Defines values for AssayRunValidationStatus.
const (
	AssayRunValidationStatusINVALID AssayRunValidationStatus = "INVALID"
	AssayRunValidationStatusVALID   AssayRunValidationStatus = "VALID"
)

// Defines values for AssayRunsArchiveReason.
const (
	AssayRunsArchiveReasonArchived    AssayRunsArchiveReason = "Archived"
	AssayRunsArchiveReasonMadeInError AssayRunsArchiveReason = "Made in error"
	AssayRunsArchiveReasonOther       AssayRunsArchiveReason = "Other"
)

// Defines values for AsyncTaskStatus.
const (
	AsyncTaskStatusFAILED    AsyncTaskStatus = "FAILED"
	AsyncTaskStatusRUNNING   AsyncTaskStatus = "RUNNING"
	AsyncTaskStatusSUCCEEDED AsyncTaskStatus = "SUCCEEDED"
)

// Defines values for AutofillPartsAsyncTaskStatus.
const (
	AutofillPartsAsyncTaskStatusFAILED    AutofillPartsAsyncTaskStatus = "FAILED"
	AutofillPartsAsyncTaskStatusRUNNING   AutofillPartsAsyncTaskStatus = "RUNNING"
	AutofillPartsAsyncTaskStatusSUCCEEDED AutofillPartsAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for AutofillTranslationsAsyncTaskStatus.
const (
	AutofillTranslationsAsyncTaskStatusFAILED    AutofillTranslationsAsyncTaskStatus = "FAILED"
	AutofillTranslationsAsyncTaskStatusRUNNING   AutofillTranslationsAsyncTaskStatus = "RUNNING"
	AutofillTranslationsAsyncTaskStatusSUCCEEDED AutofillTranslationsAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for AutomationFileStatus.
const (
	AutomationFileStatusFAILED     AutomationFileStatus = "FAILED"
	AutomationFileStatusNOTSTARTED AutomationFileStatus = "NOT_STARTED"
	AutomationFileStatusRUNNING    AutomationFileStatus = "RUNNING"
	AutomationFileStatusSUCCEEDED  AutomationFileStatus = "SUCCEEDED"
)

// Defines values for AutomationInputGeneratorStatus.
const (
	AutomationInputGeneratorStatusFAILED     AutomationInputGeneratorStatus = "FAILED"
	AutomationInputGeneratorStatusNOTSTARTED AutomationInputGeneratorStatus = "NOT_STARTED"
	AutomationInputGeneratorStatusRUNNING    AutomationInputGeneratorStatus = "RUNNING"
	AutomationInputGeneratorStatusSUCCEEDED  AutomationInputGeneratorStatus = "SUCCEEDED"
)

// Defines values for AutomationInputGeneratorCompletedV2BetaEventEventType.
const (
	V2BetaAutomationInputGeneratorCompleted AutomationInputGeneratorCompletedV2BetaEventEventType = "v2-beta.automationInputGenerator.completed"
)

// Defines values for AutomationOutputProcessorStatus.
const (
	AutomationOutputProcessorStatusFAILED     AutomationOutputProcessorStatus = "FAILED"
	AutomationOutputProcessorStatusNOTSTARTED AutomationOutputProcessorStatus = "NOT_STARTED"
	AutomationOutputProcessorStatusRUNNING    AutomationOutputProcessorStatus = "RUNNING"
	AutomationOutputProcessorStatusSUCCEEDED  AutomationOutputProcessorStatus = "SUCCEEDED"
)

// Defines values for AutomationOutputProcessorCompletedV2BetaEventEventType.
const (
	V2BetaAutomationOutputProcessorCompleted AutomationOutputProcessorCompletedV2BetaEventEventType = "v2-beta.automationOutputProcessor.completed"
)

// Defines values for AutomationOutputProcessorUploadedV2BetaEventEventType.
const (
	V2BetaAutomationOutputProcessorUploaded AutomationOutputProcessorUploadedV2BetaEventEventType = "v2-beta.automationOutputProcessor.uploaded"
)

// Defines values for AutomationOutputProcessorsArchiveReason.
const (
	AutomationOutputProcessorsArchiveReasonContaminated AutomationOutputProcessorsArchiveReason = "Contaminated"
	AutomationOutputProcessorsArchiveReasonExpended     AutomationOutputProcessorsArchiveReason = "Expended"
	AutomationOutputProcessorsArchiveReasonExpired      AutomationOutputProcessorsArchiveReason = "Expired"
	AutomationOutputProcessorsArchiveReasonMadeInError  AutomationOutputProcessorsArchiveReason = "Made in error"
	AutomationOutputProcessorsArchiveReasonMissing      AutomationOutputProcessorsArchiveReason = "Missing"
	AutomationOutputProcessorsArchiveReasonOther        AutomationOutputProcessorsArchiveReason = "Other"
	AutomationOutputProcessorsArchiveReasonRetired      AutomationOutputProcessorsArchiveReason = "Retired"
	AutomationOutputProcessorsArchiveReasonShipped      AutomationOutputProcessorsArchiveReason = "Shipped"
)

// Defines values for BadRequestErrorErrorType.
const (
	BadRequestErrorErrorTypeInvalidRequestError BadRequestErrorErrorType = "invalid_request_error"
)

// Defines values for BatchesArchiveReason.
const (
	BatchesArchiveReasonContaminated BatchesArchiveReason = "Contaminated"
	BatchesArchiveReasonExpended     BatchesArchiveReason = "Expended"
	BatchesArchiveReasonExpired      BatchesArchiveReason = "Expired"
	BatchesArchiveReasonMadeInError  BatchesArchiveReason = "Made in error"
	BatchesArchiveReasonMissing      BatchesArchiveReason = "Missing"
	BatchesArchiveReasonOther        BatchesArchiveReason = "Other"
	BatchesArchiveReasonRetired      BatchesArchiveReason = "Retired"
	BatchesArchiveReasonShipped      BatchesArchiveReason = "Shipped"
)

// Defines values for BenchlingAppsArchiveReason.
const (
	BenchlingAppsArchiveReasonMadeInError BenchlingAppsArchiveReason = "Made in error"
	BenchlingAppsArchiveReasonOther       BenchlingAppsArchiveReason = "Other"
	BenchlingAppsArchiveReasonRetired     BenchlingAppsArchiveReason = "Retired"
)

// Defines values for BlobType.
const (
	BlobTypeRAWFILE       BlobType = "RAW_FILE"
	BlobTypeVISUALIZATION BlobType = "VISUALIZATION"
)

// Defines values for BlobUploadStatus.
const (
	BlobUploadStatusABORTED    BlobUploadStatus = "ABORTED"
	BlobUploadStatusCOMPLETE   BlobUploadStatus = "COMPLETE"
	BlobUploadStatusINPROGRESS BlobUploadStatus = "IN_PROGRESS"
)

// Defines values for BlobCreateType.
const (
	BlobCreateTypeRAWFILE       BlobCreateType = "RAW_FILE"
	BlobCreateTypeVISUALIZATION BlobCreateType = "VISUALIZATION"
)

// Defines values for BlobMultipartCreateType.
const (
	RAWFILE       BlobMultipartCreateType = "RAW_FILE"
	VISUALIZATION BlobMultipartCreateType = "VISUALIZATION"
)

// Defines values for BooleanAppConfigItemType.
const (
	BooleanAppConfigItemTypeBoolean BooleanAppConfigItemType = "boolean"
)

// Defines values for BoxCreationTableNotePartType.
const (
	BoxCreationTable BoxCreationTableNotePartType = "box_creation_table"
)

// Defines values for BoxSchemaType.
const (
	BoxSchemaTypeBox BoxSchemaType = "box"
)

// Defines values for BoxesArchiveReason.
const (
	BoxesArchiveReasonContaminated BoxesArchiveReason = "Contaminated"
	BoxesArchiveReasonExpended     BoxesArchiveReason = "Expended"
	BoxesArchiveReasonExpired      BoxesArchiveReason = "Expired"
	BoxesArchiveReasonMadeInError  BoxesArchiveReason = "Made in error"
	BoxesArchiveReasonMissing      BoxesArchiveReason = "Missing"
	BoxesArchiveReasonOther        BoxesArchiveReason = "Other"
	BoxesArchiveReasonRetired      BoxesArchiveReason = "Retired"
	BoxesArchiveReasonShipped      BoxesArchiveReason = "Shipped"
)

// Defines values for BulkCreateAaSequencesAsyncTaskStatus.
const (
	BulkCreateAaSequencesAsyncTaskStatusFAILED    BulkCreateAaSequencesAsyncTaskStatus = "FAILED"
	BulkCreateAaSequencesAsyncTaskStatusRUNNING   BulkCreateAaSequencesAsyncTaskStatus = "RUNNING"
	BulkCreateAaSequencesAsyncTaskStatusSUCCEEDED BulkCreateAaSequencesAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for BulkCreateContainersAsyncTaskStatus.
const (
	BulkCreateContainersAsyncTaskStatusFAILED    BulkCreateContainersAsyncTaskStatus = "FAILED"
	BulkCreateContainersAsyncTaskStatusRUNNING   BulkCreateContainersAsyncTaskStatus = "RUNNING"
	BulkCreateContainersAsyncTaskStatusSUCCEEDED BulkCreateContainersAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for BulkCreateCustomEntitiesAsyncTaskStatus.
const (
	BulkCreateCustomEntitiesAsyncTaskStatusFAILED    BulkCreateCustomEntitiesAsyncTaskStatus = "FAILED"
	BulkCreateCustomEntitiesAsyncTaskStatusRUNNING   BulkCreateCustomEntitiesAsyncTaskStatus = "RUNNING"
	BulkCreateCustomEntitiesAsyncTaskStatusSUCCEEDED BulkCreateCustomEntitiesAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for BulkCreateDnaOligosAsyncTaskStatus.
const (
	BulkCreateDnaOligosAsyncTaskStatusFAILED    BulkCreateDnaOligosAsyncTaskStatus = "FAILED"
	BulkCreateDnaOligosAsyncTaskStatusRUNNING   BulkCreateDnaOligosAsyncTaskStatus = "RUNNING"
	BulkCreateDnaOligosAsyncTaskStatusSUCCEEDED BulkCreateDnaOligosAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for BulkCreateDnaSequencesAsyncTaskStatus.
const (
	BulkCreateDnaSequencesAsyncTaskStatusFAILED    BulkCreateDnaSequencesAsyncTaskStatus = "FAILED"
	BulkCreateDnaSequencesAsyncTaskStatusRUNNING   BulkCreateDnaSequencesAsyncTaskStatus = "RUNNING"
	BulkCreateDnaSequencesAsyncTaskStatusSUCCEEDED BulkCreateDnaSequencesAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for BulkCreateFeaturesAsyncTaskStatus.
const (
	BulkCreateFeaturesAsyncTaskStatusFAILED    BulkCreateFeaturesAsyncTaskStatus = "FAILED"
	BulkCreateFeaturesAsyncTaskStatusRUNNING   BulkCreateFeaturesAsyncTaskStatus = "RUNNING"
	BulkCreateFeaturesAsyncTaskStatusSUCCEEDED BulkCreateFeaturesAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for BulkCreateRnaOligosAsyncTaskStatus.
const (
	BulkCreateRnaOligosAsyncTaskStatusFAILED    BulkCreateRnaOligosAsyncTaskStatus = "FAILED"
	BulkCreateRnaOligosAsyncTaskStatusRUNNING   BulkCreateRnaOligosAsyncTaskStatus = "RUNNING"
	BulkCreateRnaOligosAsyncTaskStatusSUCCEEDED BulkCreateRnaOligosAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for BulkCreateRnaSequencesAsyncTaskStatus.
const (
	BulkCreateRnaSequencesAsyncTaskStatusFAILED    BulkCreateRnaSequencesAsyncTaskStatus = "FAILED"
	BulkCreateRnaSequencesAsyncTaskStatusRUNNING   BulkCreateRnaSequencesAsyncTaskStatus = "RUNNING"
	BulkCreateRnaSequencesAsyncTaskStatusSUCCEEDED BulkCreateRnaSequencesAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for BulkRegisterEntitiesAsyncTaskStatus.
const (
	BulkRegisterEntitiesAsyncTaskStatusFAILED    BulkRegisterEntitiesAsyncTaskStatus = "FAILED"
	BulkRegisterEntitiesAsyncTaskStatusRUNNING   BulkRegisterEntitiesAsyncTaskStatus = "RUNNING"
	BulkRegisterEntitiesAsyncTaskStatusSUCCEEDED BulkRegisterEntitiesAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for BulkUpdateAaSequencesAsyncTaskStatus.
const (
	BulkUpdateAaSequencesAsyncTaskStatusFAILED    BulkUpdateAaSequencesAsyncTaskStatus = "FAILED"
	BulkUpdateAaSequencesAsyncTaskStatusRUNNING   BulkUpdateAaSequencesAsyncTaskStatus = "RUNNING"
	BulkUpdateAaSequencesAsyncTaskStatusSUCCEEDED BulkUpdateAaSequencesAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for BulkUpdateContainersAsyncTaskStatus.
const (
	BulkUpdateContainersAsyncTaskStatusFAILED    BulkUpdateContainersAsyncTaskStatus = "FAILED"
	BulkUpdateContainersAsyncTaskStatusRUNNING   BulkUpdateContainersAsyncTaskStatus = "RUNNING"
	BulkUpdateContainersAsyncTaskStatusSUCCEEDED BulkUpdateContainersAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for BulkUpdateCustomEntitiesAsyncTaskStatus.
const (
	BulkUpdateCustomEntitiesAsyncTaskStatusFAILED    BulkUpdateCustomEntitiesAsyncTaskStatus = "FAILED"
	BulkUpdateCustomEntitiesAsyncTaskStatusRUNNING   BulkUpdateCustomEntitiesAsyncTaskStatus = "RUNNING"
	BulkUpdateCustomEntitiesAsyncTaskStatusSUCCEEDED BulkUpdateCustomEntitiesAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for BulkUpdateDnaOligosAsyncTaskStatus.
const (
	BulkUpdateDnaOligosAsyncTaskStatusFAILED    BulkUpdateDnaOligosAsyncTaskStatus = "FAILED"
	BulkUpdateDnaOligosAsyncTaskStatusRUNNING   BulkUpdateDnaOligosAsyncTaskStatus = "RUNNING"
	BulkUpdateDnaOligosAsyncTaskStatusSUCCEEDED BulkUpdateDnaOligosAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for BulkUpdateDnaSequencesAsyncTaskStatus.
const (
	BulkUpdateDnaSequencesAsyncTaskStatusFAILED    BulkUpdateDnaSequencesAsyncTaskStatus = "FAILED"
	BulkUpdateDnaSequencesAsyncTaskStatusRUNNING   BulkUpdateDnaSequencesAsyncTaskStatus = "RUNNING"
	BulkUpdateDnaSequencesAsyncTaskStatusSUCCEEDED BulkUpdateDnaSequencesAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for BulkUpdateRnaOligosAsyncTaskStatus.
const (
	BulkUpdateRnaOligosAsyncTaskStatusFAILED    BulkUpdateRnaOligosAsyncTaskStatus = "FAILED"
	BulkUpdateRnaOligosAsyncTaskStatusRUNNING   BulkUpdateRnaOligosAsyncTaskStatus = "RUNNING"
	BulkUpdateRnaOligosAsyncTaskStatusSUCCEEDED BulkUpdateRnaOligosAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for BulkUpdateRnaSequencesAsyncTaskStatus.
const (
	BulkUpdateRnaSequencesAsyncTaskStatusFAILED    BulkUpdateRnaSequencesAsyncTaskStatus = "FAILED"
	BulkUpdateRnaSequencesAsyncTaskStatusRUNNING   BulkUpdateRnaSequencesAsyncTaskStatus = "RUNNING"
	BulkUpdateRnaSequencesAsyncTaskStatusSUCCEEDED BulkUpdateRnaSequencesAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for ButtonUiBlockType.
const (
	BUTTON ButtonUiBlockType = "BUTTON"
)

// Defines values for CheckboxNotePartType.
const (
	ListCheckbox CheckboxNotePartType = "list_checkbox"
)

// Defines values for CheckoutRecordStatus.
const (
	CheckoutRecordStatusAVAILABLE  CheckoutRecordStatus = "AVAILABLE"
	CheckoutRecordStatusCHECKEDOUT CheckoutRecordStatus = "CHECKED_OUT"
	CheckoutRecordStatusRESERVED   CheckoutRecordStatus = "RESERVED"
)

// Defines values for ChipUiBlockType.
const (
	CHIP ChipUiBlockType = "CHIP"
)

// Defines values for ContainerQuantityUnits.
const (
	ContainerQuantityUnitsCells     ContainerQuantityUnits = "cells"
	ContainerQuantityUnitsG         ContainerQuantityUnits = "g"
	ContainerQuantityUnitsGalUS     ContainerQuantityUnits = "gal (US)"
	ContainerQuantityUnitsItems     ContainerQuantityUnits = "items"
	ContainerQuantityUnitsKg        ContainerQuantityUnits = "kg"
	ContainerQuantityUnitsL         ContainerQuantityUnits = "L"
	ContainerQuantityUnitsLb        ContainerQuantityUnits = "lb"
	ContainerQuantityUnitsML        ContainerQuantityUnits = "mL"
	ContainerQuantityUnitsMg        ContainerQuantityUnits = "mg"
	ContainerQuantityUnitsMmol      ContainerQuantityUnits = "mmol"
	ContainerQuantityUnitsMol       ContainerQuantityUnits = "mol"
	ContainerQuantityUnitsNL        ContainerQuantityUnits = "nL"
	ContainerQuantityUnitsNg        ContainerQuantityUnits = "ng"
	ContainerQuantityUnitsNil       ContainerQuantityUnits = "<nil>"
	ContainerQuantityUnitsNmol      ContainerQuantityUnits = "nmol"
	ContainerQuantityUnitsOz        ContainerQuantityUnits = "oz"
	ContainerQuantityUnitsPL        ContainerQuantityUnits = "pL"
	ContainerQuantityUnitsPg        ContainerQuantityUnits = "pg"
	ContainerQuantityUnitsPmol      ContainerQuantityUnits = "pmol"
	ContainerQuantityUnitsPtUS      ContainerQuantityUnits = "pt (US)"
	ContainerQuantityUnitsQtUS      ContainerQuantityUnits = "qt (US)"
	ContainerQuantityUnitsUL        ContainerQuantityUnits = "uL"
	ContainerQuantityUnitsUg        ContainerQuantityUnits = "ug"
	ContainerQuantityUnitsUmol      ContainerQuantityUnits = "umol"
	ContainerQuantityUnitsUnits     ContainerQuantityUnits = "units"
	ContainerQuantityUnitsX103Cells ContainerQuantityUnits = "(x10^3) cells"
	ContainerQuantityUnitsX104Cells ContainerQuantityUnits = "(x10^4) cells"
	ContainerQuantityUnitsX105Cells ContainerQuantityUnits = "(x10^5) cells"
	ContainerQuantityUnitsX106Cells ContainerQuantityUnits = "(x10^6) cells"
	ContainerQuantityUnitsX107Cells ContainerQuantityUnits = "(x10^7) cells"
	ContainerQuantityUnitsX108Cells ContainerQuantityUnits = "(x10^8) cells"
	ContainerQuantityUnitsX109Cells ContainerQuantityUnits = "(x10^9) cells"
)

// Defines values for ContainerSchemaType.
const (
	ContainerSchemaTypeContainer ContainerSchemaType = "container"
)

// Defines values for ContainersArchiveReason.
const (
	ContainersArchiveReasonContaminated ContainersArchiveReason = "Contaminated"
	ContainersArchiveReasonExpended     ContainersArchiveReason = "Expended"
	ContainersArchiveReasonExpired      ContainersArchiveReason = "Expired"
	ContainersArchiveReasonMadeInError  ContainersArchiveReason = "Made in error"
	ContainersArchiveReasonMissing      ContainersArchiveReason = "Missing"
	ContainersArchiveReasonOther        ContainersArchiveReason = "Other"
	ContainersArchiveReasonRetired      ContainersArchiveReason = "Retired"
	ContainersArchiveReasonShipped      ContainersArchiveReason = "Shipped"
)

// Defines values for CreateConsensusAlignmentAsyncTaskStatus.
const (
	CreateConsensusAlignmentAsyncTaskStatusFAILED    CreateConsensusAlignmentAsyncTaskStatus = "FAILED"
	CreateConsensusAlignmentAsyncTaskStatusRUNNING   CreateConsensusAlignmentAsyncTaskStatus = "RUNNING"
	CreateConsensusAlignmentAsyncTaskStatusSUCCEEDED CreateConsensusAlignmentAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for CreateNucleotideConsensusAlignmentAsyncTaskStatus.
const (
	CreateNucleotideConsensusAlignmentAsyncTaskStatusFAILED    CreateNucleotideConsensusAlignmentAsyncTaskStatus = "FAILED"
	CreateNucleotideConsensusAlignmentAsyncTaskStatusRUNNING   CreateNucleotideConsensusAlignmentAsyncTaskStatus = "RUNNING"
	CreateNucleotideConsensusAlignmentAsyncTaskStatusSUCCEEDED CreateNucleotideConsensusAlignmentAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for CreateNucleotideTemplateAlignmentAsyncTaskStatus.
const (
	CreateNucleotideTemplateAlignmentAsyncTaskStatusFAILED    CreateNucleotideTemplateAlignmentAsyncTaskStatus = "FAILED"
	CreateNucleotideTemplateAlignmentAsyncTaskStatusRUNNING   CreateNucleotideTemplateAlignmentAsyncTaskStatus = "RUNNING"
	CreateNucleotideTemplateAlignmentAsyncTaskStatusSUCCEEDED CreateNucleotideTemplateAlignmentAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for CreateTemplateAlignmentAsyncTaskStatus.
const (
	CreateTemplateAlignmentAsyncTaskStatusFAILED    CreateTemplateAlignmentAsyncTaskStatus = "FAILED"
	CreateTemplateAlignmentAsyncTaskStatusRUNNING   CreateTemplateAlignmentAsyncTaskStatus = "RUNNING"
	CreateTemplateAlignmentAsyncTaskStatusSUCCEEDED CreateTemplateAlignmentAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for CustomEntitySummaryEntityType.
const (
	CustomEntitySummaryEntityTypeCustomEntity CustomEntitySummaryEntityType = "custom_entity"
)

// Defines values for CustomEntityWithEntityTypeEntityType.
const (
	CustomEntityWithEntityTypeEntityTypeCustomEntity CustomEntityWithEntityTypeEntityType = "custom_entity"
)

// Defines values for DateAppConfigItemType.
const (
	DateAppConfigItemTypeDate DateAppConfigItemType = "date"
)

// Defines values for DatetimeAppConfigItemType.
const (
	Datetime DatetimeAppConfigItemType = "datetime"
)

// Defines values for DeprecatedContainerVolumeForInputUnits.
const (
	DeprecatedContainerVolumeForInputUnitsL   DeprecatedContainerVolumeForInputUnits = "L"
	DeprecatedContainerVolumeForInputUnitsML  DeprecatedContainerVolumeForInputUnits = "mL"
	DeprecatedContainerVolumeForInputUnitsNL  DeprecatedContainerVolumeForInputUnits = "nL"
	DeprecatedContainerVolumeForInputUnitsNil DeprecatedContainerVolumeForInputUnits = "<nil>"
	DeprecatedContainerVolumeForInputUnitsPL  DeprecatedContainerVolumeForInputUnits = "pL"
	DeprecatedContainerVolumeForInputUnitsUL  DeprecatedContainerVolumeForInputUnits = "uL"
)

// Defines values for DeprecatedContainerVolumeForResponseUnits.
const (
	DeprecatedContainerVolumeForResponseUnitsCells     DeprecatedContainerVolumeForResponseUnits = "cells"
	DeprecatedContainerVolumeForResponseUnitsG         DeprecatedContainerVolumeForResponseUnits = "g"
	DeprecatedContainerVolumeForResponseUnitsGalUS     DeprecatedContainerVolumeForResponseUnits = "gal (US)"
	DeprecatedContainerVolumeForResponseUnitsItems     DeprecatedContainerVolumeForResponseUnits = "items"
	DeprecatedContainerVolumeForResponseUnitsKg        DeprecatedContainerVolumeForResponseUnits = "kg"
	DeprecatedContainerVolumeForResponseUnitsL         DeprecatedContainerVolumeForResponseUnits = "L"
	DeprecatedContainerVolumeForResponseUnitsLb        DeprecatedContainerVolumeForResponseUnits = "lb"
	DeprecatedContainerVolumeForResponseUnitsML        DeprecatedContainerVolumeForResponseUnits = "mL"
	DeprecatedContainerVolumeForResponseUnitsMg        DeprecatedContainerVolumeForResponseUnits = "mg"
	DeprecatedContainerVolumeForResponseUnitsMmol      DeprecatedContainerVolumeForResponseUnits = "mmol"
	DeprecatedContainerVolumeForResponseUnitsMol       DeprecatedContainerVolumeForResponseUnits = "mol"
	DeprecatedContainerVolumeForResponseUnitsNL        DeprecatedContainerVolumeForResponseUnits = "nL"
	DeprecatedContainerVolumeForResponseUnitsNg        DeprecatedContainerVolumeForResponseUnits = "ng"
	DeprecatedContainerVolumeForResponseUnitsNil       DeprecatedContainerVolumeForResponseUnits = "<nil>"
	DeprecatedContainerVolumeForResponseUnitsNmol      DeprecatedContainerVolumeForResponseUnits = "nmol"
	DeprecatedContainerVolumeForResponseUnitsOz        DeprecatedContainerVolumeForResponseUnits = "oz"
	DeprecatedContainerVolumeForResponseUnitsPL        DeprecatedContainerVolumeForResponseUnits = "pL"
	DeprecatedContainerVolumeForResponseUnitsPg        DeprecatedContainerVolumeForResponseUnits = "pg"
	DeprecatedContainerVolumeForResponseUnitsPmol      DeprecatedContainerVolumeForResponseUnits = "pmol"
	DeprecatedContainerVolumeForResponseUnitsPtUS      DeprecatedContainerVolumeForResponseUnits = "pt (US)"
	DeprecatedContainerVolumeForResponseUnitsQtUS      DeprecatedContainerVolumeForResponseUnits = "qt (US)"
	DeprecatedContainerVolumeForResponseUnitsUL        DeprecatedContainerVolumeForResponseUnits = "uL"
	DeprecatedContainerVolumeForResponseUnitsUg        DeprecatedContainerVolumeForResponseUnits = "ug"
	DeprecatedContainerVolumeForResponseUnitsUmol      DeprecatedContainerVolumeForResponseUnits = "umol"
	DeprecatedContainerVolumeForResponseUnitsUnits     DeprecatedContainerVolumeForResponseUnits = "units"
	DeprecatedContainerVolumeForResponseUnitsX103Cells DeprecatedContainerVolumeForResponseUnits = "(x10^3) cells"
	DeprecatedContainerVolumeForResponseUnitsX104Cells DeprecatedContainerVolumeForResponseUnits = "(x10^4) cells"
	DeprecatedContainerVolumeForResponseUnitsX105Cells DeprecatedContainerVolumeForResponseUnits = "(x10^5) cells"
	DeprecatedContainerVolumeForResponseUnitsX106Cells DeprecatedContainerVolumeForResponseUnits = "(x10^6) cells"
	DeprecatedContainerVolumeForResponseUnitsX107Cells DeprecatedContainerVolumeForResponseUnits = "(x10^7) cells"
	DeprecatedContainerVolumeForResponseUnitsX108Cells DeprecatedContainerVolumeForResponseUnits = "(x10^8) cells"
	DeprecatedContainerVolumeForResponseUnitsX109Cells DeprecatedContainerVolumeForResponseUnits = "(x10^9) cells"
)

// Defines values for DeprecatedEntitySchemaContainableType.
const (
	DeprecatedEntitySchemaContainableTypeBATCH  DeprecatedEntitySchemaContainableType = "BATCH"
	DeprecatedEntitySchemaContainableTypeENTITY DeprecatedEntitySchemaContainableType = "ENTITY"
	DeprecatedEntitySchemaContainableTypeNONE   DeprecatedEntitySchemaContainableType = "NONE"
)

// Defines values for DeprecatedEntitySchemaType.
const (
	DeprecatedEntitySchemaTypeAaSequence   DeprecatedEntitySchemaType = "aa_sequence"
	DeprecatedEntitySchemaTypeCustomEntity DeprecatedEntitySchemaType = "custom_entity"
	DeprecatedEntitySchemaTypeDnaOligo     DeprecatedEntitySchemaType = "dna_oligo"
	DeprecatedEntitySchemaTypeDnaSequence  DeprecatedEntitySchemaType = "dna_sequence"
	DeprecatedEntitySchemaTypeEntry        DeprecatedEntitySchemaType = "entry"
	DeprecatedEntitySchemaTypeMixture      DeprecatedEntitySchemaType = "mixture"
	DeprecatedEntitySchemaTypeMolecule     DeprecatedEntitySchemaType = "molecule"
	DeprecatedEntitySchemaTypeRnaOligo     DeprecatedEntitySchemaType = "rna_oligo"
)

// Defines values for DnaAlignmentBaseAlgorithm.
const (
	DnaAlignmentBaseAlgorithmClustalo DnaAlignmentBaseAlgorithm = "clustalo"
	DnaAlignmentBaseAlgorithmMafft    DnaAlignmentBaseAlgorithm = "mafft"
)

// Defines values for DnaConsensusAlignmentCreateAlgorithm.
const (
	DnaConsensusAlignmentCreateAlgorithmClustalo DnaConsensusAlignmentCreateAlgorithm = "clustalo"
	DnaConsensusAlignmentCreateAlgorithmMafft    DnaConsensusAlignmentCreateAlgorithm = "mafft"
)

// Defines values for DnaOligoNucleotideType.
const (
	DnaOligoNucleotideTypeDNA DnaOligoNucleotideType = "DNA"
	DnaOligoNucleotideTypeRNA DnaOligoNucleotideType = "RNA"
)

// Defines values for DnaOligoWithEntityTypeEntityType.
const (
	DnaOligoWithEntityTypeEntityTypeDnaOligo DnaOligoWithEntityTypeEntityType = "dna_oligo"
)

// Defines values for DnaOligoWithEntityTypeNucleotideType.
const (
	DnaOligoWithEntityTypeNucleotideTypeDNA DnaOligoWithEntityTypeNucleotideType = "DNA"
	DnaOligoWithEntityTypeNucleotideTypeRNA DnaOligoWithEntityTypeNucleotideType = "RNA"
)

// Defines values for DnaSequenceSummaryEntityType.
const (
	DnaSequenceSummaryEntityTypeDnaSequence DnaSequenceSummaryEntityType = "dna_sequence"
)

// Defines values for DnaSequenceWithEntityTypeEntityType.
const (
	DnaSequenceWithEntityTypeEntityTypeDnaSequence DnaSequenceWithEntityTypeEntityType = "dna_sequence"
)

// Defines values for DnaTemplateAlignmentCreateAlgorithm.
const (
	DnaTemplateAlignmentCreateAlgorithmClustalo DnaTemplateAlignmentCreateAlgorithm = "clustalo"
	DnaTemplateAlignmentCreateAlgorithmMafft    DnaTemplateAlignmentCreateAlgorithm = "mafft"
)

// Defines values for DropdownFieldDefinitionType.
const (
	DropdownFieldDefinitionTypeDropdown DropdownFieldDefinitionType = "dropdown"
)

// Defines values for DropdownMultiValueUiBlockType.
const (
	DROPDOWNMULTIVALUE DropdownMultiValueUiBlockType = "DROPDOWN_MULTIVALUE"
)

// Defines values for DropdownOptionsArchiveReason.
const (
	DropdownOptionsArchiveReasonMadeInError DropdownOptionsArchiveReason = "Made in error"
	DropdownOptionsArchiveReasonOther       DropdownOptionsArchiveReason = "Other"
	DropdownOptionsArchiveReasonRetired     DropdownOptionsArchiveReason = "Retired"
)

// Defines values for DropdownUiBlockType.
const (
	DROPDOWN DropdownUiBlockType = "DROPDOWN"
)

// Defines values for EntityArchiveReason.
const (
	EntityArchiveReasonContaminated EntityArchiveReason = "Contaminated"
	EntityArchiveReasonExpended     EntityArchiveReason = "Expended"
	EntityArchiveReasonExpired      EntityArchiveReason = "Expired"
	EntityArchiveReasonMadeInError  EntityArchiveReason = "Made in error"
	EntityArchiveReasonMissing      EntityArchiveReason = "Missing"
	EntityArchiveReasonOther        EntityArchiveReason = "Other"
	EntityArchiveReasonRetired      EntityArchiveReason = "Retired"
	EntityArchiveReasonShipped      EntityArchiveReason = "Shipped"
)

// Defines values for EntityRegisteredEventEventType.
const (
	V2EntityRegistered EntityRegisteredEventEventType = "v2.entity.registered"
)

// Defines values for EntitySchemaContainableType.
const (
	BATCH  EntitySchemaContainableType = "BATCH"
	ENTITY EntitySchemaContainableType = "ENTITY"
	NONE   EntitySchemaContainableType = "NONE"
)

// Defines values for EntitySchemaType.
const (
	EntitySchemaTypeAaSequence   EntitySchemaType = "aa_sequence"
	EntitySchemaTypeCustomEntity EntitySchemaType = "custom_entity"
	EntitySchemaTypeDnaOligo     EntitySchemaType = "dna_oligo"
	EntitySchemaTypeDnaSequence  EntitySchemaType = "dna_sequence"
	EntitySchemaTypeMixture      EntitySchemaType = "mixture"
	EntitySchemaTypeMolecule     EntitySchemaType = "molecule"
	EntitySchemaTypeRnaOligo     EntitySchemaType = "rna_oligo"
)

// Defines values for EntitySchemaAppConfigItemType.
const (
	EntitySchemaAppConfigItemTypeEntitySchema EntitySchemaAppConfigItemType = "entity_schema"
)

// Defines values for EntriesArchiveReason.
const (
	EntriesArchiveReasonMadeInError EntriesArchiveReason = "Made in error"
	EntriesArchiveReasonOther       EntriesArchiveReason = "Other"
	EntriesArchiveReasonRetired     EntriesArchiveReason = "Retired"
)

// Defines values for EntryReviewRecordStatus.
const (
	EntryReviewRecordStatusACCEPTANCESNAPSHOTINPROGRESS EntryReviewRecordStatus = "ACCEPTANCE_SNAPSHOT_IN_PROGRESS"
	EntryReviewRecordStatusACCEPTED                     EntryReviewRecordStatus = "ACCEPTED"
	EntryReviewRecordStatusACTIONREQUIRED               EntryReviewRecordStatus = "ACTION_REQUIRED"
	EntryReviewRecordStatusINPROGRESS                   EntryReviewRecordStatus = "IN_PROGRESS"
	EntryReviewRecordStatusNEEDSREVIEW                  EntryReviewRecordStatus = "NEEDS_REVIEW"
	EntryReviewRecordStatusREJECTED                     EntryReviewRecordStatus = "REJECTED"
	EntryReviewRecordStatusRETRACTED                    EntryReviewRecordStatus = "RETRACTED"
	EntryReviewRecordStatusREVIEWSNAPSHOTINPROGRESS     EntryReviewRecordStatus = "REVIEW_SNAPSHOT_IN_PROGRESS"
)

// Defines values for EntryCreatedEventEventType.
const (
	V2EntryCreated EntryCreatedEventEventType = "v2.entry.created"
)

// Defines values for EntryLinkType.
const (
	EntryLinkTypeAaSequence   EntryLinkType = "aa_sequence"
	EntryLinkTypeBatch        EntryLinkType = "batch"
	EntryLinkTypeBox          EntryLinkType = "box"
	EntryLinkTypeContainer    EntryLinkType = "container"
	EntryLinkTypeCustomEntity EntryLinkType = "custom_entity"
	EntryLinkTypeDnaSequence  EntryLinkType = "dna_sequence"
	EntryLinkTypeEntry        EntryLinkType = "entry"
	EntryLinkTypeLink         EntryLinkType = "link"
	EntryLinkTypeLocation     EntryLinkType = "location"
	EntryLinkTypePlate        EntryLinkType = "plate"
	EntryLinkTypeProtocol     EntryLinkType = "protocol"
	EntryLinkTypeRequest      EntryLinkType = "request"
	EntryLinkTypeStageEntry   EntryLinkType = "stage_entry"
	EntryLinkTypeUser         EntryLinkType = "user"
	EntryLinkTypeWorkflow     EntryLinkType = "workflow"
)

// Defines values for EntrySchemaDetailedType.
const (
	EntrySchemaDetailedTypeEntry EntrySchemaDetailedType = "entry"
)

// Defines values for EntryUpdatedFieldsEventEventType.
const (
	V2EntryUpdatedFields EntryUpdatedFieldsEventEventType = "v2.entry.updated.fields"
)

// Defines values for EntryUpdatedReviewRecordEventEventType.
const (
	V2EntryUpdatedReviewRecord EntryUpdatedReviewRecordEventEventType = "v2.entry.updated.reviewRecord"
)

// Defines values for ExportAuditLogAsyncTaskStatus.
const (
	ExportAuditLogAsyncTaskStatusFAILED    ExportAuditLogAsyncTaskStatus = "FAILED"
	ExportAuditLogAsyncTaskStatusRUNNING   ExportAuditLogAsyncTaskStatus = "RUNNING"
	ExportAuditLogAsyncTaskStatusSUCCEEDED ExportAuditLogAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for ExportsAsyncTaskStatus.
const (
	ExportsAsyncTaskStatusFAILED    ExportsAsyncTaskStatus = "FAILED"
	ExportsAsyncTaskStatusRUNNING   ExportsAsyncTaskStatus = "RUNNING"
	ExportsAsyncTaskStatusSUCCEEDED ExportsAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for ExternalFileNotePartType.
const (
	ExternalFile ExternalFileNotePartType = "external_file"
)

// Defines values for FeatureMatchType.
const (
	FeatureMatchTypeNucleotide FeatureMatchType = "nucleotide"
	FeatureMatchTypeProtein    FeatureMatchType = "protein"
)

// Defines values for FeatureCreateMatchType.
const (
	FeatureCreateMatchTypeNucleotide FeatureCreateMatchType = "nucleotide"
	FeatureCreateMatchTypeProtein    FeatureCreateMatchType = "protein"
)

// Defines values for FieldAppConfigItemType.
const (
	FieldAppConfigItemTypeField FieldAppConfigItemType = "field"
)

// Defines values for FieldType.
const (
	FieldTypeAaSequenceLink   FieldType = "aa_sequence_link"
	FieldTypeAssayRequestLink FieldType = "assay_request_link"
	FieldTypeAssayResultLink  FieldType = "assay_result_link"
	FieldTypeAssayRunLink     FieldType = "assay_run_link"
	FieldTypeBatchLink        FieldType = "batch_link"
	FieldTypeBlobLink         FieldType = "blob_link"
	FieldTypeBoolean          FieldType = "boolean"
	FieldTypeCustomEntityLink FieldType = "custom_entity_link"
	FieldTypeDate             FieldType = "date"
	FieldTypeDatetime         FieldType = "datetime"
	FieldTypeDnaSequenceLink  FieldType = "dna_sequence_link"
	FieldTypeDropdown         FieldType = "dropdown"
	FieldTypeEntityLink       FieldType = "entity_link"
	FieldTypeEntryLink        FieldType = "entry_link"
	FieldTypeFloat            FieldType = "float"
	FieldTypeInteger          FieldType = "integer"
	FieldTypeJson             FieldType = "json"
	FieldTypeLongText         FieldType = "long_text"
	FieldTypeMixtureLink      FieldType = "mixture_link"
	FieldTypePartLink         FieldType = "part_link"
	FieldTypeStorageLink      FieldType = "storage_link"
	FieldTypeText             FieldType = "text"
	FieldTypeTranslationLink  FieldType = "translation_link"
)

// Defines values for FindMatchingRegionsAsyncTaskStatus.
const (
	FindMatchingRegionsAsyncTaskStatusFAILED    FindMatchingRegionsAsyncTaskStatus = "FAILED"
	FindMatchingRegionsAsyncTaskStatusRUNNING   FindMatchingRegionsAsyncTaskStatus = "RUNNING"
	FindMatchingRegionsAsyncTaskStatusSUCCEEDED FindMatchingRegionsAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for FindMatchingRegionsDnaAsyncTaskStatus.
const (
	FindMatchingRegionsDnaAsyncTaskStatusFAILED    FindMatchingRegionsDnaAsyncTaskStatus = "FAILED"
	FindMatchingRegionsDnaAsyncTaskStatusRUNNING   FindMatchingRegionsDnaAsyncTaskStatus = "RUNNING"
	FindMatchingRegionsDnaAsyncTaskStatusSUCCEEDED FindMatchingRegionsDnaAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for FloatAppConfigItemType.
const (
	FloatAppConfigItemTypeFloat FloatAppConfigItemType = "float"
)

// Defines values for FloatFieldDefinitionType.
const (
	FloatFieldDefinitionTypeFloat FloatFieldDefinitionType = "float"
)

// Defines values for FoldersArchiveReason.
const (
	FoldersArchiveReasonMadeInError FoldersArchiveReason = "Made in error"
	FoldersArchiveReasonOther       FoldersArchiveReason = "Other"
	FoldersArchiveReasonRetired     FoldersArchiveReason = "Retired"
)

// Defines values for ForbiddenRestrictedSampleErrorErrorType.
const (
	ForbiddenRestrictedSampleErrorErrorTypeInvalidRequestError ForbiddenRestrictedSampleErrorErrorType = "invalid_request_error"
)

// Defines values for GenericApiIdentifiedAppConfigItemType.
const (
	GenericApiIdentifiedAppConfigItemTypeAaSequence         GenericApiIdentifiedAppConfigItemType = "aa_sequence"
	GenericApiIdentifiedAppConfigItemTypeBox                GenericApiIdentifiedAppConfigItemType = "box"
	GenericApiIdentifiedAppConfigItemTypeBoxSchema          GenericApiIdentifiedAppConfigItemType = "box_schema"
	GenericApiIdentifiedAppConfigItemTypeContainer          GenericApiIdentifiedAppConfigItemType = "container"
	GenericApiIdentifiedAppConfigItemTypeContainerSchema    GenericApiIdentifiedAppConfigItemType = "container_schema"
	GenericApiIdentifiedAppConfigItemTypeCustomEntity       GenericApiIdentifiedAppConfigItemType = "custom_entity"
	GenericApiIdentifiedAppConfigItemTypeDnaOligo           GenericApiIdentifiedAppConfigItemType = "dna_oligo"
	GenericApiIdentifiedAppConfigItemTypeDnaSequence        GenericApiIdentifiedAppConfigItemType = "dna_sequence"
	GenericApiIdentifiedAppConfigItemTypeDropdown           GenericApiIdentifiedAppConfigItemType = "dropdown"
	GenericApiIdentifiedAppConfigItemTypeDropdownOption     GenericApiIdentifiedAppConfigItemType = "dropdown_option"
	GenericApiIdentifiedAppConfigItemTypeEntry              GenericApiIdentifiedAppConfigItemType = "entry"
	GenericApiIdentifiedAppConfigItemTypeEntrySchema        GenericApiIdentifiedAppConfigItemType = "entry_schema"
	GenericApiIdentifiedAppConfigItemTypeFolder             GenericApiIdentifiedAppConfigItemType = "folder"
	GenericApiIdentifiedAppConfigItemTypeLocation           GenericApiIdentifiedAppConfigItemType = "location"
	GenericApiIdentifiedAppConfigItemTypeLocationSchema     GenericApiIdentifiedAppConfigItemType = "location_schema"
	GenericApiIdentifiedAppConfigItemTypeMixture            GenericApiIdentifiedAppConfigItemType = "mixture"
	GenericApiIdentifiedAppConfigItemTypeMolecule           GenericApiIdentifiedAppConfigItemType = "molecule"
	GenericApiIdentifiedAppConfigItemTypePlate              GenericApiIdentifiedAppConfigItemType = "plate"
	GenericApiIdentifiedAppConfigItemTypePlateSchema        GenericApiIdentifiedAppConfigItemType = "plate_schema"
	GenericApiIdentifiedAppConfigItemTypeProject            GenericApiIdentifiedAppConfigItemType = "project"
	GenericApiIdentifiedAppConfigItemTypeRegistry           GenericApiIdentifiedAppConfigItemType = "registry"
	GenericApiIdentifiedAppConfigItemTypeRequestSchema      GenericApiIdentifiedAppConfigItemType = "request_schema"
	GenericApiIdentifiedAppConfigItemTypeResultSchema       GenericApiIdentifiedAppConfigItemType = "result_schema"
	GenericApiIdentifiedAppConfigItemTypeRnaOligo           GenericApiIdentifiedAppConfigItemType = "rna_oligo"
	GenericApiIdentifiedAppConfigItemTypeRnaSequence        GenericApiIdentifiedAppConfigItemType = "rna_sequence"
	GenericApiIdentifiedAppConfigItemTypeRunSchema          GenericApiIdentifiedAppConfigItemType = "run_schema"
	GenericApiIdentifiedAppConfigItemTypeWorkflowTaskSchema GenericApiIdentifiedAppConfigItemType = "workflow_task_schema"
	GenericApiIdentifiedAppConfigItemTypeWorkflowTaskStatus GenericApiIdentifiedAppConfigItemType = "workflow_task_status"
	GenericApiIdentifiedAppConfigItemTypeWorklist           GenericApiIdentifiedAppConfigItemType = "worklist"
)

// Defines values for InaccessibleResourceResourceType.
const (
	InaccessibleResourceResourceTypeInaccessibleResource InaccessibleResourceResourceType = "inaccessible_resource"
)

// Defines values for IngredientMeasurementUnits.
const (
	IngredientMeasurementUnitsG     IngredientMeasurementUnits = "g"
	IngredientMeasurementUnitsL     IngredientMeasurementUnits = "L"
	IngredientMeasurementUnitsML    IngredientMeasurementUnits = "mL"
	IngredientMeasurementUnitsMg    IngredientMeasurementUnits = "mg"
	IngredientMeasurementUnitsNL    IngredientMeasurementUnits = "nL"
	IngredientMeasurementUnitsUL    IngredientMeasurementUnits = "uL"
	IngredientMeasurementUnitsUnits IngredientMeasurementUnits = "Units"
)

// Defines values for IntegerAppConfigItemType.
const (
	IntegerAppConfigItemTypeInteger IntegerAppConfigItemType = "integer"
)

// Defines values for IntegerFieldDefinitionType.
const (
	Integer IntegerFieldDefinitionType = "integer"
)

// Defines values for JsonAppConfigItemType.
const (
	Json JsonAppConfigItemType = "json"
)

// Defines values for LabAutomationTransformStatus.
const (
	LabAutomationTransformStatusFAILED     LabAutomationTransformStatus = "FAILED"
	LabAutomationTransformStatusNOTSTARTED LabAutomationTransformStatus = "NOT_STARTED"
	LabAutomationTransformStatusRUNNING    LabAutomationTransformStatus = "RUNNING"
	LabAutomationTransformStatusSUCCEEDED  LabAutomationTransformStatus = "SUCCEEDED"
)

// Defines values for LegacyWorkflowStageRunStatus.
const (
	LegacyWorkflowStageRunStatusCOMPLETED   LegacyWorkflowStageRunStatus = "COMPLETED"
	LegacyWorkflowStageRunStatusDISCARDED   LegacyWorkflowStageRunStatus = "DISCARDED"
	LegacyWorkflowStageRunStatusINITIALIZED LegacyWorkflowStageRunStatus = "INITIALIZED"
)

// Defines values for LocationSchemaType.
const (
	LocationSchemaTypeLocation LocationSchemaType = "location"
)

// Defines values for LocationsArchiveReason.
const (
	LocationsArchiveReasonMadeInError LocationsArchiveReason = "Made in error"
	LocationsArchiveReasonOther       LocationsArchiveReason = "Other"
	LocationsArchiveReasonRetired     LocationsArchiveReason = "Retired"
)

// Defines values for LookupTableNotePartType.
const (
	LookupTable LookupTableNotePartType = "lookup_table"
)

// Defines values for MarkdownUiBlockType.
const (
	MARKDOWN MarkdownUiBlockType = "MARKDOWN"
)

// Defines values for MatchBasesRequestArchiveReason.
const (
	MatchBasesRequestArchiveReasonArchived    MatchBasesRequestArchiveReason = "Archived"
	MatchBasesRequestArchiveReasonNOTARCHIVED MatchBasesRequestArchiveReason = "NOT_ARCHIVED"
	MatchBasesRequestArchiveReasonOther       MatchBasesRequestArchiveReason = "Other"
)

// Defines values for MatchBasesRequestSort.
const (
	MatchBasesRequestSortModifiedAtAsc  MatchBasesRequestSort = "modifiedAt:asc"
	MatchBasesRequestSortModifiedAtDesc MatchBasesRequestSort = "modifiedAt:desc"
	MatchBasesRequestSortNameAsc        MatchBasesRequestSort = "name:asc"
	MatchBasesRequestSortNameDesc       MatchBasesRequestSort = "name:desc"
)

// Defines values for MixtureMeasurementUnits.
const (
	G     MixtureMeasurementUnits = "g"
	Kg    MixtureMeasurementUnits = "kg"
	L     MixtureMeasurementUnits = "L"
	ML    MixtureMeasurementUnits = "mL"
	NL    MixtureMeasurementUnits = "nL"
	UL    MixtureMeasurementUnits = "uL"
	Units MixtureMeasurementUnits = "Units"
)

// Defines values for MixturePrepTableNotePartType.
const (
	MixturePrepTable MixturePrepTableNotePartType = "mixture_prep_table"
)

// Defines values for MixtureWithEntityTypeEntityType.
const (
	MixtureWithEntityTypeEntityTypeMixture MixtureWithEntityTypeEntityType = "mixture"
)

// Defines values for MoleculesArchiveReason.
const (
	MoleculesArchiveReasonContaminated MoleculesArchiveReason = "Contaminated"
	MoleculesArchiveReasonExpended     MoleculesArchiveReason = "Expended"
	MoleculesArchiveReasonExpired      MoleculesArchiveReason = "Expired"
	MoleculesArchiveReasonMadeInError  MoleculesArchiveReason = "Made in error"
	MoleculesArchiveReasonMissing      MoleculesArchiveReason = "Missing"
	MoleculesArchiveReasonOther        MoleculesArchiveReason = "Other"
	MoleculesArchiveReasonRetired      MoleculesArchiveReason = "Retired"
	MoleculesArchiveReasonShipped      MoleculesArchiveReason = "Shipped"
)

// Defines values for MonomerPolymerType.
const (
	MonomerPolymerTypeRNA MonomerPolymerType = "RNA"
)

// Defines values for MonomerType.
const (
	BACKBONE MonomerType = "BACKBONE"
	BRANCH   MonomerType = "BRANCH"
)

// Defines values for MonomerVisualSymbol.
const (
	CLOVERFILLED    MonomerVisualSymbol = "CLOVER_FILLED"
	CLOVERHOLLOW    MonomerVisualSymbol = "CLOVER_HOLLOW"
	DIAMONDDASHED   MonomerVisualSymbol = "DIAMOND_DASHED"
	DIAMONDFILLED   MonomerVisualSymbol = "DIAMOND_FILLED"
	DIAMONDHOLLOW   MonomerVisualSymbol = "DIAMOND_HOLLOW"
	DYADFILLED      MonomerVisualSymbol = "DYAD_FILLED"
	DYADHOLLOW      MonomerVisualSymbol = "DYAD_HOLLOW"
	LETTERSP        MonomerVisualSymbol = "LETTERS_P"
	LETTERSPS       MonomerVisualSymbol = "LETTERS_PS"
	RECTANGLEFILLED MonomerVisualSymbol = "RECTANGLE_FILLED"
	RECTANGLEHOLLOW MonomerVisualSymbol = "RECTANGLE_HOLLOW"
	STARFILLED      MonomerVisualSymbol = "STAR_FILLED"
	STARHOLLOW      MonomerVisualSymbol = "STAR_HOLLOW"
	TRIADFILLED     MonomerVisualSymbol = "TRIAD_FILLED"
	TRIADHOLLOW     MonomerVisualSymbol = "TRIAD_HOLLOW"
	TRIANGLEFILLED  MonomerVisualSymbol = "TRIANGLE_FILLED"
	TRIANGLEHOLLOW  MonomerVisualSymbol = "TRIANGLE_HOLLOW"
)

// Defines values for MonomersArchiveReason.
const (
	MonomersArchiveReasonArchived    MonomersArchiveReason = "Archived"
	MonomersArchiveReasonMadeInError MonomersArchiveReason = "Made in error"
	MonomersArchiveReasonOther       MonomersArchiveReason = "Other"
)

// Defines values for NamingStrategy.
const (
	DELETENAMES               NamingStrategy = "DELETE_NAMES"
	IDSFROMNAMES              NamingStrategy = "IDS_FROM_NAMES"
	KEEPNAMES                 NamingStrategy = "KEEP_NAMES"
	NEWIDS                    NamingStrategy = "NEW_IDS"
	REPLACEIDANDNAMEFROMPARTS NamingStrategy = "REPLACE_ID_AND_NAME_FROM_PARTS"
	REPLACENAMESFROMPARTS     NamingStrategy = "REPLACE_NAMES_FROM_PARTS"
	SETFROMNAMEPARTS          NamingStrategy = "SET_FROM_NAME_PARTS"
)

// Defines values for NotFoundErrorErrorType.
const (
	InvalidRequestError NotFoundErrorErrorType = "invalid_request_error"
)

// Defines values for NucleotideAlignmentBaseAlgorithm.
const (
	NucleotideAlignmentBaseAlgorithmClustalo NucleotideAlignmentBaseAlgorithm = "clustalo"
	NucleotideAlignmentBaseAlgorithmMafft    NucleotideAlignmentBaseAlgorithm = "mafft"
)

// Defines values for NucleotideConsensusAlignmentCreateAlgorithm.
const (
	NucleotideConsensusAlignmentCreateAlgorithmClustalo NucleotideConsensusAlignmentCreateAlgorithm = "clustalo"
	NucleotideConsensusAlignmentCreateAlgorithmMafft    NucleotideConsensusAlignmentCreateAlgorithm = "mafft"
)

// Defines values for NucleotideTemplateAlignmentCreateAlgorithm.
const (
	NucleotideTemplateAlignmentCreateAlgorithmClustalo NucleotideTemplateAlignmentCreateAlgorithm = "clustalo"
	NucleotideTemplateAlignmentCreateAlgorithmMafft    NucleotideTemplateAlignmentCreateAlgorithm = "mafft"
)

// Defines values for OAuthBadRequestErrorErrorType.
const (
	InvalidGrant         OAuthBadRequestErrorErrorType = "invalid_grant"
	InvalidRequest       OAuthBadRequestErrorErrorType = "invalid_request"
	UnauthorizedClient   OAuthBadRequestErrorErrorType = "unauthorized_client"
	UnsupportedGrantType OAuthBadRequestErrorErrorType = "unsupported_grant_type"
)

// Defines values for OAuthUnauthorizedErrorErrorType.
const (
	InvalidClient OAuthUnauthorizedErrorErrorType = "invalid_client"
)

// Defines values for OligoNucleotideType.
const (
	OligoNucleotideTypeDNA OligoNucleotideType = "DNA"
	OligoNucleotideTypeRNA OligoNucleotideType = "RNA"
)

// Defines values for PlateType.
const (
	MatrixPlate PlateType = "matrix_plate"
	WellPlate   PlateType = "well_plate"
)

// Defines values for PlateCreationTableNotePartType.
const (
	PlateCreationTable PlateCreationTableNotePartType = "plate_creation_table"
)

// Defines values for PlateSchemaType.
const (
	PlateSchemaTypePlate PlateSchemaType = "plate"
)

// Defines values for PlatesArchiveReason.
const (
	PlatesArchiveReasonContaminated PlatesArchiveReason = "Contaminated"
	PlatesArchiveReasonExpended     PlatesArchiveReason = "Expended"
	PlatesArchiveReasonExpired      PlatesArchiveReason = "Expired"
	PlatesArchiveReasonMadeInError  PlatesArchiveReason = "Made in error"
	PlatesArchiveReasonMissing      PlatesArchiveReason = "Missing"
	PlatesArchiveReasonOther        PlatesArchiveReason = "Other"
	PlatesArchiveReasonRetired      PlatesArchiveReason = "Retired"
	PlatesArchiveReasonShipped      PlatesArchiveReason = "Shipped"
)

// Defines values for ProjectsArchiveReason.
const (
	ProjectsArchiveReasonMadeInError ProjectsArchiveReason = "Made in error"
	ProjectsArchiveReasonOther       ProjectsArchiveReason = "Other"
	ProjectsArchiveReasonRetired     ProjectsArchiveReason = "Retired"
)

// Defines values for RegistrationTableNotePartType.
const (
	RegistrationTable RegistrationTableNotePartType = "registration_table"
)

// Defines values for RequestCreatedEventEventType.
const (
	V2RequestCreated RequestCreatedEventEventType = "v2.request.created"
)

// Defines values for RequestResponseSamplesStatus.
const (
	RequestResponseSamplesStatusCOMPLETED RequestResponseSamplesStatus = "COMPLETED"
	RequestResponseSamplesStatusDISCARDED RequestResponseSamplesStatus = "DISCARDED"
)

// Defines values for RequestSchemaType.
const (
	RequestSchemaTypeRequest RequestSchemaType = "request"
)

// Defines values for RequestStatus.
const (
	RequestStatusCANCELLED  RequestStatus = "CANCELLED"
	RequestStatusCOMPLETED  RequestStatus = "COMPLETED"
	RequestStatusINPROGRESS RequestStatus = "IN_PROGRESS"
	RequestStatusREQUESTED  RequestStatus = "REQUESTED"
	RequestStatusSCHEDULED  RequestStatus = "SCHEDULED"
)

// Defines values for RequestTaskSchemaType.
const (
	RequestTaskSchemaTypeRequestTask RequestTaskSchemaType = "request_task"
)

// Defines values for RequestUpdatedFieldsEventEventType.
const (
	V2RequestUpdatedFields RequestUpdatedFieldsEventEventType = "v2.request.updated.fields"
)

// Defines values for ResultsTableNotePartType.
const (
	ResultsTable ResultsTableNotePartType = "results_table"
)

// Defines values for RnaOligoWithEntityTypeEntityType.
const (
	RnaOligoWithEntityTypeEntityTypeRnaOligo RnaOligoWithEntityTypeEntityType = "rna_oligo"
)

// Defines values for SampleGroupStatus.
const (
	SampleGroupStatusCOMPLETED  SampleGroupStatus = "COMPLETED"
	SampleGroupStatusFAILED     SampleGroupStatus = "FAILED"
	SampleGroupStatusINPROGRESS SampleGroupStatus = "IN_PROGRESS"
)

// Defines values for SampleRestrictionStatus.
const (
	NOTAPPLICABLE SampleRestrictionStatus = "NOT_APPLICABLE"
	RESTRICTED    SampleRestrictionStatus = "RESTRICTED"
	UNRESTRICTED  SampleRestrictionStatus = "UNRESTRICTED"
)

// Defines values for SchemaDependencySubtypes.
const (
	SchemaDependencySubtypesAaSequence   SchemaDependencySubtypes = "aa_sequence"
	SchemaDependencySubtypesCustomEntity SchemaDependencySubtypes = "custom_entity"
	SchemaDependencySubtypesDnaOligo     SchemaDependencySubtypes = "dna_oligo"
	SchemaDependencySubtypesDnaSequence  SchemaDependencySubtypes = "dna_sequence"
	SchemaDependencySubtypesMixture      SchemaDependencySubtypes = "mixture"
	SchemaDependencySubtypesMolecule     SchemaDependencySubtypes = "molecule"
	SchemaDependencySubtypesRnaOligo     SchemaDependencySubtypes = "rna_oligo"
	SchemaDependencySubtypesRnaSequence  SchemaDependencySubtypes = "rna_sequence"
)

// Defines values for SchemaLinkFieldDefinitionType.
const (
	SchemaLinkFieldDefinitionTypeAssayRequestLink SchemaLinkFieldDefinitionType = "assay_request_link"
	SchemaLinkFieldDefinitionTypeAssayResultLink  SchemaLinkFieldDefinitionType = "assay_result_link"
	SchemaLinkFieldDefinitionTypeAssayRunLink     SchemaLinkFieldDefinitionType = "assay_run_link"
	SchemaLinkFieldDefinitionTypeBatchLink        SchemaLinkFieldDefinitionType = "batch_link"
	SchemaLinkFieldDefinitionTypeEntityLink       SchemaLinkFieldDefinitionType = "entity_link"
	SchemaLinkFieldDefinitionTypeEntryLink        SchemaLinkFieldDefinitionType = "entry_link"
	SchemaLinkFieldDefinitionTypePartLink         SchemaLinkFieldDefinitionType = "part_link"
	SchemaLinkFieldDefinitionTypeStorageLink      SchemaLinkFieldDefinitionType = "storage_link"
	SchemaLinkFieldDefinitionTypeTranslationLink  SchemaLinkFieldDefinitionType = "translation_link"
)

// Defines values for SearchBasesRequestArchiveReason.
const (
	SearchBasesRequestArchiveReasonArchived    SearchBasesRequestArchiveReason = "Archived"
	SearchBasesRequestArchiveReasonNOTARCHIVED SearchBasesRequestArchiveReason = "NOT_ARCHIVED"
	SearchBasesRequestArchiveReasonOther       SearchBasesRequestArchiveReason = "Other"
)

// Defines values for SearchBasesRequestSort.
const (
	SearchBasesRequestSortModifiedAtAsc  SearchBasesRequestSort = "modifiedAt:asc"
	SearchBasesRequestSortModifiedAtDesc SearchBasesRequestSort = "modifiedAt:desc"
	SearchBasesRequestSortNameAsc        SearchBasesRequestSort = "name:asc"
	SearchBasesRequestSortNameDesc       SearchBasesRequestSort = "name:desc"
)

// Defines values for SearchInputMultiValueUiBlockType.
const (
	SEARCHINPUTMULTIVALUE SearchInputMultiValueUiBlockType = "SEARCH_INPUT_MULTIVALUE"
)

// Defines values for SearchInputUiBlockType.
const (
	SEARCHINPUT SearchInputUiBlockType = "SEARCH_INPUT"
)

// Defines values for SearchInputUiBlockItemType.
const (
	SearchInputUiBlockItemTypeAaSequence   SearchInputUiBlockItemType = "aa_sequence"
	SearchInputUiBlockItemTypeBox          SearchInputUiBlockItemType = "box"
	SearchInputUiBlockItemTypeContainer    SearchInputUiBlockItemType = "container"
	SearchInputUiBlockItemTypeCustomEntity SearchInputUiBlockItemType = "custom_entity"
	SearchInputUiBlockItemTypeDnaOligo     SearchInputUiBlockItemType = "dna_oligo"
	SearchInputUiBlockItemTypeDnaSequence  SearchInputUiBlockItemType = "dna_sequence"
	SearchInputUiBlockItemTypeLocation     SearchInputUiBlockItemType = "location"
	SearchInputUiBlockItemTypeMixture      SearchInputUiBlockItemType = "mixture"
	SearchInputUiBlockItemTypePlate        SearchInputUiBlockItemType = "plate"
)

// Defines values for SectionUiBlockType.
const (
	SECTION SectionUiBlockType = "SECTION"
)

// Defines values for SecureTextAppConfigItemType.
const (
	SecureText SecureTextAppConfigItemType = "secure_text"
)

// Defines values for SelectorInputMultiValueUiBlockType.
const (
	SELECTORINPUTMULTIVALUE SelectorInputMultiValueUiBlockType = "SELECTOR_INPUT_MULTIVALUE"
)

// Defines values for SelectorInputUiBlockType.
const (
	SELECTORINPUT SelectorInputUiBlockType = "SELECTOR_INPUT"
)

// Defines values for SimpleFieldDefinitionType.
const (
	SimpleFieldDefinitionTypeAaSequenceLink   SimpleFieldDefinitionType = "aa_sequence_link"
	SimpleFieldDefinitionTypeBlobLink         SimpleFieldDefinitionType = "blob_link"
	SimpleFieldDefinitionTypeBoolean          SimpleFieldDefinitionType = "boolean"
	SimpleFieldDefinitionTypeCustomEntityLink SimpleFieldDefinitionType = "custom_entity_link"
	SimpleFieldDefinitionTypeDate             SimpleFieldDefinitionType = "date"
	SimpleFieldDefinitionTypeDatetime         SimpleFieldDefinitionType = "datetime"
	SimpleFieldDefinitionTypeDnaSequenceLink  SimpleFieldDefinitionType = "dna_sequence_link"
	SimpleFieldDefinitionTypeJson             SimpleFieldDefinitionType = "json"
	SimpleFieldDefinitionTypeLongText         SimpleFieldDefinitionType = "long_text"
	SimpleFieldDefinitionTypeMixtureLink      SimpleFieldDefinitionType = "mixture_link"
	SimpleFieldDefinitionTypeText             SimpleFieldDefinitionType = "text"
)

// Defines values for SimpleNotePartType.
const (
	SimpleNotePartTypeCode       SimpleNotePartType = "code"
	SimpleNotePartTypeListBullet SimpleNotePartType = "list_bullet"
	SimpleNotePartTypeListNumber SimpleNotePartType = "list_number"
	SimpleNotePartTypeText       SimpleNotePartType = "text"
)

// Defines values for StageEntryUpdatedFieldsEventEventType.
const (
	V2AlphaStageEntryUpdatedFields StageEntryUpdatedFieldsEventEventType = "v2-alpha.stageEntry.updated.fields"
)

// Defines values for StageEntryUpdatedReviewRecordEventEventType.
const (
	V2AlphaStageEntryUpdatedReviewRecord StageEntryUpdatedReviewRecordEventEventType = "v2-alpha.stageEntry.updated.reviewRecord"
)

// Defines values for TableNotePartType.
const (
	Table TableNotePartType = "table"
)

// Defines values for TableUiBlockType.
const (
	TABLE TableUiBlockType = "TABLE"
)

// Defines values for TableUiBlockDataFrameSourceType.
const (
	DATAFRAME TableUiBlockDataFrameSourceType = "DATA_FRAME"
)

// Defines values for TableUiBlockDatasetSourceType.
const (
	DATASET TableUiBlockDatasetSourceType = "DATASET"
)

// Defines values for TextAppConfigItemType.
const (
	TextAppConfigItemTypeText TextAppConfigItemType = "text"
)

// Defines values for TextBoxNotePartType.
const (
	TextBox TextBoxNotePartType = "text_box"
)

// Defines values for TextInputUiBlockType.
const (
	TEXTINPUT TextInputUiBlockType = "TEXT_INPUT"
)

// Defines values for TokenCreateGrantType.
const (
	ClientCredentials TokenCreateGrantType = "client_credentials"
)

// Defines values for TokenResponseTokenType.
const (
	Bearer TokenResponseTokenType = "Bearer"
)

// Defines values for TransfersAsyncTaskStatus.
const (
	TransfersAsyncTaskStatusFAILED    TransfersAsyncTaskStatus = "FAILED"
	TransfersAsyncTaskStatusRUNNING   TransfersAsyncTaskStatus = "RUNNING"
	TransfersAsyncTaskStatusSUCCEEDED TransfersAsyncTaskStatus = "SUCCEEDED"
)

// Defines values for TranslationGeneticCode.
const (
	ALTERNATIVEFLATWORMMITOCHONDRIAL                            TranslationGeneticCode = "ALTERNATIVE_FLATWORM_MITOCHONDRIAL"
	ALTERNATIVEYEASTNUCLEAR                                     TranslationGeneticCode = "ALTERNATIVE_YEAST_NUCLEAR"
	ASCIDIANMITOCHONDRIAL                                       TranslationGeneticCode = "ASCIDIAN_MITOCHONDRIAL"
	BACTERIALARCHAEALPLANTPLASTID                               TranslationGeneticCode = "BACTERIAL_ARCHAEAL_PLANT_PLASTID"
	CANDIDATEDIVISIONSR1GRACILIBACTERIA                         TranslationGeneticCode = "CANDIDATE_DIVISION_SR1_GRACILIBACTERIA"
	CEPHALODISCIDAEMITOCHONDRIALUAATYR                          TranslationGeneticCode = "CEPHALODISCIDAE_MITOCHONDRIAL_UAA_TYR"
	CHLOROPHYCEANMITOCHONDRIAL                                  TranslationGeneticCode = "CHLOROPHYCEAN_MITOCHONDRIAL"
	CILIATEDASYCLADACEANHEXAMITANUCLEAR                         TranslationGeneticCode = "CILIATE_DASYCLADACEAN_HEXAMITA_NUCLEAR"
	ECHINODERMFLATWORMMITOCHONDRIAL                             TranslationGeneticCode = "ECHINODERM_FLATWORM_MITOCHONDRIAL"
	EUPLOTIDNUCLEAR                                             TranslationGeneticCode = "EUPLOTID_NUCLEAR"
	INVERTEBRATEMITOCHONDRIAL                                   TranslationGeneticCode = "INVERTEBRATE_MITOCHONDRIAL"
	MESODINIUMNUCLEAR                                           TranslationGeneticCode = "MESODINIUM_NUCLEAR"
	MOLDPROTOZOANCOELENTERATEMITOCHONDRIALMYCOPLASMASPIROPLASMA TranslationGeneticCode = "MOLD_PROTOZOAN_COELENTERATE_MITOCHONDRIAL_MYCOPLASMA_SPIROPLASMA"
	PACHYSOLENTANNOPHILUSNUCLEAR                                TranslationGeneticCode = "PACHYSOLEN_TANNOPHILUS_NUCLEAR"
	PERITRICHNUCLEAR                                            TranslationGeneticCode = "PERITRICH_NUCLEAR"
	RHABDOPLEURIDAEMITOCHONDRIAL                                TranslationGeneticCode = "RHABDOPLEURIDAE_MITOCHONDRIAL"
	SCENEDESMUSOBLIQUUSMITOCHONDRIAL                            TranslationGeneticCode = "SCENEDESMUS_OBLIQUUS_MITOCHONDRIAL"
	STANDARD                                                    TranslationGeneticCode = "STANDARD"
	THRAUSTOCHYTRIUMMITOCHONDRIAL                               TranslationGeneticCode = "THRAUSTOCHYTRIUM_MITOCHONDRIAL"
	TREMATODEMITOCHONDRIAL                                      TranslationGeneticCode = "TREMATODE_MITOCHONDRIAL"
	VERTEBRATEMITOCHONDRIAL                                     TranslationGeneticCode = "VERTEBRATE_MITOCHONDRIAL"
	YEASTMITOCHONDRIAL                                          TranslationGeneticCode = "YEAST_MITOCHONDRIAL"
)

// Defines values for UserValidationValidationStatus.
const (
	UserValidationValidationStatusINVALID        UserValidationValidationStatus = "INVALID"
	UserValidationValidationStatusPARTIALLYVALID UserValidationValidationStatus = "PARTIALLY_VALID"
	UserValidationValidationStatusVALID          UserValidationValidationStatus = "VALID"
)

// Defines values for WellResourceType.
const (
	WellResourceTypeContainer WellResourceType = "container"
)

// Defines values for WorkflowOutputArchiveReason.
const (
	WorkflowOutputArchiveReasonMadeInError WorkflowOutputArchiveReason = "Made in error"
	WorkflowOutputArchiveReasonOther       WorkflowOutputArchiveReason = "Other"
	WorkflowOutputArchiveReasonRetired     WorkflowOutputArchiveReason = "Retired"
)

// Defines values for WorkflowOutputCreatedEventEventType.
const (
	V2WorkflowOutputCreated WorkflowOutputCreatedEventEventType = "v2.workflowOutput.created"
)

// Defines values for WorkflowOutputUpdatedFieldsEventEventType.
const (
	V2WorkflowOutputUpdatedFields WorkflowOutputUpdatedFieldsEventEventType = "v2.workflowOutput.updated.fields"
)

// Defines values for WorkflowStageRunStatus.
const (
	WorkflowStageRunStatusCOMPLETED   WorkflowStageRunStatus = "COMPLETED"
	WorkflowStageRunStatusDISCARDED   WorkflowStageRunStatus = "DISCARDED"
	WorkflowStageRunStatusINITIALIZED WorkflowStageRunStatus = "INITIALIZED"
)

// Defines values for WorkflowTaskExecutionType.
const (
	WorkflowTaskExecutionTypeDIRECT WorkflowTaskExecutionType = "DIRECT"
	WorkflowTaskExecutionTypeENTRY  WorkflowTaskExecutionType = "ENTRY"
)

// Defines values for WorkflowTaskArchiveReason.
const (
	WorkflowTaskArchiveReasonMadeInError WorkflowTaskArchiveReason = "Made in error"
	WorkflowTaskArchiveReasonOther       WorkflowTaskArchiveReason = "Other"
	WorkflowTaskArchiveReasonRetired     WorkflowTaskArchiveReason = "Retired"
)

// Defines values for WorkflowTaskCreatedEventEventType.
const (
	V2WorkflowTaskCreated WorkflowTaskCreatedEventEventType = "v2.workflowTask.created"
)

// Defines values for WorkflowTaskExecutionOriginType.
const (
	WorkflowTaskExecutionOriginTypeAPI   WorkflowTaskExecutionOriginType = "API"
	WorkflowTaskExecutionOriginTypeENTRY WorkflowTaskExecutionOriginType = "ENTRY"
	WorkflowTaskExecutionOriginTypeMODAL WorkflowTaskExecutionOriginType = "MODAL"
)

// Defines values for WorkflowTaskGroupExecutionType.
const (
	WorkflowTaskGroupExecutionTypeDIRECT WorkflowTaskGroupExecutionType = "DIRECT"
	WorkflowTaskGroupExecutionTypeENTRY  WorkflowTaskGroupExecutionType = "ENTRY"
)

// Defines values for WorkflowTaskGroupArchiveReason.
const (
	WorkflowTaskGroupArchiveReasonMadeInError WorkflowTaskGroupArchiveReason = "Made in error"
	WorkflowTaskGroupArchiveReasonOther       WorkflowTaskGroupArchiveReason = "Other"
	WorkflowTaskGroupArchiveReasonRetired     WorkflowTaskGroupArchiveReason = "Retired"
)

// Defines values for WorkflowTaskGroupCreatedEventEventType.
const (
	V2WorkflowTaskGroupCreated WorkflowTaskGroupCreatedEventEventType = "v2.workflowTaskGroup.created"
)

// Defines values for WorkflowTaskGroupUpdatedWatchersEventEventType.
const (
	V2WorkflowTaskGroupUpdatedWatchers WorkflowTaskGroupUpdatedWatchersEventEventType = "v2.workflowTaskGroup.updated.watchers"
)

// Defines values for WorkflowTaskSchemaExecutionType.
const (
	WorkflowTaskSchemaExecutionTypeDIRECT WorkflowTaskSchemaExecutionType = "DIRECT"
	WorkflowTaskSchemaExecutionTypeENTRY  WorkflowTaskSchemaExecutionType = "ENTRY"
)

// Defines values for WorkflowTaskStatusStatusType.
const (
	WorkflowTaskStatusStatusTypeCANCELLED  WorkflowTaskStatusStatusType = "CANCELLED"
	WorkflowTaskStatusStatusTypeCOMPLETED  WorkflowTaskStatusStatusType = "COMPLETED"
	WorkflowTaskStatusStatusTypeFAILED     WorkflowTaskStatusStatusType = "FAILED"
	WorkflowTaskStatusStatusTypeINPROGRESS WorkflowTaskStatusStatusType = "IN_PROGRESS"
	WorkflowTaskStatusStatusTypeINVALID    WorkflowTaskStatusStatusType = "INVALID"
	WorkflowTaskStatusStatusTypePENDING    WorkflowTaskStatusStatusType = "PENDING"
)

// Defines values for WorkflowTaskUpdatedAssigneeEventEventType.
const (
	V2WorkflowTaskUpdatedAssignee WorkflowTaskUpdatedAssigneeEventEventType = "v2.workflowTask.updated.assignee"
)

// Defines values for WorkflowTaskUpdatedFieldsEventEventType.
const (
	V2WorkflowTaskUpdatedFields WorkflowTaskUpdatedFieldsEventEventType = "v2.workflowTask.updated.fields"
)

// Defines values for WorkflowTaskUpdatedScheduledOnEventEventType.
const (
	V2WorkflowTaskUpdatedScheduledOn WorkflowTaskUpdatedScheduledOnEventEventType = "v2.workflowTask.updated.scheduledOn"
)

// Defines values for WorkflowTaskUpdatedStatusEventEventType.
const (
	V2WorkflowTaskUpdatedStatus WorkflowTaskUpdatedStatusEventEventType = "v2.workflowTask.updated.status"
)

// Defines values for ListAASequencesParamsSort.
const (
	ListAASequencesParamsSortModifiedAt     ListAASequencesParamsSort = "modifiedAt"
	ListAASequencesParamsSortModifiedAtAsc  ListAASequencesParamsSort = "modifiedAt:asc"
	ListAASequencesParamsSortModifiedAtDesc ListAASequencesParamsSort = "modifiedAt:desc"
	ListAASequencesParamsSortName           ListAASequencesParamsSort = "name"
	ListAASequencesParamsSortNameAsc        ListAASequencesParamsSort = "name:asc"
	ListAASequencesParamsSortNameDesc       ListAASequencesParamsSort = "name:desc"
)

// Defines values for ListAppConfigurationItemsParamsSort.
const (
	ListAppConfigurationItemsParamsSortCreatedAt      ListAppConfigurationItemsParamsSort = "createdAt"
	ListAppConfigurationItemsParamsSortCreatedAtAsc   ListAppConfigurationItemsParamsSort = "createdAt:asc"
	ListAppConfigurationItemsParamsSortCreatedAtDesc  ListAppConfigurationItemsParamsSort = "createdAt:desc"
	ListAppConfigurationItemsParamsSortModifiedAt     ListAppConfigurationItemsParamsSort = "modifiedAt"
	ListAppConfigurationItemsParamsSortModifiedAtAsc  ListAppConfigurationItemsParamsSort = "modifiedAt:asc"
	ListAppConfigurationItemsParamsSortModifiedAtDesc ListAppConfigurationItemsParamsSort = "modifiedAt:desc"
)

// Defines values for ListBenchlingAppsParamsSort.
const (
	ListBenchlingAppsParamsSortModifiedAt     ListBenchlingAppsParamsSort = "modifiedAt"
	ListBenchlingAppsParamsSortModifiedAtAsc  ListBenchlingAppsParamsSort = "modifiedAt:asc"
	ListBenchlingAppsParamsSortModifiedAtDesc ListBenchlingAppsParamsSort = "modifiedAt:desc"
	ListBenchlingAppsParamsSortName           ListBenchlingAppsParamsSort = "name"
	ListBenchlingAppsParamsSortNameAsc        ListBenchlingAppsParamsSort = "name:asc"
	ListBenchlingAppsParamsSortNameDesc       ListBenchlingAppsParamsSort = "name:desc"
)

// Defines values for ListAssayResultsParamsSort.
const (
	ListAssayResultsParamsSortCreatedAtAsc   ListAssayResultsParamsSort = "createdAt:asc"
	ListAssayResultsParamsSortCreatedAtDesc  ListAssayResultsParamsSort = "createdAt:desc"
	ListAssayResultsParamsSortModifiedAtAsc  ListAssayResultsParamsSort = "modifiedAt:asc"
	ListAssayResultsParamsSortModifiedAtDesc ListAssayResultsParamsSort = "modifiedAt:desc"
)

// Defines values for ListBatchesParamsSort.
const (
	ListBatchesParamsSortModifiedAt     ListBatchesParamsSort = "modifiedAt"
	ListBatchesParamsSortModifiedAtAsc  ListBatchesParamsSort = "modifiedAt:asc"
	ListBatchesParamsSortModifiedAtDesc ListBatchesParamsSort = "modifiedAt:desc"
	ListBatchesParamsSortName           ListBatchesParamsSort = "name"
	ListBatchesParamsSortNameAsc        ListBatchesParamsSort = "name:asc"
	ListBatchesParamsSortNameDesc       ListBatchesParamsSort = "name:desc"
)

// Defines values for ListBoxesParamsSort.
const (
	ListBoxesParamsSortCreatedAtAsc   ListBoxesParamsSort = "createdAt:asc"
	ListBoxesParamsSortCreatedAtDesc  ListBoxesParamsSort = "createdAt:desc"
	ListBoxesParamsSortModifiedAt     ListBoxesParamsSort = "modifiedAt"
	ListBoxesParamsSortModifiedAtAsc  ListBoxesParamsSort = "modifiedAt:asc"
	ListBoxesParamsSortModifiedAtDesc ListBoxesParamsSort = "modifiedAt:desc"
	ListBoxesParamsSortName           ListBoxesParamsSort = "name"
	ListBoxesParamsSortNameAsc        ListBoxesParamsSort = "name:asc"
	ListBoxesParamsSortNameDesc       ListBoxesParamsSort = "name:desc"
)

// Defines values for ListContainersParamsSort.
const (
	ListContainersParamsSortBarcode        ListContainersParamsSort = "barcode"
	ListContainersParamsSortBarcodeAsc     ListContainersParamsSort = "barcode:asc"
	ListContainersParamsSortBarcodeDesc    ListContainersParamsSort = "barcode:desc"
	ListContainersParamsSortCreatedAtAsc   ListContainersParamsSort = "createdAt:asc"
	ListContainersParamsSortCreatedAtDesc  ListContainersParamsSort = "createdAt:desc"
	ListContainersParamsSortModifiedAt     ListContainersParamsSort = "modifiedAt"
	ListContainersParamsSortModifiedAtAsc  ListContainersParamsSort = "modifiedAt:asc"
	ListContainersParamsSortModifiedAtDesc ListContainersParamsSort = "modifiedAt:desc"
	ListContainersParamsSortName           ListContainersParamsSort = "name"
	ListContainersParamsSortNameAsc        ListContainersParamsSort = "name:asc"
	ListContainersParamsSortNameDesc       ListContainersParamsSort = "name:desc"
)

// Defines values for ListContainersParamsCheckoutStatus.
const (
	ListContainersParamsCheckoutStatusAVAILABLE  ListContainersParamsCheckoutStatus = "AVAILABLE"
	ListContainersParamsCheckoutStatusCHECKEDOUT ListContainersParamsCheckoutStatus = "CHECKED_OUT"
	ListContainersParamsCheckoutStatusRESERVED   ListContainersParamsCheckoutStatus = "RESERVED"
)

// Defines values for ListCustomEntitiesParamsSort.
const (
	ListCustomEntitiesParamsSortModifiedAt     ListCustomEntitiesParamsSort = "modifiedAt"
	ListCustomEntitiesParamsSortModifiedAtAsc  ListCustomEntitiesParamsSort = "modifiedAt:asc"
	ListCustomEntitiesParamsSortModifiedAtDesc ListCustomEntitiesParamsSort = "modifiedAt:desc"
	ListCustomEntitiesParamsSortName           ListCustomEntitiesParamsSort = "name"
	ListCustomEntitiesParamsSortNameAsc        ListCustomEntitiesParamsSort = "name:asc"
	ListCustomEntitiesParamsSortNameDesc       ListCustomEntitiesParamsSort = "name:desc"
)

// Defines values for ListDNAAlignmentsParamsSort.
const (
	ListDNAAlignmentsParamsSortModifiedAt     ListDNAAlignmentsParamsSort = "modifiedAt"
	ListDNAAlignmentsParamsSortModifiedAtAsc  ListDNAAlignmentsParamsSort = "modifiedAt:asc"
	ListDNAAlignmentsParamsSortModifiedAtDesc ListDNAAlignmentsParamsSort = "modifiedAt:desc"
	ListDNAAlignmentsParamsSortName           ListDNAAlignmentsParamsSort = "name"
	ListDNAAlignmentsParamsSortNameAsc        ListDNAAlignmentsParamsSort = "name:asc"
	ListDNAAlignmentsParamsSortNameDesc       ListDNAAlignmentsParamsSort = "name:desc"
)

// Defines values for ListDNAOligosParamsSort.
const (
	ListDNAOligosParamsSortModifiedAt     ListDNAOligosParamsSort = "modifiedAt"
	ListDNAOligosParamsSortModifiedAtAsc  ListDNAOligosParamsSort = "modifiedAt:asc"
	ListDNAOligosParamsSortModifiedAtDesc ListDNAOligosParamsSort = "modifiedAt:desc"
	ListDNAOligosParamsSortName           ListDNAOligosParamsSort = "name"
	ListDNAOligosParamsSortNameAsc        ListDNAOligosParamsSort = "name:asc"
	ListDNAOligosParamsSortNameDesc       ListDNAOligosParamsSort = "name:desc"
)

// Defines values for ListDNASequencesParamsSort.
const (
	ListDNASequencesParamsSortModifiedAt     ListDNASequencesParamsSort = "modifiedAt"
	ListDNASequencesParamsSortModifiedAtAsc  ListDNASequencesParamsSort = "modifiedAt:asc"
	ListDNASequencesParamsSortModifiedAtDesc ListDNASequencesParamsSort = "modifiedAt:desc"
	ListDNASequencesParamsSortName           ListDNASequencesParamsSort = "name"
	ListDNASequencesParamsSortNameAsc        ListDNASequencesParamsSort = "name:asc"
	ListDNASequencesParamsSortNameDesc       ListDNASequencesParamsSort = "name:desc"
)

// Defines values for ListEntriesParamsSort.
const (
	ListEntriesParamsSortModifiedAt     ListEntriesParamsSort = "modifiedAt"
	ListEntriesParamsSortModifiedAtAsc  ListEntriesParamsSort = "modifiedAt:asc"
	ListEntriesParamsSortModifiedAtDesc ListEntriesParamsSort = "modifiedAt:desc"
	ListEntriesParamsSortName           ListEntriesParamsSort = "name"
	ListEntriesParamsSortNameAsc        ListEntriesParamsSort = "name:asc"
	ListEntriesParamsSortNameDesc       ListEntriesParamsSort = "name:desc"
)

// Defines values for ListEntriesParamsReviewStatus.
const (
	ACCEPTED    ListEntriesParamsReviewStatus = "ACCEPTED"
	INPROGRESS  ListEntriesParamsReviewStatus = "IN_PROGRESS"
	NEEDSREVIEW ListEntriesParamsReviewStatus = "NEEDS_REVIEW"
	REJECTED    ListEntriesParamsReviewStatus = "REJECTED"
	RETRACTED   ListEntriesParamsReviewStatus = "RETRACTED"
)

// Defines values for ListFeatureLibrariesParamsSort.
const (
	ListFeatureLibrariesParamsSortModifiedAt     ListFeatureLibrariesParamsSort = "modifiedAt"
	ListFeatureLibrariesParamsSortModifiedAtAsc  ListFeatureLibrariesParamsSort = "modifiedAt:asc"
	ListFeatureLibrariesParamsSortModifiedAtDesc ListFeatureLibrariesParamsSort = "modifiedAt:desc"
	ListFeatureLibrariesParamsSortName           ListFeatureLibrariesParamsSort = "name"
	ListFeatureLibrariesParamsSortNameAsc        ListFeatureLibrariesParamsSort = "name:asc"
	ListFeatureLibrariesParamsSortNameDesc       ListFeatureLibrariesParamsSort = "name:desc"
)

// Defines values for ListFeaturesParamsMatchType.
const (
	Nucleotide ListFeaturesParamsMatchType = "nucleotide"
	Protein    ListFeaturesParamsMatchType = "protein"
)

// Defines values for ListFoldersParamsSort.
const (
	ListFoldersParamsSortModifiedAt     ListFoldersParamsSort = "modifiedAt"
	ListFoldersParamsSortModifiedAtAsc  ListFoldersParamsSort = "modifiedAt:asc"
	ListFoldersParamsSortModifiedAtDesc ListFoldersParamsSort = "modifiedAt:desc"
	ListFoldersParamsSortName           ListFoldersParamsSort = "name"
	ListFoldersParamsSortNameAsc        ListFoldersParamsSort = "name:asc"
	ListFoldersParamsSortNameDesc       ListFoldersParamsSort = "name:desc"
)

// Defines values for ListFoldersParamsSection.
const (
	INVENTORY ListFoldersParamsSection = "INVENTORY"
	NOTEBOOK  ListFoldersParamsSection = "NOTEBOOK"
)

// Defines values for ListLocationsParamsSort.
const (
	ListLocationsParamsSortBarcode        ListLocationsParamsSort = "barcode"
	ListLocationsParamsSortBarcodeAsc     ListLocationsParamsSort = "barcode:asc"
	ListLocationsParamsSortBarcodeDesc    ListLocationsParamsSort = "barcode:desc"
	ListLocationsParamsSortCreatedAtAsc   ListLocationsParamsSort = "createdAt:asc"
	ListLocationsParamsSortCreatedAtDesc  ListLocationsParamsSort = "createdAt:desc"
	ListLocationsParamsSortModifiedAt     ListLocationsParamsSort = "modifiedAt"
	ListLocationsParamsSortModifiedAtAsc  ListLocationsParamsSort = "modifiedAt:asc"
	ListLocationsParamsSortModifiedAtDesc ListLocationsParamsSort = "modifiedAt:desc"
	ListLocationsParamsSortName           ListLocationsParamsSort = "name"
	ListLocationsParamsSortNameAsc        ListLocationsParamsSort = "name:asc"
	ListLocationsParamsSortNameDesc       ListLocationsParamsSort = "name:desc"
)

// Defines values for ListMixturesParamsSort.
const (
	ListMixturesParamsSortModifiedAt     ListMixturesParamsSort = "modifiedAt"
	ListMixturesParamsSortModifiedAtAsc  ListMixturesParamsSort = "modifiedAt:asc"
	ListMixturesParamsSortModifiedAtDesc ListMixturesParamsSort = "modifiedAt:desc"
	ListMixturesParamsSortName           ListMixturesParamsSort = "name"
	ListMixturesParamsSortNameAsc        ListMixturesParamsSort = "name:asc"
	ListMixturesParamsSortNameDesc       ListMixturesParamsSort = "name:desc"
)

// Defines values for ListMoleculesParamsSort.
const (
	ListMoleculesParamsSortModifiedAt     ListMoleculesParamsSort = "modifiedAt"
	ListMoleculesParamsSortModifiedAtAsc  ListMoleculesParamsSort = "modifiedAt:asc"
	ListMoleculesParamsSortModifiedAtDesc ListMoleculesParamsSort = "modifiedAt:desc"
	ListMoleculesParamsSortName           ListMoleculesParamsSort = "name"
	ListMoleculesParamsSortNameAsc        ListMoleculesParamsSort = "name:asc"
	ListMoleculesParamsSortNameDesc       ListMoleculesParamsSort = "name:desc"
)

// Defines values for ListNucleotideAlignmentsParamsSort.
const (
	ListNucleotideAlignmentsParamsSortModifiedAt     ListNucleotideAlignmentsParamsSort = "modifiedAt"
	ListNucleotideAlignmentsParamsSortModifiedAtAsc  ListNucleotideAlignmentsParamsSort = "modifiedAt:asc"
	ListNucleotideAlignmentsParamsSortModifiedAtDesc ListNucleotideAlignmentsParamsSort = "modifiedAt:desc"
	ListNucleotideAlignmentsParamsSortName           ListNucleotideAlignmentsParamsSort = "name"
	ListNucleotideAlignmentsParamsSortNameAsc        ListNucleotideAlignmentsParamsSort = "name:asc"
	ListNucleotideAlignmentsParamsSortNameDesc       ListNucleotideAlignmentsParamsSort = "name:desc"
)

// Defines values for ListOligosParamsSort.
const (
	ListOligosParamsSortModifiedAt     ListOligosParamsSort = "modifiedAt"
	ListOligosParamsSortModifiedAtAsc  ListOligosParamsSort = "modifiedAt:asc"
	ListOligosParamsSortModifiedAtDesc ListOligosParamsSort = "modifiedAt:desc"
	ListOligosParamsSortName           ListOligosParamsSort = "name"
	ListOligosParamsSortNameAsc        ListOligosParamsSort = "name:asc"
	ListOligosParamsSortNameDesc       ListOligosParamsSort = "name:desc"
)

// Defines values for ListOrganizationsParamsSort.
const (
	ListOrganizationsParamsSortModifiedAt     ListOrganizationsParamsSort = "modifiedAt"
	ListOrganizationsParamsSortModifiedAtAsc  ListOrganizationsParamsSort = "modifiedAt:asc"
	ListOrganizationsParamsSortModifiedAtDesc ListOrganizationsParamsSort = "modifiedAt:desc"
	ListOrganizationsParamsSortName           ListOrganizationsParamsSort = "name"
	ListOrganizationsParamsSortNameAsc        ListOrganizationsParamsSort = "name:asc"
	ListOrganizationsParamsSortNameDesc       ListOrganizationsParamsSort = "name:desc"
)

// Defines values for ListPlatesParamsSort.
const (
	ListPlatesParamsSortBarcode        ListPlatesParamsSort = "barcode"
	ListPlatesParamsSortCreatedAtAsc   ListPlatesParamsSort = "createdAt:asc"
	ListPlatesParamsSortCreatedAtDesc  ListPlatesParamsSort = "createdAt:desc"
	ListPlatesParamsSortModifiedAt     ListPlatesParamsSort = "modifiedAt"
	ListPlatesParamsSortModifiedAtAsc  ListPlatesParamsSort = "modifiedAt:asc"
	ListPlatesParamsSortModifiedAtDesc ListPlatesParamsSort = "modifiedAt:desc"
	ListPlatesParamsSortName           ListPlatesParamsSort = "name"
	ListPlatesParamsSortNameAsc        ListPlatesParamsSort = "name:asc"
	ListPlatesParamsSortNameDesc       ListPlatesParamsSort = "name:desc"
)

// Defines values for ListProjectsParamsSort.
const (
	ListProjectsParamsSortModifiedAt     ListProjectsParamsSort = "modifiedAt"
	ListProjectsParamsSortModifiedAtAsc  ListProjectsParamsSort = "modifiedAt:asc"
	ListProjectsParamsSortModifiedAtDesc ListProjectsParamsSort = "modifiedAt:desc"
	ListProjectsParamsSortName           ListProjectsParamsSort = "name"
	ListProjectsParamsSortNameAsc        ListProjectsParamsSort = "name:asc"
	ListProjectsParamsSortNameDesc       ListProjectsParamsSort = "name:desc"
)

// Defines values for ListRNAOligosParamsSort.
const (
	ListRNAOligosParamsSortModifiedAt     ListRNAOligosParamsSort = "modifiedAt"
	ListRNAOligosParamsSortModifiedAtAsc  ListRNAOligosParamsSort = "modifiedAt:asc"
	ListRNAOligosParamsSortModifiedAtDesc ListRNAOligosParamsSort = "modifiedAt:desc"
	ListRNAOligosParamsSortName           ListRNAOligosParamsSort = "name"
	ListRNAOligosParamsSortNameAsc        ListRNAOligosParamsSort = "name:asc"
	ListRNAOligosParamsSortNameDesc       ListRNAOligosParamsSort = "name:desc"
)

// Defines values for ListRNASequencesParamsSort.
const (
	ListRNASequencesParamsSortModifiedAt     ListRNASequencesParamsSort = "modifiedAt"
	ListRNASequencesParamsSortModifiedAtAsc  ListRNASequencesParamsSort = "modifiedAt:asc"
	ListRNASequencesParamsSortModifiedAtDesc ListRNASequencesParamsSort = "modifiedAt:desc"
	ListRNASequencesParamsSortName           ListRNASequencesParamsSort = "name"
	ListRNASequencesParamsSortNameAsc        ListRNASequencesParamsSort = "name:asc"
	ListRNASequencesParamsSortNameDesc       ListRNASequencesParamsSort = "name:desc"
)

// Defines values for ListTeamsParamsSort.
const (
	ListTeamsParamsSortModifiedAt     ListTeamsParamsSort = "modifiedAt"
	ListTeamsParamsSortModifiedAtAsc  ListTeamsParamsSort = "modifiedAt:asc"
	ListTeamsParamsSortModifiedAtDesc ListTeamsParamsSort = "modifiedAt:desc"
	ListTeamsParamsSortName           ListTeamsParamsSort = "name"
	ListTeamsParamsSortNameAsc        ListTeamsParamsSort = "name:asc"
	ListTeamsParamsSortNameDesc       ListTeamsParamsSort = "name:desc"
)

// Defines values for ListUsersParamsSort.
const (
	ListUsersParamsSortModifiedAt     ListUsersParamsSort = "modifiedAt"
	ListUsersParamsSortModifiedAtAsc  ListUsersParamsSort = "modifiedAt:asc"
	ListUsersParamsSortModifiedAtDesc ListUsersParamsSort = "modifiedAt:desc"
	ListUsersParamsSortName           ListUsersParamsSort = "name"
	ListUsersParamsSortNameAsc        ListUsersParamsSort = "name:asc"
	ListUsersParamsSortNameDesc       ListUsersParamsSort = "name:desc"
)

// AIGGenerateInputAsyncTask defines model for AIGGenerateInputAsyncTask.
type AIGGenerateInputAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string                   `json:"message,omitempty"`
	Response *AutomationInputGenerator `json:"response,omitempty"`

	// Status The current state of the task.
	Status AIGGenerateInputAsyncTaskStatus `json:"status"`
}

// AIGGenerateInputAsyncTaskStatus The current state of the task.
type AIGGenerateInputAsyncTaskStatus string

// AOPProcessOutputAsyncTask defines model for AOPProcessOutputAsyncTask.
type AOPProcessOutputAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string                    `json:"message,omitempty"`
	Response *AutomationOutputProcessor `json:"response,omitempty"`

	// Status The current state of the task.
	Status AOPProcessOutputAsyncTaskStatus `json:"status"`
}

// AOPProcessOutputAsyncTaskStatus The current state of the task.
type AOPProcessOutputAsyncTaskStatus string

// AaAnnotation defines model for AaAnnotation.
type AaAnnotation struct {
	Color *string `json:"color,omitempty"`

	// End 0-based exclusive end index. The end of the AA sequence is always represented as 0.
	End  *int    `json:"end,omitempty"`
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`

	// Start 0-based inclusive start index.
	Start *int    `json:"start,omitempty"`
	Type  *string `json:"type,omitempty"`
}

// AaSequence defines model for AaSequence.
type AaSequence struct {
	// Aliases Array of aliases
	Aliases *[]string `json:"aliases,omitempty"`

	// AminoAcids Amino acids of the AA sequence.
	AminoAcids *string `json:"aminoAcids,omitempty"`

	// Annotations Array of annotation objects on the AA sequence.
	Annotations *[]AaAnnotation `json:"annotations,omitempty"`

	// ApiURL The canonical url of the AA Sequence in the API.
	ApiURL        *string        `json:"apiURL,omitempty"`
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`

	// CreatedAt DateTime the AA sequence was created.
	CreatedAt *time.Time   `json:"createdAt,omitempty"`
	Creator   *UserSummary `json:"creator,omitempty"`

	// CustomFields Custom fields set on the AA sequence.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// EntityRegistryId Registry ID of the AA sequence if registered.
	EntityRegistryId *string `json:"entityRegistryId"`
	Fields           *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder that contains the AA sequence.
	FolderId *string `json:"folderId"`

	// Id ID of the AA sequence.
	Id *string `json:"id,omitempty"`

	// Length Number of amino acids in the AA sequence.
	Length *int `json:"length,omitempty"`

	// ModifiedAt DateTime the AA sequence was last modified.
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Name Name of the AA sequence.
	Name               *string             `json:"name,omitempty"`
	RegistrationOrigin *RegistrationOrigin `json:"registrationOrigin"`

	// RegistryId Registry the AA sequence is registered in.
	RegistryId *string        `json:"registryId"`
	Schema     *SchemaSummary `json:"schema"`

	// WebURL URL of the protein.
	WebURL *string `json:"webURL,omitempty"`
}

// AaSequenceBaseRequest defines model for AaSequenceBaseRequest.
type AaSequenceBaseRequest struct {
	// Aliases Aliases to add to the AA sequence
	Aliases *[]string `json:"aliases,omitempty"`

	// AminoAcids Amino acids for the AA sequence.
	AminoAcids *string `json:"aminoAcids,omitempty"`

	// Annotations Annotations to create on the AA sequence.
	Annotations *[]AaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the AA sequence's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// CustomFields Custom fields to add to the AA sequence. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// Fields Fields to set on the AA sequence. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the AA sequence.
	FolderId *string `json:"folderId,omitempty"`

	// Name Name of the AA sequence.
	Name *string `json:"name,omitempty"`

	// SchemaId ID of the AA sequence's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// AaSequenceBaseRequestForCreate defines model for AaSequenceBaseRequestForCreate.
type AaSequenceBaseRequestForCreate struct {
	// Aliases Aliases to add to the AA sequence
	Aliases *[]string `json:"aliases,omitempty"`

	// AminoAcids Amino acids for the AA sequence.
	AminoAcids string `json:"aminoAcids"`

	// Annotations Annotations to create on the AA sequence.
	Annotations *[]AaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the AA sequence's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// CustomFields Custom fields to add to the AA sequence. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// Fields Fields to set on the AA sequence. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the AA sequence.
	FolderId *string `json:"folderId,omitempty"`

	// Name Name of the AA sequence.
	Name string `json:"name"`

	// SchemaId ID of the AA sequence's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// AaSequenceBulkCreate defines model for AaSequenceBulkCreate.
type AaSequenceBulkCreate = AaSequenceCreate

// AaSequenceBulkUpdate defines model for AaSequenceBulkUpdate.
type AaSequenceBulkUpdate struct {
	// Aliases Aliases to add to the AA sequence
	Aliases *[]string `json:"aliases,omitempty"`

	// AminoAcids Amino acids for the AA sequence.
	AminoAcids *string `json:"aminoAcids,omitempty"`

	// Annotations Annotations to create on the AA sequence.
	Annotations *[]AaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the AA sequence's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// CustomFields Custom fields to add to the AA sequence. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// Fields Fields to set on the AA sequence. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the AA sequence.
	FolderId *string `json:"folderId,omitempty"`
	Id       *string `json:"id,omitempty"`

	// Name Name of the AA sequence.
	Name *string `json:"name,omitempty"`

	// SchemaId ID of the AA sequence's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// AaSequenceCreate defines model for AaSequenceCreate.
type AaSequenceCreate struct {
	// Aliases Aliases to add to the AA sequence
	Aliases *[]string `json:"aliases,omitempty"`

	// AminoAcids Amino acids for the AA sequence.
	AminoAcids string `json:"aminoAcids"`

	// Annotations Annotations to create on the AA sequence.
	Annotations *[]AaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the AA sequence's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// CustomFields Custom fields to add to the AA sequence. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// EntityRegistryId Entity registry ID to set for the registered entity. Cannot specify both entityRegistryId and namingStrategy at the same time.
	EntityRegistryId *string `json:"entityRegistryId,omitempty"`

	// Fields Fields to set on the AA sequence. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the entity. Can be left empty when registryId is present.
	FolderId *string `json:"folderId,omitempty"`

	// Name Name of the AA sequence.
	Name string `json:"name"`

	// NamingStrategy Specifies the behavior for automatically generated names when registering an entity.
	// - NEW_IDS: Generate new registry IDs
	// - IDS_FROM_NAMES: Generate registry IDs based on entity names
	// - DELETE_NAMES: Generate new registry IDs and replace name with registry ID
	// - SET_FROM_NAME_PARTS: Generate new registry IDs, rename according to name template, and keep old name as alias
	// - REPLACE_NAMES_FROM_PARTS: Generate new registry IDs, and replace name according to name template
	// - KEEP_NAMES: Keep existing entity names as registry IDs
	// - REPLACE_ID_AND_NAME_FROM_PARTS: Generate registry IDs and names according to name template
	NamingStrategy *NamingStrategy `json:"namingStrategy,omitempty"`

	// RegistryId Registry ID into which entity should be registered. this is the ID of the registry which was configured for a particular organization
	// To get available registryIds, use the [/registries endpoint](#/Registry/listRegistries)
	//
	// Required in order for entities to be created directly in the registry.
	RegistryId *string `json:"registryId,omitempty"`

	// SchemaId ID of the AA sequence's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// AaSequenceRequestRegistryFields defines model for AaSequenceRequestRegistryFields.
type AaSequenceRequestRegistryFields struct {
	EntityRegistryId *string `json:"entityRegistryId,omitempty"`
}

// AaSequenceSummary defines model for AaSequenceSummary.
type AaSequenceSummary struct {
	EntityType *AaSequenceSummaryEntityType `json:"entityType,omitempty"`
	Id         *string                      `json:"id,omitempty"`
	// Deprecated:
	Type *string `json:"type,omitempty"`
}

// AaSequenceSummaryEntityType defines model for AaSequenceSummary.EntityType.
type AaSequenceSummaryEntityType string

// AaSequenceUpdate defines model for AaSequenceUpdate.
type AaSequenceUpdate struct {
	// Aliases Aliases to add to the AA sequence
	Aliases *[]string `json:"aliases,omitempty"`

	// AminoAcids Amino acids for the AA sequence.
	AminoAcids *string `json:"aminoAcids,omitempty"`

	// Annotations Annotations to create on the AA sequence.
	Annotations *[]AaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the AA sequence's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// CustomFields Custom fields to add to the AA sequence. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields     *CustomFields `json:"customFields,omitempty"`
	EntityRegistryId *string       `json:"entityRegistryId,omitempty"`

	// Fields Fields to set on the AA sequence. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the AA sequence.
	FolderId *string `json:"folderId,omitempty"`

	// Name Name of the AA sequence.
	Name *string `json:"name,omitempty"`

	// SchemaId ID of the AA sequence's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// AaSequenceWithEntityType defines model for AaSequenceWithEntityType.
type AaSequenceWithEntityType struct {
	// Aliases Array of aliases
	Aliases *[]string `json:"aliases,omitempty"`

	// AminoAcids Amino acids of the AA sequence.
	AminoAcids *string `json:"aminoAcids,omitempty"`

	// Annotations Array of annotation objects on the AA sequence.
	Annotations *[]AaAnnotation `json:"annotations,omitempty"`

	// ApiURL The canonical url of the AA Sequence in the API.
	ApiURL        *string        `json:"apiURL,omitempty"`
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`

	// CreatedAt DateTime the AA sequence was created.
	CreatedAt *time.Time   `json:"createdAt,omitempty"`
	Creator   *UserSummary `json:"creator,omitempty"`

	// CustomFields Custom fields set on the AA sequence.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// EntityRegistryId Registry ID of the AA sequence if registered.
	EntityRegistryId *string                             `json:"entityRegistryId"`
	EntityType       *AaSequenceWithEntityTypeEntityType `json:"entityType,omitempty"`
	Fields           *Fields                             `json:"fields,omitempty"`

	// FolderId ID of the folder that contains the AA sequence.
	FolderId *string `json:"folderId"`

	// Id ID of the AA sequence.
	Id *string `json:"id,omitempty"`

	// Length Number of amino acids in the AA sequence.
	Length *int `json:"length,omitempty"`

	// ModifiedAt DateTime the AA sequence was last modified.
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Name Name of the AA sequence.
	Name               *string             `json:"name,omitempty"`
	RegistrationOrigin *RegistrationOrigin `json:"registrationOrigin"`

	// RegistryId Registry the AA sequence is registered in.
	RegistryId *string        `json:"registryId"`
	Schema     *SchemaSummary `json:"schema"`

	// WebURL URL of the protein.
	WebURL *string `json:"webURL,omitempty"`
}

// AaSequenceWithEntityTypeEntityType defines model for AaSequenceWithEntityType.EntityType.
type AaSequenceWithEntityTypeEntityType string

// AaSequencesArchivalChange IDs of all items that were archived or unarchived, grouped by resource type. This includes the IDs of AA sequences along with any IDs of batches that were archived / unarchived.
type AaSequencesArchivalChange struct {
	AaSequenceIds *[]string `json:"aaSequenceIds,omitempty"`
	BatchIds      *[]string `json:"batchIds,omitempty"`
}

// AaSequencesArchive The request body for archiving AA sequences.
type AaSequencesArchive struct {
	AaSequenceIds []string `json:"aaSequenceIds"`

	// Reason The reason for archiving the provided entities. Accepted reasons may differ based on tenant configuration.
	Reason EntityArchiveReason `json:"reason"`
}

// AaSequencesBulkCreateRequest defines model for AaSequencesBulkCreateRequest.
type AaSequencesBulkCreateRequest struct {
	AaSequences *[]AaSequenceBulkCreate `json:"aaSequences,omitempty"`
}

// AaSequencesBulkGet defines model for AaSequencesBulkGet.
type AaSequencesBulkGet struct {
	AaSequences *[]AaSequence `json:"aaSequences,omitempty"`
}

// AaSequencesBulkUpdateRequest defines model for AaSequencesBulkUpdateRequest.
type AaSequencesBulkUpdateRequest struct {
	AaSequences *[]AaSequenceBulkUpdate `json:"aaSequences,omitempty"`
}

// AaSequencesPaginatedList defines model for AaSequencesPaginatedList.
type AaSequencesPaginatedList struct {
	AaSequences *[]AaSequence `json:"aaSequences,omitempty"`
	NextToken   *string       `json:"nextToken,omitempty"`
}

// AaSequencesUnarchive The request body for unarchiving AA sequences.
type AaSequencesUnarchive struct {
	AaSequenceIds []string `json:"aaSequenceIds"`
}

// AlignedNucleotideSequence defines model for AlignedNucleotideSequence.
type AlignedNucleotideSequence struct {
	Bases *string `json:"bases,omitempty"`
	// Deprecated:
	DnaSequenceId *string `json:"dnaSequenceId"`
	Name          *string `json:"name,omitempty"`

	// PairwiseIdentity Fraction of bases between trimStart and trimEnd that match the template bases. Only present for Template Alignments; Will be empty for Consensus Alignments.
	PairwiseIdentity *float32 `json:"pairwiseIdentity,omitempty"`
	SequenceId       *string  `json:"sequenceId"`
	TrimEnd          *int     `json:"trimEnd,omitempty"`
	TrimStart        *int     `json:"trimStart,omitempty"`
}

// AlignedSequence defines model for AlignedSequence.
type AlignedSequence struct {
	Bases *string `json:"bases,omitempty"`
	// Deprecated:
	DnaSequenceId *string `json:"dnaSequenceId"`
	Name          *string `json:"name,omitempty"`

	// PairwiseIdentity Fraction of bases between trimStart and trimEnd that match the template bases. Only present for Template Alignments; Will be empty for Consensus Alignments.
	PairwiseIdentity *float32 `json:"pairwiseIdentity,omitempty"`
	SequenceId       *string  `json:"sequenceId"`
	TrimEnd          *int     `json:"trimEnd,omitempty"`
	TrimStart        *int     `json:"trimStart,omitempty"`
}

// AppCanvas defines model for AppCanvas.
type AppCanvas struct {
	App *struct {
		// Id The id of the Benchling app.
		Id *string `json:"id,omitempty"`
	} `json:"app,omitempty"`
	ArchiveRecord *struct {
		// Reason Reason that canvases are being archived. Actual reason enum varies by tenant.
		Reason *AppCanvasesArchiveReason `json:"reason,omitempty"`
	} `json:"archiveRecord"`
	Blocks *[]AppCanvas_Blocks_Item `json:"blocks,omitempty"`

	// Data Additional data to associate with the canvas. Can be useful for persisting data associated with the canvas but won't be rendered to the user. If specified, it must be valid JSON in string format less than 5kb in total.
	Data *string `json:"data"`

	// Enabled Overall control for whether the canvas is interactable or not. If `false`, every block is disabled and will override the individual block's `enabled` property. If `true` or absent, the interactivity status will defer to the block's `enabled` property.
	Enabled *bool `json:"enabled,omitempty"`

	// FeatureId Identifier of the feature defined in Benchling App Manifest this canvas corresponds to.
	FeatureId *string `json:"featureId,omitempty"`
	Id        *string `json:"id,omitempty"`

	// ResourceId Identifier of the resource object to attach canvas to.
	ResourceId *string `json:"resourceId,omitempty"`

	// SessionId Identifier of a session. If specified, app status messages from the session will be reported in the canvas.
	SessionId *string `json:"sessionId"`
}

// AppCanvas_Blocks_Item defines model for AppCanvas.blocks.Item.
type AppCanvas_Blocks_Item struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// AppCanvasBase defines model for AppCanvasBase.
type AppCanvasBase struct {
	ArchiveRecord *struct {
		// Reason Reason that canvases are being archived. Actual reason enum varies by tenant.
		Reason *AppCanvasesArchiveReason `json:"reason,omitempty"`
	} `json:"archiveRecord"`
	Blocks *[]AppCanvasBase_Blocks_Item `json:"blocks,omitempty"`

	// Data Additional data to associate with the canvas. Can be useful for persisting data associated with the canvas but won't be rendered to the user. If specified, it must be valid JSON in string format less than 5kb in total.
	Data *string `json:"data"`

	// Enabled Overall control for whether the canvas is interactable or not. If `false`, every block is disabled and will override the individual block's `enabled` property. If `true` or absent, the interactivity status will defer to the block's `enabled` property.
	Enabled *bool `json:"enabled,omitempty"`

	// FeatureId Identifier of the feature defined in Benchling App Manifest this canvas corresponds to.
	FeatureId *string `json:"featureId,omitempty"`

	// ResourceId Identifier of the resource object to attach canvas to.
	ResourceId *string `json:"resourceId,omitempty"`

	// SessionId Identifier of a session. If specified, app status messages from the session will be reported in the canvas.
	SessionId *string `json:"sessionId"`
}

// AppCanvasBase_Blocks_Item defines model for AppCanvasBase.blocks.Item.
type AppCanvasBase_Blocks_Item struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// AppCanvasCreate defines model for AppCanvasCreate.
type AppCanvasCreate struct {
	// AppId Identifier of the app owning this canvas. For backwards compatibility, this property will be temporarily optional until the requisite time window for breaking changes in beta endpoints has passed.
	AppId  string                        `json:"appId"`
	Blocks []AppCanvasCreate_Blocks_Item `json:"blocks"`

	// Data Additional data to associate with the canvas. Can be useful for persisting data associated with the canvas but won't be rendered to the user. If specified, it must be valid JSON in string format less than 5kb in total.
	Data *string `json:"data"`

	// Enabled Overall control for whether the canvas is interactable or not. If `false`, every block is disabled and will override the individual block's `enabled` property. If `true` or absent, the interactivity status will defer to the block's `enabled` property.
	Enabled *bool `json:"enabled,omitempty"`

	// FeatureId Identifier of the feature defined in Benchling App Manifest this canvas corresponds to.
	FeatureId string `json:"featureId"`

	// ResourceId Identifier of the resource object to attach canvas to.
	ResourceId string `json:"resourceId"`

	// SessionId Identifier of a session. If specified, app status messages from the session will be reported in the canvas.
	SessionId *string `json:"sessionId"`
}

// AppCanvasCreate_Blocks_Item defines model for AppCanvasCreate.blocks.Item.
type AppCanvasCreate_Blocks_Item struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// AppCanvasCreateBase defines model for AppCanvasCreateBase.
type AppCanvasCreateBase struct {
	Blocks *[]AppCanvasCreateBase_Blocks_Item `json:"blocks,omitempty"`

	// Data Additional data to associate with the canvas. Can be useful for persisting data associated with the canvas but won't be rendered to the user. If specified, it must be valid JSON in string format less than 5kb in total.
	Data *string `json:"data"`

	// Enabled Overall control for whether the canvas is interactable or not. If `false`, every block is disabled and will override the individual block's `enabled` property. If `true` or absent, the interactivity status will defer to the block's `enabled` property.
	Enabled *bool `json:"enabled,omitempty"`

	// FeatureId Identifier of the feature defined in Benchling App Manifest this canvas corresponds to.
	FeatureId *string `json:"featureId,omitempty"`

	// ResourceId Identifier of the resource object to attach canvas to.
	ResourceId *string `json:"resourceId,omitempty"`

	// SessionId Identifier of a session. If specified, app status messages from the session will be reported in the canvas.
	SessionId *string `json:"sessionId"`
}

// AppCanvasCreateBase_Blocks_Item defines model for AppCanvasCreateBase.blocks.Item.
type AppCanvasCreateBase_Blocks_Item struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// AppCanvasCreateUiBlockList defines model for AppCanvasCreateUiBlockList.
type AppCanvasCreateUiBlockList struct {
	Blocks *[]AppCanvasCreateUiBlockList_Blocks_Item `json:"blocks,omitempty"`
}

// AppCanvasCreateUiBlockList_Blocks_Item defines model for AppCanvasCreateUiBlockList.blocks.Item.
type AppCanvasCreateUiBlockList_Blocks_Item struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// AppCanvasLeafNodeUiBlockList defines model for AppCanvasLeafNodeUiBlockList.
type AppCanvasLeafNodeUiBlockList struct {
	Children []AppCanvasLeafNodeUiBlockList_Children_Item `json:"children"`
}

// AppCanvasLeafNodeUiBlockList_Children_Item defines model for AppCanvasLeafNodeUiBlockList.children.Item.
type AppCanvasLeafNodeUiBlockList_Children_Item struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// AppCanvasUiBlockList defines model for AppCanvasUiBlockList.
type AppCanvasUiBlockList struct {
	Blocks *[]AppCanvasUiBlockList_Blocks_Item `json:"blocks,omitempty"`
}

// AppCanvasUiBlockList_Blocks_Item defines model for AppCanvasUiBlockList.blocks.Item.
type AppCanvasUiBlockList_Blocks_Item struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// AppCanvasUpdate defines model for AppCanvasUpdate.
type AppCanvasUpdate = AppCanvasUpdateBase

// AppCanvasUpdateBase defines model for AppCanvasUpdateBase.
type AppCanvasUpdateBase struct {
	Blocks *[]AppCanvasUpdateBase_Blocks_Item `json:"blocks,omitempty"`

	// Data Additional data to associate with the canvas. Can be useful for persisting data associated with the canvas but won't be rendered to the user. If specified, it must be valid JSON in string format less than 5kb in total.
	Data *string `json:"data"`

	// Enabled Overall control for whether the canvas is interactable or not. If `false`, every block is disabled and will override the individual block's `enabled` property. If `true` or absent, the interactivity status will defer to the block's `enabled` property.
	Enabled *bool `json:"enabled,omitempty"`

	// FeatureId Identifier of the feature defined in Benchling App Manifest this canvas corresponds to.
	FeatureId *string `json:"featureId,omitempty"`

	// ResourceId Identifier of the resource object to attach canvas to.
	ResourceId *string `json:"resourceId,omitempty"`

	// SessionId Identifier of a session. If specified, app status messages from the session will be reported in the canvas.
	SessionId *string `json:"sessionId"`
}

// AppCanvasUpdateBase_Blocks_Item defines model for AppCanvasUpdateBase.blocks.Item.
type AppCanvasUpdateBase_Blocks_Item struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// AppCanvasUpdateUiBlockList defines model for AppCanvasUpdateUiBlockList.
type AppCanvasUpdateUiBlockList struct {
	Blocks *[]AppCanvasUpdateUiBlockList_Blocks_Item `json:"blocks,omitempty"`
}

// AppCanvasUpdateUiBlockList_Blocks_Item defines model for AppCanvasUpdateUiBlockList.blocks.Item.
type AppCanvasUpdateUiBlockList_Blocks_Item struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// AppCanvasWriteBase defines model for AppCanvasWriteBase.
type AppCanvasWriteBase struct {
	// Data Additional data to associate with the canvas. Can be useful for persisting data associated with the canvas but won't be rendered to the user. If specified, it must be valid JSON in string format less than 5kb in total.
	Data *string `json:"data"`

	// Enabled Overall control for whether the canvas is interactable or not. If `false`, every block is disabled and will override the individual block's `enabled` property. If `true` or absent, the interactivity status will defer to the block's `enabled` property.
	Enabled *bool `json:"enabled,omitempty"`

	// FeatureId Identifier of the feature defined in Benchling App Manifest this canvas corresponds to.
	FeatureId *string `json:"featureId,omitempty"`

	// ResourceId Identifier of the resource object to attach canvas to.
	ResourceId *string `json:"resourceId,omitempty"`

	// SessionId Identifier of a session. If specified, app status messages from the session will be reported in the canvas.
	SessionId *string `json:"sessionId"`
}

// AppCanvasesArchivalChange IDs of all items that were archived or unarchived. This includes the IDs of canvases that were archived / unarchived.
type AppCanvasesArchivalChange struct {
	CanvasIds *[]string `json:"canvasIds,omitempty"`
}

// AppCanvasesArchive defines model for AppCanvasesArchive.
type AppCanvasesArchive struct {
	// CanvasIds Array of canvas IDs
	CanvasIds []string `json:"canvasIds"`

	// Reason Reason that canvases are being archived. Actual reason enum varies by tenant.
	Reason AppCanvasesArchiveReason `json:"reason"`
}

// AppCanvasesArchiveReason Reason that canvases are being archived. Actual reason enum varies by tenant.
type AppCanvasesArchiveReason string

// AppCanvasesUnarchive defines model for AppCanvasesUnarchive.
type AppCanvasesUnarchive struct {
	// CanvasIds Array of canvas IDs
	CanvasIds []string `json:"canvasIds"`
}

// AppConfigItem defines model for AppConfigItem.
type AppConfigItem struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// AppConfigItemApiMixin defines model for AppConfigItemApiMixin.
type AppConfigItemApiMixin struct {
	ApiURL *string `json:"apiURL,omitempty"`
	App    *struct {
		// Id The id of the Benchling app to which this configuration item belongs
		Id *string `json:"id,omitempty"`
	} `json:"app,omitempty"`

	// CreatedAt DateTime the app config item was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	Id        *string    `json:"id,omitempty"`

	// ModifiedAt DateTime the app config item was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path *[]string `json:"path,omitempty"`

	// Type Type of the app config item
	Type *string `json:"type,omitempty"`
}

// AppConfigItemBooleanBulkUpdate defines model for AppConfigItemBooleanBulkUpdate.
type AppConfigItemBooleanBulkUpdate struct {
	Id    string                             `json:"id"`
	Type  AppConfigItemBooleanBulkUpdateType `json:"type"`
	Value bool                               `json:"value"`
}

// AppConfigItemBooleanBulkUpdateType defines model for AppConfigItemBooleanBulkUpdate.Type.
type AppConfigItemBooleanBulkUpdateType string

// AppConfigItemBooleanCreate defines model for AppConfigItemBooleanCreate.
type AppConfigItemBooleanCreate struct {
	// AppId App id to which this config item belongs.
	AppId string `json:"appId"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path  []string                       `json:"path"`
	Type  AppConfigItemBooleanCreateType `json:"type"`
	Value bool                           `json:"value"`
}

// AppConfigItemBooleanCreateType defines model for AppConfigItemBooleanCreate.Type.
type AppConfigItemBooleanCreateType string

// AppConfigItemBooleanUpdate defines model for AppConfigItemBooleanUpdate.
type AppConfigItemBooleanUpdate struct {
	Type  AppConfigItemBooleanUpdateType `json:"type"`
	Value bool                           `json:"value"`
}

// AppConfigItemBooleanUpdateType defines model for AppConfigItemBooleanUpdate.Type.
type AppConfigItemBooleanUpdateType string

// AppConfigItemBulkUpdate defines model for AppConfigItemBulkUpdate.
type AppConfigItemBulkUpdate struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// AppConfigItemBulkUpdateMixin defines model for AppConfigItemBulkUpdateMixin.
type AppConfigItemBulkUpdateMixin struct {
	Id string `json:"id"`
}

// AppConfigItemCreate defines model for AppConfigItemCreate.
type AppConfigItemCreate struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// AppConfigItemCreateMixin defines model for AppConfigItemCreateMixin.
type AppConfigItemCreateMixin struct {
	// AppId App id to which this config item belongs.
	AppId string `json:"appId"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path []string `json:"path"`
}

// AppConfigItemDateBulkUpdate defines model for AppConfigItemDateBulkUpdate.
type AppConfigItemDateBulkUpdate struct {
	Id    string                          `json:"id"`
	Type  AppConfigItemDateBulkUpdateType `json:"type"`
	Value string                          `json:"value"`
}

// AppConfigItemDateBulkUpdateType defines model for AppConfigItemDateBulkUpdate.Type.
type AppConfigItemDateBulkUpdateType string

// AppConfigItemDateCreate defines model for AppConfigItemDateCreate.
type AppConfigItemDateCreate struct {
	// AppId App id to which this config item belongs.
	AppId string `json:"appId"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path  []string                    `json:"path"`
	Type  AppConfigItemDateCreateType `json:"type"`
	Value openapi_types.Date          `json:"value"`
}

// AppConfigItemDateCreateType defines model for AppConfigItemDateCreate.Type.
type AppConfigItemDateCreateType string

// AppConfigItemDateUpdate defines model for AppConfigItemDateUpdate.
type AppConfigItemDateUpdate struct {
	Type  AppConfigItemDateUpdateType `json:"type"`
	Value string                      `json:"value"`
}

// AppConfigItemDateUpdateType defines model for AppConfigItemDateUpdate.Type.
type AppConfigItemDateUpdateType string

// AppConfigItemDatetimeBulkUpdate defines model for AppConfigItemDatetimeBulkUpdate.
type AppConfigItemDatetimeBulkUpdate struct {
	Id    string                              `json:"id"`
	Type  AppConfigItemDatetimeBulkUpdateType `json:"type"`
	Value string                              `json:"value"`
}

// AppConfigItemDatetimeBulkUpdateType defines model for AppConfigItemDatetimeBulkUpdate.Type.
type AppConfigItemDatetimeBulkUpdateType string

// AppConfigItemDatetimeCreate defines model for AppConfigItemDatetimeCreate.
type AppConfigItemDatetimeCreate struct {
	// AppId App id to which this config item belongs.
	AppId string `json:"appId"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path  []string                        `json:"path"`
	Type  AppConfigItemDatetimeCreateType `json:"type"`
	Value string                          `json:"value"`
}

// AppConfigItemDatetimeCreateType defines model for AppConfigItemDatetimeCreate.Type.
type AppConfigItemDatetimeCreateType string

// AppConfigItemDatetimeUpdate defines model for AppConfigItemDatetimeUpdate.
type AppConfigItemDatetimeUpdate struct {
	Type  AppConfigItemDatetimeUpdateType `json:"type"`
	Value string                          `json:"value"`
}

// AppConfigItemDatetimeUpdateType defines model for AppConfigItemDatetimeUpdate.Type.
type AppConfigItemDatetimeUpdateType string

// AppConfigItemFloatBulkUpdate defines model for AppConfigItemFloatBulkUpdate.
type AppConfigItemFloatBulkUpdate struct {
	Id    string                           `json:"id"`
	Type  AppConfigItemFloatBulkUpdateType `json:"type"`
	Value float32                          `json:"value"`
}

// AppConfigItemFloatBulkUpdateType defines model for AppConfigItemFloatBulkUpdate.Type.
type AppConfigItemFloatBulkUpdateType string

// AppConfigItemFloatCreate defines model for AppConfigItemFloatCreate.
type AppConfigItemFloatCreate struct {
	// AppId App id to which this config item belongs.
	AppId string `json:"appId"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path  []string                     `json:"path"`
	Type  AppConfigItemFloatCreateType `json:"type"`
	Value float32                      `json:"value"`
}

// AppConfigItemFloatCreateType defines model for AppConfigItemFloatCreate.Type.
type AppConfigItemFloatCreateType string

// AppConfigItemFloatUpdate defines model for AppConfigItemFloatUpdate.
type AppConfigItemFloatUpdate struct {
	Type  AppConfigItemFloatUpdateType `json:"type"`
	Value float32                      `json:"value"`
}

// AppConfigItemFloatUpdateType defines model for AppConfigItemFloatUpdate.Type.
type AppConfigItemFloatUpdateType string

// AppConfigItemGenericBulkUpdate defines model for AppConfigItemGenericBulkUpdate.
type AppConfigItemGenericBulkUpdate struct {
	Id    string                             `json:"id"`
	Type  AppConfigItemGenericBulkUpdateType `json:"type"`
	Value string                             `json:"value"`
}

// AppConfigItemGenericBulkUpdateType defines model for AppConfigItemGenericBulkUpdate.Type.
type AppConfigItemGenericBulkUpdateType string

// AppConfigItemGenericCreate defines model for AppConfigItemGenericCreate.
type AppConfigItemGenericCreate struct {
	// AppId App id to which this config item belongs.
	AppId string `json:"appId"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path  []string                       `json:"path"`
	Type  AppConfigItemGenericCreateType `json:"type"`
	Value string                         `json:"value"`
}

// AppConfigItemGenericCreateType defines model for AppConfigItemGenericCreate.Type.
type AppConfigItemGenericCreateType string

// AppConfigItemGenericUpdate defines model for AppConfigItemGenericUpdate.
type AppConfigItemGenericUpdate struct {
	Type  AppConfigItemGenericUpdateType `json:"type"`
	Value string                         `json:"value"`
}

// AppConfigItemGenericUpdateType defines model for AppConfigItemGenericUpdate.Type.
type AppConfigItemGenericUpdateType string

// AppConfigItemIntegerBulkUpdate defines model for AppConfigItemIntegerBulkUpdate.
type AppConfigItemIntegerBulkUpdate struct {
	Id    string                             `json:"id"`
	Type  AppConfigItemIntegerBulkUpdateType `json:"type"`
	Value int                                `json:"value"`
}

// AppConfigItemIntegerBulkUpdateType defines model for AppConfigItemIntegerBulkUpdate.Type.
type AppConfigItemIntegerBulkUpdateType string

// AppConfigItemIntegerCreate defines model for AppConfigItemIntegerCreate.
type AppConfigItemIntegerCreate struct {
	// AppId App id to which this config item belongs.
	AppId string `json:"appId"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path  []string                       `json:"path"`
	Type  AppConfigItemIntegerCreateType `json:"type"`
	Value int                            `json:"value"`
}

// AppConfigItemIntegerCreateType defines model for AppConfigItemIntegerCreate.Type.
type AppConfigItemIntegerCreateType string

// AppConfigItemIntegerUpdate defines model for AppConfigItemIntegerUpdate.
type AppConfigItemIntegerUpdate struct {
	Type  AppConfigItemIntegerUpdateType `json:"type"`
	Value int                            `json:"value"`
}

// AppConfigItemIntegerUpdateType defines model for AppConfigItemIntegerUpdate.Type.
type AppConfigItemIntegerUpdateType string

// AppConfigItemJsonBulkUpdate defines model for AppConfigItemJsonBulkUpdate.
type AppConfigItemJsonBulkUpdate struct {
	Id    string                          `json:"id"`
	Type  AppConfigItemJsonBulkUpdateType `json:"type"`
	Value string                          `json:"value"`
}

// AppConfigItemJsonBulkUpdateType defines model for AppConfigItemJsonBulkUpdate.Type.
type AppConfigItemJsonBulkUpdateType string

// AppConfigItemJsonCreate defines model for AppConfigItemJsonCreate.
type AppConfigItemJsonCreate struct {
	// AppId App id to which this config item belongs.
	AppId string `json:"appId"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path []string                    `json:"path"`
	Type AppConfigItemJsonCreateType `json:"type"`

	// Value The value of a json create object should be json parseable.
	Value string `json:"value"`
}

// AppConfigItemJsonCreateType defines model for AppConfigItemJsonCreate.Type.
type AppConfigItemJsonCreateType string

// AppConfigItemJsonUpdate defines model for AppConfigItemJsonUpdate.
type AppConfigItemJsonUpdate struct {
	Type  AppConfigItemJsonUpdateType `json:"type"`
	Value string                      `json:"value"`
}

// AppConfigItemJsonUpdateType defines model for AppConfigItemJsonUpdate.Type.
type AppConfigItemJsonUpdateType string

// AppConfigItemUpdate defines model for AppConfigItemUpdate.
type AppConfigItemUpdate struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// AppConfigItemsBulkCreateRequest defines model for AppConfigItemsBulkCreateRequest.
type AppConfigItemsBulkCreateRequest struct {
	AppConfigurationItems []AppConfigItemCreate `json:"appConfigurationItems"`
}

// AppConfigItemsBulkUpdateRequest defines model for AppConfigItemsBulkUpdateRequest.
type AppConfigItemsBulkUpdateRequest struct {
	AppConfigurationItems []AppConfigItemBulkUpdate `json:"appConfigurationItems"`
}

// AppConfigurationPaginatedList defines model for AppConfigurationPaginatedList.
type AppConfigurationPaginatedList struct {
	AppConfigurationItems *[]AppConfigItem `json:"appConfigurationItems,omitempty"`
	NextToken             *string          `json:"nextToken,omitempty"`
}

// AppSession defines model for AppSession.
type AppSession struct {
	App *struct {
		// Id The id of the Benchling app.
		Id *string `json:"id,omitempty"`
	} `json:"app,omitempty"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	Id        *string    `json:"id,omitempty"`

	// Messages An array of `SessionMessage` describing the current session state.
	Messages   *[]AppSessionMessage `json:"messages"`
	ModifiedAt *time.Time           `json:"modifiedAt,omitempty"`

	// Name A brief description of the app's actions for users. Length must be between 3-100 chars. It becomes immutable once a value is set.
	Name *string `json:"name,omitempty"`

	// Status All possible values of a Session's status, including system-updated and user-updated values.
	Status *AppSessionStatus `json:"status,omitempty"`

	// TimeoutSeconds Timeout in seconds, a value between 1 second and 30 days. Once set, it can only be increased, not decreased.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

// AppSessionCreate defines model for AppSessionCreate.
type AppSessionCreate struct {
	AppId string `json:"appId"`

	// Messages An array of `SessionMessage` describing the current session state.
	Messages *[]AppSessionMessageCreate `json:"messages,omitempty"`

	// Name The name of the session. Length must be between 3-100 chars. Value is required and immutable once set.
	Name string `json:"name"`

	// TimeoutSeconds Timeout in seconds, a value between 1 second and 30 days. Once set, it can only be increased, not decreased.
	TimeoutSeconds int `json:"timeoutSeconds"`
}

// AppSessionMessage defines model for AppSessionMessage.
type AppSessionMessage = AppSessionMessageCreate

// AppSessionMessageCreate defines model for AppSessionMessageCreate.
type AppSessionMessageCreate struct {
	// Content A message string, to be rendered as plain text with Benchling chips. References to Benchling items (up to 10 per msg) will be rendered as chips in the Benchling UX. A valid reference is a Benchling API id, prefixed with "id:" and contained by braces. For example: "{id:ent_a0SApq3}."
	Content string                  `json:"content"`
	Style   *AppSessionMessageStyle `json:"style,omitempty"`
}

// AppSessionMessageStyle defines model for AppSessionMessageStyle.
type AppSessionMessageStyle string

// AppSessionStatus All possible values of a Session's status, including system-updated and user-updated values.
type AppSessionStatus string

// AppSessionUpdate Update a session's messages or increase timeoutSeconds.
type AppSessionUpdate struct {
	// Messages An array of `SessionMessage` describing the current session state.
	Messages *[]AppSessionMessageCreate `json:"messages,omitempty"`

	// Status Values that can be specified when updating the status of a Session
	Status *AppSessionUpdateStatus `json:"status,omitempty"`

	// TimeoutSeconds Timeout in seconds, a value between 1 second and 30 days. Once set, it can only be increased, not decreased.
	TimeoutSeconds *int `json:"timeoutSeconds,omitempty"`
}

// AppSessionUpdateStatus Values that can be specified when updating the status of a Session
type AppSessionUpdateStatus string

// AppSummary defines model for AppSummary.
type AppSummary struct {
	// Id The id of the Benchling app.
	Id *string `json:"id,omitempty"`
}

// ArchiveRecord defines model for ArchiveRecord.
type ArchiveRecord struct {
	Reason *string `json:"reason,omitempty"`
}

// ArrayElementAppConfigItem defines model for ArrayElementAppConfigItem.
type ArrayElementAppConfigItem = AppConfigItemApiMixin

// AssayFieldsCreate defines model for AssayFieldsCreate.
type AssayFieldsCreate map[string]interface{}

// AssayResult defines model for AssayResult.
type AssayResult struct {
	// ArchiveRecord ArchiveRecord Resource if the result is archived. This is null if the result is not archived.
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`

	// CreatedAt DateTime at which the the result was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Creator UserSummary Resource of who created the request
	Creator *UserSummary `json:"creator,omitempty"`

	// EntryId ID of the entry that this result is attached to
	EntryId *string `json:"entryId"`

	// FieldValidation Object mapping field names to a UserValidation Resource object for that field. To **set** validation for a result, you *must* use this object.
	FieldValidation *map[string]UserValidation `json:"fieldValidation,omitempty"`

	// Fields Field values for the returned result. Please note the keys of each field are the field's warehouse name (additional_prop) instead of the field's display name (additionalProp).
	Fields *Fields `json:"fields,omitempty"`

	// Id ID of the result
	Id *string `json:"id,omitempty"`

	// IsReviewed Whether or not this result is attached to an accepted entry
	IsReviewed *bool `json:"isReviewed,omitempty"`

	// ModifiedAt DateTime at which the the result was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// ProjectId ID of the project to insert the result into
	ProjectId *string `json:"projectId"`

	// Schema Schema that the result belongs to
	Schema            *SchemaSummary `json:"schema,omitempty"`
	ValidationComment *string        `json:"validationComment,omitempty"`
	ValidationStatus  *string        `json:"validationStatus,omitempty"`
}

// AssayResultCreate defines model for AssayResultCreate.
type AssayResultCreate struct {
	// FieldValidation Dictionary mapping field names to UserValidation Resources.
	FieldValidation *map[string]UserValidation `json:"fieldValidation,omitempty"`

	// Fields Dictionary of result fields. Please note the field keys must be the field's warehouse name, not display name.
	Fields AssayResultCreate_Fields `json:"fields"`

	// Id UUID
	Id *string `json:"id,omitempty"`

	// ProjectId The project that the assay result should be uploaded to. Only users with read access to the project will be able to read the assay result. Leaving this empty will result in only the creator having read access.
	ProjectId *string `json:"projectId"`

	// SchemaId ID of result schema under which to upload this result
	SchemaId string `json:"schemaId"`
}

// AssayResultCreate_Fields Dictionary of result fields. Please note the field keys must be the field's warehouse name, not display name.
type AssayResultCreate_Fields struct {
	union json.RawMessage
}

// AssayResultIdsRequest defines model for AssayResultIdsRequest.
type AssayResultIdsRequest struct {
	AssayResultIds []openapi_types.UUID `json:"assayResultIds"`
}

// AssayResultIdsResponse defines model for AssayResultIdsResponse.
type AssayResultIdsResponse struct {
	AssayResultIds *[]openapi_types.UUID `json:"assayResultIds,omitempty"`
}

// AssayResultSchema defines model for AssayResultSchema.
type AssayResultSchema struct {
	ArchiveRecord    *ArchiveRecord                             `json:"archiveRecord"`
	DerivedFrom      *string                                    `json:"derivedFrom"`
	FieldDefinitions *[]AssayResultSchema_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Id               *string                                    `json:"id,omitempty"`

	// ModifiedAt DateTime the Assay Result Schema was last modified
	ModifiedAt   *time.Time `json:"modifiedAt,omitempty"`
	Name         *string    `json:"name,omitempty"`
	Organization *struct {
		Handle *string `json:"handle,omitempty"`
		Id     *string `json:"id,omitempty"`
		Name   *string `json:"name,omitempty"`
	} `json:"organization,omitempty"`
	SystemName *string                `json:"systemName,omitempty"`
	Type       *AssayResultSchemaType `json:"type,omitempty"`
}

// AssayResultSchema_FieldDefinitions_Item defines model for AssayResultSchema.fieldDefinitions.Item.
type AssayResultSchema_FieldDefinitions_Item struct {
	union json.RawMessage
}

// AssayResultSchemaType defines model for AssayResultSchema.Type.
type AssayResultSchemaType string

// AssayResultSchemasPaginatedList defines model for AssayResultSchemasPaginatedList.
type AssayResultSchemasPaginatedList struct {
	AssayResultSchemas *[]AssayResultSchema `json:"assayResultSchemas,omitempty"`
	NextToken          *string              `json:"nextToken,omitempty"`
}

// AssayResultTransactionCreateResponse defines model for AssayResultTransactionCreateResponse.
type AssayResultTransactionCreateResponse struct {
	Id *openapi_types.UUID `json:"id,omitempty"`
}

// AssayResultsArchive defines model for AssayResultsArchive.
type AssayResultsArchive struct {
	AssayResultIds []openapi_types.UUID `json:"assayResultIds"`

	// Reason The reason for archiving the provided results. Accepted reasons may differ based on tenant configuration
	Reason *AssayResultsArchiveReason `json:"reason,omitempty"`
}

// AssayResultsArchiveReason The reason for archiving the provided results. Accepted reasons may differ based on tenant configuration
type AssayResultsArchiveReason string

// AssayResultsBulkCreateInTableRequest defines model for AssayResultsBulkCreateInTableRequest.
type AssayResultsBulkCreateInTableRequest struct {
	AssayResults []AssayResultCreate `json:"assayResults"`
	TableId      *string             `json:"tableId,omitempty"`
}

// AssayResultsBulkCreateRequest defines model for AssayResultsBulkCreateRequest.
type AssayResultsBulkCreateRequest struct {
	AssayResults []AssayResultCreate `json:"assayResults"`
}

// AssayResultsBulkGet defines model for AssayResultsBulkGet.
type AssayResultsBulkGet struct {
	AssayResults *[]AssayResult `json:"assayResults,omitempty"`
}

// AssayResultsCreateResponse defines model for AssayResultsCreateResponse.
type AssayResultsCreateResponse struct {
	AssayResults *[]openapi_types.UUID `json:"assayResults,omitempty"`
}

// AssayResultsPaginatedList defines model for AssayResultsPaginatedList.
type AssayResultsPaginatedList struct {
	AssayResults *[]AssayResult `json:"assayResults,omitempty"`
	NextToken    *string        `json:"nextToken,omitempty"`
}

// AssayRun defines model for AssayRun.
type AssayRun struct {
	// ApiURL The canonical url of the Run in the API.
	ApiURL            *string        `json:"apiURL,omitempty"`
	ArchiveRecord     *ArchiveRecord `json:"archiveRecord"`
	CreatedAt         *string        `json:"createdAt,omitempty"`
	Creator           *UserSummary   `json:"creator,omitempty"`
	EntryId           *string        `json:"entryId"`
	Fields            *Fields        `json:"fields,omitempty"`
	Id                *string        `json:"id,omitempty"`
	IsReviewed        *bool          `json:"isReviewed,omitempty"`
	ProjectId         *string        `json:"projectId"`
	Schema            *SchemaSummary `json:"schema"`
	ValidationComment *string        `json:"validationComment"`

	// ValidationStatus Must be either VALID or INVALID
	ValidationStatus *AssayRunValidationStatus `json:"validationStatus,omitempty"`
}

// AssayRunCreate defines model for AssayRunCreate.
type AssayRunCreate struct {
	// Fields Object of assay run fields
	Fields AssayRunCreate_Fields `json:"fields"`

	// Id ID of assay run
	Id *string `json:"id,omitempty"`

	// ProjectId The project that the assay run should be uploaded to. Only users with read access to the project will be able to read the assay run. Leaving this empty will result in only the creator having read access.
	ProjectId *string `json:"projectId,omitempty"`

	// SchemaId ID of assay schema that assay run conforms to
	SchemaId string `json:"schemaId"`

	// ValidationComment Additional information about the validation status
	ValidationComment *string `json:"validationComment,omitempty"`

	// ValidationStatus Must be either VALID or INVALID
	ValidationStatus *AssayRunValidationStatus `json:"validationStatus,omitempty"`
}

// AssayRunCreate_Fields Object of assay run fields
type AssayRunCreate_Fields struct {
	union json.RawMessage
}

// AssayRunCreatedEvent defines model for AssayRunCreatedEvent.
type AssayRunCreatedEvent struct {
	AssayRun   *AssayRun                      `json:"assayRun,omitempty"`
	CreatedAt  *time.Time                     `json:"createdAt,omitempty"`
	Deprecated *bool                          `json:"deprecated,omitempty"`
	EventType  *AssayRunCreatedEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
}

// AssayRunCreatedEventEventType defines model for AssayRunCreatedEvent.EventType.
type AssayRunCreatedEventEventType string

// AssayRunNotePart defines model for AssayRunNotePart.
type AssayRunNotePart struct {
	AssayRunId       *string `json:"assayRunId"`
	AssayRunSchemaId *string `json:"assayRunSchemaId,omitempty"`

	// Indentation All notes have an indentation level - the default is 0 for no indent. For lists, indentation gives notes hierarchy - a bulleted list with children is modeled as one note part with indentation 1 followed by note parts with indentation 2, for example.
	Indentation *int                  `json:"indentation,omitempty"`
	Type        *AssayRunNotePartType `json:"type,omitempty"`
}

// AssayRunNotePartType defines model for AssayRunNotePart.Type.
type AssayRunNotePartType string

// AssayRunSchema defines model for AssayRunSchema.
type AssayRunSchema struct {
	ArchiveRecord              *ArchiveRecord `json:"archiveRecord"`
	AutomationInputFileConfigs *[]struct {
		Name *string `json:"name,omitempty"`
	} `json:"automationInputFileConfigs,omitempty"`
	AutomationOutputFileConfigs *[]struct {
		Name *string `json:"name,omitempty"`
	} `json:"automationOutputFileConfigs,omitempty"`
	DerivedFrom      *string                                 `json:"derivedFrom"`
	FieldDefinitions *[]AssayRunSchema_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Id               *string                                 `json:"id,omitempty"`

	// ModifiedAt DateTime the Assay Run Schema was last modified
	ModifiedAt   *time.Time `json:"modifiedAt,omitempty"`
	Name         *string    `json:"name,omitempty"`
	Organization *struct {
		Handle *string `json:"handle,omitempty"`
		Id     *string `json:"id,omitempty"`
		Name   *string `json:"name,omitempty"`
	} `json:"organization,omitempty"`
	SystemName *string             `json:"systemName,omitempty"`
	Type       *AssayRunSchemaType `json:"type,omitempty"`
}

// AssayRunSchema_FieldDefinitions_Item defines model for AssayRunSchema.fieldDefinitions.Item.
type AssayRunSchema_FieldDefinitions_Item struct {
	union json.RawMessage
}

// AssayRunSchemaType defines model for AssayRunSchema.Type.
type AssayRunSchemaType string

// AssayRunSchemasPaginatedList defines model for AssayRunSchemasPaginatedList.
type AssayRunSchemasPaginatedList struct {
	AssayRunSchemas *[]AssayRunSchema `json:"assayRunSchemas,omitempty"`
	NextToken       *string           `json:"nextToken,omitempty"`
}

// AssayRunUpdate defines model for AssayRunUpdate.
type AssayRunUpdate struct {
	Fields *Fields `json:"fields,omitempty"`
}

// AssayRunUpdatedFieldsEvent defines model for AssayRunUpdatedFieldsEvent.
type AssayRunUpdatedFieldsEvent struct {
	AssayRun   *AssayRun                            `json:"assayRun,omitempty"`
	CreatedAt  *time.Time                           `json:"createdAt,omitempty"`
	Deprecated *bool                                `json:"deprecated,omitempty"`
	EventType  *AssayRunUpdatedFieldsEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`

	// Updates These properties have been updated, causing this message
	Updates *[]string `json:"updates,omitempty"`
}

// AssayRunUpdatedFieldsEventEventType defines model for AssayRunUpdatedFieldsEvent.EventType.
type AssayRunUpdatedFieldsEventEventType string

// AssayRunValidationStatus Must be either VALID or INVALID
type AssayRunValidationStatus string

// AssayRunsArchivalChange IDs of all Assay Runs that were archived / unarchived.
type AssayRunsArchivalChange struct {
	AssayRunIds *[]string `json:"assayRunIds,omitempty"`
}

// AssayRunsArchive The request body for archiving Assay Runs.
type AssayRunsArchive struct {
	AssayRunIds []string `json:"assayRunIds"`

	// Reason The reason for archiving the provided Assay Runs. Accepted reasons may differ based on tenant configuration.
	Reason AssayRunsArchiveReason `json:"reason"`
}

// AssayRunsArchiveReason The reason for archiving the provided Assay Runs. Accepted reasons may differ based on tenant configuration.
type AssayRunsArchiveReason string

// AssayRunsBulkCreateRequest defines model for AssayRunsBulkCreateRequest.
type AssayRunsBulkCreateRequest struct {
	AssayRuns []AssayRunCreate `json:"assayRuns"`
}

// AssayRunsBulkCreateResponse defines model for AssayRunsBulkCreateResponse.
type AssayRunsBulkCreateResponse struct {
	AssayRuns *[]string `json:"assayRuns,omitempty"`
}

// AssayRunsBulkGet defines model for AssayRunsBulkGet.
type AssayRunsBulkGet struct {
	AssayRuns *[]AssayRun `json:"assayRuns,omitempty"`
}

// AssayRunsPaginatedList defines model for AssayRunsPaginatedList.
type AssayRunsPaginatedList struct {
	AssayRuns *[]AssayRun `json:"assayRuns,omitempty"`
	NextToken *string     `json:"nextToken,omitempty"`
}

// AssayRunsUnarchive The request body for unarchiving Assay Runs.
type AssayRunsUnarchive struct {
	AssayRunIds []string `json:"assayRunIds"`
}

// AsyncTask defines model for AsyncTask.
type AsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message *string `json:"message,omitempty"`

	// Response Present only when status is SUCCEEDED. response can be empty if there is no data to be returned.
	Response *map[string]interface{} `json:"response,omitempty"`

	// Status The current state of the task.
	Status AsyncTaskStatus `json:"status"`
}

// AsyncTaskStatus The current state of the task.
type AsyncTaskStatus string

// AsyncTaskLink defines model for AsyncTaskLink.
type AsyncTaskLink struct {
	TaskId *openapi_types.UUID `json:"taskId,omitempty"`
}

// AutoAnnotateAaSequences defines model for AutoAnnotateAaSequences.
type AutoAnnotateAaSequences struct {
	// AaSequenceIds Array of AA sequence IDs.
	AaSequenceIds []string `json:"aaSequenceIds"`

	// FeatureLibraryIds Array of feature library IDs.
	FeatureLibraryIds []string `json:"featureLibraryIds"`
}

// AutoAnnotateDnaSequences defines model for AutoAnnotateDnaSequences.
type AutoAnnotateDnaSequences struct {
	// DnaSequenceIds Array of DNA sequence IDs.
	DnaSequenceIds []string `json:"dnaSequenceIds"`

	// FeatureLibraryIds Array of feature library IDs.
	FeatureLibraryIds []string `json:"featureLibraryIds"`
}

// AutoAnnotateRnaSequences defines model for AutoAnnotateRnaSequences.
type AutoAnnotateRnaSequences struct {
	// FeatureLibraryIds Array of feature library IDs.
	FeatureLibraryIds []string `json:"featureLibraryIds"`

	// RnaSequenceIds Array of RNA sequence IDs.
	RnaSequenceIds []string `json:"rnaSequenceIds"`
}

// AutofillPartsAsyncTask defines model for AutofillPartsAsyncTask.
type AutofillPartsAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string      `json:"message,omitempty"`
	Response *interface{} `json:"response,omitempty"`

	// Status The current state of the task.
	Status AutofillPartsAsyncTaskStatus `json:"status"`
}

// AutofillPartsAsyncTaskStatus The current state of the task.
type AutofillPartsAsyncTaskStatus string

// AutofillRnaSequences defines model for AutofillRnaSequences.
type AutofillRnaSequences struct {
	// RnaSequenceIds Array of RNA sequence IDs.
	RnaSequenceIds []string `json:"rnaSequenceIds"`
}

// AutofillSequences defines model for AutofillSequences.
type AutofillSequences struct {
	// DnaSequenceIds Array of DNA sequence IDs.
	DnaSequenceIds []string `json:"dnaSequenceIds"`
}

// AutofillTranslationsAsyncTask defines model for AutofillTranslationsAsyncTask.
type AutofillTranslationsAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string      `json:"message,omitempty"`
	Response *interface{} `json:"response,omitempty"`

	// Status The current state of the task.
	Status AutofillTranslationsAsyncTaskStatus `json:"status"`
}

// AutofillTranslationsAsyncTaskStatus The current state of the task.
type AutofillTranslationsAsyncTaskStatus string

// AutomationFile defines model for AutomationFile.
type AutomationFile struct {
	AssayRunId           *string `json:"assayRunId,omitempty"`
	AutomationFileConfig *struct {
		Name *string `json:"name,omitempty"`
	} `json:"automationFileConfig,omitempty"`
	File   *Blob                 `json:"file"`
	Id     *string               `json:"id,omitempty"`
	Status *AutomationFileStatus `json:"status,omitempty"`
}

// AutomationFileStatus defines model for AutomationFile.Status.
type AutomationFileStatus string

// AutomationFileInputsPaginatedList defines model for AutomationFileInputsPaginatedList.
type AutomationFileInputsPaginatedList struct {
	AutomationInputGenerators *[]AutomationInputGenerator `json:"automationInputGenerators,omitempty"`
	NextToken                 *string                     `json:"nextToken,omitempty"`
}

// AutomationInputGenerator defines model for AutomationInputGenerator.
type AutomationInputGenerator struct {
	// ApiURL The canonical url of the Automation Input Generator in the API.
	ApiURL               *string `json:"apiURL,omitempty"`
	AssayRunId           *string `json:"assayRunId,omitempty"`
	AutomationFileConfig *struct {
		Name *string `json:"name,omitempty"`
	} `json:"automationFileConfig,omitempty"`

	// CreatedAt DateTime the Automation Input Generator was last modified
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	File      *Blob      `json:"file"`
	Id        *string    `json:"id,omitempty"`

	// ModifiedAt DateTime the Automation Input Generator was last modified
	ModifiedAt *time.Time                      `json:"modifiedAt,omitempty"`
	Status     *AutomationInputGeneratorStatus `json:"status,omitempty"`
	Transforms *[]LabAutomationTransform       `json:"transforms,omitempty"`
}

// AutomationInputGeneratorStatus defines model for AutomationInputGenerator.Status.
type AutomationInputGeneratorStatus string

// AutomationInputGeneratorCompletedV2BetaEvent defines model for AutomationInputGeneratorCompletedV2BetaEvent.
type AutomationInputGeneratorCompletedV2BetaEvent struct {
	AutomationInputGenerator *AutomationFile                                        `json:"automationInputGenerator,omitempty"`
	CreatedAt                *time.Time                                             `json:"createdAt,omitempty"`
	Deprecated               *bool                                                  `json:"deprecated,omitempty"`
	EventType                *AutomationInputGeneratorCompletedV2BetaEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
}

// AutomationInputGeneratorCompletedV2BetaEventEventType defines model for AutomationInputGeneratorCompletedV2BetaEvent.EventType.
type AutomationInputGeneratorCompletedV2BetaEventEventType string

// AutomationInputGeneratorUpdate defines model for AutomationInputGeneratorUpdate.
type AutomationInputGeneratorUpdate struct {
	// FileId The ID of the file (blob) associated with the input generator. Set to `null` to remove an existing file from the generator.
	FileId *string `json:"fileId"`
}

// AutomationOutputProcessor defines model for AutomationOutputProcessor.
type AutomationOutputProcessor struct {
	// ApiURL The canonical url of the Automation Output Processor in the API.
	ApiURL               *string        `json:"apiURL,omitempty"`
	ArchiveRecord        *ArchiveRecord `json:"archiveRecord"`
	AssayRunId           *string        `json:"assayRunId,omitempty"`
	AutomationFileConfig *struct {
		Name *string `json:"name,omitempty"`
	} `json:"automationFileConfig,omitempty"`

	// CompleteWithErrors Specifies whether file processing should complete with errors. False means any error in output file processing will result in no actions being committed. True means that if row-level errors occur, then failing rows and their errors will be saved to errorFile, and actions from successful rows will be committed.
	CompleteWithErrors *bool `json:"completeWithErrors,omitempty"`

	// CreatedAt DateTime the Automation Output Processor was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	ErrorFile *Blob      `json:"errorFile"`
	File      *Blob      `json:"file"`
	Id        *string    `json:"id,omitempty"`

	// ModifiedAt DateTime the Automation Output Processor was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// ProgressStats Processing progress information.
	ProgressStats *AutomationProgressStats         `json:"progressStats,omitempty"`
	Status        *AutomationOutputProcessorStatus `json:"status,omitempty"`
	Transforms    *[]LabAutomationTransform        `json:"transforms,omitempty"`
}

// AutomationOutputProcessorStatus defines model for AutomationOutputProcessor.Status.
type AutomationOutputProcessorStatus string

// AutomationOutputProcessorArchivalChange IDs of all items that were archived or unarchived, grouped by resource type. This includes the IDs of any linked Results that were archived / unarchived.
type AutomationOutputProcessorArchivalChange struct {
	AutomationOutputProcessorIds *[]string `json:"automationOutputProcessorIds,omitempty"`
	ResultIds                    *[]string `json:"resultIds,omitempty"`
}

// AutomationOutputProcessorCompletedV2BetaEvent defines model for AutomationOutputProcessorCompletedV2BetaEvent.
type AutomationOutputProcessorCompletedV2BetaEvent struct {
	AutomationOutputProcessor *AutomationFile                                         `json:"automationOutputProcessor,omitempty"`
	CreatedAt                 *time.Time                                              `json:"createdAt,omitempty"`
	Deprecated                *bool                                                   `json:"deprecated,omitempty"`
	EventType                 *AutomationOutputProcessorCompletedV2BetaEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
}

// AutomationOutputProcessorCompletedV2BetaEventEventType defines model for AutomationOutputProcessorCompletedV2BetaEvent.EventType.
type AutomationOutputProcessorCompletedV2BetaEventEventType string

// AutomationOutputProcessorCreate defines model for AutomationOutputProcessorCreate.
type AutomationOutputProcessorCreate struct {
	AssayRunId               string `json:"assayRunId"`
	AutomationFileConfigName string `json:"automationFileConfigName"`

	// CompleteWithErrors Specifies whether file processing should complete with errors. False means any error in output file processing will result in no actions being committed. True means that if row-level errors occur, then failing rows and their errors will be saved to errorFile, and actions from successful rows will be committed.
	CompleteWithErrors *bool `json:"completeWithErrors,omitempty"`

	// FileId The ID of a blob link to process.
	FileId string `json:"fileId"`
}

// AutomationOutputProcessorUpdate defines model for AutomationOutputProcessorUpdate.
type AutomationOutputProcessorUpdate struct {
	// FileId The ID of a blob link to process.
	FileId string `json:"fileId"`
}

// AutomationOutputProcessorUploadedV2BetaEvent defines model for AutomationOutputProcessorUploadedV2BetaEvent.
type AutomationOutputProcessorUploadedV2BetaEvent struct {
	AutomationOutputProcessor *AutomationFile                                        `json:"automationOutputProcessor,omitempty"`
	CreatedAt                 *time.Time                                             `json:"createdAt,omitempty"`
	Deprecated                *bool                                                  `json:"deprecated,omitempty"`
	EventType                 *AutomationOutputProcessorUploadedV2BetaEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
}

// AutomationOutputProcessorUploadedV2BetaEventEventType defines model for AutomationOutputProcessorUploadedV2BetaEvent.EventType.
type AutomationOutputProcessorUploadedV2BetaEventEventType string

// AutomationOutputProcessorsArchive defines model for AutomationOutputProcessorsArchive.
type AutomationOutputProcessorsArchive struct {
	// AutomationOutputProcessorIds Array of automation output processor IDs
	AutomationOutputProcessorIds []string `json:"automationOutputProcessorIds"`

	// Reason The reason that the output processors are being archived. Accepted reasons may differ based on tenant configuration.
	Reason *AutomationOutputProcessorsArchiveReason `json:"reason,omitempty"`
}

// AutomationOutputProcessorsArchiveReason The reason that the output processors are being archived. Accepted reasons may differ based on tenant configuration.
type AutomationOutputProcessorsArchiveReason string

// AutomationOutputProcessorsPaginatedList A paginated list of automation output processors which have an attached file.
type AutomationOutputProcessorsPaginatedList struct {
	AutomationOutputProcessors *[]AutomationOutputProcessor `json:"automationOutputProcessors,omitempty"`
	NextToken                  *string                      `json:"nextToken,omitempty"`
}

// AutomationOutputProcessorsUnarchive defines model for AutomationOutputProcessorsUnarchive.
type AutomationOutputProcessorsUnarchive struct {
	// AutomationOutputProcessorIds Array of automation output processor IDs
	AutomationOutputProcessorIds []string `json:"automationOutputProcessorIds"`
}

// AutomationProgressStats Processing progress information.
type AutomationProgressStats struct {
	RowsFailed      *int `json:"rowsFailed,omitempty"`
	RowsSucceeded   *int `json:"rowsSucceeded,omitempty"`
	RowsUnprocessed *int `json:"rowsUnprocessed,omitempty"`
}

// BadRequestError defines model for BadRequestError.
type BadRequestError struct {
	Error *struct {
		Message     *string                   `json:"message,omitempty"`
		Type        *BadRequestErrorErrorType `json:"type,omitempty"`
		UserMessage *string                   `json:"userMessage,omitempty"`
	} `json:"error,omitempty"`
}

// BadRequestErrorErrorType defines model for BadRequestError.Error.Type.
type BadRequestErrorErrorType string

// BadRequestErrorBulk defines model for BadRequestErrorBulk.
type BadRequestErrorBulk struct {
	Error *struct {
		Errors *[]struct {
			Index   *float32 `json:"index,omitempty"`
			Message *string  `json:"message,omitempty"`
		} `json:"errors,omitempty"`
	} `json:"error,omitempty"`
}

// BarcodeValidationResult defines model for BarcodeValidationResult.
type BarcodeValidationResult struct {
	// Barcode Barcode to validate.
	Barcode *string `json:"barcode,omitempty"`

	// IsValid Whether the barcode is valid.
	IsValid *bool `json:"isValid,omitempty"`

	// Message If barcode is not valid, a message string explaining the error.
	Message *string `json:"message"`
}

// BarcodeValidationResults defines model for BarcodeValidationResults.
type BarcodeValidationResults struct {
	ValidationResults *[]BarcodeValidationResult `json:"validationResults,omitempty"`
}

// BarcodesList defines model for BarcodesList.
type BarcodesList struct {
	// Barcodes Array of barcodes to validate.
	Barcodes []string `json:"barcodes"`
}

// BaseAppConfigItem defines model for BaseAppConfigItem.
type BaseAppConfigItem struct {
	ApiURL *string `json:"apiURL,omitempty"`
	App    *struct {
		// Id The id of the Benchling app to which this configuration item belongs
		Id *string `json:"id,omitempty"`
	} `json:"app,omitempty"`

	// CreatedAt DateTime the app config item was created
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	Description *string    `json:"description,omitempty"`
	Id          *string    `json:"id,omitempty"`

	// ModifiedAt DateTime the app config item was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path           *[]string `json:"path,omitempty"`
	RequiredConfig *bool     `json:"requiredConfig,omitempty"`

	// Type Type of the app config item
	Type *string `json:"type,omitempty"`
}

// BaseAssaySchema defines model for BaseAssaySchema.
type BaseAssaySchema struct {
	ArchiveRecord    *ArchiveRecord                           `json:"archiveRecord"`
	DerivedFrom      *string                                  `json:"derivedFrom"`
	FieldDefinitions *[]BaseAssaySchema_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Id               *string                                  `json:"id,omitempty"`
	Name             *string                                  `json:"name,omitempty"`
	Organization     *struct {
		Handle *string `json:"handle,omitempty"`
		Id     *string `json:"id,omitempty"`
		Name   *string `json:"name,omitempty"`
	} `json:"organization,omitempty"`
	SystemName *string `json:"systemName,omitempty"`
	Type       *string `json:"type,omitempty"`
}

// BaseAssaySchema_FieldDefinitions_Item defines model for BaseAssaySchema.fieldDefinitions.Item.
type BaseAssaySchema_FieldDefinitions_Item struct {
	union json.RawMessage
}

// BaseDropdownUIBlock defines model for BaseDropdownUIBlock.
type BaseDropdownUIBlock struct {
	DropdownId string `json:"dropdownId"`
}

// BaseError defines model for BaseError.
type BaseError struct {
	Message     *string `json:"message,omitempty"`
	Type        *string `json:"type,omitempty"`
	UserMessage *string `json:"userMessage,omitempty"`
}

// BaseNotePart defines model for BaseNotePart.
type BaseNotePart struct {
	// Indentation All notes have an indentation level - the default is 0 for no indent. For lists, indentation gives notes hierarchy - a bulleted list with children is modeled as one note part with indentation 1 followed by note parts with indentation 2, for example.
	Indentation *int `json:"indentation,omitempty"`

	// Type The type of the note.  Type determines what other fields are present.
	Type *string `json:"type,omitempty"`
}

// BaseSearchInputUIBlock defines model for BaseSearchInputUIBlock.
type BaseSearchInputUIBlock struct {
	ItemType SearchInputUiBlockItemType `json:"itemType"`
	SchemaId *string                    `json:"schemaId"`
}

// BaseSelectorInputUIBlock defines model for BaseSelectorInputUIBlock.
type BaseSelectorInputUIBlock struct {
	Options []string `json:"options"`
}

// Batch defines model for Batch.
type Batch struct {
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`

	// CreatedAt DateTime at which the the result was created
	CreatedAt            *time.Time     `json:"createdAt,omitempty"`
	Creator              *UserSummary   `json:"creator,omitempty"`
	DefaultConcentration *Measurement   `json:"defaultConcentration,omitempty"`
	Entity               *Batch_Entity  `json:"entity,omitempty"`
	Fields               *Fields        `json:"fields,omitempty"`
	Id                   *string        `json:"id,omitempty"`
	ModifiedAt           *time.Time     `json:"modifiedAt,omitempty"`
	Name                 *string        `json:"name,omitempty"`
	Schema               *SchemaSummary `json:"schema"`
	WebURL               *string        `json:"webURL,omitempty"`
}

// Batch_Entity defines model for Batch.Entity.
type Batch_Entity struct {
	EntityType string `json:"entityType"`
	union      json.RawMessage
}

// BatchCreate defines model for BatchCreate.
type BatchCreate struct {
	DefaultConcentration *DefaultConcentrationSummary `json:"defaultConcentration,omitempty"`

	// EntityId API identifier for the entity that the batch will be added to.
	EntityId *string `json:"entityId,omitempty"`
	Fields   *Fields `json:"fields,omitempty"`
}

// BatchOrInaccessibleResource defines model for BatchOrInaccessibleResource.
type BatchOrInaccessibleResource struct {
	union json.RawMessage
}

// BatchSchema defines model for BatchSchema.
type BatchSchema struct {
	ArchiveRecord    *ArchiveRecord                       `json:"archiveRecord"`
	EntitySchemaId   *string                              `json:"entitySchemaId,omitempty"`
	FieldDefinitions *[]BatchSchema_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Id               *string                              `json:"id,omitempty"`

	// ModifiedAt DateTime the Batch Schema was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`
	Name       *string    `json:"name,omitempty"`
	Prefix     *string    `json:"prefix,omitempty"`
	RegistryId *string    `json:"registryId,omitempty"`
	Type       *string    `json:"type,omitempty"`
}

// BatchSchema_FieldDefinitions_Item defines model for BatchSchema.fieldDefinitions.Item.
type BatchSchema_FieldDefinitions_Item struct {
	union json.RawMessage
}

// BatchSchemasList defines model for BatchSchemasList.
type BatchSchemasList struct {
	BatchSchemas *[]BatchSchema `json:"batchSchemas,omitempty"`
}

// BatchSchemasPaginatedList defines model for BatchSchemasPaginatedList.
type BatchSchemasPaginatedList struct {
	BatchSchemas *[]BatchSchema `json:"batchSchemas,omitempty"`
	NextToken    *string        `json:"nextToken,omitempty"`
}

// BatchUpdate defines model for BatchUpdate.
type BatchUpdate struct {
	DefaultConcentration *DefaultConcentrationSummary `json:"defaultConcentration,omitempty"`
	Fields               *Fields                      `json:"fields,omitempty"`
}

// BatchesArchivalChange IDs of all batches that were archived / unarchived, grouped by resource type.
type BatchesArchivalChange struct {
	BatchIds *[]string `json:"batchIds,omitempty"`
}

// BatchesArchive The request body for archiving Batches.
type BatchesArchive struct {
	BatchIds []string `json:"batchIds"`

	// Reason The reason for archiving the provided Batches. Accepted reasons may differ based on tenant configuration.
	Reason BatchesArchiveReason `json:"reason"`
}

// BatchesArchiveReason The reason for archiving the provided Batches. Accepted reasons may differ based on tenant configuration.
type BatchesArchiveReason string

// BatchesBulkGet defines model for BatchesBulkGet.
type BatchesBulkGet struct {
	Batches *[]Batch `json:"batches,omitempty"`
}

// BatchesPaginatedList defines model for BatchesPaginatedList.
type BatchesPaginatedList struct {
	Batches   *[]Batch `json:"batches,omitempty"`
	NextToken *string  `json:"nextToken,omitempty"`
}

// BatchesUnarchive The request body for unarchiving Batches.
type BatchesUnarchive struct {
	BatchIds []string `json:"batchIds"`
}

// BenchlingApp defines model for BenchlingApp.
type BenchlingApp struct {
	ApiUrl        *string        `json:"apiUrl,omitempty"`
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`

	// CreatedAt DateTime at which the the app was created
	CreatedAt   *time.Time   `json:"createdAt,omitempty"`
	Creator     *UserSummary `json:"creator,omitempty"`
	Description *string      `json:"description,omitempty"`
	Id          *string      `json:"id,omitempty"`

	// ModifiedAt DateTime at which the the app was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`
	Name       *string    `json:"name,omitempty"`
	WebUrl     *string    `json:"webUrl,omitempty"`
}

// BenchlingAppCreate defines model for BenchlingAppCreate.
type BenchlingAppCreate struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

// BenchlingAppUpdate defines model for BenchlingAppUpdate.
type BenchlingAppUpdate struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// BenchlingAppsArchivalChange IDs of all items that were archived or unarchived, grouped by resource type. This includes the IDs of apps that were archived / unarchived.
type BenchlingAppsArchivalChange struct {
	AppIds *[]string `json:"appIds,omitempty"`
}

// BenchlingAppsArchive defines model for BenchlingAppsArchive.
type BenchlingAppsArchive struct {
	// AppIds Array of app IDs
	AppIds []string `json:"appIds"`

	// Reason Reason that apps are being archived. Actual reason enum varies by tenant.
	Reason BenchlingAppsArchiveReason `json:"reason"`
}

// BenchlingAppsArchiveReason Reason that apps are being archived. Actual reason enum varies by tenant.
type BenchlingAppsArchiveReason string

// BenchlingAppsPaginatedList defines model for BenchlingAppsPaginatedList.
type BenchlingAppsPaginatedList struct {
	Apps      *[]BenchlingApp `json:"apps,omitempty"`
	NextToken *string         `json:"nextToken,omitempty"`
}

// BenchlingAppsUnarchive defines model for BenchlingAppsUnarchive.
type BenchlingAppsUnarchive struct {
	// AppIds Array of app IDs
	AppIds []string `json:"appIds"`
}

// Blob defines model for Blob.
type Blob struct {
	// Id The universally unique identifier (UUID) for the blob.
	Id *openapi_types.UUID `json:"id,omitempty"`

	// MimeType eg. application/jpeg
	MimeType *string `json:"mimeType,omitempty"`

	// Name Name of the blob
	Name *string `json:"name,omitempty"`

	// Type One of RAW_FILE or VISUALIZATION. If VISUALIZATION, the blob may be displayed as an image preview.
	Type         *BlobType         `json:"type,omitempty"`
	UploadStatus *BlobUploadStatus `json:"uploadStatus,omitempty"`
}

// BlobType One of RAW_FILE or VISUALIZATION. If VISUALIZATION, the blob may be displayed as an image preview.
type BlobType string

// BlobUploadStatus defines model for Blob.UploadStatus.
type BlobUploadStatus string

// BlobComplete defines model for BlobComplete.
type BlobComplete struct {
	Parts *[]BlobPart `json:"parts,omitempty"`
}

// BlobCreate defines model for BlobCreate.
type BlobCreate struct {
	// Data64 base64 encoded file contents
	Data64 []byte `json:"data64"`

	// Md5 The MD5 hash of the blob part. Note: this should be the hash of the raw data of the blob part, not the hash of the base64 encoding.
	Md5 string `json:"md5"`

	// MimeType eg. application/jpeg
	MimeType *string `json:"mimeType,omitempty"`

	// Name Name of the blob
	Name string `json:"name"`

	// Type One of RAW_FILE or VISUALIZATION. If VISUALIZATION, the blob may be displayed as an image preview.
	Type BlobCreateType `json:"type"`
}

// BlobCreateType One of RAW_FILE or VISUALIZATION. If VISUALIZATION, the blob may be displayed as an image preview.
type BlobCreateType string

// BlobMultipartCreate defines model for BlobMultipartCreate.
type BlobMultipartCreate struct {
	// MimeType eg. application/jpeg
	MimeType *string `json:"mimeType,omitempty"`

	// Name Name of the blob
	Name string `json:"name"`

	// Type One of RAW_FILE or VISUALIZATION. If VISUALIZATION, the blob may be displayed as an image preview.
	Type BlobMultipartCreateType `json:"type"`
}

// BlobMultipartCreateType One of RAW_FILE or VISUALIZATION. If VISUALIZATION, the blob may be displayed as an image preview.
type BlobMultipartCreateType string

// BlobPart defines model for BlobPart.
type BlobPart struct {
	ETag       *string `json:"eTag,omitempty"`
	PartNumber *int    `json:"partNumber,omitempty"`
}

// BlobPartCreate defines model for BlobPartCreate.
type BlobPartCreate struct {
	Data64 string `json:"data64"`
	Md5    string `json:"md5"`

	// PartNumber An integer between 1 to 10,000, inclusive. The part number must be unique per part and indicates the ordering of the part inside the final blob. The part numbers do not need to be consecutive.
	PartNumber int `json:"partNumber"`
}

// BlobUrl defines model for BlobUrl.
type BlobUrl struct {
	// DownloadURL a pre-signed download url.
	DownloadURL *string `json:"downloadURL,omitempty"`

	// ExpiresAt The unix time that the download URL expires at.
	ExpiresAt *int `json:"expiresAt,omitempty"`
}

// BlobsBulkGet defines model for BlobsBulkGet.
type BlobsBulkGet struct {
	Blobs *[]Blob `json:"blobs,omitempty"`
}

// BooleanAppConfigItem defines model for BooleanAppConfigItem.
type BooleanAppConfigItem struct {
	ApiURL *string `json:"apiURL,omitempty"`
	App    *struct {
		// Id The id of the Benchling app to which this configuration item belongs
		Id *string `json:"id,omitempty"`
	} `json:"app,omitempty"`

	// CreatedAt DateTime the app config item was created
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	Description *string    `json:"description,omitempty"`
	Id          *string    `json:"id,omitempty"`

	// ModifiedAt DateTime the app config item was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path           *[]string                 `json:"path,omitempty"`
	RequiredConfig *bool                     `json:"requiredConfig,omitempty"`
	Type           *BooleanAppConfigItemType `json:"type,omitempty"`
	Value          *bool                     `json:"value"`
}

// BooleanAppConfigItemType defines model for BooleanAppConfigItem.Type.
type BooleanAppConfigItemType string

// Box defines model for Box.
type Box struct {
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`
	Barcode       *string        `json:"barcode"`
	CreatedAt     *time.Time     `json:"createdAt,omitempty"`
	Creator       *UserSummary   `json:"creator,omitempty"`

	// EmptyContainers The number of containers in the box that have no contents.
	EmptyContainers *int `json:"emptyContainers,omitempty"`

	// EmptyPositions The number of empty positions for adding additional containers in the box.
	EmptyPositions *int    `json:"emptyPositions,omitempty"`
	Fields         *Fields `json:"fields,omitempty"`

	// FilledPositions The number of containers currently in the box.
	FilledPositions *int           `json:"filledPositions,omitempty"`
	Id              *string        `json:"id,omitempty"`
	ModifiedAt      *time.Time     `json:"modifiedAt,omitempty"`
	Name            *string        `json:"name,omitempty"`
	ParentStorageId *string        `json:"parentStorageId"`
	ProjectId       *string        `json:"projectId"`
	Schema          *SchemaSummary `json:"schema"`

	// Size The size of the box (i.e. how many containers it can store).
	Size   *int    `json:"size,omitempty"`
	WebURL *string `json:"webURL,omitempty"`
}

// BoxContentsPaginatedList defines model for BoxContentsPaginatedList.
type BoxContentsPaginatedList struct {
	Containers *[]ContainerWithCoordinates `json:"containers,omitempty"`
	NextToken  *string                     `json:"nextToken,omitempty"`
}

// BoxCreate defines model for BoxCreate.
type BoxCreate struct {
	Barcode         *string `json:"barcode,omitempty"`
	Fields          *Fields `json:"fields,omitempty"`
	Name            *string `json:"name,omitempty"`
	ParentStorageId *string `json:"parentStorageId,omitempty"`
	ProjectId       *string `json:"projectId,omitempty"`
	SchemaId        string  `json:"schemaId"`
}

// BoxCreationTableNotePart defines model for BoxCreationTableNotePart.
type BoxCreationTableNotePart struct {
	ApiId       *string                      `json:"apiId,omitempty"`
	BoxSchemaId *string                      `json:"boxSchemaId,omitempty"`
	Columns     *[]StructuredTableColumnInfo `json:"columns,omitempty"`

	// Indentation All notes have an indentation level - the default is 0 for no indent. For lists, indentation gives notes hierarchy - a bulleted list with children is modeled as one note part with indentation 1 followed by note parts with indentation 2, for example.
	Indentation *int                          `json:"indentation,omitempty"`
	Type        *BoxCreationTableNotePartType `json:"type,omitempty"`
}

// BoxCreationTableNotePartType defines model for BoxCreationTableNotePart.Type.
type BoxCreationTableNotePartType string

// BoxSchema defines model for BoxSchema.
type BoxSchema struct {
	ArchiveRecord   *ArchiveRecord `json:"archiveRecord"`
	ContainerSchema *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"containerSchema"`
	FieldDefinitions *[]BoxSchema_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Height           *float32                           `json:"height,omitempty"`
	Id               *string                            `json:"id,omitempty"`
	Name             *string                            `json:"name,omitempty"`
	Prefix           *string                            `json:"prefix,omitempty"`
	RegistryId       *string                            `json:"registryId,omitempty"`
	Type             *BoxSchemaType                     `json:"type,omitempty"`
	Width            *float32                           `json:"width,omitempty"`
}

// BoxSchema_FieldDefinitions_Item defines model for BoxSchema.fieldDefinitions.Item.
type BoxSchema_FieldDefinitions_Item struct {
	union json.RawMessage
}

// BoxSchemaType defines model for BoxSchema.Type.
type BoxSchemaType string

// BoxSchemasList defines model for BoxSchemasList.
type BoxSchemasList struct {
	BoxSchemas *[]BoxSchema `json:"boxSchemas,omitempty"`
}

// BoxSchemasPaginatedList defines model for BoxSchemasPaginatedList.
type BoxSchemasPaginatedList struct {
	BoxSchemas *[]BoxSchema `json:"boxSchemas,omitempty"`
	NextToken  *string      `json:"nextToken,omitempty"`
}

// BoxUpdate defines model for BoxUpdate.
type BoxUpdate struct {
	Fields          *Fields `json:"fields,omitempty"`
	Name            *string `json:"name,omitempty"`
	ParentStorageId *string `json:"parentStorageId,omitempty"`
	ProjectId       *string `json:"projectId,omitempty"`
}

// BoxesArchivalChange IDs of all items that were archived or unarchived, grouped by resource type. This includes the IDs of boxes along with any IDs of containers that were archived / unarchived.
type BoxesArchivalChange struct {
	BoxIds       *[]string `json:"boxIds,omitempty"`
	ContainerIds *[]string `json:"containerIds,omitempty"`
}

// BoxesArchive defines model for BoxesArchive.
type BoxesArchive struct {
	// BoxIds Array of box IDs
	BoxIds []string `json:"boxIds"`

	// Reason Reason that boxes are being archived.
	Reason BoxesArchiveReason `json:"reason"`

	// ShouldRemoveBarcodes Remove barcodes. Removing barcodes from archived inventory that contain items will also remove barcodes from the contained items.
	ShouldRemoveBarcodes *bool `json:"shouldRemoveBarcodes,omitempty"`
}

// BoxesArchiveReason Reason that boxes are being archived.
type BoxesArchiveReason string

// BoxesBulkGet defines model for BoxesBulkGet.
type BoxesBulkGet struct {
	Boxes *[]Box `json:"boxes,omitempty"`
}

// BoxesPaginatedList defines model for BoxesPaginatedList.
type BoxesPaginatedList struct {
	Boxes     *[]Box  `json:"boxes,omitempty"`
	NextToken *string `json:"nextToken,omitempty"`
}

// BoxesUnarchive defines model for BoxesUnarchive.
type BoxesUnarchive struct {
	// BoxIds Array of box IDs
	BoxIds []string `json:"boxIds"`
}

// BulkCreateAaSequencesAsyncTask defines model for BulkCreateAaSequencesAsyncTask.
type BulkCreateAaSequencesAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		AaSequences *[]AaSequence `json:"aaSequences,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status BulkCreateAaSequencesAsyncTaskStatus `json:"status"`
}

// BulkCreateAaSequencesAsyncTaskStatus The current state of the task.
type BulkCreateAaSequencesAsyncTaskStatus string

// BulkCreateContainersAsyncTask defines model for BulkCreateContainersAsyncTask.
type BulkCreateContainersAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		Containers *[]Container `json:"containers,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status BulkCreateContainersAsyncTaskStatus `json:"status"`
}

// BulkCreateContainersAsyncTaskStatus The current state of the task.
type BulkCreateContainersAsyncTaskStatus string

// BulkCreateCustomEntitiesAsyncTask defines model for BulkCreateCustomEntitiesAsyncTask.
type BulkCreateCustomEntitiesAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		CustomEntities *[]CustomEntity `json:"customEntities,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status BulkCreateCustomEntitiesAsyncTaskStatus `json:"status"`
}

// BulkCreateCustomEntitiesAsyncTaskStatus The current state of the task.
type BulkCreateCustomEntitiesAsyncTaskStatus string

// BulkCreateDnaOligosAsyncTask defines model for BulkCreateDnaOligosAsyncTask.
type BulkCreateDnaOligosAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		DnaOligos *[]DnaOligo `json:"dnaOligos,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status BulkCreateDnaOligosAsyncTaskStatus `json:"status"`
}

// BulkCreateDnaOligosAsyncTaskStatus The current state of the task.
type BulkCreateDnaOligosAsyncTaskStatus string

// BulkCreateDnaSequencesAsyncTask defines model for BulkCreateDnaSequencesAsyncTask.
type BulkCreateDnaSequencesAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		DnaSequences *[]DnaSequence `json:"dnaSequences,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status BulkCreateDnaSequencesAsyncTaskStatus `json:"status"`
}

// BulkCreateDnaSequencesAsyncTaskStatus The current state of the task.
type BulkCreateDnaSequencesAsyncTaskStatus string

// BulkCreateFeaturesAsyncTask defines model for BulkCreateFeaturesAsyncTask.
type BulkCreateFeaturesAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		Features *[]Feature `json:"features,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status BulkCreateFeaturesAsyncTaskStatus `json:"status"`
}

// BulkCreateFeaturesAsyncTaskStatus The current state of the task.
type BulkCreateFeaturesAsyncTaskStatus string

// BulkCreateRnaOligosAsyncTask defines model for BulkCreateRnaOligosAsyncTask.
type BulkCreateRnaOligosAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		RnaOligos *[]RnaOligo `json:"rnaOligos,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status BulkCreateRnaOligosAsyncTaskStatus `json:"status"`
}

// BulkCreateRnaOligosAsyncTaskStatus The current state of the task.
type BulkCreateRnaOligosAsyncTaskStatus string

// BulkCreateRnaSequencesAsyncTask defines model for BulkCreateRnaSequencesAsyncTask.
type BulkCreateRnaSequencesAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		RnaSequences *[]RnaSequence `json:"rnaSequences,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status BulkCreateRnaSequencesAsyncTaskStatus `json:"status"`
}

// BulkCreateRnaSequencesAsyncTaskStatus The current state of the task.
type BulkCreateRnaSequencesAsyncTaskStatus string

// BulkRegisterEntitiesAsyncTask defines model for BulkRegisterEntitiesAsyncTask.
type BulkRegisterEntitiesAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string      `json:"message,omitempty"`
	Response *interface{} `json:"response,omitempty"`

	// Status The current state of the task.
	Status BulkRegisterEntitiesAsyncTaskStatus `json:"status"`
}

// BulkRegisterEntitiesAsyncTaskStatus The current state of the task.
type BulkRegisterEntitiesAsyncTaskStatus string

// BulkUpdateAaSequencesAsyncTask defines model for BulkUpdateAaSequencesAsyncTask.
type BulkUpdateAaSequencesAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		AaSequences *[]AaSequence `json:"AaSequences,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status BulkUpdateAaSequencesAsyncTaskStatus `json:"status"`
}

// BulkUpdateAaSequencesAsyncTaskStatus The current state of the task.
type BulkUpdateAaSequencesAsyncTaskStatus string

// BulkUpdateContainersAsyncTask defines model for BulkUpdateContainersAsyncTask.
type BulkUpdateContainersAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		Containers *[]Container `json:"containers,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status BulkUpdateContainersAsyncTaskStatus `json:"status"`
}

// BulkUpdateContainersAsyncTaskStatus The current state of the task.
type BulkUpdateContainersAsyncTaskStatus string

// BulkUpdateCustomEntitiesAsyncTask defines model for BulkUpdateCustomEntitiesAsyncTask.
type BulkUpdateCustomEntitiesAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		CustomEntities *[]CustomEntity `json:"customEntities,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status BulkUpdateCustomEntitiesAsyncTaskStatus `json:"status"`
}

// BulkUpdateCustomEntitiesAsyncTaskStatus The current state of the task.
type BulkUpdateCustomEntitiesAsyncTaskStatus string

// BulkUpdateDnaOligosAsyncTask defines model for BulkUpdateDnaOligosAsyncTask.
type BulkUpdateDnaOligosAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		DnaOligos *[]DnaOligo `json:"dnaOligos,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status BulkUpdateDnaOligosAsyncTaskStatus `json:"status"`
}

// BulkUpdateDnaOligosAsyncTaskStatus The current state of the task.
type BulkUpdateDnaOligosAsyncTaskStatus string

// BulkUpdateDnaSequencesAsyncTask defines model for BulkUpdateDnaSequencesAsyncTask.
type BulkUpdateDnaSequencesAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		DnaSequences *[]DnaSequence `json:"dnaSequences,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status BulkUpdateDnaSequencesAsyncTaskStatus `json:"status"`
}

// BulkUpdateDnaSequencesAsyncTaskStatus The current state of the task.
type BulkUpdateDnaSequencesAsyncTaskStatus string

// BulkUpdateRnaOligosAsyncTask defines model for BulkUpdateRnaOligosAsyncTask.
type BulkUpdateRnaOligosAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		RnaOligos *[]RnaOligo `json:"rnaOligos,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status BulkUpdateRnaOligosAsyncTaskStatus `json:"status"`
}

// BulkUpdateRnaOligosAsyncTaskStatus The current state of the task.
type BulkUpdateRnaOligosAsyncTaskStatus string

// BulkUpdateRnaSequencesAsyncTask defines model for BulkUpdateRnaSequencesAsyncTask.
type BulkUpdateRnaSequencesAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		RnaSequences *[]RnaSequence `json:"rnaSequences,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status BulkUpdateRnaSequencesAsyncTaskStatus `json:"status"`
}

// BulkUpdateRnaSequencesAsyncTaskStatus The current state of the task.
type BulkUpdateRnaSequencesAsyncTaskStatus string

// ButtonUiBlock defines model for ButtonUiBlock.
type ButtonUiBlock struct {
	Enabled *bool             `json:"enabled"`
	Id      string            `json:"id"`
	Text    string            `json:"text"`
	Type    ButtonUiBlockType `json:"type"`
}

// ButtonUiBlockType defines model for ButtonUiBlock.Type.
type ButtonUiBlockType string

// ButtonUiBlockCreate defines model for ButtonUiBlockCreate.
type ButtonUiBlockCreate = ButtonUiBlock

// ButtonUiBlockUpdate defines model for ButtonUiBlockUpdate.
type ButtonUiBlockUpdate = ButtonUiBlock

// CheckboxNotePart defines model for CheckboxNotePart.
type CheckboxNotePart struct {
	// Checked Indicates whether the checkbox is checked or not.
	Checked *bool `json:"checked,omitempty"`

	// Indentation All notes have an indentation level - the default is 0 for no indent. For lists, indentation gives notes hierarchy - a bulleted list with children is modeled as one note part with indentation 1 followed by note parts with indentation 2, for example.
	Indentation *int `json:"indentation,omitempty"`

	// Links Array of links referenced in text via an @-mention, hyperlink, or the drag-n-dropped preview attached to the note.
	Links *[]EntryLink `json:"links,omitempty"`

	// Text The textual contents of the note.
	Text *string               `json:"text,omitempty"`
	Type *CheckboxNotePartType `json:"type,omitempty"`
}

// CheckboxNotePartType defines model for CheckboxNotePart.Type.
type CheckboxNotePartType string

// CheckoutRecord *assignee field* is set if status is "RESERVED" or "CHECKED_OUT", or null if status is "AVAILABLE".
//
// *comment field* is set when container was last reserved, checked out, or checked into.
//
// *modifiedAt field* is the date and time when container was last checked out, checked in, or reserved
type CheckoutRecord struct {
	Assignee   *CheckoutRecord_Assignee `json:"assignee"`
	Comment    *string                  `json:"comment,omitempty"`
	ModifiedAt *time.Time               `json:"modifiedAt,omitempty"`
	Status     *CheckoutRecordStatus    `json:"status,omitempty"`
}

// CheckoutRecord_Assignee defines model for CheckoutRecord.Assignee.
type CheckoutRecord_Assignee struct {
	union json.RawMessage
}

// CheckoutRecordStatus defines model for CheckoutRecord.Status.
type CheckoutRecordStatus string

// ChipUiBlock defines model for ChipUiBlock.
type ChipUiBlock struct {
	Id    *string         `json:"id,omitempty"`
	Type  ChipUiBlockType `json:"type"`
	Value string          `json:"value"`
}

// ChipUiBlockType defines model for ChipUiBlock.Type.
type ChipUiBlockType string

// ChipUiBlockCreate defines model for ChipUiBlockCreate.
type ChipUiBlockCreate = ChipUiBlock

// ChipUiBlockUpdate defines model for ChipUiBlockUpdate.
type ChipUiBlockUpdate = ChipUiBlock

// ConflictError defines model for ConflictError.
type ConflictError struct {
	Error *struct {
		Conflicts   *[]map[string]interface{} `json:"conflicts,omitempty"`
		Message     *string                   `json:"message,omitempty"`
		Type        *string                   `json:"type,omitempty"`
		UserMessage *string                   `json:"userMessage,omitempty"`
	} `json:"error,omitempty"`
}

// Container defines model for Container.
type Container struct {
	ArchiveRecord       *ArchiveRecord      `json:"archiveRecord"`
	Barcode             *string             `json:"barcode"`
	CheckoutRecord      *CheckoutRecord     `json:"checkoutRecord,omitempty"`
	Contents            *[]ContainerContent `json:"contents,omitempty"`
	CreatedAt           *time.Time          `json:"createdAt,omitempty"`
	Creator             *UserSummary        `json:"creator,omitempty"`
	Fields              *Fields             `json:"fields,omitempty"`
	Id                  *string             `json:"id,omitempty"`
	ModifiedAt          *time.Time          `json:"modifiedAt,omitempty"`
	Name                *string             `json:"name,omitempty"`
	ParentStorageId     *string             `json:"parentStorageId"`
	ParentStorageSchema *SchemaSummary      `json:"parentStorageSchema"`
	ProjectId           *string             `json:"projectId"`

	// Quantity Quantity of a container, well, or transfer. Supports mass, volume, and other quantities.
	Quantity                *ContainerQuantity                        `json:"quantity,omitempty"`
	RestrictedSampleParties *[]Container_RestrictedSampleParties_Item `json:"restrictedSampleParties,omitempty"`
	RestrictionStatus       *SampleRestrictionStatus                  `json:"restrictionStatus,omitempty"`
	SampleOwners            *[]Container_SampleOwners_Item            `json:"sampleOwners,omitempty"`
	Schema                  *SchemaSummary                            `json:"schema"`
	Volume                  *DeprecatedContainerVolumeForResponse     `json:"volume,omitempty"`
	WebURL                  *string                                   `json:"webURL,omitempty"`
}

// Container_RestrictedSampleParties_Item defines model for Container.restrictedSampleParties.Item.
type Container_RestrictedSampleParties_Item struct {
	union json.RawMessage
}

// Container_SampleOwners_Item defines model for Container.sampleOwners.Item.
type Container_SampleOwners_Item struct {
	union json.RawMessage
}

// ContainerBulkUpdateItem defines model for ContainerBulkUpdateItem.
type ContainerBulkUpdateItem struct {
	// Concentration Concentration for the container. Only valid for single content containers. Null values will be ignored.
	Concentration *Measurement `json:"concentration,omitempty"`
	ContainerId   string       `json:"containerId"`
	Fields        *Fields      `json:"fields,omitempty"`
	Name          *string      `json:"name,omitempty"`

	// ParentStorageId ID of containing parent inventory, can also specify a coordinate for plates and boxes (e.g. plt_2bAks9dx:a2).
	ParentStorageId *string `json:"parentStorageId,omitempty"`

	// Quantity Quantity of a container, well, or transfer. Supports mass, volume, and other quantities.
	Quantity *ContainerQuantity `json:"quantity,omitempty"`

	// RestrictedSamplePartyIds IDs of users or teams who have access to use a restricted container. Fixed plate wells and unrestricted containers do not have restricted sample parties.
	RestrictedSamplePartyIds *[]string `json:"restrictedSamplePartyIds,omitempty"`

	// RestrictionStatus Either RESTRICTED or UNRESTRICTED. This only applies to stand-alone containers (Plate wells are always set to NOT_APPLICABLE).
	RestrictionStatus *SampleRestrictionStatus `json:"restrictionStatus,omitempty"`

	// SampleOwnerIds IDs of users or teams who are sample owners for the container. Fixed plate wells do not have sample owners.
	SampleOwnerIds *[]string `json:"sampleOwnerIds,omitempty"`

	// Volume Desired volume for a container, well, or transfer. "volume" type keys are deprecated in API requests; use the more permissive "quantity" type key instead.
	Volume *DeprecatedContainerVolumeForInput `json:"volume,omitempty"`
}

// ContainerContent defines model for ContainerContent.
type ContainerContent struct {
	Batch         *BatchOrInaccessibleResource  `json:"batch"`
	Concentration *Measurement                  `json:"concentration,omitempty"`
	Entity        *EntityOrInaccessibleResource `json:"entity"`
}

// ContainerContentUpdate defines model for ContainerContentUpdate.
type ContainerContentUpdate struct {
	Concentration Measurement `json:"concentration"`
}

// ContainerContentsList defines model for ContainerContentsList.
type ContainerContentsList struct {
	Contents *[]ContainerContent `json:"contents,omitempty"`
}

// ContainerCreate defines model for ContainerCreate.
type ContainerCreate struct {
	Barcode *string `json:"barcode,omitempty"`
	Fields  *Fields `json:"fields,omitempty"`
	Name    *string `json:"name,omitempty"`

	// ParentStorageId ID of containing parent inventory, can also specify a coordinate for plates and boxes (e.g. plt_2bAks9dx:a2).
	ParentStorageId *string `json:"parentStorageId,omitempty"`
	ProjectId       *string `json:"projectId"`

	// RestrictedSamplePartyIds IDs of users or teams who have access to use a restricted container. Fixed plate wells and unrestricted containers do not have restricted sample parties.
	RestrictedSamplePartyIds *[]string `json:"restrictedSamplePartyIds,omitempty"`

	// RestrictionStatus Either RESTRICTED or UNRESTRICTED. This only applies to stand-alone containers (Plate wells are always set to NOT_APPLICABLE).
	RestrictionStatus *SampleRestrictionStatus `json:"restrictionStatus,omitempty"`

	// SampleOwnerIds IDs of users or teams who are sample owners for the container. Fixed plate wells do not have sample owners.
	SampleOwnerIds *[]string `json:"sampleOwnerIds,omitempty"`
	SchemaId       *string   `json:"schemaId,omitempty"`
}

// ContainerLabels defines model for ContainerLabels.
type ContainerLabels struct {
	Barcode *string `json:"barcode,omitempty"`
	Id      *string `json:"id,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// ContainerQuantity Quantity of a container, well, or transfer. Supports mass, volume, and other quantities.
type ContainerQuantity struct {
	Units *ContainerQuantityUnits `json:"units"`
	Value *float32                `json:"value"`
}

// ContainerQuantityUnits defines model for ContainerQuantity.Units.
type ContainerQuantityUnits string

// ContainerSchema defines model for ContainerSchema.
type ContainerSchema struct {
	ArchiveRecord    *ArchiveRecord                           `json:"archiveRecord"`
	FieldDefinitions *[]ContainerSchema_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Id               *string                                  `json:"id,omitempty"`

	// ModifiedAt DateTime the Container Schema was last modified
	ModifiedAt *time.Time           `json:"modifiedAt,omitempty"`
	Name       *string              `json:"name,omitempty"`
	Prefix     *string              `json:"prefix,omitempty"`
	RegistryId *string              `json:"registryId,omitempty"`
	Type       *ContainerSchemaType `json:"type,omitempty"`
}

// ContainerSchema_FieldDefinitions_Item defines model for ContainerSchema.fieldDefinitions.Item.
type ContainerSchema_FieldDefinitions_Item struct {
	union json.RawMessage
}

// ContainerSchemaType defines model for ContainerSchema.Type.
type ContainerSchemaType string

// ContainerSchemasList defines model for ContainerSchemasList.
type ContainerSchemasList struct {
	ContainerSchemas *[]ContainerSchema `json:"containerSchemas,omitempty"`
}

// ContainerSchemasPaginatedList defines model for ContainerSchemasPaginatedList.
type ContainerSchemasPaginatedList struct {
	ContainerSchemas *[]ContainerSchema `json:"containerSchemas,omitempty"`
	NextToken        *string            `json:"nextToken,omitempty"`
}

// ContainerTransfer defines model for ContainerTransfer.
type ContainerTransfer struct {
	// DestinationContents This represents what the contents of the destination container should look like post-transfer.
	DestinationContents []ContainerTransferDestinationContentsItem `json:"destinationContents"`

	// DestinationQuantity This represents the desired final quantity of the destination container, post-dilution. If you don't want to dilute the destination container, you can omit this parameter. Supports mass, volume, and other quantities.
	DestinationQuantity *ContainerQuantity `json:"destinationQuantity,omitempty"`

	// DestinationVolume Deprecated - use destinationQuantity instead.
	DestinationVolume *DeprecatedContainerVolumeForInput `json:"destinationVolume,omitempty"`

	// RestrictedSamplePartyIds IDs of users or teams to be set as restricted sample parties for the destination container. If not specified, restricted sample parties from the source container, if present, will be added to those of the destination container. This only applies to stand-alone containers.
	RestrictedSamplePartyIds *[]string `json:"restrictedSamplePartyIds,omitempty"`

	// RestrictionStatus Restriction status of the destination container, either RESTRICTED or UNRESTRICTED. If not specified, the restriction status of the destination container will be the more restrictive of the source container, if present, and destination container restriction statuses. This only applies to stand-alone containers (Plate wells are always set to NOT_APPLICABLE).
	RestrictionStatus *SampleRestrictionStatus `json:"restrictionStatus,omitempty"`

	// SampleOwnerIds IDs of users or teams to be set as sample owners for the destination container. If not specified, restricted sample parties from the source container, if present, will be added to those of the destination container. This only applies to stand-alone containers.
	SampleOwnerIds *[]string `json:"sampleOwnerIds,omitempty"`

	// SourceBatchId ID of the batch that will be transferred in. Must specify one of sourceEntityId, sourceBatchId, or sourceContainerId.
	SourceBatchId *string `json:"sourceBatchId,omitempty"`

	// SourceContainerId ID of the container that will be transferred in. Must specify one of sourceEntityId, sourceBatchId, or sourceContainerId.
	SourceContainerId *string `json:"sourceContainerId,omitempty"`

	// SourceEntityId ID of the entity that will be transferred in. Must specify one of sourceEntityId, sourceBatchId, or sourceContainerId.
	SourceEntityId *string `json:"sourceEntityId,omitempty"`

	// TransferQuantity This represents the quantity of the source to be transferred into the destination container. Supports mass, volume, and other quantities. Required in place of transferVolume.
	TransferQuantity *ContainerQuantity `json:"transferQuantity,omitempty"`

	// TransferVolume Deprecated - use transferQuantity instead.
	TransferVolume *DeprecatedContainerVolumeForInput `json:"transferVolume,omitempty"`
}

// ContainerTransferBase defines model for ContainerTransferBase.
type ContainerTransferBase struct {
	// RestrictedSamplePartyIds IDs of users or teams to be set as restricted sample parties for the destination container. If not specified, restricted sample parties from the source container, if present, will be added to those of the destination container. This only applies to stand-alone containers.
	RestrictedSamplePartyIds *[]string `json:"restrictedSamplePartyIds,omitempty"`

	// RestrictionStatus Restriction status of the destination container, either RESTRICTED or UNRESTRICTED. If not specified, the restriction status of the destination container will be the more restrictive of the source container, if present, and destination container restriction statuses. This only applies to stand-alone containers (Plate wells are always set to NOT_APPLICABLE).
	RestrictionStatus *SampleRestrictionStatus `json:"restrictionStatus,omitempty"`

	// SampleOwnerIds IDs of users or teams to be set as sample owners for the destination container. If not specified, restricted sample parties from the source container, if present, will be added to those of the destination container. This only applies to stand-alone containers.
	SampleOwnerIds *[]string `json:"sampleOwnerIds,omitempty"`

	// SourceBatchId ID of the batch that will be transferred in. Must specify one of sourceEntityId, sourceBatchId, or sourceContainerId.
	SourceBatchId *string `json:"sourceBatchId,omitempty"`

	// SourceContainerId ID of the container that will be transferred in. Must specify one of sourceEntityId, sourceBatchId, or sourceContainerId.
	SourceContainerId *string `json:"sourceContainerId,omitempty"`

	// SourceEntityId ID of the entity that will be transferred in. Must specify one of sourceEntityId, sourceBatchId, or sourceContainerId.
	SourceEntityId *string `json:"sourceEntityId,omitempty"`

	// TransferQuantity This represents the quantity of the source to be transferred into the destination container. Supports mass, volume, and other quantities. Required in place of transferVolume.
	TransferQuantity *ContainerQuantity `json:"transferQuantity,omitempty"`

	// TransferVolume Deprecated - use transferQuantity instead.
	TransferVolume *DeprecatedContainerVolumeForInput `json:"transferVolume,omitempty"`
}

// ContainerTransferDestinationContentsItem defines model for ContainerTransferDestinationContentsItem.
type ContainerTransferDestinationContentsItem struct {
	Concentration *Measurement `json:"concentration,omitempty"`
	EntityId      string       `json:"entityId"`
}

// ContainerUpdate defines model for ContainerUpdate.
type ContainerUpdate struct {
	Fields *Fields `json:"fields,omitempty"`
	Name   *string `json:"name,omitempty"`

	// ParentStorageId ID of containing parent inventory, can also specify a coordinate for plates and boxes (e.g. plt_2bAks9dx:a2).
	ParentStorageId *string `json:"parentStorageId,omitempty"`
	ProjectId       *string `json:"projectId"`

	// Quantity Quantity of a container, well, or transfer. Supports mass, volume, and other quantities.
	Quantity *ContainerQuantity `json:"quantity,omitempty"`

	// RestrictedSamplePartyIds IDs of users or teams who have access to use a restricted container. Fixed plate wells and unrestricted containers do not have restricted sample parties.
	RestrictedSamplePartyIds *[]string `json:"restrictedSamplePartyIds,omitempty"`

	// RestrictionStatus Either RESTRICTED or UNRESTRICTED. This only applies to stand-alone containers (Plate wells are always set to NOT_APPLICABLE).
	RestrictionStatus *SampleRestrictionStatus `json:"restrictionStatus,omitempty"`

	// SampleOwnerIds IDs of users or teams who are sample owners for the container. Fixed plate wells do not have sample owners.
	SampleOwnerIds *[]string `json:"sampleOwnerIds,omitempty"`

	// Volume Desired volume for a container, well, or transfer. "volume" type keys are deprecated in API requests; use the more permissive "quantity" type key instead.
	Volume *DeprecatedContainerVolumeForInput `json:"volume,omitempty"`
}

// ContainerWithCoordinates defines model for ContainerWithCoordinates.
type ContainerWithCoordinates struct {
	ArchiveRecord       *ArchiveRecord      `json:"archiveRecord"`
	Barcode             *string             `json:"barcode"`
	CheckoutRecord      *CheckoutRecord     `json:"checkoutRecord,omitempty"`
	Contents            *[]ContainerContent `json:"contents,omitempty"`
	CreatedAt           *time.Time          `json:"createdAt,omitempty"`
	Creator             *UserSummary        `json:"creator,omitempty"`
	Fields              *Fields             `json:"fields,omitempty"`
	GridNumber          *float32            `json:"gridNumber,omitempty"`
	GridPosition        *string             `json:"gridPosition,omitempty"`
	Id                  *string             `json:"id,omitempty"`
	ModifiedAt          *time.Time          `json:"modifiedAt,omitempty"`
	Name                *string             `json:"name,omitempty"`
	ParentStorageId     *string             `json:"parentStorageId"`
	ParentStorageSchema *SchemaSummary      `json:"parentStorageSchema"`
	ProjectId           *string             `json:"projectId"`

	// Quantity Quantity of a container, well, or transfer. Supports mass, volume, and other quantities.
	Quantity                *ContainerQuantity                                       `json:"quantity,omitempty"`
	RestrictedSampleParties *[]ContainerWithCoordinates_RestrictedSampleParties_Item `json:"restrictedSampleParties,omitempty"`
	RestrictionStatus       *SampleRestrictionStatus                                 `json:"restrictionStatus,omitempty"`
	SampleOwners            *[]ContainerWithCoordinates_SampleOwners_Item            `json:"sampleOwners,omitempty"`
	Schema                  *SchemaSummary                                           `json:"schema"`
	Volume                  *DeprecatedContainerVolumeForResponse                    `json:"volume,omitempty"`
	WebURL                  *string                                                  `json:"webURL,omitempty"`
}

// ContainerWithCoordinates_RestrictedSampleParties_Item defines model for ContainerWithCoordinates.restrictedSampleParties.Item.
type ContainerWithCoordinates_RestrictedSampleParties_Item struct {
	union json.RawMessage
}

// ContainerWithCoordinates_SampleOwners_Item defines model for ContainerWithCoordinates.sampleOwners.Item.
type ContainerWithCoordinates_SampleOwners_Item struct {
	union json.RawMessage
}

// ContainerWriteBase defines model for ContainerWriteBase.
type ContainerWriteBase struct {
	Fields *Fields `json:"fields,omitempty"`
	Name   *string `json:"name,omitempty"`

	// ParentStorageId ID of containing parent inventory, can also specify a coordinate for plates and boxes (e.g. plt_2bAks9dx:a2).
	ParentStorageId *string `json:"parentStorageId,omitempty"`

	// RestrictedSamplePartyIds IDs of users or teams who have access to use a restricted container. Fixed plate wells and unrestricted containers do not have restricted sample parties.
	RestrictedSamplePartyIds *[]string `json:"restrictedSamplePartyIds,omitempty"`

	// RestrictionStatus Either RESTRICTED or UNRESTRICTED. This only applies to stand-alone containers (Plate wells are always set to NOT_APPLICABLE).
	RestrictionStatus *SampleRestrictionStatus `json:"restrictionStatus,omitempty"`

	// SampleOwnerIds IDs of users or teams who are sample owners for the container. Fixed plate wells do not have sample owners.
	SampleOwnerIds *[]string `json:"sampleOwnerIds,omitempty"`
}

// ContainersArchivalChange IDs of all items that were unarchived, grouped by resource type. This includes the IDs of containers that were unarchived.
type ContainersArchivalChange struct {
	ContainerIds *[]string `json:"containerIds,omitempty"`
}

// ContainersArchive defines model for ContainersArchive.
type ContainersArchive struct {
	// ContainerIds Array of container IDs
	ContainerIds []string `json:"containerIds"`

	// Reason Reason that containers are being archived.
	Reason ContainersArchiveReason `json:"reason"`

	// ShouldRemoveBarcodes Remove barcodes. Removing barcodes from archived inventory that contain items will also remove barcodes from the contained items.
	ShouldRemoveBarcodes *bool `json:"shouldRemoveBarcodes,omitempty"`
}

// ContainersArchiveReason Reason that containers are being archived.
type ContainersArchiveReason string

// ContainersBulkCreateRequest defines model for ContainersBulkCreateRequest.
type ContainersBulkCreateRequest struct {
	Containers []ContainerCreate `json:"containers"`
}

// ContainersBulkUpdateRequest defines model for ContainersBulkUpdateRequest.
type ContainersBulkUpdateRequest struct {
	Containers []ContainerBulkUpdateItem `json:"containers"`
}

// ContainersCheckin defines model for ContainersCheckin.
type ContainersCheckin struct {
	Comments *string `json:"comments,omitempty"`

	// ContainerIds Array of container IDs.
	ContainerIds []string `json:"containerIds"`
}

// ContainersCheckout defines model for ContainersCheckout.
type ContainersCheckout struct {
	// AssigneeId User or Team API ID.
	AssigneeId string  `json:"assigneeId"`
	Comment    *string `json:"comment,omitempty"`

	// ContainerIds Array of container IDs.
	ContainerIds []string `json:"containerIds"`
}

// ContainersList defines model for ContainersList.
type ContainersList struct {
	Containers *[]Container `json:"containers,omitempty"`
}

// ContainersPaginatedList defines model for ContainersPaginatedList.
type ContainersPaginatedList struct {
	Containers *[]Container `json:"containers,omitempty"`
	NextToken  *string      `json:"nextToken,omitempty"`
}

// ContainersUnarchive defines model for ContainersUnarchive.
type ContainersUnarchive struct {
	// ContainerIds Array of container IDs
	ContainerIds []string `json:"containerIds"`
}

// CreateConsensusAlignmentAsyncTask defines model for CreateConsensusAlignmentAsyncTask.
type CreateConsensusAlignmentAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string       `json:"message,omitempty"`
	Response *DnaAlignment `json:"response,omitempty"`

	// Status The current state of the task.
	Status CreateConsensusAlignmentAsyncTaskStatus `json:"status"`
}

// CreateConsensusAlignmentAsyncTaskStatus The current state of the task.
type CreateConsensusAlignmentAsyncTaskStatus string

// CreateEntityIntoRegistry defines model for CreateEntityIntoRegistry.
type CreateEntityIntoRegistry struct {
	// EntityRegistryId Entity registry ID to set for the registered entity. Cannot specify both entityRegistryId and namingStrategy at the same time.
	EntityRegistryId *string `json:"entityRegistryId,omitempty"`

	// FolderId ID of the folder containing the entity. Can be left empty when registryId is present.
	FolderId *string `json:"folderId,omitempty"`

	// NamingStrategy Specifies the behavior for automatically generated names when registering an entity.
	// - NEW_IDS: Generate new registry IDs
	// - IDS_FROM_NAMES: Generate registry IDs based on entity names
	// - DELETE_NAMES: Generate new registry IDs and replace name with registry ID
	// - SET_FROM_NAME_PARTS: Generate new registry IDs, rename according to name template, and keep old name as alias
	// - REPLACE_NAMES_FROM_PARTS: Generate new registry IDs, and replace name according to name template
	// - KEEP_NAMES: Keep existing entity names as registry IDs
	// - REPLACE_ID_AND_NAME_FROM_PARTS: Generate registry IDs and names according to name template
	NamingStrategy *NamingStrategy `json:"namingStrategy,omitempty"`

	// RegistryId Registry ID into which entity should be registered. this is the ID of the registry which was configured for a particular organization
	// To get available registryIds, use the [/registries endpoint](#/Registry/listRegistries)
	//
	// Required in order for entities to be created directly in the registry.
	RegistryId *string `json:"registryId,omitempty"`
}

// CreateNucleotideConsensusAlignmentAsyncTask defines model for CreateNucleotideConsensusAlignmentAsyncTask.
type CreateNucleotideConsensusAlignmentAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string              `json:"message,omitempty"`
	Response *NucleotideAlignment `json:"response,omitempty"`

	// Status The current state of the task.
	Status CreateNucleotideConsensusAlignmentAsyncTaskStatus `json:"status"`
}

// CreateNucleotideConsensusAlignmentAsyncTaskStatus The current state of the task.
type CreateNucleotideConsensusAlignmentAsyncTaskStatus string

// CreateNucleotideTemplateAlignmentAsyncTask defines model for CreateNucleotideTemplateAlignmentAsyncTask.
type CreateNucleotideTemplateAlignmentAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string              `json:"message,omitempty"`
	Response *NucleotideAlignment `json:"response,omitempty"`

	// Status The current state of the task.
	Status CreateNucleotideTemplateAlignmentAsyncTaskStatus `json:"status"`
}

// CreateNucleotideTemplateAlignmentAsyncTaskStatus The current state of the task.
type CreateNucleotideTemplateAlignmentAsyncTaskStatus string

// CreateTemplateAlignmentAsyncTask defines model for CreateTemplateAlignmentAsyncTask.
type CreateTemplateAlignmentAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string       `json:"message,omitempty"`
	Response *DnaAlignment `json:"response,omitempty"`

	// Status The current state of the task.
	Status CreateTemplateAlignmentAsyncTaskStatus `json:"status"`
}

// CreateTemplateAlignmentAsyncTaskStatus The current state of the task.
type CreateTemplateAlignmentAsyncTaskStatus string

// CreationOrigin defines model for CreationOrigin.
type CreationOrigin struct {
	Application     *string             `json:"application"`
	OriginId        *string             `json:"originId"`
	OriginModalUuid *openapi_types.UUID `json:"originModalUuid"`
	OriginType      *string             `json:"originType"`
}

// CustomEntitiesArchivalChange IDs of all items that were archived or unarchived, grouped by resource type. This includes the IDs of custom entities along with any IDs of batches that were archived (or unarchived).
type CustomEntitiesArchivalChange struct {
	BatchIds        *[]string `json:"batchIds,omitempty"`
	CustomEntityIds *[]string `json:"customEntityIds,omitempty"`
}

// CustomEntitiesArchive The request body for archiving custom entities.
type CustomEntitiesArchive struct {
	CustomEntityIds []string `json:"customEntityIds"`

	// Reason The reason for archiving the provided entities. Accepted reasons may differ based on tenant configuration.
	Reason EntityArchiveReason `json:"reason"`
}

// CustomEntitiesBulkCreateRequest defines model for CustomEntitiesBulkCreateRequest.
type CustomEntitiesBulkCreateRequest struct {
	CustomEntities []CustomEntityBulkCreate `json:"customEntities"`
}

// CustomEntitiesBulkUpdateRequest defines model for CustomEntitiesBulkUpdateRequest.
type CustomEntitiesBulkUpdateRequest struct {
	CustomEntities []CustomEntityBulkUpdate `json:"customEntities"`
}

// CustomEntitiesList defines model for CustomEntitiesList.
type CustomEntitiesList struct {
	CustomEntities *[]CustomEntity `json:"customEntities,omitempty"`
}

// CustomEntitiesPaginatedList defines model for CustomEntitiesPaginatedList.
type CustomEntitiesPaginatedList struct {
	CustomEntities *[]CustomEntity `json:"customEntities,omitempty"`
	NextToken      *string         `json:"nextToken,omitempty"`
}

// CustomEntitiesUnarchive The request body for unarchiving custom entities.
type CustomEntitiesUnarchive struct {
	CustomEntityIds []string `json:"customEntityIds"`
}

// CustomEntity defines model for CustomEntity.
type CustomEntity struct {
	Aliases *[]string `json:"aliases,omitempty"`

	// ApiURL The canonical url of the Custom Entity in the API.
	ApiURL             *string             `json:"apiURL,omitempty"`
	ArchiveRecord      *ArchiveRecord      `json:"archiveRecord"`
	Authors            *[]UserSummary      `json:"authors,omitempty"`
	CreatedAt          *time.Time          `json:"createdAt,omitempty"`
	Creator            *UserSummary        `json:"creator,omitempty"`
	CustomFields       *CustomFields       `json:"customFields,omitempty"`
	EntityRegistryId   *string             `json:"entityRegistryId"`
	Fields             *Fields             `json:"fields,omitempty"`
	FolderId           *string             `json:"folderId"`
	Id                 *string             `json:"id,omitempty"`
	ModifiedAt         *time.Time          `json:"modifiedAt,omitempty"`
	Name               *string             `json:"name,omitempty"`
	RegistrationOrigin *RegistrationOrigin `json:"registrationOrigin"`
	RegistryId         *string             `json:"registryId"`
	Schema             *SchemaSummary      `json:"schema"`
	WebURL             *string             `json:"webURL,omitempty"`
}

// CustomEntityBaseRequest defines model for CustomEntityBaseRequest.
type CustomEntityBaseRequest struct {
	// Aliases Aliases to add to the custom entity
	Aliases *[]string `json:"aliases,omitempty"`

	// AuthorIds IDs of users to set as the custom entity's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// CustomFields Custom fields to add to the custom entity. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// Fields Schema fields to set on the custom entity. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder that the entity is moved into
	FolderId *string `json:"folderId,omitempty"`
	Name     *string `json:"name,omitempty"`
	SchemaId *string `json:"schemaId,omitempty"`
}

// CustomEntityBaseRequestForCreate defines model for CustomEntityBaseRequestForCreate.
type CustomEntityBaseRequestForCreate struct {
	// Aliases Aliases to add to the custom entity
	Aliases *[]string `json:"aliases,omitempty"`

	// AuthorIds IDs of users to set as the custom entity's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// CustomFields Custom fields to add to the custom entity. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// Fields Schema fields to set on the custom entity. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder that the entity is moved into
	FolderId *string `json:"folderId,omitempty"`
	Name     string  `json:"name"`
	SchemaId string  `json:"schemaId"`
}

// CustomEntityBulkCreate defines model for CustomEntityBulkCreate.
type CustomEntityBulkCreate = CustomEntityCreate

// CustomEntityBulkUpdate defines model for CustomEntityBulkUpdate.
type CustomEntityBulkUpdate = CustomEntityBaseRequest

// CustomEntityCreate defines model for CustomEntityCreate.
type CustomEntityCreate struct {
	// Aliases Aliases to add to the custom entity
	Aliases *[]string `json:"aliases,omitempty"`

	// AuthorIds IDs of users to set as the custom entity's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// CustomFields Custom fields to add to the custom entity. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// EntityRegistryId Entity registry ID to set for the registered entity. Cannot specify both entityRegistryId and namingStrategy at the same time.
	EntityRegistryId *string `json:"entityRegistryId,omitempty"`

	// Fields Schema fields to set on the custom entity. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the entity. Can be left empty when registryId is present.
	FolderId *string `json:"folderId,omitempty"`
	Name     string  `json:"name"`

	// NamingStrategy Specifies the behavior for automatically generated names when registering an entity.
	// - NEW_IDS: Generate new registry IDs
	// - IDS_FROM_NAMES: Generate registry IDs based on entity names
	// - DELETE_NAMES: Generate new registry IDs and replace name with registry ID
	// - SET_FROM_NAME_PARTS: Generate new registry IDs, rename according to name template, and keep old name as alias
	// - REPLACE_NAMES_FROM_PARTS: Generate new registry IDs, and replace name according to name template
	// - KEEP_NAMES: Keep existing entity names as registry IDs
	// - REPLACE_ID_AND_NAME_FROM_PARTS: Generate registry IDs and names according to name template
	NamingStrategy *NamingStrategy `json:"namingStrategy,omitempty"`

	// RegistryId Registry ID into which entity should be registered. this is the ID of the registry which was configured for a particular organization
	// To get available registryIds, use the [/registries endpoint](#/Registry/listRegistries)
	//
	// Required in order for entities to be created directly in the registry.
	RegistryId *string `json:"registryId,omitempty"`
	SchemaId   string  `json:"schemaId"`
}

// CustomEntityRequestRegistryFields defines model for CustomEntityRequestRegistryFields.
type CustomEntityRequestRegistryFields struct {
	EntityRegistryId *string `json:"entityRegistryId,omitempty"`
}

// CustomEntitySummary defines model for CustomEntitySummary.
type CustomEntitySummary struct {
	EntityType *CustomEntitySummaryEntityType `json:"entityType,omitempty"`
	Id         *string                        `json:"id,omitempty"`
	// Deprecated:
	Type *string `json:"type,omitempty"`
}

// CustomEntitySummaryEntityType defines model for CustomEntitySummary.EntityType.
type CustomEntitySummaryEntityType string

// CustomEntityUpdate defines model for CustomEntityUpdate.
type CustomEntityUpdate struct {
	// Aliases Aliases to add to the custom entity
	Aliases *[]string `json:"aliases,omitempty"`

	// AuthorIds IDs of users to set as the custom entity's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// CustomFields Custom fields to add to the custom entity. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields     *CustomFields `json:"customFields,omitempty"`
	EntityRegistryId *string       `json:"entityRegistryId,omitempty"`

	// Fields Schema fields to set on the custom entity. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder that the entity is moved into
	FolderId *string `json:"folderId,omitempty"`
	Name     *string `json:"name,omitempty"`
	SchemaId *string `json:"schemaId,omitempty"`
}

// CustomEntityWithEntityType defines model for CustomEntityWithEntityType.
type CustomEntityWithEntityType struct {
	Aliases *[]string `json:"aliases,omitempty"`

	// ApiURL The canonical url of the Custom Entity in the API.
	ApiURL             *string                               `json:"apiURL,omitempty"`
	ArchiveRecord      *ArchiveRecord                        `json:"archiveRecord"`
	Authors            *[]UserSummary                        `json:"authors,omitempty"`
	CreatedAt          *time.Time                            `json:"createdAt,omitempty"`
	Creator            *UserSummary                          `json:"creator,omitempty"`
	CustomFields       *CustomFields                         `json:"customFields,omitempty"`
	EntityRegistryId   *string                               `json:"entityRegistryId"`
	EntityType         *CustomEntityWithEntityTypeEntityType `json:"entityType,omitempty"`
	Fields             *Fields                               `json:"fields,omitempty"`
	FolderId           *string                               `json:"folderId"`
	Id                 *string                               `json:"id,omitempty"`
	ModifiedAt         *time.Time                            `json:"modifiedAt,omitempty"`
	Name               *string                               `json:"name,omitempty"`
	RegistrationOrigin *RegistrationOrigin                   `json:"registrationOrigin"`
	RegistryId         *string                               `json:"registryId"`
	Schema             *SchemaSummary                        `json:"schema"`
	WebURL             *string                               `json:"webURL,omitempty"`
}

// CustomEntityWithEntityTypeEntityType defines model for CustomEntityWithEntityType.EntityType.
type CustomEntityWithEntityTypeEntityType string

// CustomField defines model for CustomField.
type CustomField struct {
	Value *string `json:"value,omitempty"`
}

// CustomFields defines model for CustomFields.
type CustomFields map[string]CustomField

// CustomNotation defines model for CustomNotation.
type CustomNotation struct {
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// CustomNotationRequest defines model for CustomNotationRequest.
type CustomNotationRequest struct {
	// CustomNotation Representation of the sequence or oligo in the custom notation specified by customNotationId
	CustomNotation *string `json:"customNotation,omitempty"`

	// CustomNotationId ID of the notation used to interpret the string provided in the customNotation field
	CustomNotationId *string `json:"customNotationId,omitempty"`
}

// CustomNotationsPaginatedList defines model for CustomNotationsPaginatedList.
type CustomNotationsPaginatedList struct {
	CustomNotations *[]CustomNotation `json:"customNotations,omitempty"`
	NextToken       *string           `json:"nextToken,omitempty"`
}

// DateAppConfigItem defines model for DateAppConfigItem.
type DateAppConfigItem struct {
	ApiURL *string `json:"apiURL,omitempty"`
	App    *struct {
		// Id The id of the Benchling app to which this configuration item belongs
		Id *string `json:"id,omitempty"`
	} `json:"app,omitempty"`

	// CreatedAt DateTime the app config item was created
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	Description *string    `json:"description,omitempty"`
	Id          *string    `json:"id,omitempty"`

	// ModifiedAt DateTime the app config item was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path           *[]string              `json:"path,omitempty"`
	RequiredConfig *bool                  `json:"requiredConfig,omitempty"`
	Type           *DateAppConfigItemType `json:"type,omitempty"`
	Value          *string                `json:"value"`
}

// DateAppConfigItemType defines model for DateAppConfigItem.Type.
type DateAppConfigItemType string

// DatetimeAppConfigItem defines model for DatetimeAppConfigItem.
type DatetimeAppConfigItem struct {
	ApiURL *string `json:"apiURL,omitempty"`
	App    *struct {
		// Id The id of the Benchling app to which this configuration item belongs
		Id *string `json:"id,omitempty"`
	} `json:"app,omitempty"`

	// CreatedAt DateTime the app config item was created
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	Description *string    `json:"description,omitempty"`
	Id          *string    `json:"id,omitempty"`

	// ModifiedAt DateTime the app config item was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path           *[]string                  `json:"path,omitempty"`
	RequiredConfig *bool                      `json:"requiredConfig,omitempty"`
	Type           *DatetimeAppConfigItemType `json:"type,omitempty"`
	Value          *string                    `json:"value"`
}

// DatetimeAppConfigItemType defines model for DatetimeAppConfigItem.Type.
type DatetimeAppConfigItemType string

// DefaultConcentrationSummary defines model for DefaultConcentrationSummary.
type DefaultConcentrationSummary struct {
	// Units Units of measurement.
	Units *string `json:"units,omitempty"`

	// Value Amount of measurement.
	Value *float32 `json:"value,omitempty"`
}

// DeprecatedAutomationOutputProcessorsPaginatedList Deprecated - A paginated list of automation output processors
type DeprecatedAutomationOutputProcessorsPaginatedList struct {
	AutomationOutputProcessors *[]AutomationOutputProcessor `json:"automationOutputProcessors,omitempty"`
	NextToken                  *string                      `json:"nextToken,omitempty"`
}

// DeprecatedContainerVolumeForInput Desired volume for a container, well, or transfer. "volume" type keys are deprecated in API requests; use the more permissive "quantity" type key instead.
type DeprecatedContainerVolumeForInput struct {
	Units *DeprecatedContainerVolumeForInputUnits `json:"units"`
	Value *float32                                `json:"value"`
}

// DeprecatedContainerVolumeForInputUnits defines model for DeprecatedContainerVolumeForInput.Units.
type DeprecatedContainerVolumeForInputUnits string

// DeprecatedContainerVolumeForResponse defines model for DeprecatedContainerVolumeForResponse.
type DeprecatedContainerVolumeForResponse struct {
	Units *DeprecatedContainerVolumeForResponseUnits `json:"units"`
	Value *float32                                   `json:"value"`
}

// DeprecatedContainerVolumeForResponseUnits defines model for DeprecatedContainerVolumeForResponse.Units.
type DeprecatedContainerVolumeForResponseUnits string

// DeprecatedEntitySchema defines model for DeprecatedEntitySchema.
type DeprecatedEntitySchema struct {
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`
	Constraint    *struct {
		FieldDefinitionNames *[]string `json:"fieldDefinitionNames,omitempty"`
		HasUniqueResidues    *bool     `json:"hasUniqueResidues,omitempty"`
	} `json:"constraint"`
	ContainableType  *DeprecatedEntitySchemaContainableType          `json:"containableType,omitempty"`
	FieldDefinitions *[]DeprecatedEntitySchema_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Id               *string                                         `json:"id,omitempty"`

	// ModifiedAt DateTime the Entity Schema was last modified
	ModifiedAt *time.Time                  `json:"modifiedAt,omitempty"`
	Name       *string                     `json:"name,omitempty"`
	Prefix     *string                     `json:"prefix,omitempty"`
	RegistryId *string                     `json:"registryId,omitempty"`
	Type       *DeprecatedEntitySchemaType `json:"type,omitempty"`
}

// DeprecatedEntitySchemaContainableType defines model for DeprecatedEntitySchema.ContainableType.
type DeprecatedEntitySchemaContainableType string

// DeprecatedEntitySchema_FieldDefinitions_Item defines model for DeprecatedEntitySchema.fieldDefinitions.Item.
type DeprecatedEntitySchema_FieldDefinitions_Item struct {
	union json.RawMessage
}

// DeprecatedEntitySchemaType defines model for DeprecatedEntitySchema.Type.
type DeprecatedEntitySchemaType string

// DeprecatedEntitySchemasList defines model for DeprecatedEntitySchemasList.
type DeprecatedEntitySchemasList struct {
	EntitySchemas *[]DeprecatedEntitySchema `json:"entitySchemas,omitempty"`
}

// DnaAlignment defines model for DnaAlignment.
type DnaAlignment struct {
	AlignedSequences *[]AlignedSequence `json:"alignedSequences,omitempty"`

	// ApiURL The canonical url of the DNA Alignment in the API.
	ApiURL *string `json:"apiURL,omitempty"`

	// CreatedAt DateTime the DNA Alignment was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	Id        *string    `json:"id,omitempty"`

	// ModifiedAt DateTime the DNA Alignment was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`
	Name       *string    `json:"name,omitempty"`

	// ReferenceSequenceId The ID of the template or consensus DNA Sequence associated with the DNA Alignment
	ReferenceSequenceId *string `json:"referenceSequenceId,omitempty"`

	// WebURL The Benchling web UI url to view the DNA Alignment
	WebURL *string `json:"webURL,omitempty"`
}

// DnaAlignmentBase defines model for DnaAlignmentBase.
type DnaAlignmentBase struct {
	Algorithm DnaAlignmentBaseAlgorithm     `json:"algorithm"`
	Files     []DnaAlignmentBase_Files_Item `json:"files"`
	Name      *string                       `json:"name,omitempty"`
}

// DnaAlignmentBaseAlgorithm defines model for DnaAlignmentBase.Algorithm.
type DnaAlignmentBaseAlgorithm string

// DnaAlignmentBaseFiles0 defines model for .
type DnaAlignmentBaseFiles0 struct {
	SequenceId *string `json:"sequenceId,omitempty"`
}

// DnaAlignmentBase_Files_Item defines model for DnaAlignmentBase.files.Item.
type DnaAlignmentBase_Files_Item struct {
	union json.RawMessage
}

// DnaAlignmentSummary defines model for DnaAlignmentSummary.
type DnaAlignmentSummary struct {
	// ApiURL The canonical url of the DNA Alignment in the API.
	ApiURL *string `json:"apiURL,omitempty"`

	// CreatedAt DateTime the DNA Alignment was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	Id        *string    `json:"id,omitempty"`

	// ModifiedAt DateTime the DNA Alignment was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`
	Name       *string    `json:"name,omitempty"`

	// ReferenceSequenceId The ID of the template or consensus DNA Sequence associated with the DNA Alignment
	ReferenceSequenceId *string `json:"referenceSequenceId,omitempty"`

	// WebURL The Benchling web UI url to view the DNA Alignment
	WebURL *string `json:"webURL,omitempty"`
}

// DnaAlignmentsPaginatedList defines model for DnaAlignmentsPaginatedList.
type DnaAlignmentsPaginatedList struct {
	DnaAlignments *[]DnaAlignmentSummary `json:"dnaAlignments,omitempty"`
	NextToken     *string                `json:"nextToken,omitempty"`
}

// DnaAnnotation defines model for DnaAnnotation.
type DnaAnnotation struct {
	// Color Hex color code used when displaying this feature in the UI.
	Color        *string                       `json:"color,omitempty"`
	CustomFields *[]SequenceFeatureCustomField `json:"customFields,omitempty"`

	// End 0-based exclusive end index. The end of the sequence is always represented as 0.
	End   *int    `json:"end,omitempty"`
	Name  *string `json:"name,omitempty"`
	Notes *string `json:"notes,omitempty"`

	// Start 0-based inclusive start index.
	Start  *int    `json:"start,omitempty"`
	Strand *int    `json:"strand,omitempty"`
	Type   *string `json:"type,omitempty"`
}

// DnaConsensusAlignmentCreate defines model for DnaConsensusAlignmentCreate.
type DnaConsensusAlignmentCreate struct {
	Algorithm   DnaConsensusAlignmentCreateAlgorithm     `json:"algorithm"`
	Files       []DnaConsensusAlignmentCreate_Files_Item `json:"files"`
	Name        *string                                  `json:"name,omitempty"`
	NewSequence *struct {
		FolderId *string `json:"folderId,omitempty"`
	} `json:"newSequence,omitempty"`
	SequenceId *string `json:"sequenceId,omitempty"`
}

// DnaConsensusAlignmentCreateAlgorithm defines model for DnaConsensusAlignmentCreate.Algorithm.
type DnaConsensusAlignmentCreateAlgorithm string

// DnaConsensusAlignmentCreateFiles0 defines model for .
type DnaConsensusAlignmentCreateFiles0 struct {
	SequenceId *string `json:"sequenceId,omitempty"`
}

// DnaConsensusAlignmentCreate_Files_Item defines model for DnaConsensusAlignmentCreate.files.Item.
type DnaConsensusAlignmentCreate_Files_Item struct {
	union json.RawMessage
}

// DnaOligo defines model for DnaOligo.
type DnaOligo struct {
	// Aliases Array of aliases
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations on the Oligo.
	Annotations   *[]DnaAnnotation `json:"annotations,omitempty"`
	ApiURL        *string          `json:"apiURL,omitempty"`
	ArchiveRecord *ArchiveRecord   `json:"archiveRecord"`
	Bases         *string          `json:"bases,omitempty"`

	// CreatedAt DateTime the Oligo was created.
	CreatedAt *time.Time   `json:"createdAt,omitempty"`
	Creator   *UserSummary `json:"creator,omitempty"`

	// CustomFields Custom fields set on the Oligo.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// CustomNotation Representation of the oligo in the custom notation specified in the request. Null if no notation was specified.
	CustomNotation *string `json:"customNotation"`

	// CustomNotationName Name of the custom notation specified in the request. Null if no notation was specified.
	CustomNotationName *string `json:"customNotationName"`

	// EntityRegistryId Registry ID of the Oligo if registered.
	EntityRegistryId *string `json:"entityRegistryId"`
	Fields           *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder that contains the Oligo.
	FolderId *string `json:"folderId"`

	// Helm Representation of the oligo in HELM syntax, including any chemical modifications
	Helm *string `json:"helm,omitempty"`

	// Id ID of the Oligo.
	Id *string `json:"id,omitempty"`

	// Length Number of bases in the Oligo.
	Length *int `json:"length,omitempty"`

	// ModifiedAt DateTime the Oligo was last modified.
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Name Name of the Oligo.
	Name *string `json:"name,omitempty"`

	// NucleotideType Nucleotide type of the Oligo.
	NucleotideType     DnaOligoNucleotideType `json:"nucleotideType"`
	RegistrationOrigin *RegistrationOrigin    `json:"registrationOrigin"`

	// RegistryId Registry the Oligo is registered in.
	RegistryId *string        `json:"registryId"`
	Schema     *SchemaSummary `json:"schema"`

	// WebURL URL of the Oligo.
	WebURL *string `json:"webURL,omitempty"`
}

// DnaOligoNucleotideType Nucleotide type of the Oligo.
type DnaOligoNucleotideType string

// DnaOligoBulkUpdate defines model for DnaOligoBulkUpdate.
type DnaOligoBulkUpdate struct {
	// Aliases Aliases to add to the Oligo
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations on the Oligo.
	Annotations *[]DnaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the Oligo's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs of the oligo.
	Bases *string `json:"bases,omitempty"`

	// CustomFields Custom fields to add to the Oligo. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// CustomNotation Representation of the sequence or oligo in the custom notation specified by customNotationId
	CustomNotation *string `json:"customNotation,omitempty"`

	// CustomNotationId ID of the notation used to interpret the string provided in the customNotation field
	CustomNotationId *string `json:"customNotationId,omitempty"`

	// Fields Fields to set on the Oligo. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the Oligo.
	FolderId *string `json:"folderId,omitempty"`

	// Helm Representation of the oligo in HELM syntax, including any chemical modifications
	Helm *string `json:"helm,omitempty"`
	Id   *string `json:"id,omitempty"`

	// Name Name of the Oligo.
	Name *string `json:"name,omitempty"`

	// SchemaId ID of the oligo's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// DnaOligoCreate defines model for DnaOligoCreate.
type DnaOligoCreate struct {
	// Aliases Aliases to add to the Oligo
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations on the Oligo.
	Annotations *[]DnaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the Oligo's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs of the oligo.
	Bases string `json:"bases"`

	// CustomFields Custom fields to add to the Oligo. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// CustomNotation Representation of the sequence or oligo in the custom notation specified by customNotationId
	CustomNotation *string `json:"customNotation,omitempty"`

	// CustomNotationId ID of the notation used to interpret the string provided in the customNotation field
	CustomNotationId *string `json:"customNotationId,omitempty"`

	// EntityRegistryId Entity registry ID to set for the registered entity. Cannot specify both entityRegistryId and namingStrategy at the same time.
	EntityRegistryId *string `json:"entityRegistryId,omitempty"`

	// Fields Fields to set on the Oligo. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the entity. Can be left empty when registryId is present.
	FolderId *string `json:"folderId,omitempty"`

	// Helm Representation of the oligo in HELM syntax, including any chemical modifications
	Helm *string `json:"helm,omitempty"`

	// Name Name of the Oligo.
	Name string `json:"name"`

	// NamingStrategy Specifies the behavior for automatically generated names when registering an entity.
	// - NEW_IDS: Generate new registry IDs
	// - IDS_FROM_NAMES: Generate registry IDs based on entity names
	// - DELETE_NAMES: Generate new registry IDs and replace name with registry ID
	// - SET_FROM_NAME_PARTS: Generate new registry IDs, rename according to name template, and keep old name as alias
	// - REPLACE_NAMES_FROM_PARTS: Generate new registry IDs, and replace name according to name template
	// - KEEP_NAMES: Keep existing entity names as registry IDs
	// - REPLACE_ID_AND_NAME_FROM_PARTS: Generate registry IDs and names according to name template
	NamingStrategy *NamingStrategy `json:"namingStrategy,omitempty"`

	// RegistryId Registry ID into which entity should be registered. this is the ID of the registry which was configured for a particular organization
	// To get available registryIds, use the [/registries endpoint](#/Registry/listRegistries)
	//
	// Required in order for entities to be created directly in the registry.
	RegistryId *string `json:"registryId,omitempty"`

	// SchemaId ID of the oligo's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// DnaOligoUpdate defines model for DnaOligoUpdate.
type DnaOligoUpdate struct {
	// Aliases Aliases to add to the Oligo
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations on the Oligo.
	Annotations *[]DnaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the Oligo's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs of the oligo.
	Bases *string `json:"bases,omitempty"`

	// CustomFields Custom fields to add to the Oligo. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// CustomNotation Representation of the sequence or oligo in the custom notation specified by customNotationId
	CustomNotation *string `json:"customNotation,omitempty"`

	// CustomNotationId ID of the notation used to interpret the string provided in the customNotation field
	CustomNotationId *string `json:"customNotationId,omitempty"`

	// Fields Fields to set on the Oligo. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the Oligo.
	FolderId *string `json:"folderId,omitempty"`

	// Helm Representation of the oligo in HELM syntax, including any chemical modifications
	Helm *string `json:"helm,omitempty"`

	// Name Name of the Oligo.
	Name *string `json:"name,omitempty"`

	// SchemaId ID of the oligo's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// DnaOligoWithEntityType defines model for DnaOligoWithEntityType.
type DnaOligoWithEntityType struct {
	// Aliases Array of aliases
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations on the Oligo.
	Annotations   *[]DnaAnnotation `json:"annotations,omitempty"`
	ApiURL        *string          `json:"apiURL,omitempty"`
	ArchiveRecord *ArchiveRecord   `json:"archiveRecord"`
	Bases         *string          `json:"bases,omitempty"`

	// CreatedAt DateTime the Oligo was created.
	CreatedAt *time.Time   `json:"createdAt,omitempty"`
	Creator   *UserSummary `json:"creator,omitempty"`

	// CustomFields Custom fields set on the Oligo.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// CustomNotation Representation of the oligo in the custom notation specified in the request. Null if no notation was specified.
	CustomNotation *string `json:"customNotation"`

	// CustomNotationName Name of the custom notation specified in the request. Null if no notation was specified.
	CustomNotationName *string `json:"customNotationName"`

	// EntityRegistryId Registry ID of the Oligo if registered.
	EntityRegistryId *string                           `json:"entityRegistryId"`
	EntityType       *DnaOligoWithEntityTypeEntityType `json:"entityType,omitempty"`
	Fields           *Fields                           `json:"fields,omitempty"`

	// FolderId ID of the folder that contains the Oligo.
	FolderId *string `json:"folderId"`

	// Helm Representation of the oligo in HELM syntax, including any chemical modifications
	Helm *string `json:"helm,omitempty"`

	// Id ID of the Oligo.
	Id *string `json:"id,omitempty"`

	// Length Number of bases in the Oligo.
	Length *int `json:"length,omitempty"`

	// ModifiedAt DateTime the Oligo was last modified.
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Name Name of the Oligo.
	Name *string `json:"name,omitempty"`

	// NucleotideType Nucleotide type of the Oligo.
	NucleotideType     DnaOligoWithEntityTypeNucleotideType `json:"nucleotideType"`
	RegistrationOrigin *RegistrationOrigin                  `json:"registrationOrigin"`

	// RegistryId Registry the Oligo is registered in.
	RegistryId *string        `json:"registryId"`
	Schema     *SchemaSummary `json:"schema"`

	// WebURL URL of the Oligo.
	WebURL *string `json:"webURL,omitempty"`
}

// DnaOligoWithEntityTypeEntityType defines model for DnaOligoWithEntityType.EntityType.
type DnaOligoWithEntityTypeEntityType string

// DnaOligoWithEntityTypeNucleotideType Nucleotide type of the Oligo.
type DnaOligoWithEntityTypeNucleotideType string

// DnaOligosArchivalChange IDs of all items that were archived or unarchived, grouped by resource type. This includes the IDs of DNA Oligos along with any IDs of batches that were archived / unarchived.
type DnaOligosArchivalChange struct {
	BatchIds    *[]string `json:"batchIds,omitempty"`
	DnaOligoIds *[]string `json:"dnaOligoIds,omitempty"`
}

// DnaOligosArchive The request body for archiving DNA Oligos.
type DnaOligosArchive struct {
	DnaOligoIds []string `json:"dnaOligoIds"`

	// Reason The reason for archiving the provided entities. Accepted reasons may differ based on tenant configuration.
	Reason EntityArchiveReason `json:"reason"`
}

// DnaOligosBulkCreateRequest defines model for DnaOligosBulkCreateRequest.
type DnaOligosBulkCreateRequest struct {
	DnaOligos *[]DnaOligoCreate `json:"dnaOligos,omitempty"`
}

// DnaOligosBulkUpdateRequest defines model for DnaOligosBulkUpdateRequest.
type DnaOligosBulkUpdateRequest struct {
	DnaOligos *[]DnaOligoBulkUpdate `json:"dnaOligos,omitempty"`
}

// DnaOligosPaginatedList defines model for DnaOligosPaginatedList.
type DnaOligosPaginatedList struct {
	DnaOligos *[]DnaOligo `json:"dnaOligos,omitempty"`
	NextToken *string     `json:"nextToken,omitempty"`
}

// DnaOligosUnarchive The request body for unarchiving DNA Oligos.
type DnaOligosUnarchive struct {
	DnaOligoIds []string `json:"dnaOligoIds"`
}

// DnaSequence defines model for DnaSequence.
type DnaSequence struct {
	Aliases     *[]string        `json:"aliases,omitempty"`
	Annotations *[]DnaAnnotation `json:"annotations,omitempty"`

	// ApiURL The canonical url of the DNA Sequence in the API.
	ApiURL             *string             `json:"apiURL,omitempty"`
	ArchiveRecord      *ArchiveRecord      `json:"archiveRecord"`
	Bases              *string             `json:"bases,omitempty"`
	CreatedAt          *time.Time          `json:"createdAt,omitempty"`
	Creator            *UserSummary        `json:"creator,omitempty"`
	CustomFields       *CustomFields       `json:"customFields,omitempty"`
	EntityRegistryId   *string             `json:"entityRegistryId"`
	Fields             *Fields             `json:"fields,omitempty"`
	FolderId           *string             `json:"folderId"`
	Id                 *string             `json:"id,omitempty"`
	IsCircular         *bool               `json:"isCircular,omitempty"`
	Length             *int                `json:"length,omitempty"`
	ModifiedAt         *time.Time          `json:"modifiedAt,omitempty"`
	Name               *string             `json:"name,omitempty"`
	Parts              *[]DnaSequencePart  `json:"parts,omitempty"`
	Primers            *[]Primer           `json:"primers,omitempty"`
	RegistrationOrigin *RegistrationOrigin `json:"registrationOrigin"`
	RegistryId         *string             `json:"registryId"`
	Schema             *SchemaSummary      `json:"schema"`
	Translations       *[]Translation      `json:"translations,omitempty"`
	WebURL             *string             `json:"webURL,omitempty"`
}

// DnaSequenceBaseRequest defines model for DnaSequenceBaseRequest.
type DnaSequenceBaseRequest struct {
	// Aliases Aliases to add to the DNA sequence
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations to create on the DNA sequence.
	Annotations *[]DnaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the DNA sequence's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs for the DNA sequence.
	Bases *string `json:"bases,omitempty"`

	// CustomFields Custom fields to add to the DNA sequence. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// Fields Fields to set on the DNA sequence. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the DNA sequence.
	FolderId *string `json:"folderId,omitempty"`

	// IsCircular Whether the DNA sequence is circular or linear.
	IsCircular *bool `json:"isCircular,omitempty"`

	// Name Name of the DNA sequence.
	Name    *string            `json:"name,omitempty"`
	Parts   *[]DnaSequencePart `json:"parts,omitempty"`
	Primers *[]Primer          `json:"primers,omitempty"`

	// SchemaId ID of the DNA sequence's schema.
	SchemaId *string `json:"schemaId,omitempty"`

	// Translations Translations to create on the DNA sequence. Translations are specified by either a combination of 'start' and 'end' fields, or a list of regions. Both cannot be provided.
	Translations *[]Translation `json:"translations,omitempty"`
}

// DnaSequenceBaseRequestForCreate defines model for DnaSequenceBaseRequestForCreate.
type DnaSequenceBaseRequestForCreate struct {
	// Aliases Aliases to add to the DNA sequence
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations to create on the DNA sequence.
	Annotations *[]DnaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the DNA sequence's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs for the DNA sequence.
	Bases string `json:"bases"`

	// CustomFields Custom fields to add to the DNA sequence. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// Fields Fields to set on the DNA sequence. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the DNA sequence.
	FolderId *string `json:"folderId,omitempty"`

	// IsCircular Whether the DNA sequence is circular or linear.
	IsCircular bool `json:"isCircular"`

	// Name Name of the DNA sequence.
	Name    string             `json:"name"`
	Parts   *[]DnaSequencePart `json:"parts,omitempty"`
	Primers *[]Primer          `json:"primers,omitempty"`

	// SchemaId ID of the DNA sequence's schema.
	SchemaId *string `json:"schemaId,omitempty"`

	// Translations Translations to create on the DNA sequence. Translations are specified by either a combination of 'start' and 'end' fields, or a list of regions. Both cannot be provided.
	Translations *[]Translation `json:"translations,omitempty"`
}

// DnaSequenceBulkCreate defines model for DnaSequenceBulkCreate.
type DnaSequenceBulkCreate = DnaSequenceCreate

// DnaSequenceBulkUpdate defines model for DnaSequenceBulkUpdate.
type DnaSequenceBulkUpdate struct {
	// Aliases Aliases to add to the DNA sequence
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations to create on the DNA sequence.
	Annotations *[]DnaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the DNA sequence's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs for the DNA sequence.
	Bases *string `json:"bases,omitempty"`

	// CustomFields Custom fields to add to the DNA sequence. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// Fields Fields to set on the DNA sequence. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the DNA sequence.
	FolderId *string `json:"folderId,omitempty"`
	Id       *string `json:"id,omitempty"`

	// IsCircular Whether the DNA sequence is circular or linear.
	IsCircular *bool `json:"isCircular,omitempty"`

	// Name Name of the DNA sequence.
	Name    *string            `json:"name,omitempty"`
	Parts   *[]DnaSequencePart `json:"parts,omitempty"`
	Primers *[]Primer          `json:"primers,omitempty"`

	// SchemaId ID of the DNA sequence's schema.
	SchemaId *string `json:"schemaId,omitempty"`

	// Translations Translations to create on the DNA sequence. Translations are specified by either a combination of 'start' and 'end' fields, or a list of regions. Both cannot be provided.
	Translations *[]Translation `json:"translations,omitempty"`
}

// DnaSequenceCreate defines model for DnaSequenceCreate.
type DnaSequenceCreate struct {
	// Aliases Aliases to add to the DNA sequence
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations to create on the DNA sequence.
	Annotations *[]DnaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the DNA sequence's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs for the DNA sequence.
	Bases string `json:"bases"`

	// CustomFields Custom fields to add to the DNA sequence. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// EntityRegistryId Entity registry ID to set for the registered entity. Cannot specify both entityRegistryId and namingStrategy at the same time.
	EntityRegistryId *string `json:"entityRegistryId,omitempty"`

	// Fields Fields to set on the DNA sequence. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the entity. Can be left empty when registryId is present.
	FolderId *string `json:"folderId,omitempty"`

	// IsCircular Whether the DNA sequence is circular or linear.
	IsCircular bool `json:"isCircular"`

	// Name Name of the DNA sequence.
	Name string `json:"name"`

	// NamingStrategy Specifies the behavior for automatically generated names when registering an entity.
	// - NEW_IDS: Generate new registry IDs
	// - IDS_FROM_NAMES: Generate registry IDs based on entity names
	// - DELETE_NAMES: Generate new registry IDs and replace name with registry ID
	// - SET_FROM_NAME_PARTS: Generate new registry IDs, rename according to name template, and keep old name as alias
	// - REPLACE_NAMES_FROM_PARTS: Generate new registry IDs, and replace name according to name template
	// - KEEP_NAMES: Keep existing entity names as registry IDs
	// - REPLACE_ID_AND_NAME_FROM_PARTS: Generate registry IDs and names according to name template
	NamingStrategy *NamingStrategy    `json:"namingStrategy,omitempty"`
	Parts          *[]DnaSequencePart `json:"parts,omitempty"`
	Primers        *[]Primer          `json:"primers,omitempty"`

	// RegistryId Registry ID into which entity should be registered. this is the ID of the registry which was configured for a particular organization
	// To get available registryIds, use the [/registries endpoint](#/Registry/listRegistries)
	//
	// Required in order for entities to be created directly in the registry.
	RegistryId *string `json:"registryId,omitempty"`

	// SchemaId ID of the DNA sequence's schema.
	SchemaId *string `json:"schemaId,omitempty"`

	// Translations Translations to create on the DNA sequence. Translations are specified by either a combination of 'start' and 'end' fields, or a list of regions. Both cannot be provided.
	Translations *[]Translation `json:"translations,omitempty"`
}

// DnaSequencePart defines model for DnaSequencePart.
type DnaSequencePart struct {
	// End 0-based exclusive end index. The end of the sequence is always represented as 0.
	End        *int    `json:"end,omitempty"`
	SequenceId *string `json:"sequenceId,omitempty"`

	// Start 0-based inclusive start index.
	Start  *int `json:"start,omitempty"`
	Strand *int `json:"strand,omitempty"`
}

// DnaSequenceRequestRegistryFields defines model for DnaSequenceRequestRegistryFields.
type DnaSequenceRequestRegistryFields struct {
	EntityRegistryId *string `json:"entityRegistryId,omitempty"`
}

// DnaSequenceSummary defines model for DnaSequenceSummary.
type DnaSequenceSummary struct {
	EntityType *DnaSequenceSummaryEntityType `json:"entityType,omitempty"`
	Id         *string                       `json:"id,omitempty"`
	// Deprecated:
	Type *string `json:"type,omitempty"`
}

// DnaSequenceSummaryEntityType defines model for DnaSequenceSummary.EntityType.
type DnaSequenceSummaryEntityType string

// DnaSequenceUpdate defines model for DnaSequenceUpdate.
type DnaSequenceUpdate struct {
	// Aliases Aliases to add to the DNA sequence
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations to create on the DNA sequence.
	Annotations *[]DnaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the DNA sequence's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs for the DNA sequence.
	Bases *string `json:"bases,omitempty"`

	// CustomFields Custom fields to add to the DNA sequence. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields     *CustomFields `json:"customFields,omitempty"`
	EntityRegistryId *string       `json:"entityRegistryId,omitempty"`

	// Fields Fields to set on the DNA sequence. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the DNA sequence.
	FolderId *string `json:"folderId,omitempty"`

	// IsCircular Whether the DNA sequence is circular or linear.
	IsCircular *bool `json:"isCircular,omitempty"`

	// Name Name of the DNA sequence.
	Name    *string            `json:"name,omitempty"`
	Parts   *[]DnaSequencePart `json:"parts,omitempty"`
	Primers *[]Primer          `json:"primers,omitempty"`

	// SchemaId ID of the DNA sequence's schema.
	SchemaId *string `json:"schemaId,omitempty"`

	// Translations Translations to create on the DNA sequence. Translations are specified by either a combination of 'start' and 'end' fields, or a list of regions. Both cannot be provided.
	Translations *[]Translation `json:"translations,omitempty"`
}

// DnaSequenceWithEntityType defines model for DnaSequenceWithEntityType.
type DnaSequenceWithEntityType struct {
	Aliases     *[]string        `json:"aliases,omitempty"`
	Annotations *[]DnaAnnotation `json:"annotations,omitempty"`

	// ApiURL The canonical url of the DNA Sequence in the API.
	ApiURL             *string                              `json:"apiURL,omitempty"`
	ArchiveRecord      *ArchiveRecord                       `json:"archiveRecord"`
	Bases              *string                              `json:"bases,omitempty"`
	CreatedAt          *time.Time                           `json:"createdAt,omitempty"`
	Creator            *UserSummary                         `json:"creator,omitempty"`
	CustomFields       *CustomFields                        `json:"customFields,omitempty"`
	EntityRegistryId   *string                              `json:"entityRegistryId"`
	EntityType         *DnaSequenceWithEntityTypeEntityType `json:"entityType,omitempty"`
	Fields             *Fields                              `json:"fields,omitempty"`
	FolderId           *string                              `json:"folderId"`
	Id                 *string                              `json:"id,omitempty"`
	IsCircular         *bool                                `json:"isCircular,omitempty"`
	Length             *int                                 `json:"length,omitempty"`
	ModifiedAt         *time.Time                           `json:"modifiedAt,omitempty"`
	Name               *string                              `json:"name,omitempty"`
	Parts              *[]DnaSequencePart                   `json:"parts,omitempty"`
	Primers            *[]Primer                            `json:"primers,omitempty"`
	RegistrationOrigin *RegistrationOrigin                  `json:"registrationOrigin"`
	RegistryId         *string                              `json:"registryId"`
	Schema             *SchemaSummary                       `json:"schema"`
	Translations       *[]Translation                       `json:"translations,omitempty"`
	WebURL             *string                              `json:"webURL,omitempty"`
}

// DnaSequenceWithEntityTypeEntityType defines model for DnaSequenceWithEntityType.EntityType.
type DnaSequenceWithEntityTypeEntityType string

// DnaSequencesArchivalChange IDs of all items that were archived or unarchived, grouped by resource type. This includes the IDs of DNA sequences along with any IDs of batches that were archived / unarchived.
type DnaSequencesArchivalChange struct {
	BatchIds       *[]string `json:"batchIds,omitempty"`
	DnaSequenceIds *[]string `json:"dnaSequenceIds,omitempty"`
}

// DnaSequencesArchive The request body for archiving DNA sequences.
type DnaSequencesArchive struct {
	DnaSequenceIds []string `json:"dnaSequenceIds"`

	// Reason The reason for archiving the provided entities. Accepted reasons may differ based on tenant configuration.
	Reason EntityArchiveReason `json:"reason"`
}

// DnaSequencesBulkCreateRequest defines model for DnaSequencesBulkCreateRequest.
type DnaSequencesBulkCreateRequest struct {
	DnaSequences *[]DnaSequenceBulkCreate `json:"dnaSequences,omitempty"`
}

// DnaSequencesBulkGet defines model for DnaSequencesBulkGet.
type DnaSequencesBulkGet struct {
	DnaSequences *[]DnaSequence `json:"dnaSequences,omitempty"`
}

// DnaSequencesBulkUpdateRequest defines model for DnaSequencesBulkUpdateRequest.
type DnaSequencesBulkUpdateRequest struct {
	DnaSequences *[]DnaSequenceBulkUpdate `json:"dnaSequences,omitempty"`
}

// DnaSequencesPaginatedList defines model for DnaSequencesPaginatedList.
type DnaSequencesPaginatedList struct {
	DnaSequences *[]DnaSequence `json:"dnaSequences,omitempty"`
	NextToken    *string        `json:"nextToken,omitempty"`
}

// DnaSequencesUnarchive The request body for unarchiving DNA sequences.
type DnaSequencesUnarchive struct {
	DnaSequenceIds []string `json:"dnaSequenceIds"`
}

// DnaTemplateAlignmentCreate defines model for DnaTemplateAlignmentCreate.
type DnaTemplateAlignmentCreate struct {
	Algorithm          DnaTemplateAlignmentCreateAlgorithm     `json:"algorithm"`
	Files              []DnaTemplateAlignmentCreate_Files_Item `json:"files"`
	Name               *string                                 `json:"name,omitempty"`
	TemplateSequenceId string                                  `json:"templateSequenceId"`
}

// DnaTemplateAlignmentCreateAlgorithm defines model for DnaTemplateAlignmentCreate.Algorithm.
type DnaTemplateAlignmentCreateAlgorithm string

// DnaTemplateAlignmentCreateFiles0 defines model for .
type DnaTemplateAlignmentCreateFiles0 struct {
	SequenceId *string `json:"sequenceId,omitempty"`
}

// DnaTemplateAlignmentCreate_Files_Item defines model for DnaTemplateAlignmentCreate.files.Item.
type DnaTemplateAlignmentCreate_Files_Item struct {
	union json.RawMessage
}

// DnaTemplateAlignmentFile defines model for DnaTemplateAlignmentFile.
type DnaTemplateAlignmentFile struct {
	Data *[]byte `json:"data,omitempty"`
	Name *string `json:"name,omitempty"`
}

// Dropdown defines model for Dropdown.
type Dropdown struct {
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`

	// Id ID of the dropdown
	Id *string `json:"id,omitempty"`

	// Name Name of the dropdown
	Name *string `json:"name,omitempty"`

	// Options Array of dropdown options
	Options *[]DropdownOption `json:"options,omitempty"`
}

// DropdownCreate defines model for DropdownCreate.
type DropdownCreate struct {
	// Name Name of the dropdown
	Name string `json:"name"`

	// Options Options to set for the dropdown
	Options []DropdownOptionCreate `json:"options"`

	// RegistryId ID of registry in which to create the dropdown. Required if multiple registries exist.
	RegistryId *string `json:"registryId"`
}

// DropdownFieldDefinition defines model for DropdownFieldDefinition.
type DropdownFieldDefinition struct {
	ArchiveRecord *ArchiveRecord               `json:"archiveRecord"`
	DropdownId    *string                      `json:"dropdownId"`
	Id            *string                      `json:"id,omitempty"`
	IsMulti       *bool                        `json:"isMulti,omitempty"`
	IsRequired    *bool                        `json:"isRequired,omitempty"`
	Name          *string                      `json:"name,omitempty"`
	Type          *DropdownFieldDefinitionType `json:"type,omitempty"`
}

// DropdownFieldDefinitionType defines model for DropdownFieldDefinition.Type.
type DropdownFieldDefinitionType string

// DropdownMultiValueUiBlock defines model for DropdownMultiValueUiBlock.
type DropdownMultiValueUiBlock struct {
	DropdownId string                        `json:"dropdownId"`
	Enabled    *bool                         `json:"enabled"`
	Id         string                        `json:"id"`
	Label      *string                       `json:"label"`
	Type       DropdownMultiValueUiBlockType `json:"type"`
	Value      *[]string                     `json:"value"`
}

// DropdownMultiValueUiBlockType defines model for DropdownMultiValueUiBlock.Type.
type DropdownMultiValueUiBlockType string

// DropdownMultiValueUiBlockCreate defines model for DropdownMultiValueUiBlockCreate.
type DropdownMultiValueUiBlockCreate = DropdownMultiValueUiBlock

// DropdownMultiValueUiBlockUpdate defines model for DropdownMultiValueUiBlockUpdate.
type DropdownMultiValueUiBlockUpdate = DropdownMultiValueUiBlock

// DropdownOption defines model for DropdownOption.
type DropdownOption struct {
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`
	Id            *string        `json:"id,omitempty"`
	Name          *string        `json:"name,omitempty"`
}

// DropdownOptionCreate defines model for DropdownOptionCreate.
type DropdownOptionCreate struct {
	Name string `json:"name"`
}

// DropdownOptionUpdate defines model for DropdownOptionUpdate.
type DropdownOptionUpdate struct {
	// Id ID of the dropdown option to update, omitted if creating a new option.
	Id *string `json:"id,omitempty"`

	// Name Name of the dropdown option.
	Name string `json:"name"`
}

// DropdownOptionsArchivalChange IDs of all items that were archived or unarchived.
type DropdownOptionsArchivalChange struct {
	DropdownOptionIds *[]string `json:"dropdownOptionIds,omitempty"`
}

// DropdownOptionsArchive defines model for DropdownOptionsArchive.
type DropdownOptionsArchive struct {
	// DropdownOptionIds Array of dropdown option IDs
	DropdownOptionIds *[]string `json:"dropdownOptionIds,omitempty"`

	// Reason Reason that dropdown options are being archived.
	Reason *DropdownOptionsArchiveReason `json:"reason,omitempty"`
}

// DropdownOptionsArchiveReason Reason that dropdown options are being archived.
type DropdownOptionsArchiveReason string

// DropdownOptionsUnarchive defines model for DropdownOptionsUnarchive.
type DropdownOptionsUnarchive struct {
	// DropdownOptionIds Array of dropdown option IDs
	DropdownOptionIds *[]string `json:"dropdownOptionIds,omitempty"`
}

// DropdownSummariesPaginatedList defines model for DropdownSummariesPaginatedList.
type DropdownSummariesPaginatedList struct {
	Dropdowns *[]DropdownSummary `json:"dropdowns,omitempty"`
	NextToken *string            `json:"nextToken,omitempty"`
}

// DropdownSummary defines model for DropdownSummary.
type DropdownSummary struct {
	// Id ID of the dropdown
	Id *string `json:"id,omitempty"`

	// Name Name of the dropdown
	Name *string `json:"name,omitempty"`
}

// DropdownUiBlock defines model for DropdownUiBlock.
type DropdownUiBlock struct {
	DropdownId string              `json:"dropdownId"`
	Enabled    *bool               `json:"enabled"`
	Id         string              `json:"id"`
	Label      *string             `json:"label"`
	Type       DropdownUiBlockType `json:"type"`
	Value      *string             `json:"value"`
}

// DropdownUiBlockType defines model for DropdownUiBlock.Type.
type DropdownUiBlockType string

// DropdownUiBlockCreate defines model for DropdownUiBlockCreate.
type DropdownUiBlockCreate = DropdownUiBlock

// DropdownUiBlockUpdate defines model for DropdownUiBlockUpdate.
type DropdownUiBlockUpdate = DropdownUiBlock

// DropdownUpdate defines model for DropdownUpdate.
type DropdownUpdate struct {
	// Options Options to set for the dropdown
	Options []DropdownOptionUpdate `json:"options"`
}

// DropdownsRegistryList defines model for DropdownsRegistryList.
type DropdownsRegistryList struct {
	Dropdowns *[]DropdownSummary `json:"dropdowns,omitempty"`
}

// EmptyObject defines model for EmptyObject.
type EmptyObject = map[string]interface{}

// Entity defines model for Entity.
type Entity struct {
	union json.RawMessage
}

// EntityArchiveReason The reason for archiving the provided entities. Accepted reasons may differ based on tenant configuration.
type EntityArchiveReason string

// EntityLabels defines model for EntityLabels.
type EntityLabels struct {
	EntityRegistryId *string `json:"entityRegistryId"`
	Id               *string `json:"id,omitempty"`
	Name             *string `json:"name,omitempty"`
}

// EntityOrInaccessibleResource defines model for EntityOrInaccessibleResource.
type EntityOrInaccessibleResource struct {
	union json.RawMessage
}

// EntityRegisteredEvent defines model for EntityRegisteredEvent.
type EntityRegisteredEvent struct {
	CreatedAt  *time.Time                      `json:"createdAt,omitempty"`
	Deprecated *bool                           `json:"deprecated,omitempty"`
	Entity     *GenericEntity                  `json:"entity,omitempty"`
	EventType  *EntityRegisteredEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
}

// EntityRegisteredEventEventType defines model for EntityRegisteredEvent.EventType.
type EntityRegisteredEventEventType string

// EntitySchema defines model for EntitySchema.
type EntitySchema struct {
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`
	Constraint    *struct {
		FieldDefinitionNames *[]string `json:"fieldDefinitionNames,omitempty"`
		HasUniqueResidues    *bool     `json:"hasUniqueResidues,omitempty"`
	} `json:"constraint"`
	ContainableType  *EntitySchemaContainableType          `json:"containableType,omitempty"`
	FieldDefinitions *[]EntitySchema_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Id               *string                               `json:"id,omitempty"`

	// ModifiedAt DateTime the Entity Schema was last modified
	ModifiedAt *time.Time        `json:"modifiedAt,omitempty"`
	Name       *string           `json:"name,omitempty"`
	Prefix     *string           `json:"prefix,omitempty"`
	RegistryId *string           `json:"registryId,omitempty"`
	Type       *EntitySchemaType `json:"type,omitempty"`
}

// EntitySchemaContainableType defines model for EntitySchema.ContainableType.
type EntitySchemaContainableType string

// EntitySchema_FieldDefinitions_Item defines model for EntitySchema.fieldDefinitions.Item.
type EntitySchema_FieldDefinitions_Item struct {
	union json.RawMessage
}

// EntitySchemaType defines model for EntitySchema.Type.
type EntitySchemaType string

// EntitySchemaAppConfigItem defines model for EntitySchemaAppConfigItem.
type EntitySchemaAppConfigItem struct {
	ApiURL *string `json:"apiURL,omitempty"`
	App    *struct {
		// Id The id of the Benchling app to which this configuration item belongs
		Id *string `json:"id,omitempty"`
	} `json:"app,omitempty"`

	// CreatedAt DateTime the app config item was created
	CreatedAt      *time.Time               `json:"createdAt,omitempty"`
	Description    *string                  `json:"description,omitempty"`
	Id             *string                  `json:"id,omitempty"`
	LinkedResource *LinkedAppConfigResource `json:"linkedResource"`

	// ModifiedAt DateTime the app config item was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path           *[]string                      `json:"path,omitempty"`
	RequiredConfig *bool                          `json:"requiredConfig,omitempty"`
	Subtype        *SchemaDependencySubtypes      `json:"subtype,omitempty"`
	Type           *EntitySchemaAppConfigItemType `json:"type,omitempty"`
	Value          *string                        `json:"value"`
}

// EntitySchemaAppConfigItemType defines model for EntitySchemaAppConfigItem.Type.
type EntitySchemaAppConfigItemType string

// EntitySchemasPaginatedList defines model for EntitySchemasPaginatedList.
type EntitySchemasPaginatedList struct {
	EntitySchemas *[]EntitySchema `json:"entitySchemas,omitempty"`
	NextToken     *string         `json:"nextToken,omitempty"`
}

// Entries defines model for Entries.
type Entries struct {
	Entries *[]Entry `json:"entries,omitempty"`
}

// EntriesArchivalChange IDs of all items that were archived or unarchived, grouped by resource type. This includes the IDs of entries that changed..
type EntriesArchivalChange struct {
	EntryIds *[]string `json:"entryIds,omitempty"`
}

// EntriesArchive defines model for EntriesArchive.
type EntriesArchive struct {
	// EntryIds Array of entry IDs
	EntryIds []string `json:"entryIds"`

	// Reason Reason that entries are being archived. One of ["Made in error", "Retired", "Other"].
	Reason EntriesArchiveReason `json:"reason"`
}

// EntriesArchiveReason Reason that entries are being archived. One of ["Made in error", "Retired", "Other"].
type EntriesArchiveReason string

// EntriesPaginatedList defines model for EntriesPaginatedList.
type EntriesPaginatedList struct {
	Entries   *[]Entry `json:"entries,omitempty"`
	NextToken *string  `json:"nextToken,omitempty"`
}

// EntriesUnarchive defines model for EntriesUnarchive.
type EntriesUnarchive struct {
	// EntryIds Array of entry IDs
	EntryIds []string `json:"entryIds"`
}

// Entry Entries are notes that users can take. They're organized by "days" (which are user-configurable) and modeled within each day as a list of "notes." Each note has a type - the simplest is a "text" type, but lists, tables, and external files are also supported.
//
// *Note:* the current Entry resource has a few limitations:
// - Formatting information is not yet supported. Header formatting, bolding, and other stylistic information is not presented.
// - Data in tables is presented as text always - numeric values will need to be parsed into floats or integers, as appropriate.
//
// Note: Data in Results tables are not accessible through this API call. Results table data can be called through the Results API calls.
type Entry struct {
	// ApiURL The canonical url of the Entry in the API.
	ApiURL *string `json:"apiURL,omitempty"`

	// ArchiveRecord ArchiveRecord Resource if the entry is archived. This is null if the entry is not archived.
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`

	// AssignedReviewers Array of users assigned to review the entry, if any.
	AssignedReviewers *[]UserSummary `json:"assignedReviewers,omitempty"`

	// Authors Array of UserSummary Resources of the authors of the entry. This defaults to the creator but can be manually changed.
	Authors *[]UserSummary `json:"authors,omitempty"`

	// CreatedAt DateTime the entry was created at
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Creator UserSummary Resource of the user who created the entry
	Creator      *UserSummary  `json:"creator,omitempty"`
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// Days Array of day objects. Each day object has a date field (string) and notes field (array of notes, expand further for details on note types).
	Days *[]EntryDay `json:"days,omitempty"`

	// DisplayId User-friendly ID of the entry
	DisplayId *string `json:"displayId,omitempty"`

	// EntryTemplateId ID of the Entry Template this Entry was created from
	EntryTemplateId *string `json:"entryTemplateId"`
	Fields          *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder that contains the entry
	FolderId *string `json:"folderId,omitempty"`

	// Id ID of the entry
	Id *string `json:"id,omitempty"`

	// ModifiedAt DateTime the entry was last modified
	ModifiedAt *string `json:"modifiedAt,omitempty"`

	// Name Title of the entry
	Name *string `json:"name,omitempty"`

	// ReviewRecord Review record if set
	ReviewRecord *struct {
		// Comment Reviewer's Comments
		Comment *string `json:"comment,omitempty"`

		// Status Review Status of the entry
		Status *EntryReviewRecordStatus `json:"status,omitempty"`
	} `json:"reviewRecord"`

	// Schema Entry schema if set
	Schema *EntrySchema `json:"schema"`

	// WebURL URL of the entry
	WebURL *string `json:"webURL,omitempty"`
}

// EntryReviewRecordStatus Review Status of the entry
type EntryReviewRecordStatus string

// EntryById defines model for EntryById.
type EntryById struct {
	// Entry Entries are notes that users can take. They're organized by "days" (which are user-configurable) and modeled within each day as a list of "notes." Each note has a type - the simplest is a "text" type, but lists, tables, and external files are also supported.
	//
	// *Note:* the current Entry resource has a few limitations:
	// - Formatting information is not yet supported. Header formatting, bolding, and other stylistic information is not presented.
	// - Data in tables is presented as text always - numeric values will need to be parsed into floats or integers, as appropriate.
	//
	// Note: Data in Results tables are not accessible through this API call. Results table data can be called through the Results API calls.
	Entry *Entry `json:"entry,omitempty"`
}

// EntryCreate defines model for EntryCreate.
type EntryCreate struct {
	AuthorIds *EntryCreate_AuthorIds `json:"authorIds,omitempty"`

	// CustomFields Custom fields to add to the entry
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// EntryTemplateId ID of the template to clone the entry from
	EntryTemplateId *string `json:"entryTemplateId,omitempty"`

	// Fields Fields to set on the entry. Must correspond with the schema's field definitions.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder that will contain the entry
	FolderId string `json:"folderId"`

	// InitialTables An array of table API IDs and blob id pairs to seed tables from the template while creating the entry. The entryTemplateId parameter must be set to use this parameter. The table API IDs should be the API Identifiers of the tables in the given template.
	// - If a template table has one row, the values in that row act as default values for cloned entries.
	// - If a template table has multiple rows, there is no default value and those rows are added to the cloned entry along with the provided csv data.
	// - If a table has default values, they will be populated in any respective undefined columns in the csv data.
	// - If a table has no default values, undefined columns from csv data will be empty.
	// - If no csv data is provided for a table, the table in the entry will be populated with whatever values are in the respective template table.
	InitialTables *[]InitialTable `json:"initialTables,omitempty"`

	// Name Name of the entry
	Name string `json:"name"`

	// SchemaId ID of the entry's schema
	SchemaId *string `json:"schemaId,omitempty"`
}

// EntryCreateAuthorIds0 defines model for .
type EntryCreateAuthorIds0 = string

// EntryCreateAuthorIds1 IDs of users to set as the entry's authors. Defaults to the creator.
type EntryCreateAuthorIds1 = []string

// EntryCreate_AuthorIds defines model for EntryCreate.AuthorIds.
type EntryCreate_AuthorIds struct {
	union json.RawMessage
}

// EntryCreatedEvent defines model for EntryCreatedEvent.
type EntryCreatedEvent struct {
	CreatedAt  *time.Time `json:"createdAt,omitempty"`
	Deprecated *bool      `json:"deprecated,omitempty"`

	// Entry Entries are notes that users can take. They're organized by "days" (which are user-configurable) and modeled within each day as a list of "notes." Each note has a type - the simplest is a "text" type, but lists, tables, and external files are also supported.
	//
	// *Note:* the current Entry resource has a few limitations:
	// - Formatting information is not yet supported. Header formatting, bolding, and other stylistic information is not presented.
	// - Data in tables is presented as text always - numeric values will need to be parsed into floats or integers, as appropriate.
	//
	// Note: Data in Results tables are not accessible through this API call. Results table data can be called through the Results API calls.
	Entry     *Entry                      `json:"entry,omitempty"`
	EventType *EntryCreatedEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
}

// EntryCreatedEventEventType defines model for EntryCreatedEvent.EventType.
type EntryCreatedEventEventType string

// EntryDay defines model for EntryDay.
type EntryDay struct {
	// Date A Date string
	Date  *string          `json:"date,omitempty"`
	Notes *[]EntryNotePart `json:"notes,omitempty"`

	// Title Optional title of a section if sections are enabled.
	Title *string `json:"title"`
}

// EntryExternalFile The ExternalFile resource stores metadata about the file. The actual original file can be downloaded by using the 'downloadURL' property.
type EntryExternalFile struct {
	// DownloadURL A short-lived URL that can be used to download the original file.
	DownloadURL *string `json:"downloadURL,omitempty"`

	// ExpiresAt UNIX timestamp when downloadURL expires.
	ExpiresAt *int `json:"expiresAt,omitempty"`

	// Id ID of the external file
	Id *string `json:"id,omitempty"`

	// Size Size, in bytes, of the external file
	Size *int `json:"size,omitempty"`
}

// EntryExternalFileById defines model for EntryExternalFileById.
type EntryExternalFileById struct {
	// ExternalFile The ExternalFile resource stores metadata about the file. The actual original file can be downloaded by using the 'downloadURL' property.
	ExternalFile *EntryExternalFile `json:"externalFile,omitempty"`
}

// EntryLink Links are contained within notes to reference resources that live outside of the entry. A link can target an external resource via an http(s):// hyperlink or a Benchling resource via @-mentions and drag-n-drop.
type EntryLink struct {
	// Id For linked Benchling resources, this will be the ID of that resource (e.g., 'seq_RhYGVnHF'). Omitted for "link" types.
	Id *string `json:"id,omitempty"`

	// Type The type of resource being linked. For hyperlinks: 'link'. For linked Benchling resources, one of: 'user', 'request', 'entry', 'stage_entry', 'protocol', 'workflow', 'custom_entity', 'aa_sequence', 'dna_sequence', 'batch', 'box', 'container', 'location', 'plate'.
	Type *EntryLinkType `json:"type,omitempty"`

	// WebURL Canonical URL of the linked Benchling resource (if you have at least READ authorization for that resource), or the explicit URL provided as hyperlink for "link" types. Note: locations do not currently have a URL.
	WebURL *string `json:"webURL"`
}

// EntryLinkType The type of resource being linked. For hyperlinks: 'link'. For linked Benchling resources, one of: 'user', 'request', 'entry', 'stage_entry', 'protocol', 'workflow', 'custom_entity', 'aa_sequence', 'dna_sequence', 'batch', 'box', 'container', 'location', 'plate'.
type EntryLinkType string

// EntryNotePart Notes are the main building blocks of entries. Each note corresponds roughly to a paragraph.
type EntryNotePart struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// EntrySchema Entry schema
type EntrySchema struct {
	// Id ID of the entry schema
	Id *string `json:"id,omitempty"`

	// ModifiedAt DateTime the Entry Schema was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Name Name of the entry schema
	Name *string `json:"name,omitempty"`
}

// EntrySchemaDetailed defines model for EntrySchemaDetailed.
type EntrySchemaDetailed struct {
	ArchiveRecord    *ArchiveRecord                               `json:"archiveRecord"`
	FieldDefinitions *[]EntrySchemaDetailed_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Id               *string                                      `json:"id,omitempty"`
	Name             *string                                      `json:"name,omitempty"`
	Prefix           *string                                      `json:"prefix,omitempty"`
	RegistryId       *string                                      `json:"registryId,omitempty"`
	Type             *EntrySchemaDetailedType                     `json:"type,omitempty"`
}

// EntrySchemaDetailed_FieldDefinitions_Item defines model for EntrySchemaDetailed.fieldDefinitions.Item.
type EntrySchemaDetailed_FieldDefinitions_Item struct {
	union json.RawMessage
}

// EntrySchemaDetailedType defines model for EntrySchemaDetailed.Type.
type EntrySchemaDetailedType string

// EntrySchemasPaginatedList defines model for EntrySchemasPaginatedList.
type EntrySchemasPaginatedList struct {
	EntrySchemas *[]EntrySchemaDetailed `json:"entrySchemas,omitempty"`
	NextToken    *string                `json:"nextToken,omitempty"`
}

// EntryTable Actual tabular data with rows and columns of text on the note.
type EntryTable struct {
	// ColumnLabels Array of strings, with one item per column. Defaults to null, if the user is using the default, but is set if the user has given a custom name to the column.
	ColumnLabels *[]string `json:"columnLabels,omitempty"`

	// Name Name of the table - defaults to e.g. Table1 but can be renamed.
	Name *string `json:"name,omitempty"`

	// Rows Array of row objects.
	Rows *[]EntryTableRow `json:"rows,omitempty"`
}

// EntryTableCell defines model for EntryTableCell.
type EntryTableCell struct {
	// Link A Link Resource if this cell contained a hyperlink. Otherwise, link will be omitted from the cell object. (Note: inventory and user types are not yet supported.)
	Link *EntryLink `json:"link,omitempty"`

	// Text The textual content of the cell. If the cell was originally a formula, this will be the evaluated version of the formula.
	Text *string `json:"text,omitempty"`
}

// EntryTableRow Each has property 'cells' that is an array of cell objects
type EntryTableRow struct {
	Cells *[]EntryTableCell `json:"cells,omitempty"`
}

// EntryTemplate Entry templates are templates that users can base new notebook entries off of.
type EntryTemplate struct {
	// ApiURL The canonical url of the Entry Template in the API.
	ApiURL *string `json:"apiURL,omitempty"`

	// CreatedAt DateTime the template was created at
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Creator UserSummary Resource of the user who created the template
	Creator      *UserSummary  `json:"creator,omitempty"`
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// Days Array of day objects. Each day object has a day index (integer) and notes field (array of notes, expand further for details on note types).
	Days   *[]EntryTemplateDay `json:"days,omitempty"`
	Fields *Fields             `json:"fields,omitempty"`

	// Id ID of the entry template
	Id *string `json:"id,omitempty"`

	// ModifiedAt DateTime the template was last modified
	ModifiedAt *string `json:"modifiedAt,omitempty"`

	// Name Title of the template
	Name *string `json:"name,omitempty"`

	// Schema Entry schema if set
	Schema *EntrySchema `json:"schema"`

	// TemplateCollectionId ID of the collection that contains the template
	TemplateCollectionId *string `json:"templateCollectionId,omitempty"`

	// WebURL URL of the template
	WebURL *string `json:"webURL,omitempty"`
}

// EntryTemplateDay defines model for EntryTemplateDay.
type EntryTemplateDay struct {
	// Day 1 indexed day signifier. If 0 is returned, that means the EntryTemplateDay is a section with a title but no specified Day.
	Day   *int             `json:"day,omitempty"`
	Notes *[]EntryNotePart `json:"notes,omitempty"`

	// Title Optional title of a section if sections are enabled.
	Title *string `json:"title"`
}

// EntryTemplatesPaginatedList defines model for EntryTemplatesPaginatedList.
type EntryTemplatesPaginatedList struct {
	EntryTemplates *[]EntryTemplate `json:"entryTemplates,omitempty"`
	NextToken      *string          `json:"nextToken,omitempty"`
}

// EntryUpdate defines model for EntryUpdate.
type EntryUpdate struct {
	// AuthorIds IDs of users to set as the entry's authors.
	AuthorIds *string `json:"authorIds,omitempty"`

	// Fields Schema fields to set on the entry
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder that will contain the entry
	FolderId *string `json:"folderId,omitempty"`

	// Name New name of the entry
	Name *string `json:"name,omitempty"`

	// SchemaId ID of the schema for the entry
	SchemaId *string `json:"schemaId,omitempty"`
}

// EntryUpdatedFieldsEvent defines model for EntryUpdatedFieldsEvent.
type EntryUpdatedFieldsEvent struct {
	CreatedAt  *time.Time `json:"createdAt,omitempty"`
	Deprecated *bool      `json:"deprecated,omitempty"`

	// Entry Entries are notes that users can take. They're organized by "days" (which are user-configurable) and modeled within each day as a list of "notes." Each note has a type - the simplest is a "text" type, but lists, tables, and external files are also supported.
	//
	// *Note:* the current Entry resource has a few limitations:
	// - Formatting information is not yet supported. Header formatting, bolding, and other stylistic information is not presented.
	// - Data in tables is presented as text always - numeric values will need to be parsed into floats or integers, as appropriate.
	//
	// Note: Data in Results tables are not accessible through this API call. Results table data can be called through the Results API calls.
	Entry     *Entry                            `json:"entry,omitempty"`
	EventType *EntryUpdatedFieldsEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`

	// Updates These properties have been updated, causing this message
	Updates *[]string `json:"updates,omitempty"`
}

// EntryUpdatedFieldsEventEventType defines model for EntryUpdatedFieldsEvent.EventType.
type EntryUpdatedFieldsEventEventType string

// EntryUpdatedReviewRecordEvent defines model for EntryUpdatedReviewRecordEvent.
type EntryUpdatedReviewRecordEvent struct {
	CreatedAt  *time.Time `json:"createdAt,omitempty"`
	Deprecated *bool      `json:"deprecated,omitempty"`

	// Entry Entries are notes that users can take. They're organized by "days" (which are user-configurable) and modeled within each day as a list of "notes." Each note has a type - the simplest is a "text" type, but lists, tables, and external files are also supported.
	//
	// *Note:* the current Entry resource has a few limitations:
	// - Formatting information is not yet supported. Header formatting, bolding, and other stylistic information is not presented.
	// - Data in tables is presented as text always - numeric values will need to be parsed into floats or integers, as appropriate.
	//
	// Note: Data in Results tables are not accessible through this API call. Results table data can be called through the Results API calls.
	Entry     *Entry                                  `json:"entry,omitempty"`
	EventType *EntryUpdatedReviewRecordEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`

	// Updates These properties have been updated, causing this message
	Updates *[]string `json:"updates,omitempty"`
}

// EntryUpdatedReviewRecordEventEventType defines model for EntryUpdatedReviewRecordEvent.EventType.
type EntryUpdatedReviewRecordEventEventType string

// Event defines model for Event.
type Event struct {
	EventType string `json:"eventType"`
	union     json.RawMessage
}

// EventBase defines model for EventBase.
type EventBase struct {
	CreatedAt  *time.Time `json:"createdAt,omitempty"`
	Deprecated *bool      `json:"deprecated,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
}

// EventsPaginatedList defines model for EventsPaginatedList.
type EventsPaginatedList struct {
	Events    *[]Event `json:"events,omitempty"`
	NextToken *string  `json:"nextToken,omitempty"`
}

// ExecuteSampleGroups The response is intentionally empty.
type ExecuteSampleGroups = map[string]interface{}

// ExportAuditLogAsyncTask defines model for ExportAuditLogAsyncTask.
type ExportAuditLogAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		DownloadURL *string `json:"downloadURL,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status ExportAuditLogAsyncTaskStatus `json:"status"`
}

// ExportAuditLogAsyncTaskStatus The current state of the task.
type ExportAuditLogAsyncTaskStatus string

// ExportItemRequest defines model for ExportItemRequest.
type ExportItemRequest struct {
	// Id ID of the item to export
	Id string `json:"id"`
}

// ExportsAsyncTask defines model for ExportsAsyncTask.
type ExportsAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		DownloadURL *string `json:"downloadURL,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status ExportsAsyncTaskStatus `json:"status"`
}

// ExportsAsyncTaskStatus The current state of the task.
type ExportsAsyncTaskStatus string

// ExternalFileNotePart defines model for ExternalFileNotePart.
type ExternalFileNotePart struct {
	// ExternalFileId The ID of the external file. Use the 'Get an external file' endpoint to retrieve metadata about it.
	ExternalFileId *string `json:"externalFileId,omitempty"`

	// Indentation All notes have an indentation level - the default is 0 for no indent. For lists, indentation gives notes hierarchy - a bulleted list with children is modeled as one note part with indentation 1 followed by note parts with indentation 2, for example.
	Indentation *int `json:"indentation,omitempty"`

	// Links Array of links referenced in the caption via an @-mention, hyperlink, or the drag-n-dropped preview attached to the note.
	Links *[]EntryLink `json:"links,omitempty"`

	// Text The caption of the file attachment.
	Text *string                   `json:"text,omitempty"`
	Type *ExternalFileNotePartType `json:"type,omitempty"`
}

// ExternalFileNotePartType defines model for ExternalFileNotePart.Type.
type ExternalFileNotePartType string

// Feature defines model for Feature.
type Feature struct {
	// Color The color of the annotations generated by the feature. Must be a valid hex string
	Color *string `json:"color,omitempty"`

	// FeatureLibraryId The id of the feature library the feature belongs to
	FeatureLibraryId *string `json:"featureLibraryId,omitempty"`

	// FeatureType The type of feature, like gene, promoter, etc. Note: This is an arbitrary string, not an enum
	FeatureType *string `json:"featureType"`

	// Id The id of the feature
	Id *string `json:"id,omitempty"`

	// MatchType The match type of the feature. Used to determine how auto-annotate matches are made.
	MatchType *FeatureMatchType `json:"matchType,omitempty"`

	// Name The name of the feature
	Name *string `json:"name,omitempty"`

	// Pattern The pattern used for matching during auto-annotation.
	Pattern *string `json:"pattern,omitempty"`
}

// FeatureMatchType The match type of the feature. Used to determine how auto-annotate matches are made.
type FeatureMatchType string

// FeatureBase defines model for FeatureBase.
type FeatureBase struct {
	// Color The color of the annotations generated by the feature. Must be a valid hex string
	Color *string `json:"color,omitempty"`

	// FeatureLibraryId The id of the feature library the feature belongs to
	FeatureLibraryId *string `json:"featureLibraryId,omitempty"`

	// FeatureType The type of feature, like gene, promoter, etc. Note: This is an arbitrary string, not an enum
	FeatureType *string `json:"featureType"`

	// Name The name of the feature
	Name *string `json:"name,omitempty"`

	// Pattern The pattern used for matching during auto-annotation.
	Pattern *string `json:"pattern,omitempty"`
}

// FeatureBulkCreate Inputs for a new feature
type FeatureBulkCreate = FeatureCreate

// FeatureCreate defines model for FeatureCreate.
type FeatureCreate struct {
	// Color The color of the annotations generated by the feature. Must be a valid hex string
	Color *string `json:"color,omitempty"`

	// FeatureLibraryId The id of the feature library the feature belongs to
	FeatureLibraryId string `json:"featureLibraryId"`

	// FeatureType The type of feature, like gene, promoter, etc. Note: This is an arbitrary string, not an enum
	FeatureType *string `json:"featureType"`

	// MatchType The match type of the feature. Used to determine how auto-annotate matches are made.
	MatchType FeatureCreateMatchType `json:"matchType"`

	// Name The name of the feature
	Name string `json:"name"`

	// Pattern The pattern used for matching during auto-annotation.
	Pattern string `json:"pattern"`
}

// FeatureCreateMatchType The match type of the feature. Used to determine how auto-annotate matches are made.
type FeatureCreateMatchType string

// FeatureLibrariesPaginatedList defines model for FeatureLibrariesPaginatedList.
type FeatureLibrariesPaginatedList struct {
	FeatureLibraries *[]FeatureLibrary `json:"featureLibraries,omitempty"`
	NextToken        *string           `json:"nextToken,omitempty"`
}

// FeatureLibrary defines model for FeatureLibrary.
type FeatureLibrary struct {
	// CreatedAt DateTime the Feature Library was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Description The description for the feature library
	Description *string `json:"description,omitempty"`

	// Id The id of the feature library
	Id *string `json:"id,omitempty"`

	// ModifiedAt DateTime the Feature Library was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Name The name of the feature library
	Name  *string               `json:"name,omitempty"`
	Owner *FeatureLibrary_Owner `json:"owner,omitempty"`

	// WebURL The Benchling web UI url to view the Feature Library
	WebURL *string `json:"webURL,omitempty"`
}

// FeatureLibrary_Owner defines model for FeatureLibrary.Owner.
type FeatureLibrary_Owner struct {
	union json.RawMessage
}

// FeatureLibraryBase defines model for FeatureLibraryBase.
type FeatureLibraryBase struct {
	// Description The description for the feature library
	Description *string `json:"description,omitempty"`

	// Name The name of the feature library
	Name *string `json:"name,omitempty"`
}

// FeatureLibraryCreate defines model for FeatureLibraryCreate.
type FeatureLibraryCreate struct {
	// Description The description for the feature library
	Description string `json:"description"`

	// Name The name of the feature library
	Name string `json:"name"`

	// OrganizationId The organization that will own the feature library. The requesting user must be an administrator of the organization. If unspecified and the organization allows personal ownables, then the requesting user will own the feature library
	OrganizationId *string `json:"organizationId,omitempty"`
}

// FeatureLibraryUpdate defines model for FeatureLibraryUpdate.
type FeatureLibraryUpdate = FeatureLibraryBase

// FeatureUpdate defines model for FeatureUpdate.
type FeatureUpdate = FeatureBase

// FeaturesBulkCreateRequest Inputs for bulk creating a new feature
type FeaturesBulkCreateRequest struct {
	Features *[]FeatureBulkCreate `json:"features,omitempty"`
}

// FeaturesPaginatedList defines model for FeaturesPaginatedList.
type FeaturesPaginatedList struct {
	// Features List of features for the page
	Features  *[]Feature `json:"features,omitempty"`
	NextToken *string    `json:"nextToken,omitempty"`
}

// Field defines model for Field.
type Field struct {
	DisplayValue *string    `json:"displayValue"`
	IsMulti      *bool      `json:"isMulti,omitempty"`
	TextValue    *string    `json:"textValue"`
	Type         *FieldType `json:"type,omitempty"`

	// Value For single link fields, use the id of the item you want to link (eg. "seq_jdf8BV24").
	// For multi-link fields, use an array of ids of the items you want to link (eg. ["seq_jdf8BV24"])
	Value *Field_Value `json:"value"`
}

// FieldValue0 defines model for .
type FieldValue0 = string

// FieldValue1 defines model for .
type FieldValue1 = bool

// FieldValue2 defines model for .
type FieldValue2 = float32

// FieldValue3 defines model for .
type FieldValue3 = map[string]interface{}

// FieldValue4 defines model for .
type FieldValue4 = []string

// Field_Value For single link fields, use the id of the item you want to link (eg. "seq_jdf8BV24").
// For multi-link fields, use an array of ids of the items you want to link (eg. ["seq_jdf8BV24"])
type Field_Value struct {
	union json.RawMessage
}

// FieldAppConfigItem defines model for FieldAppConfigItem.
type FieldAppConfigItem struct {
	ApiURL *string `json:"apiURL,omitempty"`
	App    *struct {
		// Id The id of the Benchling app to which this configuration item belongs
		Id *string `json:"id,omitempty"`
	} `json:"app,omitempty"`

	// CreatedAt DateTime the app config item was created
	CreatedAt      *time.Time               `json:"createdAt,omitempty"`
	Description    *string                  `json:"description,omitempty"`
	Id             *string                  `json:"id,omitempty"`
	LinkedResource *LinkedAppConfigResource `json:"linkedResource"`

	// ModifiedAt DateTime the app config item was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path           *[]string               `json:"path,omitempty"`
	RequiredConfig *bool                   `json:"requiredConfig,omitempty"`
	Type           *FieldAppConfigItemType `json:"type,omitempty"`
	Value          *string                 `json:"value"`
}

// FieldAppConfigItemType defines model for FieldAppConfigItem.Type.
type FieldAppConfigItemType string

// FieldDefinition defines model for FieldDefinition.
type FieldDefinition struct {
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`
	Id            *string        `json:"id,omitempty"`
	IsMulti       *bool          `json:"isMulti,omitempty"`
	IsRequired    *bool          `json:"isRequired,omitempty"`
	Name          *string        `json:"name,omitempty"`
	Type          *FieldType     `json:"type,omitempty"`
}

// FieldType defines model for FieldType.
type FieldType string

// Fields defines model for Fields.
type Fields map[string]Field

// FindMatchingRegionsAsyncTask defines model for FindMatchingRegionsAsyncTask.
type FindMatchingRegionsAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		AaSequenceMatches *[]struct {
			MatchingAASequenceIds *[]string `json:"matchingAASequenceIds,omitempty"`
			TargetAASequenceId    *string   `json:"targetAASequenceId,omitempty"`
		} `json:"aaSequenceMatches,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status FindMatchingRegionsAsyncTaskStatus `json:"status"`
}

// FindMatchingRegionsAsyncTaskStatus The current state of the task.
type FindMatchingRegionsAsyncTaskStatus string

// FindMatchingRegionsDnaAsyncTask defines model for FindMatchingRegionsDnaAsyncTask.
type FindMatchingRegionsDnaAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		DnaSequenceMatches *[]struct {
			MatchingDnaSequenceIds *[]string `json:"matchingDnaSequenceIds,omitempty"`
			TargetDnaSequenceId    *string   `json:"targetDnaSequenceId,omitempty"`
		} `json:"dnaSequenceMatches,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status FindMatchingRegionsDnaAsyncTaskStatus `json:"status"`
}

// FindMatchingRegionsDnaAsyncTaskStatus The current state of the task.
type FindMatchingRegionsDnaAsyncTaskStatus string

// FloatAppConfigItem defines model for FloatAppConfigItem.
type FloatAppConfigItem struct {
	ApiURL *string `json:"apiURL,omitempty"`
	App    *struct {
		// Id The id of the Benchling app to which this configuration item belongs
		Id *string `json:"id,omitempty"`
	} `json:"app,omitempty"`

	// CreatedAt DateTime the app config item was created
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	Description *string    `json:"description,omitempty"`
	Id          *string    `json:"id,omitempty"`

	// ModifiedAt DateTime the app config item was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path           *[]string               `json:"path,omitempty"`
	RequiredConfig *bool                   `json:"requiredConfig,omitempty"`
	Type           *FloatAppConfigItemType `json:"type,omitempty"`
	Value          *float32                `json:"value"`
}

// FloatAppConfigItemType defines model for FloatAppConfigItem.Type.
type FloatAppConfigItemType string

// FloatFieldDefinition defines model for FloatFieldDefinition.
type FloatFieldDefinition struct {
	ArchiveRecord       *ArchiveRecord            `json:"archiveRecord"`
	DecimalPrecision    *float32                  `json:"decimalPrecision"`
	Id                  *string                   `json:"id,omitempty"`
	IsMulti             *bool                     `json:"isMulti,omitempty"`
	IsRequired          *bool                     `json:"isRequired,omitempty"`
	LegalTextDropdownId *string                   `json:"legalTextDropdownId"`
	Name                *string                   `json:"name,omitempty"`
	NumericMax          *float32                  `json:"numericMax"`
	NumericMin          *float32                  `json:"numericMin"`
	Type                *FloatFieldDefinitionType `json:"type,omitempty"`
	Unit                *UnitSummary              `json:"unit"`
}

// FloatFieldDefinitionType defines model for FloatFieldDefinition.Type.
type FloatFieldDefinitionType string

// Folder defines model for Folder.
type Folder struct {
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`
	Id            *string        `json:"id,omitempty"`
	Name          *string        `json:"name,omitempty"`

	// ParentFolderId ID of the parent folder, if it exists
	ParentFolderId *string `json:"parentFolderId"`

	// ProjectId ID of the containing project
	ProjectId *string `json:"projectId,omitempty"`
}

// FolderCreate defines model for FolderCreate.
type FolderCreate struct {
	// Name The name of the new folder.
	Name string `json:"name"`

	// ParentFolderId The ID of the parent folder.
	ParentFolderId string `json:"parentFolderId"`
}

// FoldersArchivalChange IDs of all items that were archived or unarchived, grouped by resource type. This includes the IDs of folders along with any IDs of folder contents that were unarchived.
type FoldersArchivalChange struct {
	AaSequenceIds   *[]string `json:"aaSequenceIds,omitempty"`
	CustomEntityIds *[]string `json:"customEntityIds,omitempty"`
	DnaSequenceIds  *[]string `json:"dnaSequenceIds,omitempty"`
	EntryIds        *[]string `json:"entryIds,omitempty"`
	FolderIds       *[]string `json:"folderIds,omitempty"`
	MixtureIds      *[]string `json:"mixtureIds,omitempty"`
	OligoIds        *[]string `json:"oligoIds,omitempty"`
	ProtocolIds     *[]string `json:"protocolIds,omitempty"`
}

// FoldersArchive defines model for FoldersArchive.
type FoldersArchive struct {
	// FolderIds A list of folder IDs to archive.
	FolderIds []string `json:"folderIds"`

	// Reason The reason for archiving the provided folders. Accepted reasons may differ based on tenant configuration.
	Reason FoldersArchiveReason `json:"reason"`
}

// FoldersArchiveReason The reason for archiving the provided folders. Accepted reasons may differ based on tenant configuration.
type FoldersArchiveReason string

// FoldersPaginatedList defines model for FoldersPaginatedList.
type FoldersPaginatedList struct {
	Folders   *[]Folder `json:"folders,omitempty"`
	NextToken *string   `json:"nextToken,omitempty"`
}

// FoldersUnarchive defines model for FoldersUnarchive.
type FoldersUnarchive struct {
	// FolderIds A list of folder IDs to unarchive.
	FolderIds []string `json:"folderIds"`
}

// ForbiddenError defines model for ForbiddenError.
type ForbiddenError struct {
	Error *struct {
		InvalidId   *string `json:"invalidId,omitempty"`
		Message     *string `json:"message,omitempty"`
		Type        *string `json:"type,omitempty"`
		UserMessage *string `json:"userMessage,omitempty"`
	} `json:"error,omitempty"`
}

// ForbiddenRestrictedSampleError defines model for ForbiddenRestrictedSampleError.
type ForbiddenRestrictedSampleError struct {
	Error *struct {
		InvalidIds  *[]string                                `json:"invalidIds,omitempty"`
		Message     *string                                  `json:"message,omitempty"`
		Type        *ForbiddenRestrictedSampleErrorErrorType `json:"type,omitempty"`
		UserMessage *string                                  `json:"userMessage,omitempty"`
	} `json:"error,omitempty"`
}

// ForbiddenRestrictedSampleErrorErrorType defines model for ForbiddenRestrictedSampleError.Error.Type.
type ForbiddenRestrictedSampleErrorErrorType string

// GenericApiIdentifiedAppConfigItem defines model for GenericApiIdentifiedAppConfigItem.
type GenericApiIdentifiedAppConfigItem struct {
	ApiURL *string `json:"apiURL,omitempty"`
	App    *struct {
		// Id The id of the Benchling app to which this configuration item belongs
		Id *string `json:"id,omitempty"`
	} `json:"app,omitempty"`

	// CreatedAt DateTime the app config item was created
	CreatedAt      *time.Time               `json:"createdAt,omitempty"`
	Description    *string                  `json:"description,omitempty"`
	Id             *string                  `json:"id,omitempty"`
	LinkedResource *LinkedAppConfigResource `json:"linkedResource"`

	// ModifiedAt DateTime the app config item was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path           *[]string                              `json:"path,omitempty"`
	RequiredConfig *bool                                  `json:"requiredConfig,omitempty"`
	Type           *GenericApiIdentifiedAppConfigItemType `json:"type,omitempty"`
	Value          *string                                `json:"value"`
}

// GenericApiIdentifiedAppConfigItemType defines model for GenericApiIdentifiedAppConfigItem.Type.
type GenericApiIdentifiedAppConfigItemType string

// GenericEntity defines model for GenericEntity.
type GenericEntity struct {
	Aliases       *[]string      `json:"aliases,omitempty"`
	ApiURL        *string        `json:"apiURL,omitempty"`
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`

	// Authors Array of UserSummary Resources of the authors of the entry. This defaults to the creator but can be manually changed.
	Authors   *[]UserSummary `json:"authors,omitempty"`
	CreatedAt *time.Time     `json:"createdAt,omitempty"`

	// Creator UserSummary of the user who created the request
	Creator            *UserSummary        `json:"creator,omitempty"`
	CustomFields       *CustomFields       `json:"customFields,omitempty"`
	EntityRegistryId   *string             `json:"entityRegistryId"`
	Fields             *Fields             `json:"fields,omitempty"`
	FolderId           *string             `json:"folderId,omitempty"`
	Id                 *string             `json:"id,omitempty"`
	ModifiedAt         *time.Time          `json:"modifiedAt,omitempty"`
	Name               *string             `json:"name,omitempty"`
	RegistrationOrigin *RegistrationOrigin `json:"registrationOrigin"`
	RegistryId         *string             `json:"registryId"`
	Schema             *SchemaSummary      `json:"schema"`
	WebURL             *string             `json:"webURL,omitempty"`
}

// InaccessibleResource defines model for InaccessibleResource.
type InaccessibleResource struct {
	InaccessibleId *string                           `json:"inaccessibleId,omitempty"`
	ResourceType   *InaccessibleResourceResourceType `json:"resourceType,omitempty"`

	// Type The type of this inaccessible item. Example values: "custom_entity", "container", "plate", "dna_sequence"
	Type *string `json:"type,omitempty"`
}

// InaccessibleResourceResourceType defines model for InaccessibleResource.ResourceType.
type InaccessibleResourceResourceType string

// Ingredient defines model for Ingredient.
type Ingredient struct {
	// Amount The amount value of this ingredient in its mixture, in string format (to preserve full precision). Pair with `units`. Supports scientific notation (1.23e4). One ingredient on this mixture can have an amount value of `"QS"`.
	Amount            *string `json:"amount"`
	CatalogIdentifier *string `json:"catalogIdentifier"`
	ComponentEntity   *struct {
		EntityRegistryId *string `json:"entityRegistryId"`
		Id               *string `json:"id,omitempty"`
		Name             *string `json:"name,omitempty"`
	} `json:"componentEntity,omitempty"`

	// ComponentLotContainer The container representing the component lot for this ingredient. This is only present if the mixture schema supports component lots in "inventory" format.
	ComponentLotContainer *ContainerLabels `json:"componentLotContainer"`

	// ComponentLotEntity The entity representing the component lot for this ingredient. This is only present if the mixture schema supports component lots in "inventory" format.
	ComponentLotEntity *EntityLabels `json:"componentLotEntity"`

	// ComponentLotText Text representing the component lot for this ingredient. This is only present if the mixture schema supports component lots in "text" format.
	ComponentLotText *string `json:"componentLotText"`
	HasParent        *bool   `json:"hasParent,omitempty"`
	Notes            *string `json:"notes"`

	// TargetAmount The target amount for this ingredient such that this ingredient's proportion in its mixture would preserve the equivalent ingredient's proportion in the parent mixture. Pair with `units`.
	TargetAmount *string                     `json:"targetAmount"`
	Units        *IngredientMeasurementUnits `json:"units"`
}

// IngredientMeasurementUnits defines model for IngredientMeasurementUnits.
type IngredientMeasurementUnits string

// IngredientWriteParams defines model for IngredientWriteParams.
type IngredientWriteParams struct {
	// Amount The amount value of this ingredient in its mixture, in string format (to preserve full precision). Pair with `units`. Supports scientific notation (1.23e4). One ingredient on this mixture can have an amount value of `"QS"`.
	Amount            *string `json:"amount"`
	CatalogIdentifier *string `json:"catalogIdentifier"`

	// ComponentEntityId The entity that uniquely identifies this component.
	ComponentEntityId string `json:"componentEntityId"`

	// ComponentLotContainerId The container representing the component lot for this ingredient. This is only writable if the mixture schema supports component lots in "inventory" format.
	ComponentLotContainerId *string `json:"componentLotContainerId"`

	// ComponentLotEntityId The entity representing the component lot for this ingredient. This is only writable if the mixture schema supports component lots in "inventory" format.
	ComponentLotEntityId *string `json:"componentLotEntityId"`

	// ComponentLotText Text representing the component lot for this ingredient. This is only writable if the mixture schema supports component lots in "text" format.
	ComponentLotText *string                     `json:"componentLotText"`
	Notes            *string                     `json:"notes"`
	Units            *IngredientMeasurementUnits `json:"units"`
}

// InitialTable defines model for InitialTable.
type InitialTable struct {
	// CsvData blobId of an uploaded csv blob. The CSV should be formatted with column headers of `columnId` which can be found in the [EntryTemplate](#/components/schemas/EntryTemplate). For more information on uploading a blob, [click here](https://docs.benchling.com/docs/uploading-a-blob-to-benchling).
	CsvData *string `json:"csvData,omitempty"`

	// TemplateTableID Template table API ID
	TemplateTableID *string `json:"templateTableID,omitempty"`
}

// IntegerAppConfigItem defines model for IntegerAppConfigItem.
type IntegerAppConfigItem struct {
	ApiURL *string `json:"apiURL,omitempty"`
	App    *struct {
		// Id The id of the Benchling app to which this configuration item belongs
		Id *string `json:"id,omitempty"`
	} `json:"app,omitempty"`

	// CreatedAt DateTime the app config item was created
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	Description *string    `json:"description,omitempty"`
	Id          *string    `json:"id,omitempty"`

	// ModifiedAt DateTime the app config item was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path           *[]string                 `json:"path,omitempty"`
	RequiredConfig *bool                     `json:"requiredConfig,omitempty"`
	Type           *IntegerAppConfigItemType `json:"type,omitempty"`
	Value          *int                      `json:"value"`
}

// IntegerAppConfigItemType defines model for IntegerAppConfigItem.Type.
type IntegerAppConfigItemType string

// IntegerFieldDefinition defines model for IntegerFieldDefinition.
type IntegerFieldDefinition struct {
	ArchiveRecord *ArchiveRecord              `json:"archiveRecord"`
	Id            *string                     `json:"id,omitempty"`
	IsMulti       *bool                       `json:"isMulti,omitempty"`
	IsRequired    *bool                       `json:"isRequired,omitempty"`
	Name          *string                     `json:"name,omitempty"`
	NumericMax    *float32                    `json:"numericMax"`
	NumericMin    *float32                    `json:"numericMin"`
	Type          *IntegerFieldDefinitionType `json:"type,omitempty"`
	Unit          *UnitSummary                `json:"unit"`
}

// IntegerFieldDefinitionType defines model for IntegerFieldDefinition.Type.
type IntegerFieldDefinitionType string

// InteractiveUiBlock defines model for InteractiveUiBlock.
type InteractiveUiBlock struct {
	Enabled *bool  `json:"enabled"`
	Id      string `json:"id"`
}

// JsonAppConfigItem defines model for JsonAppConfigItem.
type JsonAppConfigItem struct {
	ApiURL *string `json:"apiURL,omitempty"`
	App    *struct {
		// Id The id of the Benchling app to which this configuration item belongs
		Id *string `json:"id,omitempty"`
	} `json:"app,omitempty"`

	// CreatedAt DateTime the app config item was created
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	Description *string    `json:"description,omitempty"`
	Id          *string    `json:"id,omitempty"`

	// ModifiedAt DateTime the app config item was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path           *[]string              `json:"path,omitempty"`
	RequiredConfig *bool                  `json:"requiredConfig,omitempty"`
	Type           *JsonAppConfigItemType `json:"type,omitempty"`
	Value          *string                `json:"value"`
}

// JsonAppConfigItemType defines model for JsonAppConfigItem.Type.
type JsonAppConfigItemType string

// LabAutomationBenchlingAppError defines model for LabAutomationBenchlingAppError.
type LabAutomationBenchlingAppError struct {
	Message *string `json:"message,omitempty"`
}

// LabAutomationBenchlingAppErrors defines model for LabAutomationBenchlingAppErrors.
type LabAutomationBenchlingAppErrors struct {
	TopLevelErrors *[]struct {
		ErrorMessage *string `json:"errorMessage,omitempty"`
	} `json:"topLevelErrors,omitempty"`
}

// LabAutomationTransform defines model for LabAutomationTransform.
type LabAutomationTransform struct {
	// ApiURL The canonical url of the transform in the API.
	ApiURL            *string                          `json:"apiURL,omitempty"`
	BlobId            *openapi_types.UUID              `json:"blobId"`
	CustomTransformId *openapi_types.UUID              `json:"customTransformId"`
	Errors            *LabAutomationBenchlingAppErrors `json:"errors,omitempty"`
	Id                *string                          `json:"id,omitempty"`
	InputGeneratorId  *string                          `json:"inputGeneratorId"`

	// ModifiedAt DateTime the transform was last modified.
	ModifiedAt        *time.Time                    `json:"modifiedAt,omitempty"`
	OutputProcessorId *string                       `json:"outputProcessorId"`
	Status            *LabAutomationTransformStatus `json:"status,omitempty"`
}

// LabAutomationTransformStatus defines model for LabAutomationTransform.Status.
type LabAutomationTransformStatus string

// LabAutomationTransformUpdate defines model for LabAutomationTransformUpdate.
type LabAutomationTransformUpdate struct {
	BlobId *openapi_types.UUID               `json:"blobId,omitempty"`
	Errors *[]LabAutomationBenchlingAppError `json:"errors,omitempty"`
}

// LabelTemplate defines model for LabelTemplate.
type LabelTemplate struct {
	// Id ID of the label template.
	Id *string `json:"id,omitempty"`

	// Name Name of the label template.
	Name *string `json:"name,omitempty"`

	// ZplTemplate The ZPL template that will be filled in and sent to a printer.
	ZplTemplate *string `json:"zplTemplate,omitempty"`
}

// LabelTemplatesList defines model for LabelTemplatesList.
type LabelTemplatesList struct {
	LabelTemplates *[]LabelTemplate `json:"labelTemplates,omitempty"`
}

// LegacyWorkflow defines model for LegacyWorkflow.
type LegacyWorkflow struct {
	// CreatedAt DateTime at which the the legacy workflow was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Description Description of the legacy workflow
	Description *string `json:"description"`

	// DisplayId User-friendly ID of the legacy workflow
	DisplayId *string `json:"displayId,omitempty"`

	// Id ID of the legacy workflow
	Id *string `json:"id,omitempty"`

	// Name Name of the legacy workflow
	Name *string `json:"name,omitempty"`

	// ProjectId ID of the project that contains the legacy workflow
	ProjectId *string `json:"projectId,omitempty"`
}

// LegacyWorkflowList defines model for LegacyWorkflowList.
type LegacyWorkflowList struct {
	Workflows *[]LegacyWorkflow `json:"workflows,omitempty"`
}

// LegacyWorkflowPatch defines model for LegacyWorkflowPatch.
type LegacyWorkflowPatch struct {
	// Description Description of the legacy workflow
	Description *string `json:"description,omitempty"`

	// Name Name of the legacy workflow
	Name *string `json:"name,omitempty"`

	// ProjectId ID of the project that contains the legacy workflow
	ProjectId *string `json:"projectId,omitempty"`
}

// LegacyWorkflowSample defines model for LegacyWorkflowSample.
type LegacyWorkflowSample struct {
	// BatchId ID of the batch
	BatchId *string `json:"batchId,omitempty"`

	// ContainerIds Array of IDs of containers
	ContainerIds *[]string `json:"containerIds,omitempty"`

	// CreatedAt DateTime at which the the sample was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id ID of the sample
	Id *string `json:"id,omitempty"`

	// Name Name of the sample
	Name *string `json:"name,omitempty"`
}

// LegacyWorkflowSampleList defines model for LegacyWorkflowSampleList.
type LegacyWorkflowSampleList struct {
	Samples *[]LegacyWorkflowSample `json:"samples,omitempty"`
}

// LegacyWorkflowStage defines model for LegacyWorkflowStage.
type LegacyWorkflowStage struct {
	// CreatedAt DateTime at which the the legacy workflow stage was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id ID of the legacy workflow stage
	Id *string `json:"id,omitempty"`

	// Name Name of the legacy workflow stage
	Name *string `json:"name,omitempty"`
}

// LegacyWorkflowStageList defines model for LegacyWorkflowStageList.
type LegacyWorkflowStageList struct {
	WorkflowStages *[]LegacyWorkflowStage `json:"workflowStages,omitempty"`
}

// LegacyWorkflowStageRun defines model for LegacyWorkflowStageRun.
type LegacyWorkflowStageRun struct {
	// CreatedAt DateTime at which the the legacy workflow stage run was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id ID of the legacy workflow stage run
	Id *string `json:"id,omitempty"`

	// Name Name of the legacy workflow stage run
	Name *string `json:"name,omitempty"`

	// Status Status of the legacy workflow stage run
	Status *LegacyWorkflowStageRunStatus `json:"status,omitempty"`
}

// LegacyWorkflowStageRunStatus Status of the legacy workflow stage run
type LegacyWorkflowStageRunStatus string

// LegacyWorkflowStageRunList defines model for LegacyWorkflowStageRunList.
type LegacyWorkflowStageRunList struct {
	WorkflowStageRuns *[]LegacyWorkflowStageRun `json:"workflowStageRuns,omitempty"`
}

// LinkedAppConfigResource defines model for LinkedAppConfigResource.
type LinkedAppConfigResource struct {
	union json.RawMessage
}

// LinkedAppConfigResourceMixin defines model for LinkedAppConfigResourceMixin.
type LinkedAppConfigResourceMixin struct {
	LinkedResource *LinkedAppConfigResource `json:"linkedResource"`
}

// LinkedAppConfigResourceSummary defines model for LinkedAppConfigResourceSummary.
type LinkedAppConfigResourceSummary struct {
	// Id The API ID of the linked resource
	Id *string `json:"id,omitempty"`

	// Name The name of the resource in Benchling
	Name *string `json:"name,omitempty"`
}

// Location defines model for Location.
type Location struct {
	ArchiveRecord   *ArchiveRecord `json:"archiveRecord"`
	Barcode         *string        `json:"barcode,omitempty"`
	CreatedAt       *string        `json:"createdAt,omitempty"`
	Creator         *UserSummary   `json:"creator,omitempty"`
	Fields          *Fields        `json:"fields,omitempty"`
	Id              *string        `json:"id,omitempty"`
	ModifiedAt      *string        `json:"modifiedAt,omitempty"`
	Name            *string        `json:"name,omitempty"`
	ParentStorageId *string        `json:"parentStorageId"`
	Schema          *SchemaSummary `json:"schema"`
	WebURL          *string        `json:"webURL,omitempty"`
}

// LocationCreate defines model for LocationCreate.
type LocationCreate struct {
	Barcode         *string `json:"barcode,omitempty"`
	Fields          *Fields `json:"fields,omitempty"`
	Name            string  `json:"name"`
	ParentStorageId *string `json:"parentStorageId,omitempty"`
	SchemaId        string  `json:"schemaId"`
}

// LocationSchema defines model for LocationSchema.
type LocationSchema struct {
	ArchiveRecord    *ArchiveRecord                          `json:"archiveRecord"`
	FieldDefinitions *[]LocationSchema_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Id               *string                                 `json:"id,omitempty"`
	Name             *string                                 `json:"name,omitempty"`
	Prefix           *string                                 `json:"prefix,omitempty"`
	RegistryId       *string                                 `json:"registryId,omitempty"`
	Type             *LocationSchemaType                     `json:"type,omitempty"`
}

// LocationSchema_FieldDefinitions_Item defines model for LocationSchema.fieldDefinitions.Item.
type LocationSchema_FieldDefinitions_Item struct {
	union json.RawMessage
}

// LocationSchemaType defines model for LocationSchema.Type.
type LocationSchemaType string

// LocationSchemasList defines model for LocationSchemasList.
type LocationSchemasList struct {
	LocationSchemas *[]LocationSchema `json:"locationSchemas,omitempty"`
}

// LocationSchemasPaginatedList defines model for LocationSchemasPaginatedList.
type LocationSchemasPaginatedList struct {
	LocationSchemas *[]LocationSchema `json:"locationSchemas,omitempty"`
	NextToken       *string           `json:"nextToken,omitempty"`
}

// LocationUpdate defines model for LocationUpdate.
type LocationUpdate struct {
	Fields          *Fields `json:"fields,omitempty"`
	Name            *string `json:"name,omitempty"`
	ParentStorageId *string `json:"parentStorageId,omitempty"`
}

// LocationsArchivalChange IDs of all items that were archived or unarchived, grouped by resource type. This includes the IDs of locations along with any IDs of locations, boxes, plates, containers that were archived.
type LocationsArchivalChange struct {
	BoxIds       *[]string `json:"boxIds,omitempty"`
	ContainerIds *[]string `json:"containerIds,omitempty"`
	LocationIds  *[]string `json:"locationIds,omitempty"`
	PlateIds     *[]string `json:"plateIds,omitempty"`
}

// LocationsArchive defines model for LocationsArchive.
type LocationsArchive struct {
	// LocationIds Array of location IDs
	LocationIds []string `json:"locationIds"`

	// Reason Reason that locations are being archived.
	Reason LocationsArchiveReason `json:"reason"`

	// ShouldRemoveBarcodes Remove barcodes. Removing barcodes from archived inventory that contain items will also remove barcodes from the contained items.
	ShouldRemoveBarcodes *bool `json:"shouldRemoveBarcodes,omitempty"`
}

// LocationsArchiveReason Reason that locations are being archived.
type LocationsArchiveReason string

// LocationsBulkGet defines model for LocationsBulkGet.
type LocationsBulkGet struct {
	Locations *[]Location `json:"locations,omitempty"`
}

// LocationsPaginatedList defines model for LocationsPaginatedList.
type LocationsPaginatedList struct {
	Locations *[]Location `json:"locations,omitempty"`
	NextToken *string     `json:"nextToken,omitempty"`
}

// LocationsUnarchive defines model for LocationsUnarchive.
type LocationsUnarchive struct {
	// LocationIds Array of location IDs
	LocationIds []string `json:"locationIds"`
}

// LookupTableNotePart defines model for LookupTableNotePart.
type LookupTableNotePart struct {
	ApiId   *string                      `json:"apiId,omitempty"`
	Columns *[]StructuredTableColumnInfo `json:"columns,omitempty"`
	Type    *LookupTableNotePartType     `json:"type,omitempty"`
}

// LookupTableNotePartType defines model for LookupTableNotePart.Type.
type LookupTableNotePartType string

// MarkdownUiBlock defines model for MarkdownUiBlock.
type MarkdownUiBlock struct {
	Id    *string             `json:"id,omitempty"`
	Type  MarkdownUiBlockType `json:"type"`
	Value string              `json:"value"`
}

// MarkdownUiBlockType defines model for MarkdownUiBlock.Type.
type MarkdownUiBlockType string

// MarkdownUiBlockCreate defines model for MarkdownUiBlockCreate.
type MarkdownUiBlockCreate = MarkdownUiBlock

// MarkdownUiBlockUpdate defines model for MarkdownUiBlockUpdate.
type MarkdownUiBlockUpdate = MarkdownUiBlock

// MatchBasesRequest defines model for MatchBasesRequest.
type MatchBasesRequest struct {
	ArchiveReason *MatchBasesRequestArchiveReason `json:"archiveReason,omitempty"`
	Bases         string                          `json:"bases"`
	NextToken     *string                         `json:"nextToken,omitempty"`
	PageSize      *int                            `json:"pageSize,omitempty"`

	// RegistryId ID of a registry. Restricts results to those registered in this registry. Specifying `null` returns unregistered items.
	RegistryId *string                `json:"registryId"`
	Sort       *MatchBasesRequestSort `json:"sort,omitempty"`
}

// MatchBasesRequestArchiveReason defines model for MatchBasesRequest.ArchiveReason.
type MatchBasesRequestArchiveReason string

// MatchBasesRequestSort defines model for MatchBasesRequest.Sort.
type MatchBasesRequestSort string

// Measurement defines model for Measurement.
type Measurement struct {
	// Units Can only be null if value is also null
	Units *string `json:"units"`

	// Value Can only be null if units is also null
	Value *float32 `json:"value"`
}

// Mixture defines model for Mixture.
type Mixture struct {
	Aliases *[]string `json:"aliases,omitempty"`

	// AllowMeasuredIngredients Derived from the mixture's schema.
	AllowMeasuredIngredients *bool `json:"allowMeasuredIngredients,omitempty"`

	// Amount The positive numerical amount value of this mixture in string format (to preserve full precision). Pair with `units`. Supports scientific notation (1.23e4).
	Amount *string `json:"amount,omitempty"`

	// ApiURL The canonical url of the Mixture in the API.
	ApiURL           *string        `json:"apiURL,omitempty"`
	ArchiveRecord    *ArchiveRecord `json:"archiveRecord"`
	Authors          *[]UserSummary `json:"authors,omitempty"`
	CreatedAt        *time.Time     `json:"createdAt,omitempty"`
	Creator          *UserSummary   `json:"creator,omitempty"`
	CustomFields     *CustomFields  `json:"customFields,omitempty"`
	EntityRegistryId *string        `json:"entityRegistryId"`

	// Fields Mixtures can have up to one parent mixture field.
	Fields   *Fields `json:"fields,omitempty"`
	FolderId *string `json:"folderId"`
	Id       *string `json:"id,omitempty"`

	// Ingredients List of ingredients on this mixture.
	Ingredients        *[]Ingredient            `json:"ingredients,omitempty"`
	ModifiedAt         *time.Time               `json:"modifiedAt,omitempty"`
	Name               *string                  `json:"name,omitempty"`
	RegistrationOrigin *RegistrationOrigin      `json:"registrationOrigin"`
	RegistryId         *string                  `json:"registryId"`
	Schema             *SchemaSummary           `json:"schema,omitempty"`
	Units              *MixtureMeasurementUnits `json:"units"`
	WebURL             *string                  `json:"webURL,omitempty"`
}

// MixtureBulkUpdate defines model for MixtureBulkUpdate.
type MixtureBulkUpdate struct {
	// Aliases Aliases to add to the mixture
	Aliases *[]string `json:"aliases,omitempty"`

	// Amount The positive numerical amount value of this mixture in string format (to preserve full precision). Pair with `units`. Supports scientific notation (1.23e4).
	Amount *string `json:"amount,omitempty"`

	// AuthorIds IDs of users to set as the mixture's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// CustomFields Custom fields to add to the mixture. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields     *CustomFields `json:"customFields,omitempty"`
	EntityRegistryId *string       `json:"entityRegistryId,omitempty"`

	// Fields Schema fields to set on the mixture. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	// If you are setting the parent mixture field here, you must also specify `ingredients`
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder that the entity is moved into
	FolderId *string `json:"folderId,omitempty"`
	Id       string  `json:"id"`

	// Ingredients Desired final state for the ingredients on this mixture.
	// Each ingredient you specify will be matched with the existing ingredients on the mixture based on the component entity, and Benchling will create, update, or delete this mixture's ingredients so that the final state of this mixture's ingredients matches your request.
	// Benchling will recognize that any ingredients you specify that match ingredients on the parent mixture (based on component entity) are inherited. This can be seen on the returned `ingredients[i].hasParent` attribute.
	Ingredients *[]IngredientWriteParams `json:"ingredients,omitempty"`
	Name        *string                  `json:"name,omitempty"`
	SchemaId    *string                  `json:"schemaId,omitempty"`
	Units       *MixtureMeasurementUnits `json:"units"`
}

// MixtureCreate defines model for MixtureCreate.
type MixtureCreate struct {
	// Aliases Aliases to add to the mixture
	Aliases *[]string `json:"aliases,omitempty"`

	// Amount The positive numerical amount value of this mixture in string format (to preserve full precision). Pair with `units`. Supports scientific notation (1.23e4).
	Amount *string `json:"amount,omitempty"`

	// AuthorIds IDs of users to set as the mixture's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// CustomFields Custom fields to add to the mixture. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// EntityRegistryId Entity registry ID to set for the registered entity. Cannot specify both entityRegistryId and namingStrategy at the same time.
	EntityRegistryId *string `json:"entityRegistryId,omitempty"`

	// Fields Schema fields to set on the mixture. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	// If you are setting the parent mixture field here, you must also specify `ingredients`
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the entity. Can be left empty when registryId is present.
	FolderId *string `json:"folderId,omitempty"`

	// Ingredients Desired final state for the ingredients on this mixture.
	// Each ingredient you specify will be matched with the existing ingredients on the mixture based on the component entity, and Benchling will create, update, or delete this mixture's ingredients so that the final state of this mixture's ingredients matches your request.
	// Benchling will recognize that any ingredients you specify that match ingredients on the parent mixture (based on component entity) are inherited. This can be seen on the returned `ingredients[i].hasParent` attribute.
	Ingredients []IngredientWriteParams `json:"ingredients"`
	Name        string                  `json:"name"`

	// NamingStrategy Specifies the behavior for automatically generated names when registering an entity.
	// - NEW_IDS: Generate new registry IDs
	// - IDS_FROM_NAMES: Generate registry IDs based on entity names
	// - DELETE_NAMES: Generate new registry IDs and replace name with registry ID
	// - SET_FROM_NAME_PARTS: Generate new registry IDs, rename according to name template, and keep old name as alias
	// - REPLACE_NAMES_FROM_PARTS: Generate new registry IDs, and replace name according to name template
	// - KEEP_NAMES: Keep existing entity names as registry IDs
	// - REPLACE_ID_AND_NAME_FROM_PARTS: Generate registry IDs and names according to name template
	NamingStrategy *NamingStrategy `json:"namingStrategy,omitempty"`

	// RegistryId Registry ID into which entity should be registered. this is the ID of the registry which was configured for a particular organization
	// To get available registryIds, use the [/registries endpoint](#/Registry/listRegistries)
	//
	// Required in order for entities to be created directly in the registry.
	RegistryId *string                  `json:"registryId,omitempty"`
	SchemaId   string                   `json:"schemaId"`
	Units      *MixtureMeasurementUnits `json:"units"`
}

// MixtureMeasurementUnits defines model for MixtureMeasurementUnits.
type MixtureMeasurementUnits string

// MixturePrepTableNotePart defines model for MixturePrepTableNotePart.
type MixturePrepTableNotePart struct {
	ApiId   *string                      `json:"apiId,omitempty"`
	Columns *[]StructuredTableColumnInfo `json:"columns,omitempty"`

	// Indentation All notes have an indentation level - the default is 0 for no indent. For lists, indentation gives notes hierarchy - a bulleted list with children is modeled as one note part with indentation 1 followed by note parts with indentation 2, for example.
	Indentation     *int                          `json:"indentation,omitempty"`
	MixtureSchemaId *string                       `json:"mixtureSchemaId,omitempty"`
	Type            *MixturePrepTableNotePartType `json:"type,omitempty"`
}

// MixturePrepTableNotePartType defines model for MixturePrepTableNotePart.Type.
type MixturePrepTableNotePartType string

// MixtureUpdate defines model for MixtureUpdate.
type MixtureUpdate struct {
	// Aliases Aliases to add to the mixture
	Aliases *[]string `json:"aliases,omitempty"`

	// Amount The positive numerical amount value of this mixture in string format (to preserve full precision). Pair with `units`. Supports scientific notation (1.23e4).
	Amount *string `json:"amount,omitempty"`

	// AuthorIds IDs of users to set as the mixture's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// CustomFields Custom fields to add to the mixture. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields     *CustomFields `json:"customFields,omitempty"`
	EntityRegistryId *string       `json:"entityRegistryId,omitempty"`

	// Fields Schema fields to set on the mixture. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	// If you are setting the parent mixture field here, you must also specify `ingredients`
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder that the entity is moved into
	FolderId *string `json:"folderId,omitempty"`

	// Ingredients Desired final state for the ingredients on this mixture.
	// Each ingredient you specify will be matched with the existing ingredients on the mixture based on the component entity, and Benchling will create, update, or delete this mixture's ingredients so that the final state of this mixture's ingredients matches your request.
	// Benchling will recognize that any ingredients you specify that match ingredients on the parent mixture (based on component entity) are inherited. This can be seen on the returned `ingredients[i].hasParent` attribute.
	Ingredients *[]IngredientWriteParams `json:"ingredients,omitempty"`
	Name        *string                  `json:"name,omitempty"`
	SchemaId    *string                  `json:"schemaId,omitempty"`
	Units       *MixtureMeasurementUnits `json:"units"`
}

// MixtureWithEntityType defines model for MixtureWithEntityType.
type MixtureWithEntityType struct {
	Aliases *[]string `json:"aliases,omitempty"`

	// AllowMeasuredIngredients Derived from the mixture's schema.
	AllowMeasuredIngredients *bool `json:"allowMeasuredIngredients,omitempty"`

	// Amount The positive numerical amount value of this mixture in string format (to preserve full precision). Pair with `units`. Supports scientific notation (1.23e4).
	Amount *string `json:"amount,omitempty"`

	// ApiURL The canonical url of the Mixture in the API.
	ApiURL           *string                          `json:"apiURL,omitempty"`
	ArchiveRecord    *ArchiveRecord                   `json:"archiveRecord"`
	Authors          *[]UserSummary                   `json:"authors,omitempty"`
	CreatedAt        *time.Time                       `json:"createdAt,omitempty"`
	Creator          *UserSummary                     `json:"creator,omitempty"`
	CustomFields     *CustomFields                    `json:"customFields,omitempty"`
	EntityRegistryId *string                          `json:"entityRegistryId"`
	EntityType       *MixtureWithEntityTypeEntityType `json:"entityType,omitempty"`

	// Fields Mixtures can have up to one parent mixture field.
	Fields   *Fields `json:"fields,omitempty"`
	FolderId *string `json:"folderId"`
	Id       *string `json:"id,omitempty"`

	// Ingredients List of ingredients on this mixture.
	Ingredients        *[]Ingredient            `json:"ingredients,omitempty"`
	ModifiedAt         *time.Time               `json:"modifiedAt,omitempty"`
	Name               *string                  `json:"name,omitempty"`
	RegistrationOrigin *RegistrationOrigin      `json:"registrationOrigin"`
	RegistryId         *string                  `json:"registryId"`
	Schema             *SchemaSummary           `json:"schema,omitempty"`
	Units              *MixtureMeasurementUnits `json:"units"`
	WebURL             *string                  `json:"webURL,omitempty"`
}

// MixtureWithEntityTypeEntityType defines model for MixtureWithEntityType.EntityType.
type MixtureWithEntityTypeEntityType string

// MixturesArchivalChange IDs of all mixtures that were archived or unarchived.
type MixturesArchivalChange struct {
	MixtureIds *[]string `json:"mixtureIds,omitempty"`
}

// MixturesArchive The request body for archiving mixtures.
type MixturesArchive struct {
	MixtureIds []string `json:"mixtureIds"`

	// Reason The reason for archiving the provided entities. Accepted reasons may differ based on tenant configuration.
	Reason EntityArchiveReason `json:"reason"`
}

// MixturesBulkCreateRequest defines model for MixturesBulkCreateRequest.
type MixturesBulkCreateRequest struct {
	Mixtures []MixtureCreate `json:"mixtures"`
}

// MixturesBulkUpdateRequest defines model for MixturesBulkUpdateRequest.
type MixturesBulkUpdateRequest struct {
	Mixtures *[]MixtureBulkUpdate `json:"mixtures,omitempty"`
}

// MixturesPaginatedList defines model for MixturesPaginatedList.
type MixturesPaginatedList struct {
	Mixtures  *[]Mixture `json:"mixtures,omitempty"`
	NextToken *string    `json:"nextToken,omitempty"`
}

// MixturesUnarchive The request body for unarchiving mixtures.
type MixturesUnarchive struct {
	MixtureIds []string `json:"mixtureIds"`
}

// Molecule defines model for Molecule.
type Molecule struct {
	// Aliases Array of aliases.
	Aliases *[]string `json:"aliases,omitempty"`

	// ApiURL The canonical url of the Molecule in the API.
	ApiURL        *string        `json:"apiURL,omitempty"`
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`

	// CanonicalizedSmiles The canonicalized chemical structure in SMILES format.
	CanonicalizedSmiles *string `json:"canonicalizedSmiles,omitempty"`

	// CreatedAt DateTime the Molecule was created.
	CreatedAt *time.Time   `json:"createdAt,omitempty"`
	Creator   *UserSummary `json:"creator,omitempty"`

	// CustomFields Custom fields set on the Molecule.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// EntityRegistryId Registry ID of the Molecule if registered.
	EntityRegistryId *string `json:"entityRegistryId"`
	Fields           *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder that contains the Molecule.
	FolderId *string `json:"folderId,omitempty"`

	// Id ID of the Molecule.
	Id *string `json:"id,omitempty"`

	// ModifiedAt DateTime the Molecule was last modified.
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Name Name of the Molecule.
	Name *string `json:"name,omitempty"`

	// OriginalSmiles The original chemical structure supplied by the user in SMILES format. Null if the user did not originally supply SMILES.
	OriginalSmiles     *string             `json:"originalSmiles"`
	RegistrationOrigin *RegistrationOrigin `json:"registrationOrigin"`

	// RegistryId Registry the Molecule is registered in.
	RegistryId *string        `json:"registryId"`
	Schema     *SchemaSummary `json:"schema"`

	// WebURL URL of the Molecule.
	WebURL *string `json:"webURL,omitempty"`
}

// MoleculeBaseRequest defines model for MoleculeBaseRequest.
type MoleculeBaseRequest struct {
	// Aliases Aliases to add to the Molecule.
	Aliases *[]string `json:"aliases,omitempty"`

	// AuthorIds IDs of users to set as the Molecule's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// ChemicalStructure Chemical structure of the Molecule.
	ChemicalStructure *MoleculeStructure `json:"chemicalStructure,omitempty"`

	// CustomFields Custom fields to add to the Molecule. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// Fields Fields to set on the Molecule. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the Molecule.
	FolderId *string `json:"folderId,omitempty"`

	// Name Name of the Molecule.
	Name *string `json:"name,omitempty"`

	// SchemaId ID of the Molecule's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// MoleculeBaseRequestForCreate defines model for MoleculeBaseRequestForCreate.
type MoleculeBaseRequestForCreate struct {
	// Aliases Aliases to add to the Molecule.
	Aliases *[]string `json:"aliases,omitempty"`

	// AuthorIds IDs of users to set as the Molecule's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// ChemicalStructure Chemical structure of the Molecule.
	ChemicalStructure MoleculeStructure `json:"chemicalStructure"`

	// CustomFields Custom fields to add to the Molecule. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// Fields Fields to set on the Molecule. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the Molecule.
	FolderId *string `json:"folderId,omitempty"`

	// Name Name of the Molecule.
	Name string `json:"name"`

	// SchemaId ID of the Molecule's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// MoleculeBulkUpdate defines model for MoleculeBulkUpdate.
type MoleculeBulkUpdate struct {
	// Aliases Aliases to add to the Molecule.
	Aliases *[]string `json:"aliases,omitempty"`

	// AuthorIds IDs of users to set as the Molecule's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// ChemicalStructure Chemical structure of the Molecule.
	ChemicalStructure *MoleculeStructure `json:"chemicalStructure,omitempty"`

	// CustomFields Custom fields to add to the Molecule. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields     *CustomFields `json:"customFields,omitempty"`
	EntityRegistryId *string       `json:"entityRegistryId,omitempty"`

	// Fields Fields to set on the Molecule. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the Molecule.
	FolderId *string `json:"folderId,omitempty"`
	Id       *string `json:"id,omitempty"`

	// Name Name of the Molecule.
	Name *string `json:"name,omitempty"`

	// SchemaId ID of the Molecule's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// MoleculeCreate defines model for MoleculeCreate.
type MoleculeCreate struct {
	// Aliases Aliases to add to the Molecule.
	Aliases *[]string `json:"aliases,omitempty"`

	// AuthorIds IDs of users to set as the Molecule's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// ChemicalStructure Chemical structure of the Molecule.
	ChemicalStructure MoleculeStructure `json:"chemicalStructure"`

	// CustomFields Custom fields to add to the Molecule. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// EntityRegistryId Entity registry ID to set for the registered entity. Cannot specify both entityRegistryId and namingStrategy at the same time.
	EntityRegistryId *string `json:"entityRegistryId,omitempty"`

	// Fields Fields to set on the Molecule. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the entity. Can be left empty when registryId is present.
	FolderId *string `json:"folderId,omitempty"`

	// Name Name of the Molecule.
	Name string `json:"name"`

	// NamingStrategy Specifies the behavior for automatically generated names when registering an entity.
	// - NEW_IDS: Generate new registry IDs
	// - IDS_FROM_NAMES: Generate registry IDs based on entity names
	// - DELETE_NAMES: Generate new registry IDs and replace name with registry ID
	// - SET_FROM_NAME_PARTS: Generate new registry IDs, rename according to name template, and keep old name as alias
	// - REPLACE_NAMES_FROM_PARTS: Generate new registry IDs, and replace name according to name template
	// - KEEP_NAMES: Keep existing entity names as registry IDs
	// - REPLACE_ID_AND_NAME_FROM_PARTS: Generate registry IDs and names according to name template
	NamingStrategy *NamingStrategy `json:"namingStrategy,omitempty"`

	// RegistryId Registry ID into which entity should be registered. this is the ID of the registry which was configured for a particular organization
	// To get available registryIds, use the [/registries endpoint](#/Registry/listRegistries)
	//
	// Required in order for entities to be created directly in the registry.
	RegistryId *string `json:"registryId,omitempty"`

	// SchemaId ID of the Molecule's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// MoleculeStructure defines model for MoleculeStructure.
type MoleculeStructure struct {
	StructureFormat *interface{} `json:"structureFormat,omitempty"`

	// Value Chemical structure in SMILES or molfile format.
	Value *string `json:"value,omitempty"`
}

// MoleculeUpdate defines model for MoleculeUpdate.
type MoleculeUpdate struct {
	// Aliases Aliases to add to the Molecule.
	Aliases *[]string `json:"aliases,omitempty"`

	// AuthorIds IDs of users to set as the Molecule's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// ChemicalStructure Chemical structure of the Molecule.
	ChemicalStructure *MoleculeStructure `json:"chemicalStructure,omitempty"`

	// CustomFields Custom fields to add to the Molecule. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields     *CustomFields `json:"customFields,omitempty"`
	EntityRegistryId *string       `json:"entityRegistryId,omitempty"`

	// Fields Fields to set on the Molecule. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the Molecule.
	FolderId *string `json:"folderId,omitempty"`

	// Name Name of the Molecule.
	Name *string `json:"name,omitempty"`

	// SchemaId ID of the Molecule's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// MoleculesArchivalChange IDs of all items that were archived or unarchived, grouped by resource type. This includes the IDs of Molecules along with any IDs of batches that were archived / unarchived.
type MoleculesArchivalChange struct {
	BatchIds    *[]string `json:"batchIds,omitempty"`
	MoleculeIds *[]string `json:"moleculeIds,omitempty"`
}

// MoleculesArchive The request body for archiving Molecules.
type MoleculesArchive struct {
	MoleculeIds []string `json:"moleculeIds"`

	// Reason The reason for archiving the provided Molecules. Accepted reasons may differ based on tenant configuration.
	Reason MoleculesArchiveReason `json:"reason"`
}

// MoleculesArchiveReason The reason for archiving the provided Molecules. Accepted reasons may differ based on tenant configuration.
type MoleculesArchiveReason string

// MoleculesBulkCreateRequest defines model for MoleculesBulkCreateRequest.
type MoleculesBulkCreateRequest struct {
	Molecules *[]MoleculeCreate `json:"molecules,omitempty"`
}

// MoleculesBulkUpdateRequest defines model for MoleculesBulkUpdateRequest.
type MoleculesBulkUpdateRequest struct {
	Molecules *[]MoleculeBulkUpdate `json:"molecules,omitempty"`
}

// MoleculesPaginatedList defines model for MoleculesPaginatedList.
type MoleculesPaginatedList struct {
	Molecules *[]Molecule `json:"molecules,omitempty"`
	NextToken *string     `json:"nextToken,omitempty"`
}

// MoleculesUnarchive The request body for unarchiving Molecules.
type MoleculesUnarchive struct {
	MoleculeIds []string `json:"moleculeIds"`
}

// Monomer defines model for Monomer.
type Monomer struct {
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`

	// AttachmentPoints A list of the capping group present at each location where the monomer can form a bond with other monomers
	AttachmentPoints *[]string `json:"attachmentPoints,omitempty"`

	// CalculatedMolecularWeight The molecular weight of the monomer as calculated by RDKit based on the monomer chemical structure
	CalculatedMolecularWeight *float32 `json:"calculatedMolecularWeight,omitempty"`

	// CanonicalSmiles The canonicalized chemical structure in SMILES format.
	CanonicalSmiles *string `json:"canonicalSmiles,omitempty"`

	// CreatedAt DateTime the monomer was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CustomMolecularWeight Optional molecular weight value that the user can provide to override the calculated molecular weight
	CustomMolecularWeight *float32 `json:"customMolecularWeight"`

	// Id ID of the monomer
	Id *string `json:"id,omitempty"`

	// ModifiedAt DateTime the monomer was last modified.
	ModifiedAt  *time.Time   `json:"modifiedAt,omitempty"`
	MonomerType *MonomerType `json:"monomerType,omitempty"`

	// Name Name of the monomer
	Name *string `json:"name,omitempty"`

	// NaturalAnalog Symbol for the natural equivalent of the monomer. Acceptable natural analog values include IUPAC bases, r, and p.
	NaturalAnalog *string             `json:"naturalAnalog,omitempty"`
	PolymerType   *MonomerPolymerType `json:"polymerType,omitempty"`

	// Symbol User-defined identifier of the monomer, unique on the monomer type.
	Symbol *string `json:"symbol,omitempty"`

	// VisualColor The hex color code of the monomer visual symbol
	VisualColor  *string              `json:"visualColor"`
	VisualSymbol *MonomerVisualSymbol `json:"visualSymbol"`
}

// MonomerBaseRequest defines model for MonomerBaseRequest.
type MonomerBaseRequest struct {
	// Color The hex color code of the monomer visual symbol
	Color *string `json:"color"`

	// CustomMolecularWeight Optional molecular weight value that the user can provide to override the calculated molecular weight
	CustomMolecularWeight *float32 `json:"customMolecularWeight"`

	// Name Name of the monomer
	Name *string `json:"name,omitempty"`

	// Smiles The chemical structure in SMILES format.
	Smiles *string `json:"smiles,omitempty"`

	// Symbol User-defined identifier of the monomer, unique on the monomer type.
	Symbol       *string              `json:"symbol,omitempty"`
	VisualSymbol *MonomerVisualSymbol `json:"visualSymbol,omitempty"`
}

// MonomerCreate defines model for MonomerCreate.
type MonomerCreate struct {
	// Color The hex color code of the monomer visual symbol
	Color *string `json:"color"`

	// CustomMolecularWeight Optional molecular weight value that the user can provide to override the calculated molecular weight
	CustomMolecularWeight *float32 `json:"customMolecularWeight"`

	// Name Name of the monomer
	Name string `json:"name"`

	// NaturalAnalog Symbol for the natural equivalent of the monomer. Acceptable natural analog values include IUPAC bases, r, and p.
	NaturalAnalog string `json:"naturalAnalog"`

	// Smiles The chemical structure in SMILES format.
	Smiles string `json:"smiles"`

	// Symbol User-defined identifier of the monomer, unique on the monomer type.
	Symbol       string               `json:"symbol"`
	VisualSymbol *MonomerVisualSymbol `json:"visualSymbol,omitempty"`
}

// MonomerPolymerType The polymer type of the monomer. Currently only RNA monomers are supported.
type MonomerPolymerType string

// MonomerType The part of the nucleotide structure that the monomer fits into, i.e. backbone or branch
type MonomerType string

// MonomerUpdate defines model for MonomerUpdate.
type MonomerUpdate = MonomerBaseRequest

// MonomerVisualSymbol The shape of the monomer visual symbol.
type MonomerVisualSymbol string

// MonomersArchivalChange IDs of all items that were archived or unarchived, grouped by resource type.
type MonomersArchivalChange struct {
	BatchIds   *[]string `json:"batchIds,omitempty"`
	MonomerIds *[]string `json:"monomerIds,omitempty"`
}

// MonomersArchive The request body for archiving Monomers.
type MonomersArchive struct {
	MonomerIds []string `json:"monomerIds"`

	// Reason The reason for archiving the provided Monomers. Accepted reasons may differ based on tenant configuration.
	Reason MonomersArchiveReason `json:"reason"`
}

// MonomersArchiveReason The reason for archiving the provided Monomers. Accepted reasons may differ based on tenant configuration.
type MonomersArchiveReason string

// MonomersPaginatedList defines model for MonomersPaginatedList.
type MonomersPaginatedList struct {
	Monomers  *[]Monomer `json:"monomers,omitempty"`
	NextToken *string    `json:"nextToken,omitempty"`
}

// MonomersUnarchive The request body for unarchiving Monomers.
type MonomersUnarchive struct {
	MonomerIds []string `json:"monomerIds"`
}

// MultipleContainersTransfer defines model for MultipleContainersTransfer.
type MultipleContainersTransfer struct {
	// DestinationContainerId ID of container that will be transferred into.
	DestinationContainerId string `json:"destinationContainerId"`

	// FinalQuantity Quantity of a container, well, or transfer. Supports mass, volume, and other quantities.
	FinalQuantity *ContainerQuantity `json:"finalQuantity,omitempty"`

	// FinalVolume Desired volume for a container, well, or transfer. "volume" type keys are deprecated in API requests; use the more permissive "quantity" type key instead.
	FinalVolume *DeprecatedContainerVolumeForInput `json:"finalVolume,omitempty"`

	// RestrictedSamplePartyIds IDs of users or teams to be set as restricted sample parties for the destination container. If not specified, restricted sample parties from the source container, if present, will be added to those of the destination container. This only applies to stand-alone containers.
	RestrictedSamplePartyIds *[]string `json:"restrictedSamplePartyIds,omitempty"`

	// RestrictionStatus Restriction status of the destination container, either RESTRICTED or UNRESTRICTED. If not specified, the restriction status of the destination container will be the more restrictive of the source container, if present, and destination container restriction statuses. This only applies to stand-alone containers (Plate wells are always set to NOT_APPLICABLE).
	RestrictionStatus *SampleRestrictionStatus `json:"restrictionStatus,omitempty"`

	// SampleOwnerIds IDs of users or teams to be set as sample owners for the destination container. If not specified, restricted sample parties from the source container, if present, will be added to those of the destination container. This only applies to stand-alone containers.
	SampleOwnerIds *[]string `json:"sampleOwnerIds,omitempty"`

	// SourceBatchId ID of the batch that will be transferred in. Must specify one of sourceEntityId, sourceBatchId, or sourceContainerId.
	SourceBatchId *string `json:"sourceBatchId,omitempty"`

	// SourceConcentration Concentration at which to transfer entities or batches. Not applicable for container-to-container transfers (the concentration of the source container’s contents will be used).
	SourceConcentration *map[string]interface{} `json:"sourceConcentration,omitempty"`

	// SourceContainerId ID of the container that will be transferred in. Must specify one of sourceEntityId, sourceBatchId, or sourceContainerId.
	SourceContainerId *string `json:"sourceContainerId,omitempty"`

	// SourceEntityId ID of the entity that will be transferred in. Must specify one of sourceEntityId, sourceBatchId, or sourceContainerId.
	SourceEntityId *string `json:"sourceEntityId,omitempty"`

	// TransferQuantity This represents the quantity of the source to be transferred into the destination container. Supports mass, volume, and other quantities. Required in place of transferVolume.
	TransferQuantity *ContainerQuantity `json:"transferQuantity,omitempty"`

	// TransferVolume Deprecated - use transferQuantity instead.
	TransferVolume *DeprecatedContainerVolumeForInput `json:"transferVolume,omitempty"`
}

// MultipleContainersTransfersList defines model for MultipleContainersTransfersList.
type MultipleContainersTransfersList struct {
	Transfers []MultipleContainersTransfer `json:"transfers"`
}

// NamingStrategy Specifies the behavior for automatically generated names when registering an entity.
// - NEW_IDS: Generate new registry IDs
// - IDS_FROM_NAMES: Generate registry IDs based on entity names
// - DELETE_NAMES: Generate new registry IDs and replace name with registry ID
// - SET_FROM_NAME_PARTS: Generate new registry IDs, rename according to name template, and keep old name as alias
// - REPLACE_NAMES_FROM_PARTS: Generate new registry IDs, and replace name according to name template
// - KEEP_NAMES: Keep existing entity names as registry IDs
// - REPLACE_ID_AND_NAME_FROM_PARTS: Generate registry IDs and names according to name template
type NamingStrategy string

// NotFoundError defines model for NotFoundError.
type NotFoundError struct {
	Error *struct {
		InvalidId   *string                 `json:"invalidId,omitempty"`
		Message     *string                 `json:"message,omitempty"`
		Type        *NotFoundErrorErrorType `json:"type,omitempty"`
		UserMessage *string                 `json:"userMessage,omitempty"`
	} `json:"error,omitempty"`
}

// NotFoundErrorErrorType defines model for NotFoundError.Error.Type.
type NotFoundErrorErrorType string

// NucleotideAlignment defines model for NucleotideAlignment.
type NucleotideAlignment struct {
	AlignedSequences *[]AlignedNucleotideSequence `json:"alignedSequences,omitempty"`

	// ApiURL The canonical url of the Alignment in the API.
	ApiURL *string `json:"apiURL,omitempty"`

	// CreatedAt DateTime the Alignment was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	Id        *string    `json:"id,omitempty"`

	// ModifiedAt DateTime the Alignment was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`
	Name       *string    `json:"name,omitempty"`

	// ReferenceSequenceId The ID of the template or consensus Sequence associated with the Alignment
	ReferenceSequenceId *string `json:"referenceSequenceId,omitempty"`

	// WebURL The Benchling web UI url to view the Alignment
	WebURL *string `json:"webURL,omitempty"`
}

// NucleotideAlignmentBase defines model for NucleotideAlignmentBase.
type NucleotideAlignmentBase struct {
	Algorithm NucleotideAlignmentBaseAlgorithm     `json:"algorithm"`
	Files     []NucleotideAlignmentBase_Files_Item `json:"files"`
	Name      *string                              `json:"name,omitempty"`
}

// NucleotideAlignmentBaseAlgorithm defines model for NucleotideAlignmentBase.Algorithm.
type NucleotideAlignmentBaseAlgorithm string

// NucleotideAlignmentBaseFiles0 defines model for .
type NucleotideAlignmentBaseFiles0 struct {
	SequenceId *string `json:"sequenceId,omitempty"`
}

// NucleotideAlignmentBase_Files_Item defines model for NucleotideAlignmentBase.files.Item.
type NucleotideAlignmentBase_Files_Item struct {
	union json.RawMessage
}

// NucleotideAlignmentFile defines model for NucleotideAlignmentFile.
type NucleotideAlignmentFile struct {
	Data *[]byte `json:"data,omitempty"`
	Name *string `json:"name,omitempty"`
}

// NucleotideAlignmentSummary defines model for NucleotideAlignmentSummary.
type NucleotideAlignmentSummary struct {
	// ApiURL The canonical url of the Alignment in the API.
	ApiURL *string `json:"apiURL,omitempty"`

	// CreatedAt DateTime the Alignment was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	Id        *string    `json:"id,omitempty"`

	// ModifiedAt DateTime the Alignment was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`
	Name       *string    `json:"name,omitempty"`

	// ReferenceSequenceId The ID of the template or consensus Sequence associated with the Alignment
	ReferenceSequenceId *string `json:"referenceSequenceId,omitempty"`

	// WebURL The Benchling web UI url to view the Alignment
	WebURL *string `json:"webURL,omitempty"`
}

// NucleotideAlignmentsPaginatedList defines model for NucleotideAlignmentsPaginatedList.
type NucleotideAlignmentsPaginatedList struct {
	Alignments *[]NucleotideAlignmentSummary `json:"alignments,omitempty"`
	NextToken  *string                       `json:"nextToken,omitempty"`
}

// NucleotideConsensusAlignmentCreate defines model for NucleotideConsensusAlignmentCreate.
type NucleotideConsensusAlignmentCreate struct {
	Algorithm   NucleotideConsensusAlignmentCreateAlgorithm     `json:"algorithm"`
	Files       []NucleotideConsensusAlignmentCreate_Files_Item `json:"files"`
	Name        *string                                         `json:"name,omitempty"`
	NewSequence *struct {
		FolderId *string `json:"folderId,omitempty"`
	} `json:"newSequence,omitempty"`
	SequenceId *string `json:"sequenceId,omitempty"`
}

// NucleotideConsensusAlignmentCreateAlgorithm defines model for NucleotideConsensusAlignmentCreate.Algorithm.
type NucleotideConsensusAlignmentCreateAlgorithm string

// NucleotideConsensusAlignmentCreateFiles0 defines model for .
type NucleotideConsensusAlignmentCreateFiles0 struct {
	SequenceId *string `json:"sequenceId,omitempty"`
}

// NucleotideConsensusAlignmentCreate_Files_Item defines model for NucleotideConsensusAlignmentCreate.files.Item.
type NucleotideConsensusAlignmentCreate_Files_Item struct {
	union json.RawMessage
}

// NucleotideSequencePart defines model for NucleotideSequencePart.
type NucleotideSequencePart struct {
	// End 0-based exclusive end index. The end of the sequence is always represented as 0.
	End        *int    `json:"end,omitempty"`
	SequenceId *string `json:"sequenceId,omitempty"`

	// Start 0-based inclusive start index.
	Start *int `json:"start,omitempty"`
}

// NucleotideTemplateAlignmentCreate defines model for NucleotideTemplateAlignmentCreate.
type NucleotideTemplateAlignmentCreate struct {
	Algorithm          NucleotideTemplateAlignmentCreateAlgorithm     `json:"algorithm"`
	Files              []NucleotideTemplateAlignmentCreate_Files_Item `json:"files"`
	Name               *string                                        `json:"name,omitempty"`
	TemplateSequenceId string                                         `json:"templateSequenceId"`
}

// NucleotideTemplateAlignmentCreateAlgorithm defines model for NucleotideTemplateAlignmentCreate.Algorithm.
type NucleotideTemplateAlignmentCreateAlgorithm string

// NucleotideTemplateAlignmentCreateFiles0 defines model for .
type NucleotideTemplateAlignmentCreateFiles0 struct {
	SequenceId *string `json:"sequenceId,omitempty"`
}

// NucleotideTemplateAlignmentCreate_Files_Item defines model for NucleotideTemplateAlignmentCreate.files.Item.
type NucleotideTemplateAlignmentCreate_Files_Item struct {
	union json.RawMessage
}

// OAuthBadRequestError defines model for OAuthBadRequestError.
type OAuthBadRequestError struct {
	Error *struct {
		Message     *string                        `json:"message,omitempty"`
		Type        *OAuthBadRequestErrorErrorType `json:"type,omitempty"`
		UserMessage *string                        `json:"userMessage,omitempty"`
	} `json:"error,omitempty"`
}

// OAuthBadRequestErrorErrorType defines model for OAuthBadRequestError.Error.Type.
type OAuthBadRequestErrorErrorType string

// OAuthUnauthorizedError defines model for OAuthUnauthorizedError.
type OAuthUnauthorizedError struct {
	Error *struct {
		Message     *string                          `json:"message,omitempty"`
		Type        *OAuthUnauthorizedErrorErrorType `json:"type,omitempty"`
		UserMessage *string                          `json:"userMessage,omitempty"`
	} `json:"error,omitempty"`
}

// OAuthUnauthorizedErrorErrorType defines model for OAuthUnauthorizedError.Error.Type.
type OAuthUnauthorizedErrorErrorType string

// Oligo defines model for Oligo.
type Oligo struct {
	// Aliases Array of aliases
	Aliases *[]string `json:"aliases,omitempty"`

	// ApiURL The canonical url of the Oligo in the API.
	ApiURL        *string        `json:"apiURL,omitempty"`
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`

	// Bases Base pairs of the Oligo.
	Bases *string `json:"bases,omitempty"`

	// CreatedAt DateTime the Oligo was created.
	CreatedAt *time.Time   `json:"createdAt,omitempty"`
	Creator   *UserSummary `json:"creator,omitempty"`

	// CustomFields Custom fields set on the Oligo.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// EntityRegistryId Registry ID of the Oligo if registered.
	EntityRegistryId *string `json:"entityRegistryId"`
	Fields           *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder that contains the Oligo.
	FolderId *string `json:"folderId"`

	// Id ID of the Oligo.
	Id *string `json:"id,omitempty"`

	// Length Number of bases in the Oligo.
	Length *int `json:"length,omitempty"`

	// ModifiedAt DateTime the Oligo was last modified.
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Name Name of the Oligo.
	Name *string `json:"name,omitempty"`

	// NucleotideType Nucleotide type of the Oligo.
	NucleotideType     OligoNucleotideType `json:"nucleotideType"`
	RegistrationOrigin *RegistrationOrigin `json:"registrationOrigin"`

	// RegistryId Registry the Oligo is registered in.
	RegistryId *string        `json:"registryId"`
	Schema     *SchemaSummary `json:"schema"`

	// WebURL URL of the Oligo.
	WebURL *string `json:"webURL,omitempty"`
}

// OligoNucleotideType Nucleotide type of the Oligo.
type OligoNucleotideType string

// OligoBaseRequest defines model for OligoBaseRequest.
type OligoBaseRequest struct {
	// Aliases Aliases to add to the Oligo
	Aliases *[]string `json:"aliases,omitempty"`

	// AuthorIds IDs of users to set as the Oligo's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs of the oligo.
	Bases *string `json:"bases,omitempty"`

	// CustomFields Custom fields to add to the Oligo. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// Fields Fields to set on the Oligo. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the Oligo.
	FolderId *string `json:"folderId,omitempty"`

	// Name Name of the Oligo.
	Name *string `json:"name,omitempty"`

	// SchemaId ID of the oligo's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// OligoBaseRequestForCreate defines model for OligoBaseRequestForCreate.
type OligoBaseRequestForCreate struct {
	// Aliases Aliases to add to the Oligo
	Aliases *[]string `json:"aliases,omitempty"`

	// AuthorIds IDs of users to set as the Oligo's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs of the oligo.
	Bases string `json:"bases"`

	// CustomFields Custom fields to add to the Oligo. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// Fields Fields to set on the Oligo. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the Oligo.
	FolderId *string `json:"folderId,omitempty"`

	// Name Name of the Oligo.
	Name string `json:"name"`

	// SchemaId ID of the oligo's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// OligoCreate defines model for OligoCreate.
type OligoCreate struct {
	// Aliases Aliases to add to the Oligo
	Aliases *[]string `json:"aliases,omitempty"`

	// AuthorIds IDs of users to set as the Oligo's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs of the oligo.
	Bases string `json:"bases"`

	// CustomFields Custom fields to add to the Oligo. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// EntityRegistryId Entity registry ID to set for the registered entity. Cannot specify both entityRegistryId and namingStrategy at the same time.
	EntityRegistryId *string `json:"entityRegistryId,omitempty"`

	// Fields Fields to set on the Oligo. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the entity. Can be left empty when registryId is present.
	FolderId *string `json:"folderId,omitempty"`

	// Name Name of the Oligo.
	Name string `json:"name"`

	// NamingStrategy Specifies the behavior for automatically generated names when registering an entity.
	// - NEW_IDS: Generate new registry IDs
	// - IDS_FROM_NAMES: Generate registry IDs based on entity names
	// - DELETE_NAMES: Generate new registry IDs and replace name with registry ID
	// - SET_FROM_NAME_PARTS: Generate new registry IDs, rename according to name template, and keep old name as alias
	// - REPLACE_NAMES_FROM_PARTS: Generate new registry IDs, and replace name according to name template
	// - KEEP_NAMES: Keep existing entity names as registry IDs
	// - REPLACE_ID_AND_NAME_FROM_PARTS: Generate registry IDs and names according to name template
	NamingStrategy *NamingStrategy `json:"namingStrategy,omitempty"`

	// RegistryId Registry ID into which entity should be registered. this is the ID of the registry which was configured for a particular organization
	// To get available registryIds, use the [/registries endpoint](#/Registry/listRegistries)
	//
	// Required in order for entities to be created directly in the registry.
	RegistryId *string `json:"registryId,omitempty"`

	// SchemaId ID of the oligo's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// OligoUpdate defines model for OligoUpdate.
type OligoUpdate = OligoBaseRequest

// OligosArchivalChange IDs of all items that were archived or unarchived, grouped by resource type. This includes the IDs of Oligos along with any IDs of batches that were archived / unarchived.
type OligosArchivalChange struct {
	BatchIds *[]string `json:"batchIds,omitempty"`
	OligoIds *[]string `json:"oligoIds,omitempty"`
}

// OligosArchive The request body for archiving Oligos.
type OligosArchive struct {
	OligoIds []string `json:"oligoIds"`

	// Reason The reason for archiving the provided entities. Accepted reasons may differ based on tenant configuration.
	Reason EntityArchiveReason `json:"reason"`
}

// OligosBulkCreateRequest defines model for OligosBulkCreateRequest.
type OligosBulkCreateRequest struct {
	Oligos *[]OligoCreate `json:"oligos,omitempty"`
}

// OligosBulkGet defines model for OligosBulkGet.
type OligosBulkGet struct {
	Oligos *[]OligosBulkGet_Oligos_Item `json:"oligos,omitempty"`
}

// OligosBulkGet_Oligos_Item defines model for OligosBulkGet.oligos.Item.
type OligosBulkGet_Oligos_Item struct {
	union json.RawMessage
}

// OligosPaginatedList defines model for OligosPaginatedList.
type OligosPaginatedList struct {
	NextToken *string  `json:"nextToken,omitempty"`
	Oligos    *[]Oligo `json:"oligos,omitempty"`
}

// OligosUnarchive The request body for unarchiving Oligos.
type OligosUnarchive struct {
	OligoIds []string `json:"oligoIds"`
}

// Organization defines model for Organization.
type Organization struct {
	Handle *string `json:"handle,omitempty"`
	Id     *string `json:"id,omitempty"`
	Name   *string `json:"name,omitempty"`
}

// OrganizationSummary defines model for OrganizationSummary.
type OrganizationSummary struct {
	Handle *string `json:"handle,omitempty"`
	Id     *string `json:"id,omitempty"`
	Name   *string `json:"name,omitempty"`
}

// OrganizationsPaginatedList defines model for OrganizationsPaginatedList.
type OrganizationsPaginatedList struct {
	NextToken     *string         `json:"nextToken,omitempty"`
	Organizations *[]Organization `json:"organizations,omitempty"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	NextToken *string `json:"nextToken,omitempty"`
}

// PartySummary defines model for PartySummary.
type PartySummary struct {
	Handle *string `json:"handle,omitempty"`
	Id     *string `json:"id,omitempty"`
	Name   *string `json:"name,omitempty"`
}

// Plate defines model for Plate.
type Plate struct {
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`

	// Barcode Barcode of the plate
	Barcode *string `json:"barcode"`

	// CreatedAt DateTime the container was created
	CreatedAt *time.Time   `json:"createdAt,omitempty"`
	Creator   *UserSummary `json:"creator,omitempty"`
	Fields    *Fields      `json:"fields,omitempty"`

	// Id ID of the plate
	Id *string `json:"id,omitempty"`

	// ModifiedAt DateTime the plate was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Name Name of the plate, defaults to barcode if name is not provided.
	Name *string `json:"name,omitempty"`

	// ParentStorageId ID of containing parent inventory (e.g. loc_k2lNspzS).
	ParentStorageId *string `json:"parentStorageId"`

	// ProjectId ID of the project if set
	ProjectId *string        `json:"projectId"`
	Schema    *SchemaSummary `json:"schema"`
	Type      *PlateType     `json:"type,omitempty"`
	WebURL    *string        `json:"webURL,omitempty"`

	// Wells Well contents of the plate, keyed by position string (eg. "A1").
	Wells *map[string]WellOrInaccessibleResource `json:"wells,omitempty"`
}

// PlateType defines model for Plate.Type.
type PlateType string

// PlateCreate defines model for PlateCreate.
type PlateCreate struct {
	Barcode           *string `json:"barcode,omitempty"`
	ContainerSchemaId *string `json:"containerSchemaId,omitempty"`
	Fields            *Fields `json:"fields,omitempty"`
	Name              *string `json:"name,omitempty"`
	ParentStorageId   *string `json:"parentStorageId,omitempty"`
	ProjectId         *string `json:"projectId,omitempty"`
	SchemaId          string  `json:"schemaId"`
	Wells             *map[string]struct {
		Barcode *string `json:"barcode,omitempty"`
	} `json:"wells,omitempty"`
}

// PlateCreationTableNotePart defines model for PlateCreationTableNotePart.
type PlateCreationTableNotePart struct {
	ApiId   *string                      `json:"apiId,omitempty"`
	Columns *[]StructuredTableColumnInfo `json:"columns,omitempty"`

	// Indentation All notes have an indentation level - the default is 0 for no indent. For lists, indentation gives notes hierarchy - a bulleted list with children is modeled as one note part with indentation 1 followed by note parts with indentation 2, for example.
	Indentation   *int                            `json:"indentation,omitempty"`
	PlateSchemaId *string                         `json:"plateSchemaId,omitempty"`
	Type          *PlateCreationTableNotePartType `json:"type,omitempty"`
}

// PlateCreationTableNotePartType defines model for PlateCreationTableNotePart.Type.
type PlateCreationTableNotePartType string

// PlateSchema defines model for PlateSchema.
type PlateSchema struct {
	ArchiveRecord   *ArchiveRecord `json:"archiveRecord"`
	ContainerSchema *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"containerSchema"`
	FieldDefinitions *[]PlateSchema_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Height           *float32                             `json:"height,omitempty"`
	Id               *string                              `json:"id,omitempty"`
	Name             *string                              `json:"name,omitempty"`
	PlateType        *string                              `json:"plateType,omitempty"`
	Prefix           *string                              `json:"prefix,omitempty"`
	RegistryId       *string                              `json:"registryId,omitempty"`
	Type             *PlateSchemaType                     `json:"type,omitempty"`
	Width            *float32                             `json:"width,omitempty"`
}

// PlateSchema_FieldDefinitions_Item defines model for PlateSchema.fieldDefinitions.Item.
type PlateSchema_FieldDefinitions_Item struct {
	union json.RawMessage
}

// PlateSchemaType defines model for PlateSchema.Type.
type PlateSchemaType string

// PlateSchemasList defines model for PlateSchemasList.
type PlateSchemasList struct {
	PlateSchemas *[]PlateSchema `json:"plateSchemas,omitempty"`
}

// PlateSchemasPaginatedList defines model for PlateSchemasPaginatedList.
type PlateSchemasPaginatedList struct {
	NextToken    *string        `json:"nextToken,omitempty"`
	PlateSchemas *[]PlateSchema `json:"plateSchemas,omitempty"`
}

// PlateUpdate defines model for PlateUpdate.
type PlateUpdate struct {
	Fields          *Fields `json:"fields,omitempty"`
	Name            *string `json:"name,omitempty"`
	ParentStorageId *string `json:"parentStorageId,omitempty"`
	ProjectId       *string `json:"projectId,omitempty"`
}

// PlatesArchivalChange IDs of all items that were archived or unarchived, grouped by resource type. This includes the IDs of plates along with any IDs of containers that were archived / unarchived.
type PlatesArchivalChange struct {
	ContainerIds *[]string `json:"containerIds,omitempty"`
	PlateIds     *[]string `json:"plateIds,omitempty"`
}

// PlatesArchive defines model for PlatesArchive.
type PlatesArchive struct {
	// PlateIds Array of plate IDs
	PlateIds []string `json:"plateIds"`

	// Reason Reason that plates are being archived.
	Reason PlatesArchiveReason `json:"reason"`

	// ShouldRemoveBarcodes Remove barcodes. Removing barcodes from archived inventory that contain items will also remove barcodes from the contained items.
	ShouldRemoveBarcodes bool `json:"shouldRemoveBarcodes"`
}

// PlatesArchiveReason Reason that plates are being archived.
type PlatesArchiveReason string

// PlatesBulkGet defines model for PlatesBulkGet.
type PlatesBulkGet struct {
	Plates *[]Plate `json:"plates,omitempty"`
}

// PlatesPaginatedList defines model for PlatesPaginatedList.
type PlatesPaginatedList struct {
	NextToken *string  `json:"nextToken,omitempty"`
	Plates    *[]Plate `json:"plates,omitempty"`
}

// PlatesUnarchive defines model for PlatesUnarchive.
type PlatesUnarchive struct {
	// PlateIds Array of plate IDs
	PlateIds []string `json:"plateIds"`
}

// Primer defines model for Primer.
type Primer struct {
	Bases        *string `json:"bases,omitempty"`
	BindPosition *int    `json:"bindPosition,omitempty"`
	Color        *string `json:"color,omitempty"`

	// End 0-based exclusive end index. The end of the sequence is always represented as 0.
	End            *int    `json:"end,omitempty"`
	Name           *string `json:"name,omitempty"`
	OligoId        *string `json:"oligoId,omitempty"`
	OverhangLength *int    `json:"overhangLength,omitempty"`

	// Start 0-based inclusive start index.
	Start  *int `json:"start,omitempty"`
	Strand *int `json:"strand,omitempty"`
}

// PrintLabels defines model for PrintLabels.
type PrintLabels struct {
	// ContainerIds List of IDs of containers that will have labels printed (one label will be printed per container).
	ContainerIds []string `json:"containerIds"`

	// LabelTemplateId ID of label template to use (same template will be used for all labels printed).
	LabelTemplateId string `json:"labelTemplateId"`

	// PrinterId ID of printer to use (same printer will be used for all labels printed).
	PrinterId string `json:"printerId"`
}

// Printer defines model for Printer.
type Printer struct {
	// Address Web address of the printer (either IP address or URL).
	Address *string `json:"address,omitempty"`

	// Description Short description of the printer.
	Description *string `json:"description"`

	// Id ID of the printer.
	Id *string `json:"id,omitempty"`

	// Name Name of the printer.
	Name *string `json:"name,omitempty"`

	// Port Port to reach the printer at.
	Port *int `json:"port"`

	// RegistryId ID of the registry associated with this printer.
	RegistryId *string `json:"registryId,omitempty"`
}

// PrintersList defines model for PrintersList.
type PrintersList struct {
	LabelPrinters *[]Printer `json:"labelPrinters,omitempty"`
}

// Project defines model for Project.
type Project struct {
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`
	Id            *string        `json:"id,omitempty"`
	Name          *string        `json:"name,omitempty"`
	Owner         *Project_Owner `json:"owner,omitempty"`
}

// Project_Owner defines model for Project.Owner.
type Project_Owner struct {
	union json.RawMessage
}

// ProjectsArchivalChange IDs of all items that were archived or unarchived, grouped by resource type. This includes the IDs of projects along with any IDs of project contents that were unarchived.
type ProjectsArchivalChange struct {
	AaSequenceIds   *[]string `json:"aaSequenceIds,omitempty"`
	CustomEntityIds *[]string `json:"customEntityIds,omitempty"`
	DnaSequenceIds  *[]string `json:"dnaSequenceIds,omitempty"`
	EntryIds        *[]string `json:"entryIds,omitempty"`
	FolderIds       *[]string `json:"folderIds,omitempty"`
	MixtureIds      *[]string `json:"mixtureIds,omitempty"`
	OligoIds        *[]string `json:"oligoIds,omitempty"`
	ProjectIds      *[]string `json:"projectIds,omitempty"`
	ProtocolIds     *[]string `json:"protocolIds,omitempty"`
}

// ProjectsArchive defines model for ProjectsArchive.
type ProjectsArchive struct {
	// ProjectIds A list of project IDs to archive.
	ProjectIds []string `json:"projectIds"`

	// Reason The reason for archiving the provided projects. Accepted reasons may differ based on tenant configuration.
	Reason ProjectsArchiveReason `json:"reason"`
}

// ProjectsArchiveReason The reason for archiving the provided projects. Accepted reasons may differ based on tenant configuration.
type ProjectsArchiveReason string

// ProjectsPaginatedList defines model for ProjectsPaginatedList.
type ProjectsPaginatedList struct {
	NextToken *string    `json:"nextToken,omitempty"`
	Projects  *[]Project `json:"projects,omitempty"`
}

// ProjectsUnarchive defines model for ProjectsUnarchive.
type ProjectsUnarchive struct {
	// ProjectIds A list of project IDs to unarchive.
	ProjectIds []string `json:"projectIds"`
}

// RegisterEntities defines model for RegisterEntities.
type RegisterEntities struct {
	// EntityIds Array of entity IDs
	EntityIds []string `json:"entityIds"`

	// NamingStrategy Specifies the behavior for automatically generated names when registering an entity.
	// - NEW_IDS: Generate new registry IDs
	// - IDS_FROM_NAMES: Generate registry IDs based on entity names
	// - DELETE_NAMES: Generate new registry IDs and replace name with registry ID
	// - SET_FROM_NAME_PARTS: Generate new registry IDs, rename according to name template, and keep old name as alias
	// - REPLACE_NAMES_FROM_PARTS: Generate new registry IDs, and replace name according to name template
	// - KEEP_NAMES: Keep existing entity names as registry IDs
	// - REPLACE_ID_AND_NAME_FROM_PARTS: Generate registry IDs and names according to name template
	NamingStrategy NamingStrategy `json:"namingStrategy"`
}

// RegisteredEntitiesList defines model for RegisteredEntitiesList.
type RegisteredEntitiesList struct {
	Entities *[]RegisteredEntitiesList_Entities_Item `json:"entities,omitempty"`
}

// RegisteredEntitiesList_Entities_Item defines model for RegisteredEntitiesList.entities.Item.
type RegisteredEntitiesList_Entities_Item struct {
	EntityType string `json:"entityType"`
	union      json.RawMessage
}

// RegistrationOrigin defines model for RegistrationOrigin.
type RegistrationOrigin struct {
	OriginEntryId *string    `json:"originEntryId"`
	RegisteredAt  *time.Time `json:"registeredAt,omitempty"`
}

// RegistrationTableNotePart defines model for RegistrationTableNotePart.
type RegistrationTableNotePart struct {
	ApiId          *string                      `json:"apiId,omitempty"`
	Columns        *[]StructuredTableColumnInfo `json:"columns,omitempty"`
	EntitySchemaId *string                      `json:"entitySchemaId,omitempty"`

	// Indentation All notes have an indentation level - the default is 0 for no indent. For lists, indentation gives notes hierarchy - a bulleted list with children is modeled as one note part with indentation 1 followed by note parts with indentation 2, for example.
	Indentation *int                           `json:"indentation,omitempty"`
	Type        *RegistrationTableNotePartType `json:"type,omitempty"`
}

// RegistrationTableNotePartType defines model for RegistrationTableNotePart.Type.
type RegistrationTableNotePartType string

// RegistriesList defines model for RegistriesList.
type RegistriesList struct {
	Registries *[]Registry `json:"registries,omitempty"`
}

// Registry defines model for Registry.
type Registry struct {
	Id *string `json:"id,omitempty"`

	// ModifiedAt DateTime the Registry was last modified
	ModifiedAt *time.Time    `json:"modifiedAt,omitempty"`
	Name       *string       `json:"name,omitempty"`
	Owner      *Organization `json:"owner,omitempty"`
}

// RegistrySchema defines model for RegistrySchema.
type RegistrySchema struct {
	ArchiveRecord    *ArchiveRecord                          `json:"archiveRecord"`
	FieldDefinitions *[]RegistrySchema_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Id               *string                                 `json:"id,omitempty"`
	Name             *string                                 `json:"name,omitempty"`
	Prefix           *string                                 `json:"prefix,omitempty"`
	RegistryId       *string                                 `json:"registryId,omitempty"`
	Type             *string                                 `json:"type,omitempty"`
}

// RegistrySchema_FieldDefinitions_Item defines model for RegistrySchema.fieldDefinitions.Item.
type RegistrySchema_FieldDefinitions_Item struct {
	union json.RawMessage
}

// Request defines model for Request.
type Request struct {
	// ApiURL The canonical url of the Request in the API.
	ApiURL *string `json:"apiURL,omitempty"`

	// Assignees Array of assignees
	Assignees *[]Request_Assignees_Item `json:"assignees,omitempty"`

	// CreatedAt Date and time the request was created
	CreatedAt *string `json:"createdAt,omitempty"`

	// Creator UserSummary of the user who created the request
	Creator *UserSummary `json:"creator,omitempty"`

	// DisplayId User-friendly ID of the request
	DisplayId *string `json:"displayId,omitempty"`
	Fields    *Fields `json:"fields,omitempty"`

	// Id Unique ID for the request
	Id *string `json:"id,omitempty"`

	// ProjectId The ID of the project to which the request belongs.
	ProjectId     *string        `json:"projectId,omitempty"`
	RequestStatus *RequestStatus `json:"requestStatus,omitempty"`

	// Requestor UserSummary of the user making the request
	Requestor    *UserSummary          `json:"requestor,omitempty"`
	SampleGroups *[]RequestSampleGroup `json:"sampleGroups,omitempty"`

	// ScheduledOn Date the request is scheduled to be executed on, in YYYY-MM-DD format.
	ScheduledOn *openapi_types.Date `json:"scheduledOn"`

	// Schema SchemaSummary for the request
	Schema *SchemaSummary `json:"schema,omitempty"`
	Tasks  *[]RequestTask `json:"tasks,omitempty"`

	// WebURL URL of the request
	WebURL *string `json:"webURL,omitempty"`
}

// Request_Assignees_Item defines model for Request.assignees.Item.
type Request_Assignees_Item struct {
	union json.RawMessage
}

// RequestBase A request is an ask to perform a service, e.g. produce a sample or perform assays on a sample. Requests are usually placed to another team or individual who specializes in performing the service.
type RequestBase = map[string]interface{}

// RequestCreate defines model for RequestCreate.
type RequestCreate struct {
	// Assignees Array of assignees
	Assignees *[]RequestCreate_Assignees_Item `json:"assignees,omitempty"`

	// Fields The request's fields
	Fields Fields `json:"fields"`

	// ProjectId The ID of the project to which the request belongs.
	ProjectId string `json:"projectId"`

	// RequestorId ID of the user making the request. If unspecified, the requestor is the request creator.
	RequestorId  *string                    `json:"requestorId"`
	SampleGroups []RequestSampleGroupCreate `json:"sampleGroups"`

	// ScheduledOn Date the request is scheduled to be executed on, in YYYY-MM-DD format.
	ScheduledOn *openapi_types.Date `json:"scheduledOn,omitempty"`

	// SchemaId ID of the request's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// RequestCreate_Assignees_Item defines model for RequestCreate.assignees.Item.
type RequestCreate_Assignees_Item struct {
	union json.RawMessage
}

// RequestCreatedEvent defines model for RequestCreatedEvent.
type RequestCreatedEvent struct {
	CreatedAt  *time.Time                    `json:"createdAt,omitempty"`
	Deprecated *bool                         `json:"deprecated,omitempty"`
	EventType  *RequestCreatedEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Request            *Request  `json:"request,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
}

// RequestCreatedEventEventType defines model for RequestCreatedEvent.EventType.
type RequestCreatedEventEventType string

// RequestFulfillment A request fulfillment represents work that is done which changes the status of a request or a sample group within that request.
// Fulfillments are created when state changes between IN_PROGRESS, COMPLETED, or FAILED statuses. Fulfillments do not capture a PENDING state because all requests or request sample groups are considered PENDING until the first corresponding fulfillment is created.
type RequestFulfillment struct {
	// CreatedAt Date and time the fulfillment was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// EntryId ID of the entry this fulfillment was executed in, if any
	EntryId *string `json:"entryId,omitempty"`

	// Id ID of the request fulfillment
	Id *string `json:"id,omitempty"`

	// ModifiedAt DateTime the Request Fulfillment was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// RequestId ID of the request this fulfillment fulfills
	RequestId *string `json:"requestId,omitempty"`

	// SampleGroup The request sample group this fulfillment was executed upon, if any.
	SampleGroup *SampleGroup `json:"sampleGroup"`

	// Status Status of a sample group
	Status *SampleGroupStatus `json:"status,omitempty"`
}

// RequestFulfillmentsPaginatedList An object containing an array of RequestFulfillments
type RequestFulfillmentsPaginatedList struct {
	NextToken           *string               `json:"nextToken,omitempty"`
	RequestFulfillments *[]RequestFulfillment `json:"requestFulfillments,omitempty"`
}

// RequestResponse defines model for RequestResponse.
type RequestResponse struct {
	Results *[]AssayResult `json:"results,omitempty"`

	// Samples Array of samples produced by the request.
	Samples *[]struct {
		// Batch The sample, if it is a batch resource. Null otherwise.
		Batch *RequestResponseSamplesItemBatch `json:"batch"`

		// Entity The sample, if it is an entity resource. Null otherwise.
		Entity *RequestResponseSamplesItemEntity `json:"entity"`

		// Status The status of the sample, based on the status of the stage run that generated it.
		Status *RequestResponseSamplesStatus `json:"status,omitempty"`
	} `json:"samples,omitempty"`
}

// RequestResponseSamplesStatus The status of the sample, based on the status of the stage run that generated it.
type RequestResponseSamplesStatus string

// RequestResponseSamplesItemBatch defines model for RequestResponseSamplesItemBatch.
type RequestResponseSamplesItemBatch = BatchOrInaccessibleResource

// RequestResponseSamplesItemEntity defines model for RequestResponseSamplesItemEntity.
type RequestResponseSamplesItemEntity = EntityOrInaccessibleResource

// RequestSampleGroup defines model for RequestSampleGroup.
type RequestSampleGroup struct {
	Id *string `json:"id,omitempty"`

	// Samples The key for each RequestSample should match one of the samplesSchema[n].name property in the request schema json.
	Samples *RequestSampleGroupSamples `json:"samples,omitempty"`
}

// RequestSampleGroupCreate defines model for RequestSampleGroupCreate.
type RequestSampleGroupCreate struct {
	// Samples The key for each RequestSample should match one of the samplesSchema[n].name property in the request schema json.
	Samples RequestSampleGroupSamples `json:"samples"`
}

// RequestSampleGroupSamples The key for each RequestSample should match one of the samplesSchema[n].name property in the request schema json.
type RequestSampleGroupSamples map[string]RequestSampleGroupSamples_AdditionalProperties

// RequestSampleGroupSamples_AdditionalProperties defines model for RequestSampleGroupSamples.AdditionalProperties.
type RequestSampleGroupSamples_AdditionalProperties struct {
	union json.RawMessage
}

// RequestSampleWithBatch defines model for RequestSampleWithBatch.
type RequestSampleWithBatch struct {
	BatchId     string  `json:"batchId"`
	ContainerId *string `json:"containerId,omitempty"`
}

// RequestSampleWithEntity defines model for RequestSampleWithEntity.
type RequestSampleWithEntity struct {
	ContainerId *string `json:"containerId,omitempty"`
	EntityId    string  `json:"entityId"`
}

// RequestSchema defines model for RequestSchema.
type RequestSchema struct {
	ArchiveRecord    *ArchiveRecord                         `json:"archiveRecord"`
	FieldDefinitions *[]RequestSchema_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Id               *string                                `json:"id,omitempty"`

	// ModifiedAt DateTime the Request Schema was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`
	Name       *string    `json:"name,omitempty"`

	// Organization The organization that owns the schema.
	Organization *struct {
		Handle *string `json:"handle,omitempty"`
		Id     *string `json:"id,omitempty"`
		Name   *string `json:"name,omitempty"`
	} `json:"organization,omitempty"`
	SystemName *string            `json:"systemName,omitempty"`
	Type       *RequestSchemaType `json:"type,omitempty"`
}

// RequestSchema_FieldDefinitions_Item defines model for RequestSchema.fieldDefinitions.Item.
type RequestSchema_FieldDefinitions_Item struct {
	union json.RawMessage
}

// RequestSchemaType defines model for RequestSchema.Type.
type RequestSchemaType string

// RequestSchemasPaginatedList defines model for RequestSchemasPaginatedList.
type RequestSchemasPaginatedList struct {
	NextToken      *string          `json:"nextToken,omitempty"`
	RequestSchemas *[]RequestSchema `json:"requestSchemas,omitempty"`
}

// RequestStatus defines model for RequestStatus.
type RequestStatus string

// RequestTask A request task.
type RequestTask = RequestTaskBase

// RequestTaskBase Shared fields for request tasks and related endpoints.
type RequestTaskBase = RequestTaskBaseFields

// RequestTaskBaseFields Shared fields for request tasks and related endpoints.
type RequestTaskBaseFields struct {
	// Fields Schema fields to set on the request task.
	// Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// SampleGroupIds IDs of all request sample groups now associated with this task.
	SampleGroupIds *[]string `json:"sampleGroupIds,omitempty"`
}

// RequestTaskSchema defines model for RequestTaskSchema.
type RequestTaskSchema struct {
	ArchiveRecord    *ArchiveRecord                             `json:"archiveRecord"`
	FieldDefinitions *[]RequestTaskSchema_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Id               *string                                    `json:"id,omitempty"`

	// ModifiedAt DateTime the Request Task Schema was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`
	Name       *string    `json:"name,omitempty"`

	// Organization The organization that owns the schema.
	Organization *struct {
		Handle *string `json:"handle,omitempty"`
		Id     *string `json:"id,omitempty"`
		Name   *string `json:"name,omitempty"`
	} `json:"organization,omitempty"`
	SystemName *string                `json:"systemName,omitempty"`
	Type       *RequestTaskSchemaType `json:"type,omitempty"`
}

// RequestTaskSchema_FieldDefinitions_Item defines model for RequestTaskSchema.fieldDefinitions.Item.
type RequestTaskSchema_FieldDefinitions_Item struct {
	union json.RawMessage
}

// RequestTaskSchemaType defines model for RequestTaskSchema.Type.
type RequestTaskSchemaType string

// RequestTaskSchemasPaginatedList defines model for RequestTaskSchemasPaginatedList.
type RequestTaskSchemasPaginatedList struct {
	NextToken          *string              `json:"nextToken,omitempty"`
	RequestTaskSchemas *[]RequestTaskSchema `json:"requestTaskSchemas,omitempty"`
}

// RequestTasksBulkCreate Shared fields for request tasks and related endpoints.
type RequestTasksBulkCreate = RequestTaskBaseFields

// RequestTasksBulkCreateRequest defines model for RequestTasksBulkCreateRequest.
type RequestTasksBulkCreateRequest struct {
	// Tasks The tasks to create
	Tasks []RequestTasksBulkCreate `json:"tasks"`
}

// RequestTasksBulkCreateResponse defines model for RequestTasksBulkCreateResponse.
type RequestTasksBulkCreateResponse struct {
	// Tasks The created tasks
	Tasks *[]RequestTask `json:"tasks,omitempty"`
}

// RequestTasksBulkUpdateRequest A request body for bulk updating request tasks.
type RequestTasksBulkUpdateRequest struct {
	// Tasks The tasks to update
	Tasks []RequestTaskBase `json:"tasks"`
}

// RequestTasksBulkUpdateResponse defines model for RequestTasksBulkUpdateResponse.
type RequestTasksBulkUpdateResponse struct {
	// Tasks The tasks to update
	Tasks *[]RequestTask `json:"tasks,omitempty"`
}

// RequestTeamAssignee defines model for RequestTeamAssignee.
type RequestTeamAssignee struct {
	Team *TeamSummary `json:"team,omitempty"`
}

// RequestUpdate defines model for RequestUpdate.
type RequestUpdate struct {
	// Assignees Array of assignees
	Assignees *[]RequestUpdate_Assignees_Item `json:"assignees,omitempty"`

	// Fields The request's fields
	Fields *Fields `json:"fields,omitempty"`

	// ProjectId The ID of the project to which the request belongs.
	ProjectId     *string        `json:"projectId,omitempty"`
	RequestStatus *RequestStatus `json:"requestStatus,omitempty"`

	// RequestorId ID of the user making the request. If unspecified, the requestor is the request creator.
	RequestorId  *string                     `json:"requestorId"`
	SampleGroups *[]RequestSampleGroupCreate `json:"sampleGroups,omitempty"`

	// ScheduledOn Date the request is scheduled to be executed on, in YYYY-MM-DD format.
	ScheduledOn *openapi_types.Date `json:"scheduledOn,omitempty"`
}

// RequestUpdate_Assignees_Item defines model for RequestUpdate.assignees.Item.
type RequestUpdate_Assignees_Item struct {
	union json.RawMessage
}

// RequestUpdatedFieldsEvent defines model for RequestUpdatedFieldsEvent.
type RequestUpdatedFieldsEvent struct {
	CreatedAt  *time.Time                          `json:"createdAt,omitempty"`
	Deprecated *bool                               `json:"deprecated,omitempty"`
	EventType  *RequestUpdatedFieldsEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Request            *Request  `json:"request,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`

	// Updates These properties have been updated, causing this message
	Updates *[]string `json:"updates,omitempty"`
}

// RequestUpdatedFieldsEventEventType defines model for RequestUpdatedFieldsEvent.EventType.
type RequestUpdatedFieldsEventEventType string

// RequestUserAssignee defines model for RequestUserAssignee.
type RequestUserAssignee struct {
	User *UserSummary `json:"user,omitempty"`
}

// RequestWriteBase defines model for RequestWriteBase.
type RequestWriteBase struct {
	// Assignees Array of assignees
	Assignees *[]RequestWriteBase_Assignees_Item `json:"assignees,omitempty"`

	// Fields The request's fields
	Fields *Fields `json:"fields,omitempty"`

	// ProjectId The ID of the project to which the request belongs.
	ProjectId *string `json:"projectId,omitempty"`

	// RequestorId ID of the user making the request. If unspecified, the requestor is the request creator.
	RequestorId  *string                     `json:"requestorId"`
	SampleGroups *[]RequestSampleGroupCreate `json:"sampleGroups,omitempty"`

	// ScheduledOn Date the request is scheduled to be executed on, in YYYY-MM-DD format.
	ScheduledOn *openapi_types.Date `json:"scheduledOn,omitempty"`
}

// RequestWriteBase_Assignees_Item defines model for RequestWriteBase.assignees.Item.
type RequestWriteBase_Assignees_Item struct {
	union json.RawMessage
}

// RequestWriteTeamAssignee defines model for RequestWriteTeamAssignee.
type RequestWriteTeamAssignee struct {
	TeamId string `json:"teamId"`
}

// RequestWriteUserAssignee defines model for RequestWriteUserAssignee.
type RequestWriteUserAssignee struct {
	UserId string `json:"userId"`
}

// RequestsBulkGet defines model for RequestsBulkGet.
type RequestsBulkGet struct {
	Requests *[]Request `json:"requests,omitempty"`
}

// RequestsPaginatedList defines model for RequestsPaginatedList.
type RequestsPaginatedList struct {
	NextToken *string    `json:"nextToken,omitempty"`
	Requests  *[]Request `json:"requests,omitempty"`
}

// ResultsTableNotePart defines model for ResultsTableNotePart.
type ResultsTableNotePart struct {
	ApiId               *string                      `json:"apiId,omitempty"`
	AssayResultSchemaId *string                      `json:"assayResultSchemaId,omitempty"`
	Columns             *[]StructuredTableColumnInfo `json:"columns,omitempty"`

	// Indentation All notes have an indentation level - the default is 0 for no indent. For lists, indentation gives notes hierarchy - a bulleted list with children is modeled as one note part with indentation 1 followed by note parts with indentation 2, for example.
	Indentation *int                      `json:"indentation,omitempty"`
	Type        *ResultsTableNotePartType `json:"type,omitempty"`
}

// ResultsTableNotePartType defines model for ResultsTableNotePart.Type.
type ResultsTableNotePartType string

// RnaAnnotation defines model for RnaAnnotation.
type RnaAnnotation struct {
	// Color Hex color code used when displaying this feature in the UI.
	Color        *string                       `json:"color,omitempty"`
	CustomFields *[]SequenceFeatureCustomField `json:"customFields,omitempty"`

	// End 0-based exclusive end index. The end of the sequence is always represented as 0.
	End   *int    `json:"end,omitempty"`
	Name  *string `json:"name,omitempty"`
	Notes *string `json:"notes,omitempty"`

	// Start 0-based inclusive start index.
	Start  *int    `json:"start,omitempty"`
	Strand *int    `json:"strand,omitempty"`
	Type   *string `json:"type,omitempty"`
}

// RnaOligo defines model for RnaOligo.
type RnaOligo struct {
	// Aliases Array of aliases
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations on the Oligo.
	Annotations   *[]RnaAnnotation `json:"annotations,omitempty"`
	ApiURL        *string          `json:"apiURL,omitempty"`
	ArchiveRecord *ArchiveRecord   `json:"archiveRecord"`
	Bases         *string          `json:"bases,omitempty"`

	// CreatedAt DateTime the Oligo was created.
	CreatedAt *time.Time   `json:"createdAt,omitempty"`
	Creator   *UserSummary `json:"creator,omitempty"`

	// CustomFields Custom fields set on the Oligo.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// CustomNotation Representation of the oligo in the custom notation specified in the request. Null if no notation was specified.
	CustomNotation *string `json:"customNotation"`

	// CustomNotationName Name of the custom notation specified in the request. Null if no notation was specified.
	CustomNotationName *string `json:"customNotationName"`

	// EntityRegistryId Registry ID of the Oligo if registered.
	EntityRegistryId *string `json:"entityRegistryId"`
	Fields           *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder that contains the Oligo.
	FolderId *string `json:"folderId"`

	// Helm Representation of the oligo in HELM syntax, including any chemical modifications
	Helm *string `json:"helm,omitempty"`

	// Id ID of the Oligo.
	Id *string `json:"id,omitempty"`

	// Length Number of bases in the Oligo.
	Length *int `json:"length,omitempty"`

	// ModifiedAt DateTime the Oligo was last modified.
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Name Name of the Oligo.
	Name               *string             `json:"name,omitempty"`
	NucleotideType     string              `json:"nucleotideType"`
	RegistrationOrigin *RegistrationOrigin `json:"registrationOrigin"`

	// RegistryId Registry the Oligo is registered in.
	RegistryId *string        `json:"registryId"`
	Schema     *SchemaSummary `json:"schema"`

	// WebURL URL of the Oligo.
	WebURL *string `json:"webURL,omitempty"`
}

// RnaOligoBulkUpdate defines model for RnaOligoBulkUpdate.
type RnaOligoBulkUpdate struct {
	// Aliases Aliases to add to the Oligo
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations on the Oligo.
	Annotations *[]RnaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the Oligo's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs of the oligo.
	Bases *string `json:"bases,omitempty"`

	// CustomFields Custom fields to add to the Oligo. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// CustomNotation Representation of the sequence or oligo in the custom notation specified by customNotationId
	CustomNotation *string `json:"customNotation,omitempty"`

	// CustomNotationId ID of the notation used to interpret the string provided in the customNotation field
	CustomNotationId *string `json:"customNotationId,omitempty"`

	// Fields Fields to set on the Oligo. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the Oligo.
	FolderId *string `json:"folderId,omitempty"`

	// Helm Representation of the oligo in HELM syntax, including any chemical modifications
	Helm *string `json:"helm,omitempty"`
	Id   *string `json:"id,omitempty"`

	// Name Name of the Oligo.
	Name *string `json:"name,omitempty"`

	// SchemaId ID of the oligo's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// RnaOligoCreate defines model for RnaOligoCreate.
type RnaOligoCreate struct {
	// Aliases Aliases to add to the Oligo
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations on the Oligo.
	Annotations *[]RnaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the Oligo's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs of the oligo.
	Bases string `json:"bases"`

	// CustomFields Custom fields to add to the Oligo. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// CustomNotation Representation of the sequence or oligo in the custom notation specified by customNotationId
	CustomNotation *string `json:"customNotation,omitempty"`

	// CustomNotationId ID of the notation used to interpret the string provided in the customNotation field
	CustomNotationId *string `json:"customNotationId,omitempty"`

	// EntityRegistryId Entity registry ID to set for the registered entity. Cannot specify both entityRegistryId and namingStrategy at the same time.
	EntityRegistryId *string `json:"entityRegistryId,omitempty"`

	// Fields Fields to set on the Oligo. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the entity. Can be left empty when registryId is present.
	FolderId *string `json:"folderId,omitempty"`

	// Helm Representation of the oligo in HELM syntax, including any chemical modifications
	Helm *string `json:"helm,omitempty"`

	// Name Name of the Oligo.
	Name string `json:"name"`

	// NamingStrategy Specifies the behavior for automatically generated names when registering an entity.
	// - NEW_IDS: Generate new registry IDs
	// - IDS_FROM_NAMES: Generate registry IDs based on entity names
	// - DELETE_NAMES: Generate new registry IDs and replace name with registry ID
	// - SET_FROM_NAME_PARTS: Generate new registry IDs, rename according to name template, and keep old name as alias
	// - REPLACE_NAMES_FROM_PARTS: Generate new registry IDs, and replace name according to name template
	// - KEEP_NAMES: Keep existing entity names as registry IDs
	// - REPLACE_ID_AND_NAME_FROM_PARTS: Generate registry IDs and names according to name template
	NamingStrategy *NamingStrategy `json:"namingStrategy,omitempty"`

	// RegistryId Registry ID into which entity should be registered. this is the ID of the registry which was configured for a particular organization
	// To get available registryIds, use the [/registries endpoint](#/Registry/listRegistries)
	//
	// Required in order for entities to be created directly in the registry.
	RegistryId *string `json:"registryId,omitempty"`

	// SchemaId ID of the oligo's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// RnaOligoUpdate defines model for RnaOligoUpdate.
type RnaOligoUpdate struct {
	// Aliases Aliases to add to the Oligo
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations on the Oligo.
	Annotations *[]RnaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the Oligo's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs of the oligo.
	Bases *string `json:"bases,omitempty"`

	// CustomFields Custom fields to add to the Oligo. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// CustomNotation Representation of the sequence or oligo in the custom notation specified by customNotationId
	CustomNotation *string `json:"customNotation,omitempty"`

	// CustomNotationId ID of the notation used to interpret the string provided in the customNotation field
	CustomNotationId *string `json:"customNotationId,omitempty"`

	// Fields Fields to set on the Oligo. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the Oligo.
	FolderId *string `json:"folderId,omitempty"`

	// Helm Representation of the oligo in HELM syntax, including any chemical modifications
	Helm *string `json:"helm,omitempty"`

	// Name Name of the Oligo.
	Name *string `json:"name,omitempty"`

	// SchemaId ID of the oligo's schema.
	SchemaId *string `json:"schemaId,omitempty"`
}

// RnaOligoWithEntityType defines model for RnaOligoWithEntityType.
type RnaOligoWithEntityType struct {
	// Aliases Array of aliases
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations on the Oligo.
	Annotations   *[]RnaAnnotation `json:"annotations,omitempty"`
	ApiURL        *string          `json:"apiURL,omitempty"`
	ArchiveRecord *ArchiveRecord   `json:"archiveRecord"`
	Bases         *string          `json:"bases,omitempty"`

	// CreatedAt DateTime the Oligo was created.
	CreatedAt *time.Time   `json:"createdAt,omitempty"`
	Creator   *UserSummary `json:"creator,omitempty"`

	// CustomFields Custom fields set on the Oligo.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// CustomNotation Representation of the oligo in the custom notation specified in the request. Null if no notation was specified.
	CustomNotation *string `json:"customNotation"`

	// CustomNotationName Name of the custom notation specified in the request. Null if no notation was specified.
	CustomNotationName *string `json:"customNotationName"`

	// EntityRegistryId Registry ID of the Oligo if registered.
	EntityRegistryId *string                           `json:"entityRegistryId"`
	EntityType       *RnaOligoWithEntityTypeEntityType `json:"entityType,omitempty"`
	Fields           *Fields                           `json:"fields,omitempty"`

	// FolderId ID of the folder that contains the Oligo.
	FolderId *string `json:"folderId"`

	// Helm Representation of the oligo in HELM syntax, including any chemical modifications
	Helm *string `json:"helm,omitempty"`

	// Id ID of the Oligo.
	Id *string `json:"id,omitempty"`

	// Length Number of bases in the Oligo.
	Length *int `json:"length,omitempty"`

	// ModifiedAt DateTime the Oligo was last modified.
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Name Name of the Oligo.
	Name               *string             `json:"name,omitempty"`
	NucleotideType     string              `json:"nucleotideType"`
	RegistrationOrigin *RegistrationOrigin `json:"registrationOrigin"`

	// RegistryId Registry the Oligo is registered in.
	RegistryId *string        `json:"registryId"`
	Schema     *SchemaSummary `json:"schema"`

	// WebURL URL of the Oligo.
	WebURL *string `json:"webURL,omitempty"`
}

// RnaOligoWithEntityTypeEntityType defines model for RnaOligoWithEntityType.EntityType.
type RnaOligoWithEntityTypeEntityType string

// RnaOligosArchivalChange IDs of all items that were archived or unarchived, grouped by resource type. This includes the IDs of RNA Oligos along with any IDs of batches that were archived / unarchived.
type RnaOligosArchivalChange struct {
	BatchIds    *[]string `json:"batchIds,omitempty"`
	RnaOligoIds *[]string `json:"rnaOligoIds,omitempty"`
}

// RnaOligosArchive The request body for archiving RNA Oligos.
type RnaOligosArchive struct {
	// Reason The reason for archiving the provided entities. Accepted reasons may differ based on tenant configuration.
	Reason      EntityArchiveReason `json:"reason"`
	RnaOligoIds []string            `json:"rnaOligoIds"`
}

// RnaOligosBulkCreateRequest defines model for RnaOligosBulkCreateRequest.
type RnaOligosBulkCreateRequest struct {
	RnaOligos *[]RnaOligoCreate `json:"rnaOligos,omitempty"`
}

// RnaOligosBulkUpdateRequest defines model for RnaOligosBulkUpdateRequest.
type RnaOligosBulkUpdateRequest struct {
	RnaOligos *[]RnaOligoBulkUpdate `json:"rnaOligos,omitempty"`
}

// RnaOligosPaginatedList defines model for RnaOligosPaginatedList.
type RnaOligosPaginatedList struct {
	NextToken *string     `json:"nextToken,omitempty"`
	RnaOligos *[]RnaOligo `json:"rnaOligos,omitempty"`
}

// RnaOligosUnarchive The request body for unarchiving RNA Oligos.
type RnaOligosUnarchive struct {
	RnaOligoIds []string `json:"rnaOligoIds"`
}

// RnaSequence defines model for RnaSequence.
type RnaSequence struct {
	Aliases     *[]string        `json:"aliases,omitempty"`
	Annotations *[]RnaAnnotation `json:"annotations,omitempty"`

	// ApiURL The canonical url of the RNA Sequence in the API.
	ApiURL        *string        `json:"apiURL,omitempty"`
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`
	Bases         *string        `json:"bases,omitempty"`
	CreatedAt     *time.Time     `json:"createdAt,omitempty"`
	Creator       *UserSummary   `json:"creator,omitempty"`
	CustomFields  *CustomFields  `json:"customFields,omitempty"`

	// CustomNotation Representation of the RNA Sequence in the custom notation specified in the request. Null if no notation was specified.
	CustomNotation *string `json:"customNotation"`

	// CustomNotationName Name of the custom notation specified in the request. Null if no notation was specified.
	CustomNotationName *string `json:"customNotationName"`
	EntityRegistryId   *string `json:"entityRegistryId"`
	Fields             *Fields `json:"fields,omitempty"`
	FolderId           *string `json:"folderId"`

	// Helm Representation of the RNA Sequence in HELM syntax, including any chemical modifications.
	Helm               *string             `json:"helm"`
	Id                 *string             `json:"id,omitempty"`
	IsCircular         *bool               `json:"isCircular,omitempty"`
	Length             *int                `json:"length,omitempty"`
	ModifiedAt         *time.Time          `json:"modifiedAt,omitempty"`
	Name               *string             `json:"name,omitempty"`
	Parts              *[]RnaSequencePart  `json:"parts,omitempty"`
	Primers            *[]Primer           `json:"primers,omitempty"`
	RegistrationOrigin *RegistrationOrigin `json:"registrationOrigin"`
	RegistryId         *string             `json:"registryId"`
	Schema             *SchemaSummary      `json:"schema"`
	Translations       *[]Translation      `json:"translations,omitempty"`
	WebURL             *string             `json:"webURL,omitempty"`
}

// RnaSequenceBaseRequest defines model for RnaSequenceBaseRequest.
type RnaSequenceBaseRequest struct {
	// Aliases Aliases to add to the RNA sequence
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations to create on the RNA sequence.
	Annotations *[]RnaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the RNA sequence's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs for the RNA sequence.
	Bases *string `json:"bases,omitempty"`

	// CustomFields Custom fields to add to the RNA sequence. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// CustomNotation Representation of the sequence or oligo in the custom notation specified by customNotationId
	CustomNotation *string `json:"customNotation,omitempty"`

	// CustomNotationId ID of the notation used to interpret the string provided in the customNotation field
	CustomNotationId *string `json:"customNotationId,omitempty"`

	// Fields Fields to set on the RNA sequence. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the RNA sequence.
	FolderId *string `json:"folderId,omitempty"`

	// Helm Representation of the RNA sequence in HELM syntax, including any chemical modifications
	Helm *string `json:"helm,omitempty"`

	// IsCircular Whether the RNA sequence is circular or linear. RNA sequences can only be linear
	IsCircular *bool `json:"isCircular,omitempty"`

	// Name Name of the RNA sequence.
	Name    *string            `json:"name,omitempty"`
	Parts   *[]RnaSequencePart `json:"parts,omitempty"`
	Primers *[]Primer          `json:"primers,omitempty"`

	// SchemaId ID of the RNA sequence's schema.
	SchemaId *string `json:"schemaId,omitempty"`

	// Translations Translations to create on the RNA sequence. Translations are specified by either a combination of 'start' and 'end' fields, or a list of regions. Both cannot be provided.
	Translations *[]Translation `json:"translations,omitempty"`
}

// RnaSequenceBaseRequestForCreate defines model for RnaSequenceBaseRequestForCreate.
type RnaSequenceBaseRequestForCreate struct {
	// Aliases Aliases to add to the RNA sequence
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations to create on the RNA sequence.
	Annotations *[]RnaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the RNA sequence's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs for the RNA sequence.
	Bases *string `json:"bases,omitempty"`

	// CustomFields Custom fields to add to the RNA sequence. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// CustomNotation Representation of the sequence or oligo in the custom notation specified by customNotationId
	CustomNotation *string `json:"customNotation,omitempty"`

	// CustomNotationId ID of the notation used to interpret the string provided in the customNotation field
	CustomNotationId *string `json:"customNotationId,omitempty"`

	// Fields Fields to set on the RNA sequence. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the RNA sequence.
	FolderId *string `json:"folderId,omitempty"`

	// Helm Representation of the RNA sequence in HELM syntax, including any chemical modifications
	Helm *string `json:"helm,omitempty"`

	// IsCircular Whether the RNA sequence is circular or linear. RNA sequences can only be linear
	IsCircular *bool `json:"isCircular,omitempty"`

	// Name Name of the RNA sequence.
	Name    string             `json:"name"`
	Parts   *[]RnaSequencePart `json:"parts,omitempty"`
	Primers *[]Primer          `json:"primers,omitempty"`

	// SchemaId ID of the RNA sequence's schema.
	SchemaId *string `json:"schemaId,omitempty"`

	// Translations Translations to create on the RNA sequence. Translations are specified by either a combination of 'start' and 'end' fields, or a list of regions. Both cannot be provided.
	Translations *[]Translation `json:"translations,omitempty"`
}

// RnaSequenceBulkCreate defines model for RnaSequenceBulkCreate.
type RnaSequenceBulkCreate = RnaSequenceCreate

// RnaSequenceBulkUpdate defines model for RnaSequenceBulkUpdate.
type RnaSequenceBulkUpdate struct {
	// Aliases Aliases to add to the RNA sequence
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations to create on the RNA sequence.
	Annotations *[]RnaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the RNA sequence's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs for the RNA sequence.
	Bases *string `json:"bases,omitempty"`

	// CustomFields Custom fields to add to the RNA sequence. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// CustomNotation Representation of the sequence or oligo in the custom notation specified by customNotationId
	CustomNotation *string `json:"customNotation,omitempty"`

	// CustomNotationId ID of the notation used to interpret the string provided in the customNotation field
	CustomNotationId *string `json:"customNotationId,omitempty"`

	// Fields Fields to set on the RNA sequence. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the RNA sequence.
	FolderId *string `json:"folderId,omitempty"`

	// Helm Representation of the RNA sequence in HELM syntax, including any chemical modifications
	Helm *string `json:"helm,omitempty"`
	Id   *string `json:"id,omitempty"`

	// IsCircular Whether the RNA sequence is circular or linear. RNA sequences can only be linear
	IsCircular *bool `json:"isCircular,omitempty"`

	// Name Name of the RNA sequence.
	Name    *string            `json:"name,omitempty"`
	Parts   *[]RnaSequencePart `json:"parts,omitempty"`
	Primers *[]Primer          `json:"primers,omitempty"`

	// SchemaId ID of the RNA sequence's schema.
	SchemaId *string `json:"schemaId,omitempty"`

	// Translations Translations to create on the RNA sequence. Translations are specified by either a combination of 'start' and 'end' fields, or a list of regions. Both cannot be provided.
	Translations *[]Translation `json:"translations,omitempty"`
}

// RnaSequenceCreate defines model for RnaSequenceCreate.
type RnaSequenceCreate struct {
	// Aliases Aliases to add to the RNA sequence
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations to create on the RNA sequence.
	Annotations *[]RnaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the RNA sequence's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs for the RNA sequence.
	Bases *string `json:"bases,omitempty"`

	// CustomFields Custom fields to add to the RNA sequence. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// CustomNotation Representation of the sequence or oligo in the custom notation specified by customNotationId
	CustomNotation *string `json:"customNotation,omitempty"`

	// CustomNotationId ID of the notation used to interpret the string provided in the customNotation field
	CustomNotationId *string `json:"customNotationId,omitempty"`

	// EntityRegistryId Entity registry ID to set for the registered entity. Cannot specify both entityRegistryId and namingStrategy at the same time.
	EntityRegistryId *string `json:"entityRegistryId,omitempty"`

	// Fields Fields to set on the RNA sequence. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the entity. Can be left empty when registryId is present.
	FolderId *string `json:"folderId,omitempty"`

	// Helm Representation of the RNA sequence in HELM syntax, including any chemical modifications
	Helm *string `json:"helm,omitempty"`

	// IsCircular Whether the RNA sequence is circular or linear. RNA sequences can only be linear
	IsCircular *bool `json:"isCircular,omitempty"`

	// Name Name of the RNA sequence.
	Name string `json:"name"`

	// NamingStrategy Specifies the behavior for automatically generated names when registering an entity.
	// - NEW_IDS: Generate new registry IDs
	// - IDS_FROM_NAMES: Generate registry IDs based on entity names
	// - DELETE_NAMES: Generate new registry IDs and replace name with registry ID
	// - SET_FROM_NAME_PARTS: Generate new registry IDs, rename according to name template, and keep old name as alias
	// - REPLACE_NAMES_FROM_PARTS: Generate new registry IDs, and replace name according to name template
	// - KEEP_NAMES: Keep existing entity names as registry IDs
	// - REPLACE_ID_AND_NAME_FROM_PARTS: Generate registry IDs and names according to name template
	NamingStrategy *NamingStrategy    `json:"namingStrategy,omitempty"`
	Parts          *[]RnaSequencePart `json:"parts,omitempty"`
	Primers        *[]Primer          `json:"primers,omitempty"`

	// RegistryId Registry ID into which entity should be registered. this is the ID of the registry which was configured for a particular organization
	// To get available registryIds, use the [/registries endpoint](#/Registry/listRegistries)
	//
	// Required in order for entities to be created directly in the registry.
	RegistryId *string `json:"registryId,omitempty"`

	// SchemaId ID of the RNA sequence's schema.
	SchemaId *string `json:"schemaId,omitempty"`

	// Translations Translations to create on the RNA sequence. Translations are specified by either a combination of 'start' and 'end' fields, or a list of regions. Both cannot be provided.
	Translations *[]Translation `json:"translations,omitempty"`
}

// RnaSequencePart defines model for RnaSequencePart.
type RnaSequencePart struct {
	// End 0-based exclusive end index. The end of the sequence is always represented as 0.
	End        *int    `json:"end,omitempty"`
	SequenceId *string `json:"sequenceId,omitempty"`

	// Start 0-based inclusive start index.
	Start  *int `json:"start,omitempty"`
	Strand *int `json:"strand,omitempty"`
}

// RnaSequenceRequestRegistryFields defines model for RnaSequenceRequestRegistryFields.
type RnaSequenceRequestRegistryFields struct {
	EntityRegistryId *string `json:"entityRegistryId,omitempty"`
}

// RnaSequenceUpdate defines model for RnaSequenceUpdate.
type RnaSequenceUpdate struct {
	// Aliases Aliases to add to the RNA sequence
	Aliases *[]string `json:"aliases,omitempty"`

	// Annotations Annotations to create on the RNA sequence.
	Annotations *[]RnaAnnotation `json:"annotations,omitempty"`

	// AuthorIds IDs of users to set as the RNA sequence's authors.
	AuthorIds *[]string `json:"authorIds,omitempty"`

	// Bases Base pairs for the RNA sequence.
	Bases *string `json:"bases,omitempty"`

	// CustomFields Custom fields to add to the RNA sequence. Every field should have its name as a key, mapping to an object with information about the value of the field.
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// CustomNotation Representation of the sequence or oligo in the custom notation specified by customNotationId
	CustomNotation *string `json:"customNotation,omitempty"`

	// CustomNotationId ID of the notation used to interpret the string provided in the customNotation field
	CustomNotationId *string `json:"customNotationId,omitempty"`
	EntityRegistryId *string `json:"entityRegistryId,omitempty"`

	// Fields Fields to set on the RNA sequence. Must correspond with the schema's field definitions. Every field should have its name as a key, mapping to an object with information about the value of the field.
	Fields *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder containing the RNA sequence.
	FolderId *string `json:"folderId,omitempty"`

	// Helm Representation of the RNA sequence in HELM syntax, including any chemical modifications
	Helm *string `json:"helm,omitempty"`

	// IsCircular Whether the RNA sequence is circular or linear. RNA sequences can only be linear
	IsCircular *bool `json:"isCircular,omitempty"`

	// Name Name of the RNA sequence.
	Name    *string            `json:"name,omitempty"`
	Parts   *[]RnaSequencePart `json:"parts,omitempty"`
	Primers *[]Primer          `json:"primers,omitempty"`

	// SchemaId ID of the RNA sequence's schema.
	SchemaId *string `json:"schemaId,omitempty"`

	// Translations Translations to create on the RNA sequence. Translations are specified by either a combination of 'start' and 'end' fields, or a list of regions. Both cannot be provided.
	Translations *[]Translation `json:"translations,omitempty"`
}

// RnaSequencesArchivalChange IDs of all RNA Sequences that were archived or unarchived, grouped by resource type.
type RnaSequencesArchivalChange struct {
	RnaSequenceIds *[]string `json:"rnaSequenceIds,omitempty"`
}

// RnaSequencesArchive The request body for archiving RNA sequences.
type RnaSequencesArchive struct {
	// Reason The reason for archiving the provided entities. Accepted reasons may differ based on tenant configuration.
	Reason         EntityArchiveReason `json:"reason"`
	RnaSequenceIds []string            `json:"rnaSequenceIds"`
}

// RnaSequencesBulkCreateRequest defines model for RnaSequencesBulkCreateRequest.
type RnaSequencesBulkCreateRequest struct {
	RnaSequences *[]RnaSequenceBulkCreate `json:"rnaSequences,omitempty"`
}

// RnaSequencesBulkGet defines model for RnaSequencesBulkGet.
type RnaSequencesBulkGet struct {
	RnaSequences *[]RnaSequence `json:"rnaSequences,omitempty"`
}

// RnaSequencesBulkUpdateRequest defines model for RnaSequencesBulkUpdateRequest.
type RnaSequencesBulkUpdateRequest struct {
	RnaSequences *[]RnaSequenceBulkUpdate `json:"rnaSequences,omitempty"`
}

// RnaSequencesPaginatedList defines model for RnaSequencesPaginatedList.
type RnaSequencesPaginatedList struct {
	NextToken    *string        `json:"nextToken,omitempty"`
	RnaSequences *[]RnaSequence `json:"rnaSequences,omitempty"`
}

// RnaSequencesUnarchive The request body for unarchiving RNA sequences.
type RnaSequencesUnarchive struct {
	RnaSequenceIds []string `json:"rnaSequenceIds"`
}

// SampleGroup Represents a sample group that is an input to a request. A sample group is a set of samples upon which work in the request should be done.
type SampleGroup struct {
	Id      *string                 `json:"id,omitempty"`
	Samples *map[string]interface{} `json:"samples,omitempty"`
}

// SampleGroupStatus Status of a sample group
type SampleGroupStatus string

// SampleGroupStatusUpdate defines model for SampleGroupStatusUpdate.
type SampleGroupStatusUpdate struct {
	// SampleGroupId The string id of the sample group
	SampleGroupId string `json:"sampleGroupId"`

	// Status Status of a sample group
	Status SampleGroupStatus `json:"status"`
}

// SampleGroupsStatusUpdate Specification to update status of sample groups on the request which were executed.
type SampleGroupsStatusUpdate struct {
	SampleGroups []SampleGroupStatusUpdate `json:"sampleGroups"`
}

// SampleRestrictionStatus defines model for SampleRestrictionStatus.
type SampleRestrictionStatus string

// Schema defines model for Schema.
type Schema struct {
	ArchiveRecord    *ArchiveRecord                  `json:"archiveRecord"`
	FieldDefinitions *[]Schema_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Id               *string                         `json:"id,omitempty"`
	Name             *string                         `json:"name,omitempty"`
	Type             *string                         `json:"type,omitempty"`
}

// Schema_FieldDefinitions_Item defines model for Schema.fieldDefinitions.Item.
type Schema_FieldDefinitions_Item struct {
	union json.RawMessage
}

// SchemaDependencySubtypes defines model for SchemaDependencySubtypes.
type SchemaDependencySubtypes string

// SchemaFieldsQueryParam defines model for SchemaFieldsQueryParam.
type SchemaFieldsQueryParam map[string]interface{}

// SchemaLinkFieldDefinition defines model for SchemaLinkFieldDefinition.
type SchemaLinkFieldDefinition struct {
	ArchiveRecord *ArchiveRecord                 `json:"archiveRecord"`
	Id            *string                        `json:"id,omitempty"`
	IsMulti       *bool                          `json:"isMulti,omitempty"`
	IsRequired    *bool                          `json:"isRequired,omitempty"`
	Name          *string                        `json:"name,omitempty"`
	SchemaId      *string                        `json:"schemaId"`
	Type          *SchemaLinkFieldDefinitionType `json:"type,omitempty"`
}

// SchemaLinkFieldDefinitionType defines model for SchemaLinkFieldDefinition.Type.
type SchemaLinkFieldDefinitionType string

// SchemaSummary defines model for SchemaSummary.
type SchemaSummary struct {
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// SearchBasesRequest defines model for SearchBasesRequest.
type SearchBasesRequest struct {
	ArchiveReason *SearchBasesRequestArchiveReason `json:"archiveReason,omitempty"`
	Bases         string                           `json:"bases"`
	NextToken     *string                          `json:"nextToken,omitempty"`
	PageSize      *int                             `json:"pageSize,omitempty"`

	// RegistryId ID of a registry. Restricts results to those registered in this registry. Specifying `null` returns unregistered items.
	RegistryId *string `json:"registryId"`

	// SchemaId ID of the nucleotide sequence's schema.
	SchemaId *string                 `json:"schemaId,omitempty"`
	Sort     *SearchBasesRequestSort `json:"sort,omitempty"`
}

// SearchBasesRequestArchiveReason defines model for SearchBasesRequest.ArchiveReason.
type SearchBasesRequestArchiveReason string

// SearchBasesRequestSort defines model for SearchBasesRequest.Sort.
type SearchBasesRequestSort string

// SearchInputMultiValueUiBlock defines model for SearchInputMultiValueUiBlock.
type SearchInputMultiValueUiBlock struct {
	Enabled  *bool                            `json:"enabled"`
	Id       string                           `json:"id"`
	ItemType SearchInputUiBlockItemType       `json:"itemType"`
	Label    *string                          `json:"label"`
	SchemaId *string                          `json:"schemaId"`
	Type     SearchInputMultiValueUiBlockType `json:"type"`
	Value    *[]string                        `json:"value"`
}

// SearchInputMultiValueUiBlockType defines model for SearchInputMultiValueUiBlock.Type.
type SearchInputMultiValueUiBlockType string

// SearchInputMultiValueUiBlockCreate defines model for SearchInputMultiValueUiBlockCreate.
type SearchInputMultiValueUiBlockCreate = SearchInputMultiValueUiBlock

// SearchInputMultiValueUiBlockUpdate defines model for SearchInputMultiValueUiBlockUpdate.
type SearchInputMultiValueUiBlockUpdate = SearchInputMultiValueUiBlock

// SearchInputUiBlock defines model for SearchInputUiBlock.
type SearchInputUiBlock struct {
	Enabled  *bool                      `json:"enabled"`
	Id       string                     `json:"id"`
	ItemType SearchInputUiBlockItemType `json:"itemType"`
	Label    *string                    `json:"label"`
	SchemaId *string                    `json:"schemaId"`
	Type     SearchInputUiBlockType     `json:"type"`
	Value    *string                    `json:"value"`
}

// SearchInputUiBlockType defines model for SearchInputUiBlock.Type.
type SearchInputUiBlockType string

// SearchInputUiBlockCreate defines model for SearchInputUiBlockCreate.
type SearchInputUiBlockCreate = SearchInputUiBlock

// SearchInputUiBlockItemType defines model for SearchInputUiBlockItemType.
type SearchInputUiBlockItemType string

// SearchInputUiBlockUpdate defines model for SearchInputUiBlockUpdate.
type SearchInputUiBlockUpdate = SearchInputUiBlock

// SectionUiBlock defines model for SectionUiBlock.
type SectionUiBlock struct {
	Children []SectionUiBlock_Children_Item `json:"children"`
	Id       *string                        `json:"id,omitempty"`
	Type     *SectionUiBlockType            `json:"type,omitempty"`
}

// SectionUiBlock_Children_Item defines model for SectionUiBlock.children.Item.
type SectionUiBlock_Children_Item struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// SectionUiBlockType defines model for SectionUiBlock.Type.
type SectionUiBlockType string

// SectionUiBlockCreate defines model for SectionUiBlockCreate.
type SectionUiBlockCreate = SectionUiBlock

// SectionUiBlockUpdate defines model for SectionUiBlockUpdate.
type SectionUiBlockUpdate = SectionUiBlock

// SecureTextAppConfigItem defines model for SecureTextAppConfigItem.
type SecureTextAppConfigItem struct {
	ApiURL *string `json:"apiURL,omitempty"`
	App    *struct {
		// Id The id of the Benchling app to which this configuration item belongs
		Id *string `json:"id,omitempty"`
	} `json:"app,omitempty"`

	// CreatedAt DateTime the app config item was created
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	Description *string    `json:"description,omitempty"`
	Id          *string    `json:"id,omitempty"`

	// ModifiedAt DateTime the app config item was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path           *[]string                    `json:"path,omitempty"`
	RequiredConfig *bool                        `json:"requiredConfig,omitempty"`
	Type           *SecureTextAppConfigItemType `json:"type,omitempty"`
	Value          *string                      `json:"value"`
}

// SecureTextAppConfigItemType defines model for SecureTextAppConfigItem.Type.
type SecureTextAppConfigItemType string

// SelectorInputMultiValueUiBlock defines model for SelectorInputMultiValueUiBlock.
type SelectorInputMultiValueUiBlock struct {
	Enabled *bool                              `json:"enabled"`
	Id      string                             `json:"id"`
	Label   *string                            `json:"label"`
	Options []string                           `json:"options"`
	Type    SelectorInputMultiValueUiBlockType `json:"type"`
	Value   *[]string                          `json:"value"`
}

// SelectorInputMultiValueUiBlockType defines model for SelectorInputMultiValueUiBlock.Type.
type SelectorInputMultiValueUiBlockType string

// SelectorInputMultiValueUiBlockCreate defines model for SelectorInputMultiValueUiBlockCreate.
type SelectorInputMultiValueUiBlockCreate = SelectorInputMultiValueUiBlock

// SelectorInputMultiValueUiBlockUpdate defines model for SelectorInputMultiValueUiBlockUpdate.
type SelectorInputMultiValueUiBlockUpdate = SelectorInputMultiValueUiBlock

// SelectorInputUiBlock defines model for SelectorInputUiBlock.
type SelectorInputUiBlock struct {
	Enabled *bool                    `json:"enabled"`
	Id      string                   `json:"id"`
	Label   *string                  `json:"label"`
	Options []string                 `json:"options"`
	Type    SelectorInputUiBlockType `json:"type"`
	Value   *string                  `json:"value"`
}

// SelectorInputUiBlockType defines model for SelectorInputUiBlock.Type.
type SelectorInputUiBlockType string

// SelectorInputUiBlockCreate defines model for SelectorInputUiBlockCreate.
type SelectorInputUiBlockCreate = SelectorInputUiBlock

// SelectorInputUiBlockUpdate defines model for SelectorInputUiBlockUpdate.
type SelectorInputUiBlockUpdate = SelectorInputUiBlock

// SequenceFeatureBase defines model for SequenceFeatureBase.
type SequenceFeatureBase struct {
	// Color Hex color code used when displaying this feature in the UI.
	Color        *string                       `json:"color,omitempty"`
	CustomFields *[]SequenceFeatureCustomField `json:"customFields,omitempty"`
	Name         *string                       `json:"name,omitempty"`
	Notes        *string                       `json:"notes,omitempty"`
}

// SequenceFeatureCustomField A name and value pair associated with a sequence feature (annotation or translation). For genbank imports, these are the qualifiers associated with each feature.
type SequenceFeatureCustomField struct {
	// Name Name of the custom field
	Name *string `json:"name,omitempty"`

	// Value Value of the custom field
	Value *string `json:"value,omitempty"`
}

// SimpleFieldDefinition defines model for SimpleFieldDefinition.
type SimpleFieldDefinition struct {
	ArchiveRecord *ArchiveRecord             `json:"archiveRecord"`
	Id            *string                    `json:"id,omitempty"`
	IsMulti       *bool                      `json:"isMulti,omitempty"`
	IsRequired    *bool                      `json:"isRequired,omitempty"`
	Name          *string                    `json:"name,omitempty"`
	Type          *SimpleFieldDefinitionType `json:"type,omitempty"`
}

// SimpleFieldDefinitionType defines model for SimpleFieldDefinition.Type.
type SimpleFieldDefinitionType string

// SimpleNotePart defines model for SimpleNotePart.
type SimpleNotePart struct {
	// Indentation All notes have an indentation level - the default is 0 for no indent. For lists, indentation gives notes hierarchy - a bulleted list with children is modeled as one note part with indentation 1 followed by note parts with indentation 2, for example.
	Indentation *int `json:"indentation,omitempty"`

	// Links Array of links referenced in text via an @-mention, hyperlink, or the drag-n-dropped preview attached to the note.
	Links *[]EntryLink `json:"links,omitempty"`

	// Text The textual contents of the note.
	Text *string             `json:"text,omitempty"`
	Type *SimpleNotePartType `json:"type,omitempty"`
}

// SimpleNotePartType defines model for SimpleNotePart.Type.
type SimpleNotePartType string

// StageEntry A notebook entry used for execution of one or more stage runs in a legacy workflow.
type StageEntry struct {
	// ApiURL The canonical url of the Stage Entry in the API.
	ApiURL *string `json:"apiURL,omitempty"`

	// Authors Array of UserSummary Resources of the authors of the stage entry. This defaults to the creator but can be manually changed.
	Authors *[]UserSummary `json:"authors,omitempty"`

	// CreatedAt DateTime the stage entry was created at
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Creator UserSummary Resource of the user who created the stage entry
	Creator      *UserSummary  `json:"creator,omitempty"`
	CustomFields *CustomFields `json:"customFields,omitempty"`

	// DisplayId User-friendly ID of the stage entry
	DisplayId *string `json:"displayId,omitempty"`
	Fields    *Fields `json:"fields,omitempty"`

	// FolderId ID of the folder that contains the stage entry
	FolderId *string `json:"folderId,omitempty"`

	// Id ID of the stage entry
	Id *string `json:"id,omitempty"`

	// ModifiedAt DateTime the stage entry was last modified
	ModifiedAt *string `json:"modifiedAt,omitempty"`

	// Name Title of the stage entry
	Name *string `json:"name,omitempty"`

	// ReviewRecord Review record if set
	ReviewRecord *map[string]interface{} `json:"reviewRecord"`

	// Schema Entry schema if set
	Schema *EntrySchema `json:"schema"`

	// WebURL URL of the stage entry
	WebURL *string `json:"webURL,omitempty"`

	// WorkflowId ID of the parent workflow
	WorkflowId *string `json:"workflowId,omitempty"`

	// WorkflowStageId ID of the associated workflow stage
	WorkflowStageId *string `json:"workflowStageId,omitempty"`
}

// StageEntryCreatedEvent defines model for StageEntryCreatedEvent.
type StageEntryCreatedEvent = EventBase

// StageEntryUpdatedFieldsEvent defines model for StageEntryUpdatedFieldsEvent.
type StageEntryUpdatedFieldsEvent struct {
	CreatedAt  *time.Time                             `json:"createdAt,omitempty"`
	Deprecated *bool                                  `json:"deprecated,omitempty"`
	EventType  *StageEntryUpdatedFieldsEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`

	// StageEntry A notebook entry used for execution of one or more stage runs in a legacy workflow.
	StageEntry *StageEntry `json:"stageEntry,omitempty"`

	// Updates These properties have been updated, causing this message
	Updates *[]string `json:"updates,omitempty"`
}

// StageEntryUpdatedFieldsEventEventType defines model for StageEntryUpdatedFieldsEvent.EventType.
type StageEntryUpdatedFieldsEventEventType string

// StageEntryUpdatedReviewRecordEvent defines model for StageEntryUpdatedReviewRecordEvent.
type StageEntryUpdatedReviewRecordEvent struct {
	CreatedAt  *time.Time `json:"createdAt,omitempty"`
	Deprecated *bool      `json:"deprecated,omitempty"`

	// Entry A notebook entry used for execution of one or more stage runs in a legacy workflow.
	Entry     *StageEntry                                  `json:"entry,omitempty"`
	EventType *StageEntryUpdatedReviewRecordEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`

	// Updates These properties have been updated, causing this message
	Updates *[]string `json:"updates,omitempty"`
}

// StageEntryUpdatedReviewRecordEventEventType defines model for StageEntryUpdatedReviewRecordEvent.EventType.
type StageEntryUpdatedReviewRecordEventEventType string

// StructuredTableApiIdentifiers defines model for StructuredTableApiIdentifiers.
type StructuredTableApiIdentifiers struct {
	ApiId   *string                      `json:"apiId,omitempty"`
	Columns *[]StructuredTableColumnInfo `json:"columns,omitempty"`
}

// StructuredTableColumnInfo defines model for StructuredTableColumnInfo.
type StructuredTableColumnInfo struct {
	ColumnId   *string `json:"columnId,omitempty"`
	IsReadOnly *bool   `json:"isReadOnly,omitempty"`
	Name       *string `json:"name,omitempty"`
}

// TableNotePart defines model for TableNotePart.
type TableNotePart struct {
	// Indentation All notes have an indentation level - the default is 0 for no indent. For lists, indentation gives notes hierarchy - a bulleted list with children is modeled as one note part with indentation 1 followed by note parts with indentation 2, for example.
	Indentation *int `json:"indentation,omitempty"`

	// Links Array of links referenced in the caption via an @-mention, hyperlink, or the drag-n-dropped preview attached to the note.
	Links *[]EntryLink `json:"links,omitempty"`
	Table *EntryTable  `json:"table,omitempty"`

	// Text The caption of the table.
	Text *string            `json:"text,omitempty"`
	Type *TableNotePartType `json:"type,omitempty"`
}

// TableNotePartType defines model for TableNotePart.Type.
type TableNotePartType string

// TableUiBlock defines model for TableUiBlock.
type TableUiBlock struct {
	Enabled *bool  `json:"enabled"`
	Id      string `json:"id"`

	// Name Display name for the table block, to be shown in the UI
	Name   string             `json:"name"`
	Source TableUiBlockSource `json:"source"`
	Type   TableUiBlockType   `json:"type"`
}

// TableUiBlockType defines model for TableUiBlock.Type.
type TableUiBlockType string

// TableUiBlockCreate defines model for TableUiBlockCreate.
type TableUiBlockCreate = TableUiBlock

// TableUiBlockDataFrameSource defines model for TableUiBlockDataFrameSource.
type TableUiBlockDataFrameSource struct {
	// DataFrameId `dataFrameId` of an uploaded data frame (see [Create Data Frame endpoint](https://benchling.com/api/v2-beta/reference#/Data%20Frames)). Note: Canvas tables currently support only text-type columns.
	DataFrameId *string                         `json:"dataFrameId"`
	Type        TableUiBlockDataFrameSourceType `json:"type"`
}

// TableUiBlockDataFrameSourceType defines model for TableUiBlockDataFrameSource.Type.
type TableUiBlockDataFrameSourceType string

// TableUiBlockDatasetSource defines model for TableUiBlockDatasetSource.
type TableUiBlockDatasetSource struct {
	// DatasetId `datasetId` of an uploaded dataset (see [Create Data Frame endpoint](https://benchling.com/api/v2-beta/reference#/Data%20Frames)). Note: Canvas tables currently support only text-type columns. Datasets are currently undergoing re-work. datasetId will refer to a DataFrame until Dataset APIs are stable. Prefer `TableUiBlockDataFrameSource` meanwhile.
	DatasetId *string                       `json:"datasetId"`
	Type      TableUiBlockDatasetSourceType `json:"type"`
}

// TableUiBlockDatasetSourceType defines model for TableUiBlockDatasetSource.Type.
type TableUiBlockDatasetSourceType string

// TableUiBlockSource defines model for TableUiBlockSource.
type TableUiBlockSource struct {
	Type  string `json:"type"`
	union json.RawMessage
}

// TableUiBlockUpdate defines model for TableUiBlockUpdate.
type TableUiBlockUpdate = TableUiBlock

// Team defines model for Team.
type Team struct {
	Handle       *string              `json:"handle,omitempty"`
	Id           *string              `json:"id,omitempty"`
	Name         *string              `json:"name,omitempty"`
	Organization *OrganizationSummary `json:"organization,omitempty"`
}

// TeamSummary defines model for TeamSummary.
type TeamSummary struct {
	Handle *string `json:"handle,omitempty"`
	Id     *string `json:"id,omitempty"`
	Name   *string `json:"name,omitempty"`
}

// TeamsPaginatedList defines model for TeamsPaginatedList.
type TeamsPaginatedList struct {
	NextToken *string `json:"nextToken,omitempty"`
	Teams     *[]Team `json:"teams,omitempty"`
}

// TextAppConfigItem defines model for TextAppConfigItem.
type TextAppConfigItem struct {
	ApiURL *string `json:"apiURL,omitempty"`
	App    *struct {
		// Id The id of the Benchling app to which this configuration item belongs
		Id *string `json:"id,omitempty"`
	} `json:"app,omitempty"`

	// CreatedAt DateTime the app config item was created
	CreatedAt   *time.Time `json:"createdAt,omitempty"`
	Description *string    `json:"description,omitempty"`
	Id          *string    `json:"id,omitempty"`

	// ModifiedAt DateTime the app config item was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Path Array-based representation of config item's location in the tree in order from top to bottom.
	Path           *[]string              `json:"path,omitempty"`
	RequiredConfig *bool                  `json:"requiredConfig,omitempty"`
	Type           *TextAppConfigItemType `json:"type,omitempty"`
	Value          *string                `json:"value"`
}

// TextAppConfigItemType defines model for TextAppConfigItem.Type.
type TextAppConfigItemType string

// TextBoxNotePart defines model for TextBoxNotePart.
type TextBoxNotePart struct {
	// Indentation All notes have an indentation level - the default is 0 for no indent. For lists, indentation gives notes hierarchy - a bulleted list with children is modeled as one note part with indentation 1 followed by note parts with indentation 2, for example.
	Indentation *int `json:"indentation,omitempty"`

	// Links Array of links referenced via an @-mention, hyperlink, or the drag-n-dropped preview attached to the note.
	Links *[]EntryLink         `json:"links,omitempty"`
	Name  *string              `json:"name,omitempty"`
	Text  *string              `json:"text,omitempty"`
	Type  *TextBoxNotePartType `json:"type,omitempty"`
}

// TextBoxNotePartType defines model for TextBoxNotePart.Type.
type TextBoxNotePartType string

// TextInputUiBlock defines model for TextInputUiBlock.
type TextInputUiBlock struct {
	Enabled     *bool                `json:"enabled"`
	Id          string               `json:"id"`
	Label       *string              `json:"label"`
	Placeholder *string              `json:"placeholder"`
	Type        TextInputUiBlockType `json:"type"`
	Value       *string              `json:"value"`
}

// TextInputUiBlockType defines model for TextInputUiBlock.Type.
type TextInputUiBlockType string

// TextInputUiBlockCreate defines model for TextInputUiBlockCreate.
type TextInputUiBlockCreate = TextInputUiBlock

// TextInputUiBlockUpdate defines model for TextInputUiBlockUpdate.
type TextInputUiBlockUpdate = TextInputUiBlock

// TokenCreate defines model for TokenCreate.
type TokenCreate struct {
	// ClientId ID of client to request token for. Leave off if client ID and secret are being supplied through Authorization header.
	ClientId *string `json:"client_id,omitempty"`

	// ClientSecret Leave off if client ID and secret are being supplied through Authorization header.
	ClientSecret *string              `json:"client_secret,omitempty"`
	GrantType    TokenCreateGrantType `json:"grant_type"`
}

// TokenCreateGrantType defines model for TokenCreate.GrantType.
type TokenCreateGrantType string

// TokenResponse defines model for TokenResponse.
type TokenResponse struct {
	AccessToken *string `json:"access_token,omitempty"`

	// ExpiresIn Number of seconds that token is valid for
	ExpiresIn *int                    `json:"expires_in,omitempty"`
	TokenType *TokenResponseTokenType `json:"token_type,omitempty"`
}

// TokenResponseTokenType defines model for TokenResponse.TokenType.
type TokenResponseTokenType string

// TransfersAsyncTask defines model for TransfersAsyncTask.
type TransfersAsyncTask struct {
	// Errors Present only when status is FAILED for a bulk task. Contains information about the individual errors in the bulk task.
	Errors *map[string]interface{} `json:"errors,omitempty"`

	// Message Present only when status is FAILED. Contains information about the error.
	Message  *string `json:"message,omitempty"`
	Response *struct {
		DestinationContainers *[]Container `json:"destinationContainers,omitempty"`
	} `json:"response,omitempty"`

	// Status The current state of the task.
	Status TransfersAsyncTaskStatus `json:"status"`
}

// TransfersAsyncTaskStatus The current state of the task.
type TransfersAsyncTaskStatus string

// Translation defines model for Translation.
type Translation struct {
	AminoAcids *string `json:"aminoAcids,omitempty"`

	// Color Hex color code used when displaying this feature in the UI.
	Color        *string                       `json:"color,omitempty"`
	CustomFields *[]SequenceFeatureCustomField `json:"customFields,omitempty"`

	// End 0-based exclusive end index. The end of the sequence is always represented as 0.
	End *int `json:"end,omitempty"`

	// GeneticCode The genetic code to use when translating the nucleotide sequence into amino acids.
	GeneticCode *TranslationGeneticCode `json:"geneticCode,omitempty"`
	Name        *string                 `json:"name,omitempty"`
	Notes       *string                 `json:"notes,omitempty"`
	Regions     *[]struct {
		// End 0-based exclusive end index. The end of the sequence is always represented as 0.
		End *int `json:"end,omitempty"`

		// Start 0-based inclusive start index.
		Start *int `json:"start,omitempty"`
	} `json:"regions,omitempty"`

	// Start 0-based inclusive start index.
	Start  *int `json:"start,omitempty"`
	Strand *int `json:"strand,omitempty"`
}

// TranslationGeneticCode The genetic code to use when translating the nucleotide sequence into amino acids.
type TranslationGeneticCode string

// UnitSummary defines model for UnitSummary.
type UnitSummary struct {
	Id         *string `json:"id,omitempty"`
	Name       *string `json:"name,omitempty"`
	Symbol     *string `json:"symbol,omitempty"`
	UnitTypeId *string `json:"unitTypeId,omitempty"`
}

// UnregisterEntities defines model for UnregisterEntities.
type UnregisterEntities struct {
	// EntityIds Array of entity IDs
	EntityIds []string `json:"entityIds"`

	// FolderId ID of the folder that the entities should be moved to
	FolderId string `json:"folderId"`
}

// UpdateEventMixin defines model for UpdateEventMixin.
type UpdateEventMixin struct {
	// Updates These properties have been updated, causing this message
	Updates *[]string `json:"updates,omitempty"`
}

// User defines model for User.
type User struct {
	ApiKeyLastChangedAt   *string `json:"apiKeyLastChangedAt"`
	Email                 *string `json:"email,omitempty"`
	Handle                *string `json:"handle,omitempty"`
	Id                    *string `json:"id,omitempty"`
	IsSuspended           *bool   `json:"isSuspended,omitempty"`
	Name                  *string `json:"name,omitempty"`
	PasswordLastChangedAt *string `json:"passwordLastChangedAt"`
}

// UserActivity defines model for UserActivity.
type UserActivity struct {
	LastSeen *time.Time `json:"lastSeen"`
	UserId   *string    `json:"userId,omitempty"`
}

// UserBulkCreateRequest defines model for UserBulkCreateRequest.
type UserBulkCreateRequest struct {
	Users *[]UserCreate `json:"users,omitempty"`
}

// UserBulkUpdate defines model for UserBulkUpdate.
type UserBulkUpdate struct {
	// Email Email of the User
	Email *string `json:"email,omitempty"`

	// Handle Handle of the User
	Handle *string `json:"handle,omitempty"`
	Id     string  `json:"id"`

	// IsSuspended Suspended status of the User
	IsSuspended *bool `json:"isSuspended,omitempty"`

	// Name Name of the User
	Name *string `json:"name,omitempty"`
}

// UserBulkUpdateRequest defines model for UserBulkUpdateRequest.
type UserBulkUpdateRequest struct {
	Users *[]UserBulkUpdate `json:"users,omitempty"`
}

// UserCreate defines model for UserCreate.
type UserCreate struct {
	// Email Email of the User
	Email string `json:"email"`

	// Handle Handle of the User
	Handle string `json:"handle"`

	// Name Name of the User
	Name string `json:"name"`
}

// UserInputMultiValueUiBlock defines model for UserInputMultiValueUiBlock.
type UserInputMultiValueUiBlock struct {
	Enabled *bool     `json:"enabled"`
	Id      string    `json:"id"`
	Label   *string   `json:"label"`
	Value   *[]string `json:"value"`
}

// UserInputUiBlock defines model for UserInputUiBlock.
type UserInputUiBlock struct {
	Enabled *bool   `json:"enabled"`
	Id      string  `json:"id"`
	Label   *string `json:"label"`
	Value   *string `json:"value"`
}

// UserSummary defines model for UserSummary.
type UserSummary struct {
	Handle *string `json:"handle,omitempty"`
	Id     *string `json:"id,omitempty"`
	Name   *string `json:"name,omitempty"`
}

// UserUpdate defines model for UserUpdate.
type UserUpdate struct {
	// Email Email of the User
	Email *string `json:"email,omitempty"`

	// Handle Handle of the User
	Handle *string `json:"handle,omitempty"`

	// IsSuspended Suspended status of the User
	IsSuspended *bool `json:"isSuspended,omitempty"`

	// Name Name of the User
	Name *string `json:"name,omitempty"`
}

// UserValidation defines model for UserValidation.
type UserValidation struct {
	// ValidationComment A string explaining the reason for the provided validation status.
	ValidationComment *string `json:"validationComment,omitempty"`

	// ValidationStatus Valid values for this enum depend on whether it is used to set a value (e.g., in a POST request), or is a return value for an existing result.
	// Acceptable values for setting a status are 'VALID' or 'INVALID'. Possible return values are 'VALID', 'INVALID', or 'PARTIALLY_VALID' (a result will be partially valid if it has some valid fields and some invalid fields).
	ValidationStatus *UserValidationValidationStatus `json:"validationStatus,omitempty"`
}

// UserValidationValidationStatus Valid values for this enum depend on whether it is used to set a value (e.g., in a POST request), or is a return value for an existing result.
// Acceptable values for setting a status are 'VALID' or 'INVALID'. Possible return values are 'VALID', 'INVALID', or 'PARTIALLY_VALID' (a result will be partially valid if it has some valid fields and some invalid fields).
type UserValidationValidationStatus string

// UsersPaginatedList defines model for UsersPaginatedList.
type UsersPaginatedList struct {
	NextToken *string `json:"nextToken,omitempty"`
	Users     *[]User `json:"users,omitempty"`
}

// WarehouseCredentials defines model for WarehouseCredentials.
type WarehouseCredentials struct {
	// ExpiresAt The time after which new connections using the username/password will not be permitted. Upon expiration, currently open connections are not terminated.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Password The password to connect to the warehouse.
	Password *string `json:"password,omitempty"`

	// Username The username to connect to the warehouse.
	Username *string `json:"username,omitempty"`
}

// WarehouseCredentialsCreate defines model for WarehouseCredentialsCreate.
type WarehouseCredentialsCreate struct {
	// ExpiresIn Duration, in seconds, that credentials should be active for. Must be greater than 0 and less than 3600.
	ExpiresIn int `json:"expiresIn"`
}

// Well defines model for Well.
type Well struct {
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`

	// Barcode Barcode of the well
	Barcode        *string         `json:"barcode,omitempty"`
	CheckoutRecord *CheckoutRecord `json:"checkoutRecord,omitempty"`

	// Contents Array of well contents, each with a batch and concentration
	Contents *[]ContainerContent `json:"contents,omitempty"`

	// CreatedAt DateTime the well was created
	CreatedAt *time.Time   `json:"createdAt,omitempty"`
	Creator   *UserSummary `json:"creator,omitempty"`
	Fields    *Fields      `json:"fields,omitempty"`

	// Id ID of the well
	Id *string `json:"id,omitempty"`

	// ModifiedAt DateTime the well was last modified
	ModifiedAt *time.Time `json:"modifiedAt,omitempty"`

	// Name Name of the well, defaults to barcode if name is not provided.
	Name *string `json:"name,omitempty"`

	// ParentStorageId ID of containing parent inventory, a plate well with a coordinate (e.g. plt_2bAks9dx:a2).
	ParentStorageId     *string        `json:"parentStorageId"`
	ParentStorageSchema *SchemaSummary `json:"parentStorageSchema,omitempty"`

	// ProjectId ID of the project if set
	ProjectId *string `json:"projectId"`

	// Quantity Quantity of a container, well, or transfer. Supports mass, volume, and other quantities.
	Quantity     *ContainerQuantity `json:"quantity,omitempty"`
	ResourceType *WellResourceType  `json:"resourceType,omitempty"`

	// RestrictedSampleParties Not applicable for fixed plate wells.
	RestrictedSampleParties *[]Well_RestrictedSampleParties_Item `json:"restrictedSampleParties,omitempty"`

	// RestrictionStatus Not applicable for fixed plate wells.
	RestrictionStatus *SampleRestrictionStatus `json:"restrictionStatus,omitempty"`

	// SampleOwners Not applicable for fixed plate wells.
	SampleOwners *[]Well_SampleOwners_Item             `json:"sampleOwners,omitempty"`
	Schema       *SchemaSummary                        `json:"schema"`
	Volume       *DeprecatedContainerVolumeForResponse `json:"volume,omitempty"`
	WebURL       *string                               `json:"webURL,omitempty"`
}

// WellResourceType defines model for Well.ResourceType.
type WellResourceType string

// Well_RestrictedSampleParties_Item defines model for Well.restrictedSampleParties.Item.
type Well_RestrictedSampleParties_Item struct {
	union json.RawMessage
}

// Well_SampleOwners_Item defines model for Well.sampleOwners.Item.
type Well_SampleOwners_Item struct {
	union json.RawMessage
}

// WellOrInaccessibleResource defines model for WellOrInaccessibleResource.
type WellOrInaccessibleResource struct {
	ResourceType string `json:"resourceType"`
	union        json.RawMessage
}

// WorkflowList defines model for WorkflowList.
type WorkflowList struct {
	Workflows *[]LegacyWorkflow `json:"workflows,omitempty"`
}

// WorkflowOutput defines model for WorkflowOutput.
type WorkflowOutput struct {
	// CreatedAt The ISO formatted date and time that the output was created
	CreatedAt      *string         `json:"createdAt,omitempty"`
	CreationOrigin *CreationOrigin `json:"creationOrigin,omitempty"`

	// DisplayId User-friendly ID of the workflow task group
	DisplayId *string `json:"displayId,omitempty"`
	Fields    *Fields `json:"fields,omitempty"`

	// Id The ID of the workflow output
	Id *string `json:"id,omitempty"`

	// ModifiedAt The ISO formatted date and time that the output was last modified
	ModifiedAt *string              `json:"modifiedAt,omitempty"`
	Task       *WorkflowTaskSummary `json:"task,omitempty"`

	// WebURL URL of the workflow output
	WebURL            *string                   `json:"webURL,omitempty"`
	WorkflowTaskGroup *WorkflowTaskGroupSummary `json:"workflowTaskGroup,omitempty"`
}

// WorkflowOutputArchiveReason The reason for archiving the provided workflow outputs. Accepted reasons may differ based on tenant configuration.
type WorkflowOutputArchiveReason string

// WorkflowOutputBulkCreate defines model for WorkflowOutputBulkCreate.
type WorkflowOutputBulkCreate = WorkflowOutputCreate

// WorkflowOutputBulkUpdate defines model for WorkflowOutputBulkUpdate.
type WorkflowOutputBulkUpdate struct {
	Fields *Fields `json:"fields,omitempty"`

	// WorkflowOutputId The ID of the workflow output
	WorkflowOutputId *string `json:"workflowOutputId,omitempty"`
}

// WorkflowOutputCreate defines model for WorkflowOutputCreate.
type WorkflowOutputCreate struct {
	Fields *Fields `json:"fields,omitempty"`

	// WorkflowTaskId The ID of the workflow task this output belogns to
	WorkflowTaskId string `json:"workflowTaskId"`
}

// WorkflowOutputCreatedEvent defines model for WorkflowOutputCreatedEvent.
type WorkflowOutputCreatedEvent struct {
	CreatedAt  *time.Time                           `json:"createdAt,omitempty"`
	Deprecated *bool                                `json:"deprecated,omitempty"`
	EventType  *WorkflowOutputCreatedEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
	WorkflowOutput *WorkflowOutput `json:"workflowOutput,omitempty"`
}

// WorkflowOutputCreatedEventEventType defines model for WorkflowOutputCreatedEvent.EventType.
type WorkflowOutputCreatedEventEventType string

// WorkflowOutputSchema defines model for WorkflowOutputSchema.
type WorkflowOutputSchema struct {
	ArchiveRecord    *ArchiveRecord                                `json:"archiveRecord"`
	FieldDefinitions *[]WorkflowOutputSchema_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Name             *string                                       `json:"name,omitempty"`
	Prefix           *string                                       `json:"prefix,omitempty"`
	Type             *string                                       `json:"type,omitempty"`
}

// WorkflowOutputSchema_FieldDefinitions_Item defines model for WorkflowOutputSchema.fieldDefinitions.Item.
type WorkflowOutputSchema_FieldDefinitions_Item struct {
	union json.RawMessage
}

// WorkflowOutputSummary defines model for WorkflowOutputSummary.
type WorkflowOutputSummary struct {
	// DisplayId User-friendly ID of the workflow task group
	DisplayId *string `json:"displayId,omitempty"`

	// Id The ID of the workflow output
	Id *string `json:"id,omitempty"`
}

// WorkflowOutputUpdate defines model for WorkflowOutputUpdate.
type WorkflowOutputUpdate = WorkflowOutputWriteBase

// WorkflowOutputUpdatedFieldsEvent defines model for WorkflowOutputUpdatedFieldsEvent.
type WorkflowOutputUpdatedFieldsEvent struct {
	CreatedAt  *time.Time                                 `json:"createdAt,omitempty"`
	Deprecated *bool                                      `json:"deprecated,omitempty"`
	EventType  *WorkflowOutputUpdatedFieldsEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
	WorkflowOutput *WorkflowOutput `json:"workflowOutput,omitempty"`
}

// WorkflowOutputUpdatedFieldsEventEventType defines model for WorkflowOutputUpdatedFieldsEvent.EventType.
type WorkflowOutputUpdatedFieldsEventEventType string

// WorkflowOutputWriteBase defines model for WorkflowOutputWriteBase.
type WorkflowOutputWriteBase struct {
	Fields *Fields `json:"fields,omitempty"`
}

// WorkflowOutputsArchivalChange IDs of all items that were archived or unarchived, grouped by resource type
type WorkflowOutputsArchivalChange struct {
	WorkflowOutputIds *[]string `json:"workflowOutputIds,omitempty"`
}

// WorkflowOutputsArchive defines model for WorkflowOutputsArchive.
type WorkflowOutputsArchive struct {
	// Reason The reason for archiving the provided workflow outputs. Accepted reasons may differ based on tenant configuration.
	Reason            WorkflowOutputArchiveReason `json:"reason"`
	WorkflowOutputIds []string                    `json:"workflowOutputIds"`
}

// WorkflowOutputsBulkCreateRequest defines model for WorkflowOutputsBulkCreateRequest.
type WorkflowOutputsBulkCreateRequest struct {
	WorkflowOutputs *[]WorkflowOutputBulkCreate `json:"workflowOutputs,omitempty"`
}

// WorkflowOutputsBulkUpdateRequest defines model for WorkflowOutputsBulkUpdateRequest.
type WorkflowOutputsBulkUpdateRequest struct {
	WorkflowOutputs *[]WorkflowOutputBulkUpdate `json:"workflowOutputs,omitempty"`
}

// WorkflowOutputsPaginatedList defines model for WorkflowOutputsPaginatedList.
type WorkflowOutputsPaginatedList struct {
	NextToken       *string           `json:"nextToken,omitempty"`
	WorkflowOutputs *[]WorkflowOutput `json:"workflowOutputs,omitempty"`
}

// WorkflowOutputsUnarchive defines model for WorkflowOutputsUnarchive.
type WorkflowOutputsUnarchive struct {
	WorkflowOutputIds []string `json:"workflowOutputIds"`
}

// WorkflowPatch defines model for WorkflowPatch.
type WorkflowPatch struct {
	// Description Description of the workflow
	Description *string `json:"description,omitempty"`

	// Name Name of the workflow
	Name *string `json:"name,omitempty"`

	// ProjectId ID of the project that contains the workflow
	ProjectId *string `json:"projectId,omitempty"`
}

// WorkflowSample defines model for WorkflowSample.
type WorkflowSample struct {
	// BatchId ID of the batch
	BatchId *string `json:"batchId,omitempty"`

	// ContainerIds Array of IDs of containers
	ContainerIds *[]string `json:"containerIds,omitempty"`

	// CreatedAt DateTime at which the the sample was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id ID of the sample
	Id *string `json:"id,omitempty"`

	// Name Name of the sample
	Name *string `json:"name,omitempty"`
}

// WorkflowSampleList defines model for WorkflowSampleList.
type WorkflowSampleList struct {
	Samples *[]WorkflowSample `json:"samples,omitempty"`
}

// WorkflowStage defines model for WorkflowStage.
type WorkflowStage struct {
	// CreatedAt DateTime at which the the workflow stage was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id ID of the workflow stage
	Id *string `json:"id,omitempty"`

	// Name Name of the workflow stage
	Name *string `json:"name,omitempty"`
}

// WorkflowStageList defines model for WorkflowStageList.
type WorkflowStageList struct {
	WorkflowStages *[]WorkflowStage `json:"workflowStages,omitempty"`
}

// WorkflowStageRun defines model for WorkflowStageRun.
type WorkflowStageRun struct {
	// CreatedAt DateTime at which the the stage run was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Id ID of the stage run
	Id *string `json:"id,omitempty"`

	// Name Name of the stage run
	Name *string `json:"name,omitempty"`

	// Status Status of the stage run
	Status *WorkflowStageRunStatus `json:"status,omitempty"`
}

// WorkflowStageRunStatus Status of the stage run
type WorkflowStageRunStatus string

// WorkflowStageRunList defines model for WorkflowStageRunList.
type WorkflowStageRunList struct {
	WorkflowStageRuns *[]WorkflowStageRun `json:"workflowStageRuns,omitempty"`
}

// WorkflowTask defines model for WorkflowTask.
type WorkflowTask struct {
	Assignee   *UserSummary         `json:"assignee"`
	ClonedFrom *WorkflowTaskSummary `json:"clonedFrom"`

	// CreatedAt The ISO formatted date and time that the task was created
	CreatedAt      *string         `json:"createdAt,omitempty"`
	CreationOrigin *CreationOrigin `json:"creationOrigin,omitempty"`
	Creator        *UserSummary    `json:"creator,omitempty"`

	// DisplayId User-friendly ID of the workflow task
	DisplayId       *string                      `json:"displayId,omitempty"`
	ExecutionOrigin *WorkflowTaskExecutionOrigin `json:"executionOrigin"`

	// ExecutionType The method by which the task of the workflow is executed
	ExecutionType *WorkflowTaskExecutionType `json:"executionType,omitempty"`
	Fields        *Fields                    `json:"fields,omitempty"`

	// Id The ID of the workflow task
	Id *string `json:"id,omitempty"`

	// ModifiedAt The ISO formatted date and time that the task was last modified
	ModifiedAt *string                  `json:"modifiedAt,omitempty"`
	Outputs    *[]WorkflowOutputSummary `json:"outputs,omitempty"`

	// ScheduledOn The date on which the task is scheduled to be executed
	ScheduledOn *openapi_types.Date `json:"scheduledOn"`
	Status      *WorkflowTaskStatus `json:"status,omitempty"`

	// WebURL URL of the workflow task
	WebURL            *string                   `json:"webURL,omitempty"`
	WorkflowTaskGroup *WorkflowTaskGroupSummary `json:"workflowTaskGroup,omitempty"`
}

// WorkflowTaskExecutionType The method by which the task of the workflow is executed
type WorkflowTaskExecutionType string

// WorkflowTaskArchiveReason The reason for archiving the provided workflow tasks. Accepted reasons may differ based on tenant configuration.
type WorkflowTaskArchiveReason string

// WorkflowTaskBase defines model for WorkflowTaskBase.
type WorkflowTaskBase struct {
	Assignee   *UserSummary         `json:"assignee"`
	ClonedFrom *WorkflowTaskSummary `json:"clonedFrom"`

	// CreatedAt The ISO formatted date and time that the task was created
	CreatedAt      *string         `json:"createdAt,omitempty"`
	CreationOrigin *CreationOrigin `json:"creationOrigin,omitempty"`
	Creator        *UserSummary    `json:"creator,omitempty"`

	// DisplayId User-friendly ID of the workflow task
	DisplayId       *string                      `json:"displayId,omitempty"`
	ExecutionOrigin *WorkflowTaskExecutionOrigin `json:"executionOrigin"`
	Fields          *Fields                      `json:"fields,omitempty"`

	// Id The ID of the workflow task
	Id *string `json:"id,omitempty"`

	// ModifiedAt The ISO formatted date and time that the task was last modified
	ModifiedAt *string                  `json:"modifiedAt,omitempty"`
	Outputs    *[]WorkflowOutputSummary `json:"outputs,omitempty"`

	// ScheduledOn The date on which the task is scheduled to be executed
	ScheduledOn *openapi_types.Date `json:"scheduledOn"`
	Status      *WorkflowTaskStatus `json:"status,omitempty"`

	// WebURL URL of the workflow task
	WebURL            *string                   `json:"webURL,omitempty"`
	WorkflowTaskGroup *WorkflowTaskGroupSummary `json:"workflowTaskGroup,omitempty"`
}

// WorkflowTaskBulkCreate defines model for WorkflowTaskBulkCreate.
type WorkflowTaskBulkCreate = WorkflowTaskCreate

// WorkflowTaskBulkUpdate defines model for WorkflowTaskBulkUpdate.
type WorkflowTaskBulkUpdate struct {
	// AssigneeId The id of the user assigned to the task
	AssigneeId *string `json:"assigneeId,omitempty"`
	Fields     *Fields `json:"fields,omitempty"`

	// ScheduledOn The date on which the task is scheduled to be executed
	ScheduledOn *openapi_types.Date `json:"scheduledOn,omitempty"`
	StatusId    *string             `json:"statusId,omitempty"`

	// WorkflowTaskId The workflow task ID
	WorkflowTaskId *string `json:"workflowTaskId,omitempty"`
}

// WorkflowTaskCreate defines model for WorkflowTaskCreate.
type WorkflowTaskCreate struct {
	// AssigneeId The id of the user assigned to the task
	AssigneeId *string `json:"assigneeId,omitempty"`
	Fields     *Fields `json:"fields,omitempty"`

	// ScheduledOn The date on which the task is scheduled to be executed
	ScheduledOn *openapi_types.Date `json:"scheduledOn,omitempty"`

	// WorkflowTaskGroupId The workflow ID
	WorkflowTaskGroupId string `json:"workflowTaskGroupId"`
}

// WorkflowTaskCreatedEvent defines model for WorkflowTaskCreatedEvent.
type WorkflowTaskCreatedEvent struct {
	CreatedAt  *time.Time                         `json:"createdAt,omitempty"`
	Deprecated *bool                              `json:"deprecated,omitempty"`
	EventType  *WorkflowTaskCreatedEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
	WorkflowTask *WorkflowTask `json:"workflowTask,omitempty"`
}

// WorkflowTaskCreatedEventEventType defines model for WorkflowTaskCreatedEvent.EventType.
type WorkflowTaskCreatedEventEventType string

// WorkflowTaskExecutionOrigin The context into which a task was executed
type WorkflowTaskExecutionOrigin struct {
	EntryId         *string                          `json:"entryId"`
	OriginModalUuid *openapi_types.UUID              `json:"originModalUuid"`
	Type            *WorkflowTaskExecutionOriginType `json:"type,omitempty"`
}

// WorkflowTaskExecutionOriginType defines model for WorkflowTaskExecutionOrigin.Type.
type WorkflowTaskExecutionOriginType string

// WorkflowTaskGroup defines model for WorkflowTaskGroup.
type WorkflowTaskGroup struct {
	// CreatedAt The ISO formatted date and time that the task group was created
	CreatedAt      *string         `json:"createdAt,omitempty"`
	CreationOrigin *CreationOrigin `json:"creationOrigin,omitempty"`
	Creator        *UserSummary    `json:"creator,omitempty"`

	// DisplayId User-friendly ID of the workflow task group
	DisplayId *string `json:"displayId,omitempty"`

	// ExecutionType The method by which the workflow is executed
	ExecutionType *WorkflowTaskGroupExecutionType `json:"executionType,omitempty"`
	Folder        *Folder                         `json:"folder,omitempty"`

	// Id The ID of the workflow task group
	Id *string `json:"id,omitempty"`

	// ModifiedAt The ISO formatted date and time that the task group was last modified
	ModifiedAt *string `json:"modifiedAt,omitempty"`

	// Name The name of the workflow task group
	Name *string `json:"name,omitempty"`

	// Outputs The outputs of the workflow task group
	Outputs         *[]WorkflowOutputSummary `json:"outputs,omitempty"`
	ResponsibleTeam *TeamSummary             `json:"responsibleTeam"`

	// Watchers The users watching the workflow task group
	Watchers *[]UserSummary `json:"watchers,omitempty"`

	// WebURL URL of the workflow task group
	WebURL             *string                    `json:"webURL,omitempty"`
	WorkflowTaskSchema *WorkflowTaskSchemaSummary `json:"workflowTaskSchema,omitempty"`

	// WorkflowTasks The input tasks to the workflow task group
	WorkflowTasks *[]WorkflowTaskSummary `json:"workflowTasks,omitempty"`
}

// WorkflowTaskGroupExecutionType The method by which the workflow is executed
type WorkflowTaskGroupExecutionType string

// WorkflowTaskGroupArchiveReason The reason for archiving the provided workflow task groups. Accepted reasons may differ based on tenant configuration.
type WorkflowTaskGroupArchiveReason string

// WorkflowTaskGroupBase defines model for WorkflowTaskGroupBase.
type WorkflowTaskGroupBase struct {
	// CreatedAt The ISO formatted date and time that the task group was created
	CreatedAt      *string         `json:"createdAt,omitempty"`
	CreationOrigin *CreationOrigin `json:"creationOrigin,omitempty"`
	Creator        *UserSummary    `json:"creator,omitempty"`

	// DisplayId User-friendly ID of the workflow task group
	DisplayId *string `json:"displayId,omitempty"`
	Folder    *Folder `json:"folder,omitempty"`

	// Id The ID of the workflow task group
	Id *string `json:"id,omitempty"`

	// ModifiedAt The ISO formatted date and time that the task group was last modified
	ModifiedAt *string `json:"modifiedAt,omitempty"`

	// Name The name of the workflow task group
	Name *string `json:"name,omitempty"`

	// Outputs The outputs of the workflow task group
	Outputs         *[]WorkflowOutputSummary `json:"outputs,omitempty"`
	ResponsibleTeam *TeamSummary             `json:"responsibleTeam"`

	// Watchers The users watching the workflow task group
	Watchers *[]UserSummary `json:"watchers,omitempty"`

	// WebURL URL of the workflow task group
	WebURL             *string                    `json:"webURL,omitempty"`
	WorkflowTaskSchema *WorkflowTaskSchemaSummary `json:"workflowTaskSchema,omitempty"`

	// WorkflowTasks The input tasks to the workflow task group
	WorkflowTasks *[]WorkflowTaskSummary `json:"workflowTasks,omitempty"`
}

// WorkflowTaskGroupCreate defines model for WorkflowTaskGroupCreate.
type WorkflowTaskGroupCreate struct {
	// FolderId ID of the folder that contains the workflow task group
	FolderId string `json:"folderId"`

	// Name The name of the workflow task group
	Name *string `json:"name,omitempty"`

	// SchemaId The workflow task schema of tasks in this task group
	SchemaId string `json:"schemaId"`

	// WatcherIds IDs of the users watching the workflow task group
	WatcherIds *[]string `json:"watcherIds,omitempty"`
}

// WorkflowTaskGroupCreatedEvent defines model for WorkflowTaskGroupCreatedEvent.
type WorkflowTaskGroupCreatedEvent struct {
	CreatedAt  *time.Time                              `json:"createdAt,omitempty"`
	Deprecated *bool                                   `json:"deprecated,omitempty"`
	EventType  *WorkflowTaskGroupCreatedEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
	WorkflowTaskGroup *WorkflowTaskGroup `json:"workflowTaskGroup,omitempty"`
}

// WorkflowTaskGroupCreatedEventEventType defines model for WorkflowTaskGroupCreatedEvent.EventType.
type WorkflowTaskGroupCreatedEventEventType string

// WorkflowTaskGroupSummary defines model for WorkflowTaskGroupSummary.
type WorkflowTaskGroupSummary struct {
	// DisplayId User-friendly ID of the workflow task group
	DisplayId *string `json:"displayId,omitempty"`

	// Id The ID of the workflow task group
	Id *string `json:"id,omitempty"`

	// Name The name of the workflow task group
	Name *string `json:"name,omitempty"`
}

// WorkflowTaskGroupUpdate defines model for WorkflowTaskGroupUpdate.
type WorkflowTaskGroupUpdate = WorkflowTaskGroupWriteBase

// WorkflowTaskGroupUpdatedWatchersEvent defines model for WorkflowTaskGroupUpdatedWatchersEvent.
type WorkflowTaskGroupUpdatedWatchersEvent struct {
	CreatedAt  *time.Time                                      `json:"createdAt,omitempty"`
	Deprecated *bool                                           `json:"deprecated,omitempty"`
	EventType  *WorkflowTaskGroupUpdatedWatchersEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
	WorkflowTaskGroup *WorkflowTaskGroup `json:"workflowTaskGroup,omitempty"`
}

// WorkflowTaskGroupUpdatedWatchersEventEventType defines model for WorkflowTaskGroupUpdatedWatchersEvent.EventType.
type WorkflowTaskGroupUpdatedWatchersEventEventType string

// WorkflowTaskGroupWriteBase defines model for WorkflowTaskGroupWriteBase.
type WorkflowTaskGroupWriteBase struct {
	// FolderId ID of the folder that contains the workflow task group
	FolderId *string `json:"folderId,omitempty"`

	// Name The name of the workflow task group
	Name *string `json:"name,omitempty"`

	// WatcherIds IDs of the users watching the workflow task group
	WatcherIds *[]string `json:"watcherIds,omitempty"`
}

// WorkflowTaskGroupsArchivalChange IDs of all items that were archived or unarchived, grouped by resource type
type WorkflowTaskGroupsArchivalChange struct {
	WorkflowTaskGroupIds *[]string `json:"workflowTaskGroupIds,omitempty"`
}

// WorkflowTaskGroupsArchive defines model for WorkflowTaskGroupsArchive.
type WorkflowTaskGroupsArchive struct {
	// Reason The reason for archiving the provided workflow task groups. Accepted reasons may differ based on tenant configuration.
	Reason               WorkflowTaskGroupArchiveReason `json:"reason"`
	WorkflowTaskGroupIds []string                       `json:"workflowTaskGroupIds"`
}

// WorkflowTaskGroupsPaginatedList defines model for WorkflowTaskGroupsPaginatedList.
type WorkflowTaskGroupsPaginatedList struct {
	NextToken          *string              `json:"nextToken,omitempty"`
	WorkflowTaskGroups *[]WorkflowTaskGroup `json:"workflowTaskGroups,omitempty"`
}

// WorkflowTaskGroupsUnarchive defines model for WorkflowTaskGroupsUnarchive.
type WorkflowTaskGroupsUnarchive struct {
	WorkflowTaskGroupIds []string `json:"workflowTaskGroupIds"`
}

// WorkflowTaskSchema defines model for WorkflowTaskSchema.
type WorkflowTaskSchema struct {
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`

	// CanSetAssigneeOnTaskCreation Whether or not tasks of this schema can be created with a non-null assignee.
	CanSetAssigneeOnTaskCreation *bool `json:"canSetAssigneeOnTaskCreation,omitempty"`

	// DefaultCreationFolderId ID of the default folder for creating workflow task groups
	DefaultCreationFolderId *string `json:"defaultCreationFolderId"`

	// DefaultEntryExecutionFolderId ID of the default folder for workflow task execution entries
	DefaultEntryExecutionFolderId *string      `json:"defaultEntryExecutionFolderId"`
	DefaultResponsibleTeam        *TeamSummary `json:"defaultResponsibleTeam"`

	// EntryTemplateId The ID of the template of the entries tasks of this schema will be executed into.
	EntryTemplateId *string `json:"entryTemplateId"`

	// ExecutionType The method by which instances of this schema are executed
	ExecutionType    *WorkflowTaskSchemaExecutionType            `json:"executionType,omitempty"`
	FieldDefinitions *[]WorkflowTaskSchema_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Id               *string                                     `json:"id,omitempty"`

	// IsPropagateWatchersEnabled Whether propagation of watchers has been enabled for this task schema.
	IsPropagateWatchersEnabled *bool   `json:"isPropagateWatchersEnabled,omitempty"`
	Name                       *string `json:"name,omitempty"`

	// Prefix The prefix for the displayId of tasks of this schema.
	Prefix          *string                      `json:"prefix,omitempty"`
	StatusLifecycle *WorkflowTaskStatusLifecycle `json:"statusLifecycle,omitempty"`

	// TaskGroupPrefix The prefix for the displayId of task groups containing tasks of this schema
	TaskGroupPrefix      *string               `json:"taskGroupPrefix,omitempty"`
	Type                 *string               `json:"type,omitempty"`
	WorkflowOutputSchema *WorkflowOutputSchema `json:"workflowOutputSchema"`
}

// WorkflowTaskSchemaExecutionType The method by which instances of this schema are executed
type WorkflowTaskSchemaExecutionType string

// WorkflowTaskSchema_FieldDefinitions_Item defines model for WorkflowTaskSchema.fieldDefinitions.Item.
type WorkflowTaskSchema_FieldDefinitions_Item struct {
	union json.RawMessage
}

// WorkflowTaskSchemaBase defines model for WorkflowTaskSchemaBase.
type WorkflowTaskSchemaBase struct {
	ArchiveRecord *ArchiveRecord `json:"archiveRecord"`

	// CanSetAssigneeOnTaskCreation Whether or not tasks of this schema can be created with a non-null assignee.
	CanSetAssigneeOnTaskCreation *bool `json:"canSetAssigneeOnTaskCreation,omitempty"`

	// DefaultCreationFolderId ID of the default folder for creating workflow task groups
	DefaultCreationFolderId *string `json:"defaultCreationFolderId"`

	// DefaultEntryExecutionFolderId ID of the default folder for workflow task execution entries
	DefaultEntryExecutionFolderId *string      `json:"defaultEntryExecutionFolderId"`
	DefaultResponsibleTeam        *TeamSummary `json:"defaultResponsibleTeam"`

	// EntryTemplateId The ID of the template of the entries tasks of this schema will be executed into.
	EntryTemplateId  *string                                         `json:"entryTemplateId"`
	FieldDefinitions *[]WorkflowTaskSchemaBase_FieldDefinitions_Item `json:"fieldDefinitions,omitempty"`
	Id               *string                                         `json:"id,omitempty"`

	// IsPropagateWatchersEnabled Whether propagation of watchers has been enabled for this task schema.
	IsPropagateWatchersEnabled *bool   `json:"isPropagateWatchersEnabled,omitempty"`
	Name                       *string `json:"name,omitempty"`

	// Prefix The prefix for the displayId of tasks of this schema.
	Prefix          *string                      `json:"prefix,omitempty"`
	StatusLifecycle *WorkflowTaskStatusLifecycle `json:"statusLifecycle,omitempty"`

	// TaskGroupPrefix The prefix for the displayId of task groups containing tasks of this schema
	TaskGroupPrefix      *string               `json:"taskGroupPrefix,omitempty"`
	Type                 *string               `json:"type,omitempty"`
	WorkflowOutputSchema *WorkflowOutputSchema `json:"workflowOutputSchema"`
}

// WorkflowTaskSchemaBase_FieldDefinitions_Item defines model for WorkflowTaskSchemaBase.fieldDefinitions.Item.
type WorkflowTaskSchemaBase_FieldDefinitions_Item struct {
	union json.RawMessage
}

// WorkflowTaskSchemaSummary defines model for WorkflowTaskSchemaSummary.
type WorkflowTaskSchemaSummary struct {
	// Id The ID of the workflow task schema
	Id *string `json:"id,omitempty"`

	// Name The name of the workflow task schema
	Name *string `json:"name,omitempty"`
}

// WorkflowTaskSchemasPaginatedList defines model for WorkflowTaskSchemasPaginatedList.
type WorkflowTaskSchemasPaginatedList struct {
	NextToken           *string               `json:"nextToken,omitempty"`
	WorkflowTaskSchemas *[]WorkflowTaskSchema `json:"workflowTaskSchemas,omitempty"`
}

// WorkflowTaskStatus defines model for WorkflowTaskStatus.
type WorkflowTaskStatus struct {
	// DisplayName The status label
	DisplayName *string `json:"displayName,omitempty"`

	// Id The ID of the workflow task status
	Id *string `json:"id,omitempty"`

	// StatusType The status type
	StatusType *WorkflowTaskStatusStatusType `json:"statusType,omitempty"`
}

// WorkflowTaskStatusStatusType The status type
type WorkflowTaskStatusStatusType string

// WorkflowTaskStatusLifecycle defines model for WorkflowTaskStatusLifecycle.
type WorkflowTaskStatusLifecycle struct {
	Id            *string                                  `json:"id,omitempty"`
	InitialStatus *WorkflowTaskStatus                      `json:"initialStatus,omitempty"`
	Name          *string                                  `json:"name,omitempty"`
	Statuses      *[]WorkflowTaskStatus                    `json:"statuses,omitempty"`
	Transitions   *[]WorkflowTaskStatusLifecycleTransition `json:"transitions,omitempty"`
}

// WorkflowTaskStatusLifecycleTransition defines model for WorkflowTaskStatusLifecycleTransition.
type WorkflowTaskStatusLifecycleTransition struct {
	From *WorkflowTaskStatus `json:"from,omitempty"`
	To   *WorkflowTaskStatus `json:"to,omitempty"`
}

// WorkflowTaskSummary defines model for WorkflowTaskSummary.
type WorkflowTaskSummary struct {
	// DisplayId User-friendly ID of the workflow task
	DisplayId *string `json:"displayId,omitempty"`

	// Id The ID of the workflow task
	Id *string `json:"id,omitempty"`
}

// WorkflowTaskUpdate defines model for WorkflowTaskUpdate.
type WorkflowTaskUpdate struct {
	// AssigneeId The id of the user assigned to the task
	AssigneeId *string `json:"assigneeId,omitempty"`
	Fields     *Fields `json:"fields,omitempty"`

	// ScheduledOn The date on which the task is scheduled to be executed
	ScheduledOn *openapi_types.Date `json:"scheduledOn,omitempty"`
	StatusId    *string             `json:"statusId,omitempty"`
}

// WorkflowTaskUpdatedAssigneeEvent defines model for WorkflowTaskUpdatedAssigneeEvent.
type WorkflowTaskUpdatedAssigneeEvent struct {
	CreatedAt  *time.Time                                 `json:"createdAt,omitempty"`
	Deprecated *bool                                      `json:"deprecated,omitempty"`
	EventType  *WorkflowTaskUpdatedAssigneeEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
	WorkflowTask *WorkflowTask `json:"workflowTask,omitempty"`
}

// WorkflowTaskUpdatedAssigneeEventEventType defines model for WorkflowTaskUpdatedAssigneeEvent.EventType.
type WorkflowTaskUpdatedAssigneeEventEventType string

// WorkflowTaskUpdatedFieldsEvent defines model for WorkflowTaskUpdatedFieldsEvent.
type WorkflowTaskUpdatedFieldsEvent struct {
	CreatedAt  *time.Time                               `json:"createdAt,omitempty"`
	Deprecated *bool                                    `json:"deprecated,omitempty"`
	EventType  *WorkflowTaskUpdatedFieldsEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
	WorkflowTask *WorkflowTask `json:"workflowTask,omitempty"`
}

// WorkflowTaskUpdatedFieldsEventEventType defines model for WorkflowTaskUpdatedFieldsEvent.EventType.
type WorkflowTaskUpdatedFieldsEventEventType string

// WorkflowTaskUpdatedScheduledOnEvent defines model for WorkflowTaskUpdatedScheduledOnEvent.
type WorkflowTaskUpdatedScheduledOnEvent struct {
	CreatedAt  *time.Time                                    `json:"createdAt,omitempty"`
	Deprecated *bool                                         `json:"deprecated,omitempty"`
	EventType  *WorkflowTaskUpdatedScheduledOnEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
	WorkflowTask *WorkflowTask `json:"workflowTask,omitempty"`
}

// WorkflowTaskUpdatedScheduledOnEventEventType defines model for WorkflowTaskUpdatedScheduledOnEvent.EventType.
type WorkflowTaskUpdatedScheduledOnEventEventType string

// WorkflowTaskUpdatedStatusEvent defines model for WorkflowTaskUpdatedStatusEvent.
type WorkflowTaskUpdatedStatusEvent struct {
	CreatedAt  *time.Time                               `json:"createdAt,omitempty"`
	Deprecated *bool                                    `json:"deprecated,omitempty"`
	EventType  *WorkflowTaskUpdatedStatusEventEventType `json:"eventType,omitempty"`

	// ExcludedProperties These properties have been dropped from the payload due to size.
	ExcludedProperties *[]string `json:"excludedProperties,omitempty"`
	Id                 *string   `json:"id,omitempty"`
	Schema             *struct {
		Id   *string `json:"id,omitempty"`
		Name *string `json:"name,omitempty"`
	} `json:"schema"`
	WorkflowTask *WorkflowTask `json:"workflowTask,omitempty"`
}

// WorkflowTaskUpdatedStatusEventEventType defines model for WorkflowTaskUpdatedStatusEvent.EventType.
type WorkflowTaskUpdatedStatusEventEventType string

// WorkflowTaskWriteBase defines model for WorkflowTaskWriteBase.
type WorkflowTaskWriteBase struct {
	// AssigneeId The id of the user assigned to the task
	AssigneeId *string `json:"assigneeId,omitempty"`
	Fields     *Fields `json:"fields,omitempty"`

	// ScheduledOn The date on which the task is scheduled to be executed
	ScheduledOn *openapi_types.Date `json:"scheduledOn,omitempty"`
}

// WorkflowTasksArchivalChange IDs of all items that were archived or unarchived, grouped by resource type
type WorkflowTasksArchivalChange struct {
	WorkflowTaskIds *[]string `json:"workflowTaskIds,omitempty"`
}

// WorkflowTasksArchive defines model for WorkflowTasksArchive.
type WorkflowTasksArchive struct {
	// Reason The reason for archiving the provided workflow tasks. Accepted reasons may differ based on tenant configuration.
	Reason          WorkflowTaskArchiveReason `json:"reason"`
	WorkflowTaskIds []string                  `json:"workflowTaskIds"`
}

// WorkflowTasksBulkCopyRequest defines model for WorkflowTasksBulkCopyRequest.
type WorkflowTasksBulkCopyRequest struct {
	WorkflowTaskIds *[]string `json:"workflowTaskIds,omitempty"`
}

// WorkflowTasksBulkCreateRequest defines model for WorkflowTasksBulkCreateRequest.
type WorkflowTasksBulkCreateRequest struct {
	WorkflowTasks *[]WorkflowTaskBulkCreate `json:"workflowTasks,omitempty"`
}

// WorkflowTasksBulkUpdateRequest defines model for WorkflowTasksBulkUpdateRequest.
type WorkflowTasksBulkUpdateRequest struct {
	WorkflowTasks *[]WorkflowTaskBulkUpdate `json:"workflowTasks,omitempty"`
}

// WorkflowTasksPaginatedList defines model for WorkflowTasksPaginatedList.
type WorkflowTasksPaginatedList struct {
	NextToken     *string         `json:"nextToken,omitempty"`
	WorkflowTasks *[]WorkflowTask `json:"workflowTasks,omitempty"`
}

// WorkflowTasksUnarchive defines model for WorkflowTasksUnarchive.
type WorkflowTasksUnarchive struct {
	WorkflowTaskIds []string `json:"workflowTaskIds"`
}

// ListAASequencesParams defines parameters for ListAASequences.
type ListAASequencesParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string                    `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Sort      *ListAASequencesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of an AA Sequence. Restricts results to those with the specified name, alias, or entity registry ID.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of an AA sequence. Restricts results to those with names, aliases, or entity registry IDs that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// AminoAcids String of amino acids. Restricts results to AA sequences exactly matching these amino acids (case-insensitive).
	AminoAcids *string `form:"aminoAcids,omitempty" json:"aminoAcids,omitempty"`

	// FolderId ID of a folder. Restricts results to those in the folder.
	FolderId *string `form:"folderId,omitempty" json:"folderId,omitempty"`

	// MentionedIn Comma-separated list of entry IDs. Restricts results to AA sequences mentioned in those entries.
	MentionedIn *string `form:"mentionedIn,omitempty" json:"mentionedIn,omitempty"`

	// ProjectId ID of a project. Restricts results to those in the project.
	ProjectId *string `form:"projectId,omitempty" json:"projectId,omitempty"`

	// RegistryId ID of a registry. Restricts results to those registered in this registry. Specifying "null" returns unregistered items.
	RegistryId *string `form:"registryId,omitempty" json:"registryId,omitempty"`

	// SchemaId ID of a schema. Restricts results to those of the specified schema.
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// SchemaFields Filter based on schema field value (not display value). Restricts results to those with a field whose value matches the filter. For Integer, Float, and Date type fields, supports the >= and <= operators (but not < or >). If any schemaField filters are present, the schemaId param must also be present. Note that all operators must be separated from any values by a single space.
	SchemaFields *SchemaFieldsQueryParam `form:"schemaFields,omitempty" json:"schemaFields,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived AA sequences. Use "ANY_ARCHIVED" to filter for archived AA sequences regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// Mentions Comma-separated list of item IDs. Restricts results to those that mention the given items in the description.
	Mentions *string `form:"mentions,omitempty" json:"mentions,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// EntityRegistryIdsAnyOf Comma-separated list of entity registry IDs. Maximum of 100. Restricts results to those that match any of the specified registry IDs.
	EntityRegistryIdsAnyOf *string `form:"entityRegistryIds.anyOf,omitempty" json:"entityRegistryIds.anyOf,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// CreatorIds Comma separated list of users IDs
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`

	// AuthorIdsAnyOf Comma separated list of user or app IDs. Maximum of 100.
	AuthorIdsAnyOf *string `form:"authorIds.anyOf,omitempty" json:"authorIds.anyOf,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	//
	// **Note**: Fields annotations, translations, and primers cannot be introspected with the returning parameter, and any sub fields will be ignored. E.g.: "aaSequences.annotations.id" will return the same as "aaSequences.annotations".
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListAASequencesParamsSort defines parameters for ListAASequences.
type ListAASequencesParamsSort string

// GetAASequenceParams defines parameters for GetAASequence.
type GetAASequenceParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	//
	// **Note**: Fields annotations, translations, and primers cannot be introspected with the returning parameter, and any sub fields will be ignored. E.g.: "annotations.id" will return the same as "annotations".
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// BulkGetAASequencesParams defines parameters for BulkGetAASequences.
type BulkGetAASequencesParams struct {
	// AaSequenceIds Comma-separated list of IDs of AA sequences to get.
	AaSequenceIds string `form:"aaSequenceIds" json:"aaSequenceIds"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	//
	// **Note**: Fields annotations, translations, and primers cannot be introspected with the returning parameter, and any sub fields will be ignored. E.g.: "aaSequences.annotations.id" will return the same as "aaSequences.annotations".
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// GetAppCanvasParams defines parameters for GetAppCanvas.
type GetAppCanvasParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListAppConfigurationItemsParams defines parameters for ListAppConfigurationItems.
type ListAppConfigurationItemsParams struct {
	// NextToken Token for pagination
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// AppId App id to which the configuration belongs.
	AppId *string `form:"appId,omitempty" json:"appId,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids  *string                              `form:"ids,omitempty" json:"ids,omitempty"`
	Sort *ListAppConfigurationItemsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListAppConfigurationItemsParamsSort defines parameters for ListAppConfigurationItems.
type ListAppConfigurationItemsParamsSort string

// GetAppSessionByIdParams defines parameters for GetAppSessionById.
type GetAppSessionByIdParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListBenchlingAppsParams defines parameters for ListBenchlingApps.
type ListBenchlingAppsParams struct {
	// PageSize Number of results to return.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// Sort Method by which to order search results. Valid sorts are modifiedAt (modified time, most recent first) and name (app name, alphabetical). Optionally add :asc or :desc to specify ascending or descending order. Default is modifiedAt.
	Sort *ListBenchlingAppsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of an app. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of an app. Restricts results to those with names that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// NamesAnyOf Comma-separated list of app names. Maximum of 100. Restricts results to those that match any of the specified names, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of app names. Maximum of 100. Restricts results to those that match any of the specified names, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// CreatorIds Comma separated list of users IDs
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`

	// MemberOf Comma-separated list of organization and/or team API IDs. Restricts results to apps that are members of all given groups.
	MemberOf *string `form:"memberOf,omitempty" json:"memberOf,omitempty"`

	// AdminOf Comma-separated list of organization and/or team API IDs. Restricts results to apps that are admins of all given groups.
	AdminOf *string `form:"adminOf,omitempty" json:"adminOf,omitempty"`
}

// ListBenchlingAppsParamsSort defines parameters for ListBenchlingApps.
type ListBenchlingAppsParamsSort string

// ListAssayResultSchemasParams defines parameters for ListAssayResultSchemas.
type ListAssayResultSchemasParams struct {
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`
}

// ListAssayResultsParams defines parameters for ListAssayResults.
type ListAssayResultsParams struct {
	// SchemaId ID of the assay result schema to filter by
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// CreatedAtLt Datetime, in RFC 3339 format. Time zone defaults to UTC. Restricts results to those created before the specified time. e.g. < 2017-04-30.
	CreatedAtLt *string `form:"createdAt.lt,omitempty" json:"createdAt.lt,omitempty"`

	// CreatedAtGt Datetime, in RFC 3339 format. Time zone defaults to UTC. Restricts results to those created after the specified time. e.g. > 2017-04-30.
	CreatedAtGt *string `form:"createdAt.gt,omitempty" json:"createdAt.gt,omitempty"`

	// CreatedAtLte Datetime, in RFC 3339 format. Time zone defaults to UTC. Restricts results to those created on or before the specified time. e.g. <= 2017-04-30.
	CreatedAtLte *string `form:"createdAt.lte,omitempty" json:"createdAt.lte,omitempty"`

	// CreatedAtGte Datetime, in RFC 3339 format. Time zone defaults to UTC. Restricts results to those created on or after the specified time. e.g. >= 2017-04-30.
	CreatedAtGte *string `form:"createdAt.gte,omitempty" json:"createdAt.gte,omitempty"`

	// MinCreatedTime Filter by results created after this unix timestamp
	MinCreatedTime *int `form:"minCreatedTime,omitempty" json:"minCreatedTime,omitempty"`

	// MaxCreatedTime Filter by results created before this unix timestamp
	MaxCreatedTime *int `form:"maxCreatedTime,omitempty" json:"maxCreatedTime,omitempty"`

	// Sort Method by which to order search results. Valid sorts are createdAt (created time, oldest first). Use :asc or :desc to specify ascending or descending order. Default is createdAt:asc.
	Sort *ListAssayResultsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// NextToken Token for pagination
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// EntityIds Filter by comma-separated list of related Entity IDs, maximum of 20.
	EntityIds *string `form:"entityIds,omitempty" json:"entityIds,omitempty"`

	// StorageIds Filter by comma-separated list of related inventory (container, box, plate, or location) IDs, maximum of 20.
	StorageIds *string `form:"storageIds,omitempty" json:"storageIds,omitempty"`

	// AssayRunIds Filter by comma-separated list of associated AssayRun IDs. At most one of {assayRunIds, automationOutputProcessorId} may be supplied.
	AssayRunIds *string `form:"assayRunIds,omitempty" json:"assayRunIds,omitempty"`

	// AutomationOutputProcessorId Filter by Automation Output Processor ID. Either this or schemaId is required; if both are given, the associated schemas must match. At most one of {assayRunIds, automationOutputProcessorId} may be supplied.
	AutomationOutputProcessorId *string `form:"automationOutputProcessorId,omitempty" json:"automationOutputProcessorId,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *openapi_types.UUID `form:"ids,omitempty" json:"ids,omitempty"`

	// ModifiedAtLt Datetime, in RFC 3339 format. Time zone defaults to UTC. Restricts results to those modified before the specified time. e.g. < 2017-04-30.
	ModifiedAtLt *string `form:"modifiedAt.lt,omitempty" json:"modifiedAt.lt,omitempty"`

	// ModifiedAtGt Datetime, in RFC 3339 format. Time zone defaults to UTC. Restricts results to those modified after the specified time. e.g. > 2017-04-30.
	ModifiedAtGt *string `form:"modifiedAt.gt,omitempty" json:"modifiedAt.gt,omitempty"`

	// ModifiedAtLte Datetime, in RFC 3339 format. Time zone defaults to UTC. Restricts results to those modified on or before the specified time. e.g. <= 2017-04-30.
	ModifiedAtLte *string `form:"modifiedAt.lte,omitempty" json:"modifiedAt.lte,omitempty"`

	// ModifiedAtGte Datetime, in RFC 3339 format. Time zone defaults to UTC. Restricts results to those modified on or after the specified time. e.g. >= 2017-04-30.
	ModifiedAtGte *string `form:"modifiedAt.gte,omitempty" json:"modifiedAt.gte,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived Assay Results. Use "ANY_ARCHIVED" to filter for archived Assay Results regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`
}

// ListAssayResultsParamsSort defines parameters for ListAssayResults.
type ListAssayResultsParamsSort string

// BulkGetAssayResultsParams defines parameters for BulkGetAssayResults.
type BulkGetAssayResultsParams struct {
	// AssayResultIds Comma-separated list of assay result IDs.
	AssayResultIds string `form:"assayResultIds" json:"assayResultIds"`
}

// ListAssayRunSchemasParams defines parameters for ListAssayRunSchemas.
type ListAssayRunSchemasParams struct {
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`
}

// ListAssayRunsParams defines parameters for ListAssayRuns.
type ListAssayRunsParams struct {
	// SchemaId ID of the assay run schema to filter by
	SchemaId string `form:"schemaId" json:"schemaId"`

	// MinCreatedTime Filter by runs created after this unix timestamp
	MinCreatedTime *int `form:"minCreatedTime,omitempty" json:"minCreatedTime,omitempty"`

	// MaxCreatedTime Filter by runs created before this unix timestamp
	MaxCreatedTime *int `form:"maxCreatedTime,omitempty" json:"maxCreatedTime,omitempty"`

	// NextToken Token for pagination
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *openapi_types.UUID `form:"ids,omitempty" json:"ids,omitempty"`
}

// ListAutomationInputGeneratorsParams defines parameters for ListAutomationInputGenerators.
type ListAutomationInputGeneratorsParams struct {
	// NextToken Token for pagination
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`
}

// ListAutomationOutputProcessorsDeprecatedParams defines parameters for ListAutomationOutputProcessorsDeprecated.
type ListAutomationOutputProcessorsDeprecatedParams struct {
	// NextToken Token for pagination
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// BulkGetAssayRunsParams defines parameters for BulkGetAssayRuns.
type BulkGetAssayRunsParams struct {
	// AssayRunIds Comma-separated list of assay run IDs
	AssayRunIds string `form:"assayRunIds" json:"assayRunIds"`
}

// ListAutomationOutputProcessorsParams defines parameters for ListAutomationOutputProcessors.
type ListAutomationOutputProcessorsParams struct {
	// AssayRunId Id of the Run
	AssayRunId *string `form:"assayRunId,omitempty" json:"assayRunId,omitempty"`

	// AutomationFileConfigName Name of the Automation File Config
	AutomationFileConfigName *string `form:"automationFileConfigName,omitempty" json:"automationFileConfigName,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived processors. Use "ANY_ARCHIVED" to filter for archived processors regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// NextToken Token for pagination
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// ListBatchSchemasParams defines parameters for ListBatchSchemas.
type ListBatchSchemasParams struct {
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`
}

// ListBatchesParams defines parameters for ListBatches.
type ListBatchesParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string                `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Sort      *ListBatchesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// SchemaId ID of a schema. Restricts results to those of the specified schema.
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// SchemaFields Filter based on schema field value (not display value). Restricts results to those with a field whose value matches the filter. For Integer, Float, and Date type fields, supports the >= and <= operators (but not < or >). If any schemaField filters are present, the schemaId param must also be present. Note that all operators must be separated from any values by a single space.
	SchemaFields *SchemaFieldsQueryParam `form:"schemaFields,omitempty" json:"schemaFields,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived batches. Use "ANY_ARCHIVED" to filter for archived batches regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// CreatorIds Comma separated list of users IDs
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`
}

// ListBatchesParamsSort defines parameters for ListBatches.
type ListBatchesParamsSort string

// BulkGetBatchesParams defines parameters for BulkGetBatches.
type BulkGetBatchesParams struct {
	// BatchIds Comma-separated list of batch IDs.
	BatchIds *string `form:"batchIds,omitempty" json:"batchIds,omitempty"`

	// BatchNames Comma-separated list of batch names. Batch names have the format {file name}-{creation date as YYYYMMDD}-{optional inventory number}. Must specify registryId with batchNames.
	BatchNames *string `form:"batchNames,omitempty" json:"batchNames,omitempty"`

	// RegistryId ID of the registry that batches are registered in. Required if querying by batchNames.
	RegistryId *string `form:"registryId,omitempty" json:"registryId,omitempty"`
}

// GetBlobParams defines parameters for GetBlob.
type GetBlobParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// BulkGetBlobsParams defines parameters for BulkGetBlobs.
type BulkGetBlobsParams struct {
	// BlobIds Comma-separated list of blob IDs.
	BlobIds *string `form:"blobIds,omitempty" json:"blobIds,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListBoxSchemasParams defines parameters for ListBoxSchemas.
type ListBoxSchemasParams struct {
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// ListBoxesParams defines parameters for ListBoxes.
type ListBoxesParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string              `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Sort      *ListBoxesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// SchemaId ID of a schema. Restricts results to those of the specified schema.
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// SchemaFields Filter based on schema field value (not display value). Restricts results to those with a field whose value matches the filter. For Integer, Float, and Date type fields, supports the >= and <= operators (but not < or >). If any schemaField filters are present, the schemaId param must also be present. Note that all operators must be separated from any values by a single space.
	SchemaFields *SchemaFieldsQueryParam `form:"schemaFields,omitempty" json:"schemaFields,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of a box. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of a box. Restricts results to those with names that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// EmptyPositions Only return boxes that have the specified number of empty positions
	EmptyPositions *int `form:"emptyPositions,omitempty" json:"emptyPositions,omitempty"`

	// EmptyPositionsGte Only return boxes that have greater-than or equal-to the specified number of empty positions.
	EmptyPositionsGte *int `form:"emptyPositions.gte,omitempty" json:"emptyPositions.gte,omitempty"`

	// EmptyPositionsGt Only return boxes that have greater-than the specified number of empty positions.
	EmptyPositionsGt *int `form:"emptyPositions.gt,omitempty" json:"emptyPositions.gt,omitempty"`

	// EmptyPositionsLte Only return boxes that have less-than or equal-to the specified number of empty positions.
	EmptyPositionsLte *int `form:"emptyPositions.lte,omitempty" json:"emptyPositions.lte,omitempty"`

	// EmptyPositionsLt Only return boxes that have less-than the specified number of empty positions.
	EmptyPositionsLt *int `form:"emptyPositions.lt,omitempty" json:"emptyPositions.lt,omitempty"`

	// EmptyContainers Only return boxes that have the specified number of empty containers (containers without contents).
	EmptyContainers *int `form:"emptyContainers,omitempty" json:"emptyContainers,omitempty"`

	// EmptyContainersGte Only return boxes that have greater-than or equal-to the specified number of empty containers (containers without contents).
	EmptyContainersGte *int `form:"emptyContainers.gte,omitempty" json:"emptyContainers.gte,omitempty"`

	// EmptyContainersGt Only return boxes that have greater-than the specified number of empty containers (containers without contents).
	EmptyContainersGt *int `form:"emptyContainers.gt,omitempty" json:"emptyContainers.gt,omitempty"`

	// EmptyContainersLte Only return boxes that have less-than or equal-to the specified number of empty containers (containers without contents).
	EmptyContainersLte *int `form:"emptyContainers.lte,omitempty" json:"emptyContainers.lte,omitempty"`

	// EmptyContainersLt Only return boxes that have less-than the specified number of empty containers (containers without contents).
	EmptyContainersLt *int `form:"emptyContainers.lt,omitempty" json:"emptyContainers.lt,omitempty"`

	// AncestorStorageId ID of a location. Restricts results to those located in the specified inventory.
	AncestorStorageId *string `form:"ancestorStorageId,omitempty" json:"ancestorStorageId,omitempty"`

	// StorageContentsId ID of a batch, entity, or entity schema. Restricts results to those that hold containers with entities or batches associated with the specified ID.
	StorageContentsId *string `form:"storageContentsId,omitempty" json:"storageContentsId,omitempty"`

	// StorageContentsIds Comma-separated list of IDs of batches or entities. Restricts results to those that hold containers with at least one of the specified batches, entities, or batches of the specified entities.
	StorageContentsIds *string `form:"storageContentsIds,omitempty" json:"storageContentsIds,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived boxes. Use "ANY_ARCHIVED" to filter for archived boxes regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// Barcodes Comma-separated list of barcodes. Matches all of the provided barcodes, or returns a 400 error that includes a list of which barcodes are invalid.
	Barcodes *string `form:"barcodes,omitempty" json:"barcodes,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// CreatorIds Comma separated list of users IDs
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`
}

// ListBoxesParamsSort defines parameters for ListBoxes.
type ListBoxesParamsSort string

// ListBoxContentsParams defines parameters for ListBoxContents.
type ListBoxContentsParams struct {
	// PageSize Number of results to return.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// BulkGetBoxesParams defines parameters for BulkGetBoxes.
type BulkGetBoxesParams struct {
	BoxIds   *string `form:"boxIds,omitempty" json:"boxIds,omitempty"`
	Barcodes *string `form:"barcodes,omitempty" json:"barcodes,omitempty"`
}

// ListContainerSchemasParams defines parameters for ListContainerSchemas.
type ListContainerSchemasParams struct {
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`
}

// ListContainersParams defines parameters for ListContainers.
type ListContainersParams struct {
	// PageSize Number of results to return.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// Sort Method by which to order search results. Valid sorts are barcode (bar code, alphabetical) modifiedAt (modified time, most recent first) and name (entity name, alphabetical). Optionally add :asc or :desc to specify ascending or descending order. Default is modifiedAt.
	Sort *ListContainersParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// SchemaId ID of a schema. Restricts results to those of the specified schema.
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// SchemaFields Filter based on schema field value (not display value). Restricts results to those with a field whose value matches the filter. For Integer, Float, and Date type fields, supports the >= and <= operators (but not < or >). If any schemaField filters are present, the schemaId param must also be present. Note that all operators must be separated from any values by a single space.
	SchemaFields *SchemaFieldsQueryParam `form:"schemaFields,omitempty" json:"schemaFields,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of a container. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of a container. Restricts results to those with names that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// AncestorStorageId ID of a plate, box, or location. Restricts results to those located in the specified inventory.
	AncestorStorageId *string `form:"ancestorStorageId,omitempty" json:"ancestorStorageId,omitempty"`

	// StorageContentsId ID of a batch, entity, or entity schema. Restricts results to those that contain the specified batches, batches of the specified entities, or batches of entities of the specified schema.
	StorageContentsId *string `form:"storageContentsId,omitempty" json:"storageContentsId,omitempty"`

	// StorageContentsIds Comma-separated list of IDs of batches or entities. Restricts results to those that hold containers with at least one of the specified batches, entities, or batches of the specified entities.
	StorageContentsIds *string `form:"storageContentsIds,omitempty" json:"storageContentsIds,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived containers. Use "ANY_ARCHIVED" to filter for archived containers regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// CheckoutStatus Comma-separated list of check-out statuses. Restricts results to those that match one of the specified statuses. Valid statuses are AVAILABLE, RESERVED, and CHECKED_OUT.
	CheckoutStatus *ListContainersParamsCheckoutStatus `form:"checkoutStatus,omitempty" json:"checkoutStatus,omitempty"`

	// CheckoutAssigneeIdsAnyOf Comma-separated list of user or team IDs. Maximum of 100. Restricts results to those that are reserved or checked out for a user or team who matches any of the specified IDs or returns a 400 error with a list of invalid IDs.
	CheckoutAssigneeIdsAnyOf *string `form:"checkoutAssigneeIds.anyOf,omitempty" json:"checkoutAssigneeIds.anyOf,omitempty"`

	// RestrictionStatus Comma-separated list of restriction statuses. Restricts results to those that match one of the specified statuses. Valid statuses are RESTRICTED, UNRESTRICTED, and NOT_APPLICABLE.
	RestrictionStatus *SampleRestrictionStatus `form:"restrictionStatus,omitempty" json:"restrictionStatus,omitempty"`

	// SampleOwnerIdsAllOf Comma-separated list of user or team IDs. Restricts results to those that match all of the specified IDs or returns a 400 error with a list of invalid IDs.
	SampleOwnerIdsAllOf *string `form:"sampleOwnerIds.allOf,omitempty" json:"sampleOwnerIds.allOf,omitempty"`

	// SampleOwnerIdsAnyOf Comma-separated list of user or team IDs. Maximum of 100. Restricts results to those that match any of the specified IDs or returns a 400 error with a list of invalid IDs.
	SampleOwnerIdsAnyOf *string `form:"sampleOwnerIds.anyOf,omitempty" json:"sampleOwnerIds.anyOf,omitempty"`

	// SampleOwnerIdsNoneOf Comma-separated list of user or team IDs. Restricts results to those that do not match any of the specified IDs or returns a 400 error with a list of invalid IDs.
	SampleOwnerIdsNoneOf *string `form:"sampleOwnerIds.noneOf,omitempty" json:"sampleOwnerIds.noneOf,omitempty"`

	// RestrictedSamplePartyIdsAllOf Comma-separated list of user, team, or app IDs. Restricts results to those that match all of the specified IDs or returns a 400 error with a list of invalid IDs.
	RestrictedSamplePartyIdsAllOf *string `form:"restrictedSamplePartyIds.allOf,omitempty" json:"restrictedSamplePartyIds.allOf,omitempty"`

	// RestrictedSamplePartyIdsAnyOf Comma-separated list of user, team, or app IDs. Maximum of 100. Restricts results to those that match any of the specified IDs or returns a 400 error with a list of invalid IDs.
	RestrictedSamplePartyIdsAnyOf *string `form:"restrictedSamplePartyIds.anyOf,omitempty" json:"restrictedSamplePartyIds.anyOf,omitempty"`

	// RestrictedSamplePartyIdsNoneOf Comma-separated list of user, team, or app IDs. Restricts results to those that do not match any of the specified IDs or returns a 400 error with a list of invalid IDs.
	RestrictedSamplePartyIdsNoneOf *string `form:"restrictedSamplePartyIds.noneOf,omitempty" json:"restrictedSamplePartyIds.noneOf,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// Barcodes Comma-separated list of barcodes. Matches all of the provided barcodes, or returns a 400 error that includes a list of which barcodes are invalid.
	Barcodes *string `form:"barcodes,omitempty" json:"barcodes,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// CreatorIds Comma separated list of users IDs
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListContainersParamsSort defines parameters for ListContainers.
type ListContainersParamsSort string

// ListContainersParamsCheckoutStatus defines parameters for ListContainers.
type ListContainersParamsCheckoutStatus string

// GetContainerParams defines parameters for GetContainer.
type GetContainerParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// BulkGetContainersParams defines parameters for BulkGetContainers.
type BulkGetContainersParams struct {
	// ContainerIds Comma-separated list of container IDs.
	ContainerIds *string `form:"containerIds,omitempty" json:"containerIds,omitempty"`

	// Barcodes Comma-separated list of barcodes. Matches all of the provided barcodes, or returns a 400 error that includes a list of which barcodes are invalid.
	Barcodes *string `form:"barcodes,omitempty" json:"barcodes,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListCustomEntitiesParams defines parameters for ListCustomEntities.
type ListCustomEntitiesParams struct {
	NextToken *string                       `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int                          `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	Sort      *ListCustomEntitiesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of a custom entity. Restricts results to those with the specified name, alias, or entity registry ID.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`

	// NameIncludes Name substring of a custom entity. Restricts results to those with names, aliases, or entity registry IDs that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// FolderId ID of a folder. Restricts results to those in the folder.
	FolderId *string `form:"folderId,omitempty" json:"folderId,omitempty"`

	// MentionedIn Comma-separated list of entry IDs. Restricts results to custom entities mentioned in those entries.
	MentionedIn *string `form:"mentionedIn,omitempty" json:"mentionedIn,omitempty"`

	// ProjectId ID of a project. Restricts results to those in the project.
	ProjectId *string `form:"projectId,omitempty" json:"projectId,omitempty"`

	// RegistryId ID of a registry. Restricts results to those registered in this registry. Specifying "null" returns unregistered items.
	RegistryId *string `form:"registryId,omitempty" json:"registryId,omitempty"`

	// SchemaId ID of a schema. Restricts results to those of the specified schema.
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// SchemaFields Filter based on schema field value (not display value). Restricts results to those with a field whose value matches the filter. For Integer, Float, and Date type fields, supports the >= and <= operators (but not < or >). If any schemaField filters are present, the schemaId param must also be present. Note that all operators must be separated from any values by a single space.
	SchemaFields *SchemaFieldsQueryParam `form:"schemaFields,omitempty" json:"schemaFields,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived custom entities. Use "ANY_ARCHIVED" to filter for archived custom entities regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// Mentions Comma-separated list of resource IDs. Restricts results to those that mention the given items in the description.
	Mentions *string `form:"mentions,omitempty" json:"mentions,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// EntityRegistryIdsAnyOf Comma-separated list of entity registry IDs. Maximum of 100. Restricts results to those that match any of the specified registry IDs
	EntityRegistryIdsAnyOf *string `form:"entityRegistryIds.anyOf,omitempty" json:"entityRegistryIds.anyOf,omitempty"`

	// CreatorIds Comma separated list of users IDs
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`

	// AuthorIdsAnyOf Comma separated list of user or app IDs. Maximum of 100.
	AuthorIdsAnyOf *string `form:"authorIds.anyOf,omitempty" json:"authorIds.anyOf,omitempty"`
}

// ListCustomEntitiesParamsSort defines parameters for ListCustomEntities.
type ListCustomEntitiesParamsSort string

// GetCustomEntityParams defines parameters for GetCustomEntity.
type GetCustomEntityParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// BulkGetCustomEntitiesParams defines parameters for BulkGetCustomEntities.
type BulkGetCustomEntitiesParams struct {
	// CustomEntityIds Comma-separated list of IDs of custom entities to get.
	CustomEntityIds string `form:"customEntityIds" json:"customEntityIds"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListCustomNotationsParams defines parameters for ListCustomNotations.
type ListCustomNotationsParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
}

// ListDNAAlignmentsParams defines parameters for ListDNAAlignments.
type ListDNAAlignmentsParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string                      `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Sort      *ListDNAAlignmentsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of a DNA Alignment. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of a DNA Alignment. Restricts results to those with names that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// SequenceIds Comma-separated list of sequence ids that own one or more DNA Alignments (i.e. ids of sequences used as the template in a Template Alignment or created as the consensus sequence from a Consensus Alignment). Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	SequenceIds *string `form:"sequenceIds,omitempty" json:"sequenceIds,omitempty"`
}

// ListDNAAlignmentsParamsSort defines parameters for ListDNAAlignments.
type ListDNAAlignmentsParamsSort string

// ListDNAOligosParams defines parameters for ListDNAOligos.
type ListDNAOligosParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string                  `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Sort      *ListDNAOligosParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of a DNA Oligo. Restricts results to those with the specified name, alias, or entity registry ID.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of a DNA Oligo. Restricts results to those with names, aliases, or entity registry IDs that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// Bases Full bases of the DNA Oligo. Restricts results to those with the specified bases, case-insensitive, allowing for circular or reverse complement matches. Does not allow partial matching or loose matching via degenerate bases.
	Bases *string `form:"bases,omitempty" json:"bases,omitempty"`

	// FolderId ID of a folder. Restricts results to those in the folder.
	FolderId *string `form:"folderId,omitempty" json:"folderId,omitempty"`

	// MentionedIn Comma-separated list of entry IDs. Restricts results to DNA Oligos mentioned in those entries.
	MentionedIn *string `form:"mentionedIn,omitempty" json:"mentionedIn,omitempty"`

	// ProjectId ID of a project. Restricts results to those in the project.
	ProjectId *string `form:"projectId,omitempty" json:"projectId,omitempty"`

	// RegistryId ID of a registry. Restricts results to those registered in this registry. Specifying "null" returns unregistered items.
	RegistryId *string `form:"registryId,omitempty" json:"registryId,omitempty"`

	// SchemaId ID of a schema. Restricts results to those of the specified schema.
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// SchemaFields Filter based on schema field value (not display value). Restricts results to those with a field whose value matches the filter. For Integer, Float, and Date type fields, supports the >= and <= operators (but not < or >). If any schemaField filters are present, the schemaId param must also be present. Note that all operators must be separated from any values by a single space.
	SchemaFields *SchemaFieldsQueryParam `form:"schemaFields,omitempty" json:"schemaFields,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived DNA Oligos. Use "ANY_ARCHIVED" to filter for archived DNA Oligos regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// Mentions Comma-separated list of item IDs. Restricts results to those that mention the given items in the description.
	Mentions *string `form:"mentions,omitempty" json:"mentions,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// EntityRegistryIdsAnyOf Comma-separated list of entity registry IDs. Maximum of 100. Restricts results to those that match any of the specified registry IDs.
	EntityRegistryIdsAnyOf *string `form:"entityRegistryIds.anyOf,omitempty" json:"entityRegistryIds.anyOf,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// CreatorIds Comma separated list of users IDs
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`

	// AuthorIdsAnyOf Comma separated list of user or app IDs. Maximum of 100.
	AuthorIdsAnyOf *string `form:"authorIds.anyOf,omitempty" json:"authorIds.anyOf,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`

	// CustomNotationId ID of the notation to use in populating the customNotation field.
	CustomNotationId *string `form:"customNotationId,omitempty" json:"customNotationId,omitempty"`
}

// ListDNAOligosParamsSort defines parameters for ListDNAOligos.
type ListDNAOligosParamsSort string

// GetDNAOligoParams defines parameters for GetDNAOligo.
type GetDNAOligoParams struct {
	// CustomNotationId ID of the notation to use in populating the customNotation field.
	CustomNotationId *string `form:"customNotationId,omitempty" json:"customNotationId,omitempty"`
}

// ListDNASequencesParams defines parameters for ListDNASequences.
type ListDNASequencesParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string                     `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Sort      *ListDNASequencesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of a DNA Sequence. Restricts results to those with the specified name, alias, or entity registry ID.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of a DNA Sequence. Restricts results to those with names, aliases, or entity registry IDs that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// Bases Full bases of the DNA sequence. Restricts results to those with the specified bases, case-insensitive, allowing for circular or reverse complement matches. Does not allow partial matching or loose matching via degenerate bases.
	Bases *string `form:"bases,omitempty" json:"bases,omitempty"`

	// FolderId ID of a folder. Restricts results to those in the folder.
	FolderId *string `form:"folderId,omitempty" json:"folderId,omitempty"`

	// MentionedIn Comma-separated list of entry IDs. Restricts results to DNA sequences mentioned in those entries.
	MentionedIn *string `form:"mentionedIn,omitempty" json:"mentionedIn,omitempty"`

	// ProjectId ID of a project. Restricts results to those in the project.
	ProjectId *string `form:"projectId,omitempty" json:"projectId,omitempty"`

	// RegistryId ID of a registry. Restricts results to those registered in this registry. Specifying "null" returns unregistered items.
	RegistryId *string `form:"registryId,omitempty" json:"registryId,omitempty"`

	// SchemaId ID of a schema. Restricts results to those of the specified schema.
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// SchemaFields Filter based on schema field value (not display value). Restricts results to those with a field whose value matches the filter. For Integer, Float, and Date type fields, supports the >= and <= operators (but not < or >). If any schemaField filters are present, the schemaId param must also be present. Note that all operators must be separated from any values by a single space.
	SchemaFields *SchemaFieldsQueryParam `form:"schemaFields,omitempty" json:"schemaFields,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived DNA sequences. Use "ANY_ARCHIVED" to filter for archived DNA sequences regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// Mentions Comma-separated list of item IDs. Restricts results to those that mention the given items in the description.
	Mentions *string `form:"mentions,omitempty" json:"mentions,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// EntityRegistryIdsAnyOf Comma-separated list of entity registry IDs. Maximum of 100. Restricts results to those that match any of the specified registry IDs.
	EntityRegistryIdsAnyOf *string `form:"entityRegistryIds.anyOf,omitempty" json:"entityRegistryIds.anyOf,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// CreatorIds Comma separated list of users IDs
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`

	// AuthorIdsAnyOf Comma separated list of user or app IDs. Maximum of 100.
	AuthorIdsAnyOf *string `form:"authorIds.anyOf,omitempty" json:"authorIds.anyOf,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	//
	// **Note**: Fields annotations, translations, and primers cannot be introspected with the returning parameter, and any sub fields will be ignored. E.g.: "dnaSequences.annotations.id" will return the same as "dnaSequences.annotations".
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListDNASequencesParamsSort defines parameters for ListDNASequences.
type ListDNASequencesParamsSort string

// GetDNASequenceParams defines parameters for GetDNASequence.
type GetDNASequenceParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	//
	// **Note**: Fields annotations, translations, and primers cannot be introspected with the returning parameter, and any sub fields will be ignored. E.g.: "annotations.id" will return the same as "annotations".
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// BulkGetDNASequencesParams defines parameters for BulkGetDNASequences.
type BulkGetDNASequencesParams struct {
	// DnaSequenceIds Comma-separated list of IDs of DNA sequences to get.
	DnaSequenceIds string `form:"dnaSequenceIds" json:"dnaSequenceIds"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	//
	// **Note**: Fields annotations, translations, and primers cannot be introspected with the returning parameter, and any sub fields will be ignored. E.g.: "dnaSequences.annotations.id" will return the same as "dnaSequences.annotations".
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListDropdownsParams defines parameters for ListDropdowns.
type ListDropdownsParams struct {
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// ListEntitySchemasParams defines parameters for ListEntitySchemas.
type ListEntitySchemasParams struct {
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`
}

// ListEntriesParams defines parameters for ListEntries.
type ListEntriesParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// Sort Method by which to order search results. Valid sorts are modifiedAt (modified time, most recent first) and name (entity name, alphabetical). Optionally add :asc or :desc to specify ascending or descending order.
	Sort *ListEntriesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of an Entry. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// ProjectId ID of a project. Restricts results to those in the project.
	ProjectId *string `form:"projectId,omitempty" json:"projectId,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived entries. Use "ANY_ARCHIVED" to filter for archived entries regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// ReviewStatus Restrict results to those with the given review status. Supported statuses: IN_PROGRESS, ACCEPTED, REJECTED, NEEDS_REVIEW, RETRACTED
	ReviewStatus *ListEntriesParamsReviewStatus `form:"reviewStatus,omitempty" json:"reviewStatus,omitempty"`

	// MentionedIn Comma-separated list of entry IDs. Restricts results to those mentioned within the entries in this list.
	MentionedIn *string `form:"mentionedIn,omitempty" json:"mentionedIn,omitempty"`

	// Mentions Comma-separated list of resource IDs. Restricts results to entries that mention the given items.
	Mentions *string `form:"mentions,omitempty" json:"mentions,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// SchemaId ID of a schema. Restricts results to those of the specified schema.
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// AssignedReviewerIdsAnyOf Comma-separated list of ids. Restricts results to entries that have assignees of any of the specified ids.
	AssignedReviewerIdsAnyOf *string `form:"assignedReviewerIds.anyOf,omitempty" json:"assignedReviewerIds.anyOf,omitempty"`

	// CreatorIds Comma separated list of users IDs.
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`

	// AuthorIdsAnyOf Comma separated list of user or app IDs. Maximum of 100.
	AuthorIdsAnyOf *string `form:"authorIds.anyOf,omitempty" json:"authorIds.anyOf,omitempty"`

	// DisplayIds Comma-separated list of Entry Display IDs.
	DisplayIds *string `form:"displayIds,omitempty" json:"displayIds,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	//
	// **Note:** "entries.days.notes" cannot be introspected with the returning parameter, and any sub fields will be ignored. E.g., "entries.days.notes.text" will return the same model as "entries.days.notes".
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListEntriesParamsSort defines parameters for ListEntries.
type ListEntriesParamsSort string

// ListEntriesParamsReviewStatus defines parameters for ListEntries.
type ListEntriesParamsReviewStatus string

// GetEntryParams defines parameters for GetEntry.
type GetEntryParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	//
	// **Note:** "days.notes" cannot be introspected with the returning parameter, and any sub fields will be ignored. E.g., "days.notes.text" will return the same model as "days.notes".
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// UpdateEntryParams defines parameters for UpdateEntry.
type UpdateEntryParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	//
	// **Note:** "days.notes" cannot be introspected with the returning parameter, and any sub fields will be ignored. E.g., "days.notes.text" will return the same model as "days.notes".
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// BulkGetEntriesParams defines parameters for BulkGetEntries.
type BulkGetEntriesParams struct {
	// EntryIds Comma-separated list of Entry IDs.
	EntryIds *string `form:"entryIds,omitempty" json:"entryIds,omitempty"`

	// DisplayIds Comma-separated list of Entry Display IDs.
	DisplayIds *string `form:"displayIds,omitempty" json:"displayIds,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	//
	// **Note:** "entries.days.notes" cannot be introspected with the returning parameter, and any sub fields will be ignored. E.g., "entries.days.notes.text" will return the same model as "entries.days.notes".
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListEntrySchemasParams defines parameters for ListEntrySchemas.
type ListEntrySchemasParams struct {
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`
}

// ListEntryTemplatesParams defines parameters for ListEntryTemplates.
type ListEntryTemplatesParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of an Entry Template. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// TemplateCollectionId ID of a template collection. Resticts results to those in the template collection.
	TemplateCollectionId *string `form:"templateCollectionId,omitempty" json:"templateCollectionId,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// SchemaId ID of a schema. Restricts results to those of the specified schema.
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	//
	// **Note:** "entryTemplates.days.notes" cannot be introspected with the returning parameter, and any sub fields will be ignored. E.g., "entryTemplates.days.notes.text" will return the same model as "entryTemplates.days.notes".
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// GetEntryTemplateParams defines parameters for GetEntryTemplate.
type GetEntryTemplateParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	//
	// **Note:** "days.notes" cannot be introspected with the returning parameter, and any sub fields will be ignored. E.g., "days.notes.text" will return the same model as "days.notes".
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListEventsParams defines parameters for ListEvents.
type ListEventsParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// CreatedAtGte Datetime, in RFC 3339 format. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. "2020-05-23".
	CreatedAtGte *string `form:"createdAt.gte,omitempty" json:"createdAt.gte,omitempty"`

	// StartingAfter Event ID after which events will be returned.
	StartingAfter *string `form:"startingAfter,omitempty" json:"startingAfter,omitempty"`

	// EventTypes Comma-separated list of event types to return.
	EventTypes *string `form:"eventTypes,omitempty" json:"eventTypes,omitempty"`

	// Poll When True, the API will always return a nextToken to enable polling events indefinitely.
	Poll *bool `form:"poll,omitempty" json:"poll,omitempty"`
}

// ListFeatureLibrariesParams defines parameters for ListFeatureLibraries.
type ListFeatureLibrariesParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string                         `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Sort      *ListFeatureLibrariesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of a Feature Library. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of a Feature Library. Restricts results to those with names that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListFeatureLibrariesParamsSort defines parameters for ListFeatureLibraries.
type ListFeatureLibrariesParamsSort string

// GetFeatureLibraryParams defines parameters for GetFeatureLibrary.
type GetFeatureLibraryParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListFeaturesParams defines parameters for ListFeatures.
type ListFeaturesParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// Name Name of a Feature. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// FeatureLibraryId Id of a Feature Library. Restricts results to those associated with the provided feature library
	FeatureLibraryId *string `form:"featureLibraryId,omitempty" json:"featureLibraryId,omitempty"`

	// FeatureType The type of feature, like gene, promoter, etc. Note: This is an arbitrary string, not an enum
	FeatureType *string `form:"featureType,omitempty" json:"featureType,omitempty"`

	// MatchType The match type of the feature used to determine how auto-annotate matches are made.
	MatchType *ListFeaturesParamsMatchType `form:"matchType,omitempty" json:"matchType,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListFeaturesParamsMatchType defines parameters for ListFeatures.
type ListFeaturesParamsMatchType string

// GetFeatureParams defines parameters for GetFeature.
type GetFeatureParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListFoldersParams defines parameters for ListFolders.
type ListFoldersParams struct {
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Sort Method by which to order search results. Valid sorts are modifiedAt (modified time, most recent first) and name (folder name, alphabetical). Optionally add :asc or :desc to specify ascending or descending order.
	Sort *ListFoldersParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived folders. Use "ANY_ARCHIVED" to filter for archived folders regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// NameIncludes Name substring of a folder. Restricts results to those with names that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// ParentFolderId ID of a folder. Restricts results to those in the folder. Use "NO_PARENT" to filter for root folders.
	ParentFolderId *string `form:"parentFolderId,omitempty" json:"parentFolderId,omitempty"`

	// ProjectId ID of a project. Restricts results to those in the project.
	ProjectId *string `form:"projectId,omitempty" json:"projectId,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// Name Name of a folder. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Section INVENTORY or NOTEBOOK. Returns folders of inventory type or notebook type. Returns all folders if sections are merged.
	Section *ListFoldersParamsSection `form:"section,omitempty" json:"section,omitempty"`
}

// ListFoldersParamsSort defines parameters for ListFolders.
type ListFoldersParamsSort string

// ListFoldersParamsSection defines parameters for ListFolders.
type ListFoldersParamsSection string

// ListLocationSchemasParams defines parameters for ListLocationSchemas.
type ListLocationSchemasParams struct {
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// ListLocationsParams defines parameters for ListLocations.
type ListLocationsParams struct {
	// PageSize Number of results to return.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// Sort Method by which to order search results. Valid sorts are barcode (barcode, alphabetical) modifiedAt (modified time, most recent first) and name (location name, alphabetical). Optionally add :asc or :desc to specify ascending or descending order. Default is modifiedAt.
	Sort *ListLocationsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// SchemaId ID of a schema. Restricts results to those of the specified schema.
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// SchemaFields Filter based on schema field value (not display value). Restricts results to those with a field whose value matches the filter. For Integer, Float, and Date type fields, supports the >= and <= operators (but not < or >). If any schemaField filters are present, the schemaId param must also be present. Note that all operators must be separated from any values by a single space.
	SchemaFields *SchemaFieldsQueryParam `form:"schemaFields,omitempty" json:"schemaFields,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of a location. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of a location. Restricts results to those with names that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// AncestorStorageId ID of a plate, box, or location. Restricts results to those located in the specified inventory.
	AncestorStorageId *string `form:"ancestorStorageId,omitempty" json:"ancestorStorageId,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived locations. Use "ANY_ARCHIVED" to filter for archived locations regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// Barcodes Comma-separated list of barcodes. Matches all of the provided barcodes, or returns a 400 error that includes a list of which barcodes are invalid.
	Barcodes *string `form:"barcodes,omitempty" json:"barcodes,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// CreatorIds Comma separated list of users IDs
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`
}

// ListLocationsParamsSort defines parameters for ListLocations.
type ListLocationsParamsSort string

// BulkGetLocationsParams defines parameters for BulkGetLocations.
type BulkGetLocationsParams struct {
	// LocationIds Comma-separated list of location IDs.
	LocationIds *string `form:"locationIds,omitempty" json:"locationIds,omitempty"`

	// Barcodes Comma-separated list of location barcodes.
	Barcodes *string `form:"barcodes,omitempty" json:"barcodes,omitempty"`
}

// ListMixturesParams defines parameters for ListMixtures.
type ListMixturesParams struct {
	NextToken *string                 `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int                    `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	Sort      *ListMixturesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of a mixture. Restricts results to those with the specified name, alias, or entity registry ID.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of a mixture. Restricts results to those with names, aliases, or entity registry IDs that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// FolderId ID of a folder. Restricts results to those in the folder.
	FolderId *string `form:"folderId,omitempty" json:"folderId,omitempty"`

	// MentionedIn Comma-separated list of entry IDs. Restricts results to mixtures mentioned in those entries.
	MentionedIn *string `form:"mentionedIn,omitempty" json:"mentionedIn,omitempty"`

	// ProjectId ID of a project. Restricts results to those in the project.
	ProjectId *string `form:"projectId,omitempty" json:"projectId,omitempty"`

	// RegistryId ID of a registry. Restricts results to those registered in this registry. Specifying "null" returns unregistered items.
	RegistryId *string `form:"registryId,omitempty" json:"registryId,omitempty"`

	// SchemaId ID of a schema. Restricts results to those of the specified schema.
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// SchemaFields Filter based on schema field value (not display value). Restricts results to those with a field whose value matches the filter. For Integer, Float, and Date type fields, supports the >= and <= operators (but not < or >). If any schemaField filters are present, the schemaId param must also be present. Note that all operators must be separated from any values by a single space.
	SchemaFields *SchemaFieldsQueryParam `form:"schemaFields,omitempty" json:"schemaFields,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived mixtures. Use "ANY_ARCHIVED" to filter for archived mixtures regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// Mentions Comma-separated list of resource IDs. Restricts results to those that mention the given items in the description.
	Mentions *string `form:"mentions,omitempty" json:"mentions,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// EntityRegistryIdsAnyOf Comma-separated list of entity registry IDs. Maximum of 100. Restricts results to those that match any of the specified registry IDs.
	EntityRegistryIdsAnyOf *string `form:"entityRegistryIds.anyOf,omitempty" json:"entityRegistryIds.anyOf,omitempty"`

	// IngredientComponentEntityIds Comma-separated list of ingredient component entity ids. Matches all mixtures that contain ingredients whose component entities match all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	IngredientComponentEntityIds *string `form:"ingredientComponentEntityIds,omitempty" json:"ingredientComponentEntityIds,omitempty"`

	// IngredientComponentEntityIdsAnyOf Comma-separated list of ingredient component entity ids. Maximum of 100. Matches all mixtures that contain ingredients whose component entities match any of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	IngredientComponentEntityIdsAnyOf *string `form:"ingredientComponentEntityIds.anyOf,omitempty" json:"ingredientComponentEntityIds.anyOf,omitempty"`

	// AuthorIdsAnyOf Comma separated list of user or app IDs. Maximum of 100.
	AuthorIdsAnyOf *string `form:"authorIds.anyOf,omitempty" json:"authorIds.anyOf,omitempty"`
}

// ListMixturesParamsSort defines parameters for ListMixtures.
type ListMixturesParamsSort string

// ListMoleculesParams defines parameters for ListMolecules.
type ListMoleculesParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string                  `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Sort      *ListMoleculesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of a Molecule. Restricts results to those with the specified name, alias, or entity registry ID.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of a Molecule. Restricts results to those with names, aliases, or entity registry IDs that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// FolderId ID of a folder. Restricts results to those in the folder.
	FolderId *string `form:"folderId,omitempty" json:"folderId,omitempty"`

	// MentionedIn Comma-separated list of entry IDs. Restricts results to Molecules mentioned in those entries.
	MentionedIn *[]string `form:"mentionedIn,omitempty" json:"mentionedIn,omitempty"`

	// ProjectId ID of a project. Restricts results to those in the project.
	ProjectId *string `form:"projectId,omitempty" json:"projectId,omitempty"`

	// RegistryId ID of a registry. Restricts results to those registered in this registry. Specifying "null" returns unregistered items.
	RegistryId *string `form:"registryId,omitempty" json:"registryId,omitempty"`

	// SchemaId ID of a schema. Restricts results to those of the specified schema.
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// SchemaFields Filter based on schema field value (not display value). Restricts results to those with a field whose value matches the filter. For Integer, Float, and Date type fields, supports the >= and <= operators (but not < or >). If any schemaField filters are present, the schemaId param must also be present. Note that all operators must be separated from any values by a single space.
	SchemaFields *SchemaFieldsQueryParam `form:"schemaFields,omitempty" json:"schemaFields,omitempty"`

	// ArchiveReason Archive reason. Restricts results to those with the specified archive reason. Use “NOT_ARCHIVED” to filter for unarchived Molecules. Use "ANY_ARCHIVED" to filter for archived Molecules regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// Mentions Comma-separated list of item IDs. Restricts results to those that mention the given items in the description.
	Mentions *[]string `form:"mentions,omitempty" json:"mentions,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// EntityRegistryIdsAnyOf Comma-separated list of entity registry IDs. Maximum of 100. Restricts results to those that match any of the specified registry IDs.
	EntityRegistryIdsAnyOf *string `form:"entityRegistryIds.anyOf,omitempty" json:"entityRegistryIds.anyOf,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// AuthorIdsAnyOf Comma separated list of user or app IDs. Maximum of 100.
	AuthorIdsAnyOf *string `form:"authorIds.anyOf,omitempty" json:"authorIds.anyOf,omitempty"`

	// ChemicalSubstructureMol mol-formatted string for a chemical substructure to search by
	ChemicalSubstructureMol *string `form:"chemicalSubstructure.mol,omitempty" json:"chemicalSubstructure.mol,omitempty"`

	// ChemicalSubstructureSmiles SMILES string for a chemical substructure to search by
	ChemicalSubstructureSmiles *string `form:"chemicalSubstructure.smiles,omitempty" json:"chemicalSubstructure.smiles,omitempty"`
}

// ListMoleculesParamsSort defines parameters for ListMolecules.
type ListMoleculesParamsSort string

// ListMonomersParams defines parameters for ListMonomers.
type ListMonomersParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// CreateMonomerParams defines parameters for CreateMonomer.
type CreateMonomerParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// UpdateMonomerParams defines parameters for UpdateMonomer.
type UpdateMonomerParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListNucleotideAlignmentsParams defines parameters for ListNucleotideAlignments.
type ListNucleotideAlignmentsParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string                             `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Sort      *ListNucleotideAlignmentsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of a Nucleotide Alignment. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of a Nucleotide Alignment. Restricts results to those with names that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// SequenceIds Comma-separated list of sequence ids that own one or more Nucleotide Alignments (i.e. ids of sequences used as the template in a Template Alignment or created as the consensus sequence from a Consensus Alignment). Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	SequenceIds *string `form:"sequenceIds,omitempty" json:"sequenceIds,omitempty"`
}

// ListNucleotideAlignmentsParamsSort defines parameters for ListNucleotideAlignments.
type ListNucleotideAlignmentsParamsSort string

// ListOligosParams defines parameters for ListOligos.
type ListOligosParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string               `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Sort      *ListOligosParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of an Oligo. Restricts results to those with the specified name, alias, or entity registry ID.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Bases Full bases of the oligo. Restricts results to those with the specified bases, case-insensitive, allowing for circular or reverse complement matches. Does not allow partial matching or loose matching via degenerate bases.
	Bases *string `form:"bases,omitempty" json:"bases,omitempty"`

	// FolderId ID of a folder. Restricts results to those in the folder.
	FolderId *string `form:"folderId,omitempty" json:"folderId,omitempty"`

	// MentionedIn Comma-separated list of entry IDs. Restricts results to Oligos mentioned in those entries.
	MentionedIn *string `form:"mentionedIn,omitempty" json:"mentionedIn,omitempty"`

	// ProjectId ID of a project. Restricts results to those in the project.
	ProjectId *string `form:"projectId,omitempty" json:"projectId,omitempty"`

	// RegistryId ID of a registry. Restricts results to those registered in this registry. Specifying "null" returns unregistered items.
	RegistryId *string `form:"registryId,omitempty" json:"registryId,omitempty"`

	// SchemaId ID of a schema. Restricts results to those of the specified schema.
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// SchemaFields Filter based on schema field value (not display value). Restricts results to those with a field whose value matches the filter. For Integer, Float, and Date type fields, supports the >= and <= operators (but not < or >). If any schemaField filters are present, the schemaId param must also be present. Note that all operators must be separated from any values by a single space.
	SchemaFields *SchemaFieldsQueryParam `form:"schemaFields,omitempty" json:"schemaFields,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived Oligos. Use "ANY_ARCHIVED" to filter for archived Oligos regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// Mentions Comma-separated list of item IDs. Restricts results to those that mention the given items in the description.
	Mentions *string `form:"mentions,omitempty" json:"mentions,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// EntityRegistryIdsAnyOf Comma-separated list of entity registry IDs. Maximum of 100. Restricts results to those that match any of the specified registry IDs.
	EntityRegistryIdsAnyOf *string `form:"entityRegistryIds.anyOf,omitempty" json:"entityRegistryIds.anyOf,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// CreatorIds Comma separated list of users IDs
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListOligosParamsSort defines parameters for ListOligos.
type ListOligosParamsSort string

// GetOligoParams defines parameters for GetOligo.
type GetOligoParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// BulkGetOligosParams defines parameters for BulkGetOligos.
type BulkGetOligosParams struct {
	// OligoIds Comma-separated list of IDs of Oligos to get.
	OligoIds string `form:"oligoIds" json:"oligoIds"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListOrganizationsParams defines parameters for ListOrganizations.
type ListOrganizationsParams struct {
	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// Name Name of an organization. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of an organization. Restricts results to those with names that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// HasMembers Comma-separated list of user or Benchling app IDs. Restricts results to organizations that include all the given users/apps as members.
	HasMembers *string `form:"hasMembers,omitempty" json:"hasMembers,omitempty"`

	// HasAdmins Comma-separated list of user or Benchling app IDs. Restricts results to organizations that include all the given users/apps as admins.
	HasAdmins *string `form:"hasAdmins,omitempty" json:"hasAdmins,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string                      `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Sort      *ListOrganizationsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListOrganizationsParamsSort defines parameters for ListOrganizations.
type ListOrganizationsParamsSort string

// ListPlateSchemasParams defines parameters for ListPlateSchemas.
type ListPlateSchemasParams struct {
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// ListPlatesParams defines parameters for ListPlates.
type ListPlatesParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string               `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Sort      *ListPlatesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// SchemaId ID of a schema. Restricts results to those of the specified schema.
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// SchemaFields Filter based on schema field value (not display value). Restricts results to those with a field whose value matches the filter. For Integer, Float, and Date type fields, supports the >= and <= operators (but not < or >). If any schemaField filters are present, the schemaId param must also be present. Note that all operators must be separated from any values by a single space.
	SchemaFields *SchemaFieldsQueryParam `form:"schemaFields,omitempty" json:"schemaFields,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of a plate. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of a plate. Restricts results to those with names that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// AncestorStorageId ID of a location. Restricts results to those located in the specified inventory.
	AncestorStorageId *string `form:"ancestorStorageId,omitempty" json:"ancestorStorageId,omitempty"`

	// StorageContentsId ID of a batch, entity, or entity schema. Restricts results to those that hold containers with entities or batches associated with the specified ID.
	StorageContentsId *string `form:"storageContentsId,omitempty" json:"storageContentsId,omitempty"`

	// StorageContentsIds Comma-separated list of IDs of batches or entities. Restricts results to those that hold containers with at least one of the specified batches, entities, or batches of the specified entities.
	StorageContentsIds *string `form:"storageContentsIds,omitempty" json:"storageContentsIds,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived plates. Use "ANY_ARCHIVED" to filter for archived plates regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// Barcodes Comma-separated list of barcodes. Matches all of the provided barcodes, or returns a 400 error that includes a list of which barcodes are invalid.
	Barcodes *string `form:"barcodes,omitempty" json:"barcodes,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`

	// CreatorIds Comma separated list of users IDs
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`
}

// ListPlatesParamsSort defines parameters for ListPlates.
type ListPlatesParamsSort string

// CreatePlateParams defines parameters for CreatePlate.
type CreatePlateParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// GetPlateParams defines parameters for GetPlate.
type GetPlateParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// UpdatePlateParams defines parameters for UpdatePlate.
type UpdatePlateParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// BulkGetPlatesParams defines parameters for BulkGetPlates.
type BulkGetPlatesParams struct {
	// PlateIds Comma-separated list of plate IDs.
	PlateIds *string `form:"plateIds,omitempty" json:"plateIds,omitempty"`

	// Barcodes Comma-separated list of plate barcodes.
	Barcodes *string `form:"barcodes,omitempty" json:"barcodes,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListProjectsParams defines parameters for ListProjects.
type ListProjectsParams struct {
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Sort Method by which to order search results. Valid sorts are modifiedAt (modified time, most recent first) and name (project name, alphabetical). Optionally add :asc or :desc to specify ascending or descending order. Default is modifiedAt.
	Sort *ListProjectsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived projects. Use "ANY_ARCHIVED" to filter for archived projects regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// Name Name of a project. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// ListProjectsParamsSort defines parameters for ListProjects.
type ListProjectsParamsSort string

// ListRegistriesParams defines parameters for ListRegistries.
type ListRegistriesParams struct {
	// Name Name of a registry. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`
}

// ListPrintersParams defines parameters for ListPrinters.
type ListPrintersParams struct {
	// Name Name of a printer. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// ListLabelTemplatesParams defines parameters for ListLabelTemplates.
type ListLabelTemplatesParams struct {
	// Name Name of a label template. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// BulkGetRegisteredEntitiesParams defines parameters for BulkGetRegisteredEntities.
type BulkGetRegisteredEntitiesParams struct {
	// EntityRegistryIds Comma separated list of entity Registry IDs
	EntityRegistryIds string `form:"entityRegistryIds" json:"entityRegistryIds"`
}

// ListRequestFulfillmentsParams defines parameters for ListRequestFulfillments.
type ListRequestFulfillmentsParams struct {
	EntryId string `form:"entryId" json:"entryId"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`
	NextToken  *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize   *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`
}

// ListRequestSchemasParams defines parameters for ListRequestSchemas.
type ListRequestSchemasParams struct {
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`
}

// ListRequestTaskSchemasParams defines parameters for ListRequestTaskSchemas.
type ListRequestTaskSchemasParams struct {
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`
}

// ListRequestsParams defines parameters for ListRequests.
type ListRequestsParams struct {
	SchemaId      string         `form:"schemaId" json:"schemaId"`
	RequestStatus *RequestStatus `form:"requestStatus,omitempty" json:"requestStatus,omitempty"`

	// MinCreatedTime minimum create time (unix seconds)
	MinCreatedTime *int `form:"minCreatedTime,omitempty" json:"minCreatedTime,omitempty"`

	// MaxCreatedTime maximum create time (unix seconds)
	MaxCreatedTime *int    `form:"maxCreatedTime,omitempty" json:"maxCreatedTime,omitempty"`
	NextToken      *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize       *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// GetRequestParams defines parameters for GetRequest.
type GetRequestParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// BulkGetRequestsParams defines parameters for BulkGetRequests.
type BulkGetRequestsParams struct {
	// RequestIds Comma-separated list of request IDs. Exactly one of requestIds or displayIds must be specified.
	RequestIds *string `form:"requestIds,omitempty" json:"requestIds,omitempty"`

	// DisplayIds Comma-separated list of display IDs. Exactly one of requestIds or displayIds must be specified.
	DisplayIds *string `form:"displayIds,omitempty" json:"displayIds,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListRNAOligosParams defines parameters for ListRNAOligos.
type ListRNAOligosParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string                  `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Sort      *ListRNAOligosParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of an RNA Oligo. Restricts results to those with the specified name, alias, or entity registry ID.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of an RNA Oligo. Restricts results to those with names, aliases, or entity registry IDs that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// Bases Full bases of the RNA Oligo. Restricts results to those with the specified bases, case-insensitive, allowing for circular or reverse complement matches. Does not allow partial matching or loose matching via degenerate bases.
	Bases *string `form:"bases,omitempty" json:"bases,omitempty"`

	// FolderId ID of a folder. Restricts results to those in the folder.
	FolderId *string `form:"folderId,omitempty" json:"folderId,omitempty"`

	// MentionedIn Comma-separated list of entry IDs. Restricts results to RNA Oligos mentioned in those entries.
	MentionedIn *string `form:"mentionedIn,omitempty" json:"mentionedIn,omitempty"`

	// ProjectId ID of a project. Restricts results to those in the project.
	ProjectId *string `form:"projectId,omitempty" json:"projectId,omitempty"`

	// RegistryId ID of a registry. Restricts results to those registered in this registry. Specifying "null" returns unregistered items.
	RegistryId *string `form:"registryId,omitempty" json:"registryId,omitempty"`

	// SchemaId ID of a schema. Restricts results to those of the specified schema.
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// SchemaFields Filter based on schema field value (not display value). Restricts results to those with a field whose value matches the filter. For Integer, Float, and Date type fields, supports the >= and <= operators (but not < or >). If any schemaField filters are present, the schemaId param must also be present. Note that all operators must be separated from any values by a single space.
	SchemaFields *SchemaFieldsQueryParam `form:"schemaFields,omitempty" json:"schemaFields,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived RNA Oligos. Use "ANY_ARCHIVED" to filter for archived RNA Oligos regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// Mentions Comma-separated list of item IDs. Restricts results to those that mention the given items in the description.
	Mentions *string `form:"mentions,omitempty" json:"mentions,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// EntityRegistryIdsAnyOf Comma-separated list of entity registry IDs. Maximum of 100. Restricts results to those that match any of the specified registry IDs.
	EntityRegistryIdsAnyOf *string `form:"entityRegistryIds.anyOf,omitempty" json:"entityRegistryIds.anyOf,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// CreatorIds Comma separated list of users IDs
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`

	// AuthorIdsAnyOf Comma separated list of user or app IDs. Maximum of 100.
	AuthorIdsAnyOf *string `form:"authorIds.anyOf,omitempty" json:"authorIds.anyOf,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`

	// CustomNotationId ID of the notation to use in populating the customNotation field.
	CustomNotationId *string `form:"customNotationId,omitempty" json:"customNotationId,omitempty"`
}

// ListRNAOligosParamsSort defines parameters for ListRNAOligos.
type ListRNAOligosParamsSort string

// GetRNAOligoParams defines parameters for GetRNAOligo.
type GetRNAOligoParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`

	// CustomNotationId ID of the notation to use in populating the customNotation field.
	CustomNotationId *string `form:"customNotationId,omitempty" json:"customNotationId,omitempty"`
}

// ListRNASequencesParams defines parameters for ListRNASequences.
type ListRNASequencesParams struct {
	// PageSize Number of results to return. Defaults to 50, maximum of 100.
	PageSize *int `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string                     `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Sort      *ListRNASequencesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// Name Name of an RNA Sequence. Restricts results to those with the specified name, alias, or entity registry ID.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of an RNA Sequence. Restricts results to those with names, aliases, or entity registry IDs that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// Bases Full bases of the RNA sequence. Restricts results to those with the specified bases, case-insensitive, allowing for circular or reverse complement matches. Does not allow partial matching or loose matching via degenerate bases.
	Bases *string `form:"bases,omitempty" json:"bases,omitempty"`

	// FolderId ID of a folder. Restricts results to those in the folder.
	FolderId *string `form:"folderId,omitempty" json:"folderId,omitempty"`

	// MentionedIn Comma-separated list of entry IDs. Restricts results to RNA sequences mentioned in those entries.
	MentionedIn *string `form:"mentionedIn,omitempty" json:"mentionedIn,omitempty"`

	// ProjectId ID of a project. Restricts results to those in the project.
	ProjectId *string `form:"projectId,omitempty" json:"projectId,omitempty"`

	// RegistryId ID of a registry. Restricts results to those registered in this registry. Specifying "null" returns unregistered items.
	RegistryId *string `form:"registryId,omitempty" json:"registryId,omitempty"`

	// SchemaId ID of a schema. Restricts results to those of the specified schema.
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// SchemaFields Filter based on schema field value (not display value). Restricts results to those with a field whose value matches the filter. For Integer, Float, and Date type fields, supports the >= and <= operators (but not < or >). If any schemaField filters are present, the schemaId param must also be present. Note that all operators must be separated from any values by a single space.
	SchemaFields *SchemaFieldsQueryParam `form:"schemaFields,omitempty" json:"schemaFields,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived RNA sequences. Use "ANY_ARCHIVED" to filter for archived RNA sequences regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`

	// Mentions Comma-separated list of item IDs. Restricts results to those that mention the given items in the description.
	Mentions *string `form:"mentions,omitempty" json:"mentions,omitempty"`

	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// EntityRegistryIdsAnyOf Comma-separated list of entity registry IDs. Maximum of 100. Restricts results to those that match any of the specified registry IDs.
	EntityRegistryIdsAnyOf *string `form:"entityRegistryIds.anyOf,omitempty" json:"entityRegistryIds.anyOf,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, aliases, or entity registry IDs, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// CreatorIds Comma separated list of users IDs
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`

	// AuthorIdsAnyOf Comma separated list of user or app IDs. Maximum of 100.
	AuthorIdsAnyOf *string `form:"authorIds.anyOf,omitempty" json:"authorIds.anyOf,omitempty"`

	// CustomNotationId ID of the notation to use in populating the customNotation field.
	CustomNotationId *string `form:"customNotationId,omitempty" json:"customNotationId,omitempty"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	//
	// **Note**: Fields annotations, translations, and primers cannot be introspected with the returning parameter, and any sub fields will be ignored. E.g.: "rnaSequences.annotations.id" will return the same as "rnaSequences.annotations".
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListRNASequencesParamsSort defines parameters for ListRNASequences.
type ListRNASequencesParamsSort string

// GetRNASequenceParams defines parameters for GetRNASequence.
type GetRNASequenceParams struct {
	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	//
	// **Note**: Fields annotations, translations, and primers cannot be introspected with the returning parameter, and any sub fields will be ignored. E.g.: "annotations.id" will return the same as "annotations".
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`

	// CustomNotationId ID of the notation to use in populating the customNotation field.
	CustomNotationId *string `form:"customNotationId,omitempty" json:"customNotationId,omitempty"`
}

// BulkGetRNASequencesParams defines parameters for BulkGetRNASequences.
type BulkGetRNASequencesParams struct {
	// RnaSequenceIds Comma-separated list of IDs of RNA sequences to get.
	RnaSequenceIds string `form:"rnaSequenceIds" json:"rnaSequenceIds"`

	// Returning Comma-separated list of fields to return. Modifies the output shape. To return all keys at a given level, enumerate them or use the wildcard, '*'. For more information, [click here](https://docs.benchling.com/docs/getting-started-1#returning-query-parameter).
	//
	// **Note**: Fields annotations, translations, and primers cannot be introspected with the returning parameter, and any sub fields will be ignored. E.g.: "rnaSequences.annotations.id" will return the same as "rnaSequences.annotations".
	Returning *string `form:"returning,omitempty" json:"returning,omitempty"`
}

// ListTeamsParams defines parameters for ListTeams.
type ListTeamsParams struct {
	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// Name Name of a team. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of a team. Restricts results to those with names that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// MentionedIn Comma-separated list of entry IDs. Restricts results to teams mentioned in those entries.
	MentionedIn *string `form:"mentionedIn,omitempty" json:"mentionedIn,omitempty"`

	// OrganizationId Restricts results to those in the organization.
	OrganizationId *string `form:"organizationId,omitempty" json:"organizationId,omitempty"`

	// HasMembers Comma-separated list of user or Benchling app IDs. Restricts results to teams that include all the given users/apps as members.
	HasMembers *string `form:"hasMembers,omitempty" json:"hasMembers,omitempty"`

	// HasAdmins Comma-separated list of user or Benchling app IDs. Restricts results to teams that include all the given users/apps as admins.
	HasAdmins *string `form:"hasAdmins,omitempty" json:"hasAdmins,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string              `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Sort      *ListTeamsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListTeamsParamsSort defines parameters for ListTeams.
type ListTeamsParamsSort string

// ListUsersParams defines parameters for ListUsers.
type ListUsersParams struct {
	// Ids Comma-separated list of ids. Matches all of the provided IDs, or returns a 400 error that includes a list of which IDs are invalid.
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// Name Name of a user. Restricts results to those with the specified name.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Name substring of a user. Restricts results to those with names that include the provided substring.
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// NamesAnyOf Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case insensitive.  Warning - this filter can be non-performant due to case insensitivity.
	NamesAnyOf *string `form:"names.anyOf,omitempty" json:"names.anyOf,omitempty"`

	// NamesAnyOfCaseSensitive Comma-separated list of names. Maximum of 100. Restricts results to those that match any of the specified names, case sensitive.
	NamesAnyOfCaseSensitive *string `form:"names.anyOf.caseSensitive,omitempty" json:"names.anyOf.caseSensitive,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`

	// MemberOf Comma-separated list of organization and/or team API IDs. Restricts results to users that are members of all given groups.
	MemberOf *string `form:"memberOf,omitempty" json:"memberOf,omitempty"`

	// AdminOf Comma-separated list of organization and/or team API IDs. Restricts results to users that are admins of all given groups.
	AdminOf *string `form:"adminOf,omitempty" json:"adminOf,omitempty"`

	// Handles Comma-separated list of handles. Restricts results to the users with the specified handles.
	Handles *string `form:"handles,omitempty" json:"handles,omitempty"`

	// EmailAnyOf Comma-separated list of emails. Maximum of 100. Restricts results to the users with the specified emails.
	EmailAnyOf *string `form:"email.anyOf,omitempty" json:"email.anyOf,omitempty"`

	// PasswordLastChangedAt Datetime, in RFC 3339 format. Supports the >, >=, <, <=, operators. Time zone defaults to UTC. Restricts results to users who have last changed their password in the specified range. e.g. > 2017-04-30. If "null" is provided returns users that have no password set (SAML).
	PasswordLastChangedAt *string `form:"passwordLastChangedAt,omitempty" json:"passwordLastChangedAt,omitempty"`
	PageSize              *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// NextToken Token for pagination
	NextToken *string              `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	Sort      *ListUsersParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// ListUsersParamsSort defines parameters for ListUsers.
type ListUsersParamsSort string

// ListWorkflowOutputsParams defines parameters for ListWorkflowOutputs.
type ListWorkflowOutputsParams struct {
	// Ids Comma separated list of workflow output IDs
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// WorkflowTaskGroupIds Comma separated list of workflow IDs
	WorkflowTaskGroupIds *string `form:"workflowTaskGroupIds,omitempty" json:"workflowTaskGroupIds,omitempty"`

	// WorkflowTaskIds Comma separated list of workflow task IDs
	WorkflowTaskIds *string `form:"workflowTaskIds,omitempty" json:"workflowTaskIds,omitempty"`

	// SchemaId The ID of the workflow task schema of the workflow output
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// WatcherIds Comma separated list of user IDs or "null"
	WatcherIds *string `form:"watcherIds,omitempty" json:"watcherIds,omitempty"`

	// ResponsibleTeamIds Comma separated list of team IDs or "null"
	ResponsibleTeamIds *string `form:"responsibleTeamIds,omitempty" json:"responsibleTeamIds,omitempty"`

	// CreationOriginIds Comma separated list of entry IDs
	CreationOriginIds *string `form:"creationOriginIds,omitempty" json:"creationOriginIds,omitempty"`

	// LinkedItemIdsAnyOf Comma separated list of bioentity or storable IDs. Maximum of 100. Returns workflow outputs where the output's schema fields reference at least one of the provided items.
	LinkedItemIdsAnyOf *string `form:"linkedItemIds.anyOf,omitempty" json:"linkedItemIds.anyOf,omitempty"`

	// LinkedItemIdsAllOf Comma separated list of bioentity or storable IDs. Returns workflow outputs where the output's schema fields reference all of the provided items.
	LinkedItemIdsAllOf *string `form:"linkedItemIds.allOf,omitempty" json:"linkedItemIds.allOf,omitempty"`

	// LinkedItemIdsNoneOf Comma separated list of bioentity or storable IDs. Returns workflow outputs where the output's schema fields do not reference any of the provided items.
	LinkedItemIdsNoneOf *string `form:"linkedItemIds.noneOf,omitempty" json:"linkedItemIds.noneOf,omitempty"`

	// SchemaFields Filter based on schema field value (not display value). Restricts results to those with a field whose value matches the filter. For Integer, Float, and Date type fields, supports the >= and <= operators (but not < or >). If any schemaField filters are present, the schemaId param must also be present. Note that all operators must be separated from any values by a single space.
	SchemaFields *SchemaFieldsQueryParam `form:"schemaFields,omitempty" json:"schemaFields,omitempty"`

	// Name The name of the workflow task
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Part of the name of the workflow task
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// CreatorIds Comma separated list of user IDs.
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`
	NextToken  *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize   *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// DisplayIds Comma-separated list of Workflow Output Display IDs.
	DisplayIds *string `form:"displayIds,omitempty" json:"displayIds,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived workflow outputs. Use "ANY_ARCHIVED" to filter for archived workflow outputs regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`
}

// ListWorkflowTaskGroupsParams defines parameters for ListWorkflowTaskGroups.
type ListWorkflowTaskGroupsParams struct {
	// Ids Comma separated list of workflow task group IDs
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// SchemaId The workflow task schema ID of tasks in this task group
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// FolderId A folder ID
	FolderId *string `form:"folderId,omitempty" json:"folderId,omitempty"`

	// ProjectId A project ID
	ProjectId *string `form:"projectId,omitempty" json:"projectId,omitempty"`

	// MentionedIn A comma separated list entry IDs
	MentionedIn *string `form:"mentionedIn,omitempty" json:"mentionedIn,omitempty"`

	// WatcherIds Comma separated list of user IDs or "null"
	WatcherIds *string `form:"watcherIds,omitempty" json:"watcherIds,omitempty"`

	// ExecutionTypes Comma separated list of workflow execution types. Acceptable execution types are "DIRECT" and "ENTRY"
	ExecutionTypes *string `form:"executionTypes,omitempty" json:"executionTypes,omitempty"`

	// ResponsibleTeamIds Comma separated list of team IDs or "null"
	ResponsibleTeamIds *string `form:"responsibleTeamIds,omitempty" json:"responsibleTeamIds,omitempty"`

	// StatusIdsAnyOf Commas separated list of Status ids. Maximum of 100. Returns workflows where at least one task is of one of the provided statuses.
	StatusIdsAnyOf *string `form:"statusIds.anyOf,omitempty" json:"statusIds.anyOf,omitempty"`

	// StatusIdsNoneOf Commas separated list of Status ids. Returns workflows where none of the tasks are of any of the provided statuses.
	StatusIdsNoneOf *string `form:"statusIds.noneOf,omitempty" json:"statusIds.noneOf,omitempty"`

	// StatusIdsOnly Commas separated list of Status ids. Returns workflows where all of the tasks are of one of the provided statuses.
	StatusIdsOnly *string `form:"statusIds.only,omitempty" json:"statusIds.only,omitempty"`

	// Name The name of the workflow task group
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Part of the name of the workflow task group
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// CreatorIds Comma separated list of user IDs.
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`
	NextToken  *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize   *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// DisplayIds Comma-separated list of Workflow Display IDs.
	DisplayIds *string `form:"displayIds,omitempty" json:"displayIds,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived workflow task groups. Use "ANY_ARCHIVED" to filter for archived workflow task groups regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`
}

// ListWorkflowTaskSchemasParams defines parameters for ListWorkflowTaskSchemas.
type ListWorkflowTaskSchemasParams struct {
	NextToken *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize  *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`
}

// ListWorkflowTasksParams defines parameters for ListWorkflowTasks.
type ListWorkflowTasksParams struct {
	// Ids Comma separated list of workflow task IDs
	Ids *string `form:"ids,omitempty" json:"ids,omitempty"`

	// WorkflowTaskGroupIds Comma separated list of workflow IDs
	WorkflowTaskGroupIds *string `form:"workflowTaskGroupIds,omitempty" json:"workflowTaskGroupIds,omitempty"`

	// SchemaId The ID of the workflow task schema of the workflow task
	SchemaId *string `form:"schemaId,omitempty" json:"schemaId,omitempty"`

	// StatusIds Comma separated list of workflow task status ids
	StatusIds *string `form:"statusIds,omitempty" json:"statusIds,omitempty"`

	// AssigneeIds Comma separated list of user ids or "null"
	AssigneeIds *string `form:"assigneeIds,omitempty" json:"assigneeIds,omitempty"`

	// WatcherIds Comma separated list of user IDs or "null"
	WatcherIds *string `form:"watcherIds,omitempty" json:"watcherIds,omitempty"`

	// ResponsibleTeamIds Comma separated list of team IDs or "null"
	ResponsibleTeamIds *string `form:"responsibleTeamIds,omitempty" json:"responsibleTeamIds,omitempty"`

	// ExecutionOriginIds Comma separated list of entry IDs
	ExecutionOriginIds *string `form:"executionOriginIds,omitempty" json:"executionOriginIds,omitempty"`

	// ExecutionTypes Comma separated list of workflow execution types. Acceptable execution types are "DIRECT" and "ENTRY"
	ExecutionTypes *string `form:"executionTypes,omitempty" json:"executionTypes,omitempty"`

	// LinkedItemIdsAnyOf Comma separated list of bioentity or storable IDs. Maximum of 100. Returns workflow tasks where the task's schema fields reference at least one of the provided items.
	LinkedItemIdsAnyOf *string `form:"linkedItemIds.anyOf,omitempty" json:"linkedItemIds.anyOf,omitempty"`

	// LinkedItemIdsAllOf Comma separated list of bioentity or storable IDs. Returns workflow tasks where the task's schema fields reference all of the provided items.
	LinkedItemIdsAllOf *string `form:"linkedItemIds.allOf,omitempty" json:"linkedItemIds.allOf,omitempty"`

	// LinkedItemIdsNoneOf Comma separated list of bioentity or storable IDs. Returns workflow tasks where the task's schema fields do not reference any of the provided items.
	LinkedItemIdsNoneOf *string `form:"linkedItemIds.noneOf,omitempty" json:"linkedItemIds.noneOf,omitempty"`

	// SchemaFields Filter based on schema field value (not display value). Restricts results to those with a field whose value matches the filter. For Integer, Float, and Date type fields, supports the >= and <= operators (but not < or >). If any schemaField filters are present, the schemaId param must also be present. Note that all operators must be separated from any values by a single space.
	SchemaFields *SchemaFieldsQueryParam `form:"schemaFields,omitempty" json:"schemaFields,omitempty"`

	// Name The name of the workflow task
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// NameIncludes Part of the name of the workflow task
	NameIncludes *string `form:"nameIncludes,omitempty" json:"nameIncludes,omitempty"`

	// CreatorIds Comma separated list of user IDs.
	CreatorIds *string `form:"creatorIds,omitempty" json:"creatorIds,omitempty"`

	// ScheduledOn The date on which the task was scheduled to be executed. Returns tasks which are scheduled on the provided date. If "null" is provided returns tasks which are unshceduled.
	ScheduledOn *openapi_types.Date `form:"scheduledOn,omitempty" json:"scheduledOn,omitempty"`

	// ScheduledOnLt The date on which the task was scheduled to be executed. Returns tasks which are scheduled before the provided date.
	ScheduledOnLt *openapi_types.Date `form:"scheduledOn.lt,omitempty" json:"scheduledOn.lt,omitempty"`

	// ScheduledOnLte The date on which the task was scheduled to be executed. Returns tasks which are scheduled before or on the provided date.
	ScheduledOnLte *openapi_types.Date `form:"scheduledOn.lte,omitempty" json:"scheduledOn.lte,omitempty"`

	// ScheduledOnGte The date on which the task was scheduled to be executed. Returns tasks which are scheduled on or after the provided date.
	ScheduledOnGte *openapi_types.Date `form:"scheduledOn.gte,omitempty" json:"scheduledOn.gte,omitempty"`

	// ScheduledOnGt The date on which the task was scheduled to be executed. Returns tasks which are scheduled after the provided date.
	ScheduledOnGt *openapi_types.Date `form:"scheduledOn.gt,omitempty" json:"scheduledOn.gt,omitempty"`

	// ModifiedAt Datetime, in RFC 3339 format. Supports the > and < operators. Time zone defaults to UTC. Restricts results to those modified in the specified range. e.g. > 2017-04-30. Date ranges can be specified with the following nomenclature > YYYY-MM-DD AND <YYYY-MM-DD.
	ModifiedAt *string `form:"modifiedAt,omitempty" json:"modifiedAt,omitempty"`
	NextToken  *string `form:"nextToken,omitempty" json:"nextToken,omitempty"`
	PageSize   *int    `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// DisplayIds Comma-separated list of Workflow Task Display IDs.
	DisplayIds *string `form:"displayIds,omitempty" json:"displayIds,omitempty"`

	// ArchiveReason Archive reason. Restricts items to those with the specified archive reason. Use "NOT_ARCHIVED" to filter for unarchived workflow tasks. Use "ANY_ARCHIVED" to filter for archived workflow tasks regardless of reason. Use "ANY_ARCHIVED_OR_NOT_ARCHIVED" to return items for both archived and unarchived.
	ArchiveReason *string `form:"archiveReason,omitempty" json:"archiveReason,omitempty"`
}

// CreateAASequenceJSONRequestBody defines body for CreateAASequence for application/json ContentType.
type CreateAASequenceJSONRequestBody = AaSequenceCreate

// UpdateAASequenceJSONRequestBody defines body for UpdateAASequence for application/json ContentType.
type UpdateAASequenceJSONRequestBody = AaSequenceUpdate

// ArchiveAASequencesJSONRequestBody defines body for ArchiveAASequences for application/json ContentType.
type ArchiveAASequencesJSONRequestBody = AaSequencesArchive

// AutoAnnotateAaSequencesJSONRequestBody defines body for AutoAnnotateAaSequences for application/json ContentType.
type AutoAnnotateAaSequencesJSONRequestBody = AutoAnnotateAaSequences

// BulkCreateAASequencesJSONRequestBody defines body for BulkCreateAASequences for application/json ContentType.
type BulkCreateAASequencesJSONRequestBody = AaSequencesBulkCreateRequest

// BulkUpdateAASequencesJSONRequestBody defines body for BulkUpdateAASequences for application/json ContentType.
type BulkUpdateAASequencesJSONRequestBody = AaSequencesBulkUpdateRequest

// UnarchiveAASequencesJSONRequestBody defines body for UnarchiveAASequences for application/json ContentType.
type UnarchiveAASequencesJSONRequestBody = AaSequencesUnarchive

// CreateAppCanvasJSONRequestBody defines body for CreateAppCanvas for application/json ContentType.
type CreateAppCanvasJSONRequestBody = AppCanvasCreate

// UpdateAppCanvasJSONRequestBody defines body for UpdateAppCanvas for application/json ContentType.
type UpdateAppCanvasJSONRequestBody = AppCanvasUpdate

// ArchiveAppCanvasesJSONRequestBody defines body for ArchiveAppCanvases for application/json ContentType.
type ArchiveAppCanvasesJSONRequestBody = AppCanvasesArchive

// UnarchiveAppCanvasesJSONRequestBody defines body for UnarchiveAppCanvases for application/json ContentType.
type UnarchiveAppCanvasesJSONRequestBody = AppCanvasesUnarchive

// CreateAppConfigurationItemJSONRequestBody defines body for CreateAppConfigurationItem for application/json ContentType.
type CreateAppConfigurationItemJSONRequestBody = AppConfigItemCreate

// UpdateAppConfigurationItemJSONRequestBody defines body for UpdateAppConfigurationItem for application/json ContentType.
type UpdateAppConfigurationItemJSONRequestBody = AppConfigItemUpdate

// BulkCreateAppConfigurationItemsJSONRequestBody defines body for BulkCreateAppConfigurationItems for application/json ContentType.
type BulkCreateAppConfigurationItemsJSONRequestBody = AppConfigItemsBulkCreateRequest

// BulkUpdateAppConfigurationItemsJSONRequestBody defines body for BulkUpdateAppConfigurationItems for application/json ContentType.
type BulkUpdateAppConfigurationItemsJSONRequestBody = AppConfigItemsBulkUpdateRequest

// CreateAppSessionJSONRequestBody defines body for CreateAppSession for application/json ContentType.
type CreateAppSessionJSONRequestBody = AppSessionCreate

// UpdateAppSessionJSONRequestBody defines body for UpdateAppSession for application/json ContentType.
type UpdateAppSessionJSONRequestBody = AppSessionUpdate

// CreateBenchlingAppJSONRequestBody defines body for CreateBenchlingApp for application/json ContentType.
type CreateBenchlingAppJSONRequestBody = BenchlingAppCreate

// PatchBenchlingAppJSONRequestBody defines body for PatchBenchlingApp for application/json ContentType.
type PatchBenchlingAppJSONRequestBody = BenchlingAppUpdate

// ArchiveBenchlingAppsJSONRequestBody defines body for ArchiveBenchlingApps for application/json ContentType.
type ArchiveBenchlingAppsJSONRequestBody = BenchlingAppsArchive

// UnarchiveBenchlingAppsJSONRequestBody defines body for UnarchiveBenchlingApps for application/json ContentType.
type UnarchiveBenchlingAppsJSONRequestBody = BenchlingAppsUnarchive

// CreateAssayResultsJSONRequestBody defines body for CreateAssayResults for application/json ContentType.
type CreateAssayResultsJSONRequestBody = AssayResultsBulkCreateRequest

// ArchiveAssayResultsJSONRequestBody defines body for ArchiveAssayResults for application/json ContentType.
type ArchiveAssayResultsJSONRequestBody = AssayResultsArchive

// BulkCreateAssayResultsJSONRequestBody defines body for BulkCreateAssayResults for application/json ContentType.
type BulkCreateAssayResultsJSONRequestBody = AssayResultsBulkCreateInTableRequest

// UnarchiveAssayResultsJSONRequestBody defines body for UnarchiveAssayResults for application/json ContentType.
type UnarchiveAssayResultsJSONRequestBody = AssayResultIdsRequest

// CreateAssayRunsJSONRequestBody defines body for CreateAssayRuns for application/json ContentType.
type CreateAssayRunsJSONRequestBody = AssayRunsBulkCreateRequest

// UpdateAssayRunJSONRequestBody defines body for UpdateAssayRun for application/json ContentType.
type UpdateAssayRunJSONRequestBody = AssayRunUpdate

// ArchiveAssayRunsJSONRequestBody defines body for ArchiveAssayRuns for application/json ContentType.
type ArchiveAssayRunsJSONRequestBody = AssayRunsArchive

// UnarchiveAssayRunsJSONRequestBody defines body for UnarchiveAssayRuns for application/json ContentType.
type UnarchiveAssayRunsJSONRequestBody = AssayRunsUnarchive

// UpdateLabAutomationTransformJSONRequestBody defines body for UpdateLabAutomationTransform for application/json ContentType.
type UpdateLabAutomationTransformJSONRequestBody = LabAutomationTransformUpdate

// UpdateAutomationInputGeneratorJSONRequestBody defines body for UpdateAutomationInputGenerator for application/json ContentType.
type UpdateAutomationInputGeneratorJSONRequestBody = AutomationInputGeneratorUpdate

// CreateAutomationOutputProcessorJSONRequestBody defines body for CreateAutomationOutputProcessor for application/json ContentType.
type CreateAutomationOutputProcessorJSONRequestBody = AutomationOutputProcessorCreate

// UpdateAutomationOutputProcessorJSONRequestBody defines body for UpdateAutomationOutputProcessor for application/json ContentType.
type UpdateAutomationOutputProcessorJSONRequestBody = AutomationOutputProcessorUpdate

// ArchiveAutomationOutputProcessorsJSONRequestBody defines body for ArchiveAutomationOutputProcessors for application/json ContentType.
type ArchiveAutomationOutputProcessorsJSONRequestBody = AutomationOutputProcessorsArchive

// UnarchiveAutomationOutputProcessorsJSONRequestBody defines body for UnarchiveAutomationOutputProcessors for application/json ContentType.
type UnarchiveAutomationOutputProcessorsJSONRequestBody = AutomationOutputProcessorsUnarchive

// CreateBatchJSONRequestBody defines body for CreateBatch for application/json ContentType.
type CreateBatchJSONRequestBody = BatchCreate

// UpdateBatchJSONRequestBody defines body for UpdateBatch for application/json ContentType.
type UpdateBatchJSONRequestBody = BatchUpdate

// ArchiveBatchesJSONRequestBody defines body for ArchiveBatches for application/json ContentType.
type ArchiveBatchesJSONRequestBody = BatchesArchive

// UnarchiveBatchesJSONRequestBody defines body for UnarchiveBatches for application/json ContentType.
type UnarchiveBatchesJSONRequestBody = BatchesUnarchive

// CreateBlobJSONRequestBody defines body for CreateBlob for application/json ContentType.
type CreateBlobJSONRequestBody = BlobCreate

// CreateBlobPartJSONRequestBody defines body for CreateBlobPart for application/json ContentType.
type CreateBlobPartJSONRequestBody = BlobPartCreate

// CompleteMultipartBlobJSONRequestBody defines body for CompleteMultipartBlob for application/json ContentType.
type CompleteMultipartBlobJSONRequestBody = BlobComplete

// CreateMultipartBlobJSONRequestBody defines body for CreateMultipartBlob for application/json ContentType.
type CreateMultipartBlobJSONRequestBody = BlobMultipartCreate

// CreateBoxJSONRequestBody defines body for CreateBox for application/json ContentType.
type CreateBoxJSONRequestBody = BoxCreate

// UpdateBoxJSONRequestBody defines body for UpdateBox for application/json ContentType.
type UpdateBoxJSONRequestBody = BoxUpdate

// ArchiveBoxesJSONRequestBody defines body for ArchiveBoxes for application/json ContentType.
type ArchiveBoxesJSONRequestBody = BoxesArchive

// UnarchiveBoxesJSONRequestBody defines body for UnarchiveBoxes for application/json ContentType.
type UnarchiveBoxesJSONRequestBody = BoxesUnarchive

// CreateContainerJSONRequestBody defines body for CreateContainer for application/json ContentType.
type CreateContainerJSONRequestBody = ContainerCreate

// UpdateContainerJSONRequestBody defines body for UpdateContainer for application/json ContentType.
type UpdateContainerJSONRequestBody = ContainerUpdate

// UpdateContainerContentJSONRequestBody defines body for UpdateContainerContent for application/json ContentType.
type UpdateContainerContentJSONRequestBody = ContainerContentUpdate

// TransferIntoContainerJSONRequestBody defines body for TransferIntoContainer for application/json ContentType.
type TransferIntoContainerJSONRequestBody = ContainerTransfer

// ArchiveContainersJSONRequestBody defines body for ArchiveContainers for application/json ContentType.
type ArchiveContainersJSONRequestBody = ContainersArchive

// BulkCreateContainersJSONRequestBody defines body for BulkCreateContainers for application/json ContentType.
type BulkCreateContainersJSONRequestBody = ContainersBulkCreateRequest

// BulkUpdateContainersJSONRequestBody defines body for BulkUpdateContainers for application/json ContentType.
type BulkUpdateContainersJSONRequestBody = ContainersBulkUpdateRequest

// CheckinContainersJSONRequestBody defines body for CheckinContainers for application/json ContentType.
type CheckinContainersJSONRequestBody = ContainersCheckin

// CheckoutContainersJSONRequestBody defines body for CheckoutContainers for application/json ContentType.
type CheckoutContainersJSONRequestBody = ContainersCheckout

// PrintLabelsJSONRequestBody defines body for PrintLabels for application/json ContentType.
type PrintLabelsJSONRequestBody = PrintLabels

// ReserveContainersJSONRequestBody defines body for ReserveContainers for application/json ContentType.
type ReserveContainersJSONRequestBody = ContainersCheckout

// UnarchiveContainersJSONRequestBody defines body for UnarchiveContainers for application/json ContentType.
type UnarchiveContainersJSONRequestBody = ContainersUnarchive

// CreateCustomEntityJSONRequestBody defines body for CreateCustomEntity for application/json ContentType.
type CreateCustomEntityJSONRequestBody = CustomEntityCreate

// UpdateCustomEntityJSONRequestBody defines body for UpdateCustomEntity for application/json ContentType.
type UpdateCustomEntityJSONRequestBody = CustomEntityUpdate

// ArchiveCustomEntitiesJSONRequestBody defines body for ArchiveCustomEntities for application/json ContentType.
type ArchiveCustomEntitiesJSONRequestBody = CustomEntitiesArchive

// BulkCreateCustomEntitiesJSONRequestBody defines body for BulkCreateCustomEntities for application/json ContentType.
type BulkCreateCustomEntitiesJSONRequestBody = CustomEntitiesBulkCreateRequest

// BulkUpdateCustomEntitiesJSONRequestBody defines body for BulkUpdateCustomEntities for application/json ContentType.
type BulkUpdateCustomEntitiesJSONRequestBody = CustomEntitiesBulkUpdateRequest

// UnarchiveCustomEntitiesJSONRequestBody defines body for UnarchiveCustomEntities for application/json ContentType.
type UnarchiveCustomEntitiesJSONRequestBody = CustomEntitiesUnarchive

// CreateDnaConsensusAlignmentJSONRequestBody defines body for CreateDnaConsensusAlignment for application/json ContentType.
type CreateDnaConsensusAlignmentJSONRequestBody = DnaConsensusAlignmentCreate

// CreateDnaTemplateAlignmentJSONRequestBody defines body for CreateDnaTemplateAlignment for application/json ContentType.
type CreateDnaTemplateAlignmentJSONRequestBody = DnaTemplateAlignmentCreate

// CreateDNAOligoJSONRequestBody defines body for CreateDNAOligo for application/json ContentType.
type CreateDNAOligoJSONRequestBody = DnaOligoCreate

// UpdateDNAOligoJSONRequestBody defines body for UpdateDNAOligo for application/json ContentType.
type UpdateDNAOligoJSONRequestBody = DnaOligoUpdate

// ArchiveDNAOligosJSONRequestBody defines body for ArchiveDNAOligos for application/json ContentType.
type ArchiveDNAOligosJSONRequestBody = DnaOligosArchive

// BulkCreateDNAOligosJSONRequestBody defines body for BulkCreateDNAOligos for application/json ContentType.
type BulkCreateDNAOligosJSONRequestBody = DnaOligosBulkCreateRequest

// BulkUpdateDNAOligosJSONRequestBody defines body for BulkUpdateDNAOligos for application/json ContentType.
type BulkUpdateDNAOligosJSONRequestBody = DnaOligosBulkUpdateRequest

// UnarchiveDNAOligosJSONRequestBody defines body for UnarchiveDNAOligos for application/json ContentType.
type UnarchiveDNAOligosJSONRequestBody = DnaOligosUnarchive

// CreateDNASequenceJSONRequestBody defines body for CreateDNASequence for application/json ContentType.
type CreateDNASequenceJSONRequestBody = DnaSequenceCreate

// UpdateDNASequenceJSONRequestBody defines body for UpdateDNASequence for application/json ContentType.
type UpdateDNASequenceJSONRequestBody = DnaSequenceUpdate

// ArchiveDNASequencesJSONRequestBody defines body for ArchiveDNASequences for application/json ContentType.
type ArchiveDNASequencesJSONRequestBody = DnaSequencesArchive

// AutoAnnotateDnaSequencesJSONRequestBody defines body for AutoAnnotateDnaSequences for application/json ContentType.
type AutoAnnotateDnaSequencesJSONRequestBody = AutoAnnotateDnaSequences

// AutofillDNASequencePartsJSONRequestBody defines body for AutofillDNASequenceParts for application/json ContentType.
type AutofillDNASequencePartsJSONRequestBody = AutofillSequences

// AutofillDNASequenceTranslationsJSONRequestBody defines body for AutofillDNASequenceTranslations for application/json ContentType.
type AutofillDNASequenceTranslationsJSONRequestBody = AutofillSequences

// BulkCreateDNASequencesJSONRequestBody defines body for BulkCreateDNASequences for application/json ContentType.
type BulkCreateDNASequencesJSONRequestBody = DnaSequencesBulkCreateRequest

// BulkUpdateDNASequencesJSONRequestBody defines body for BulkUpdateDNASequences for application/json ContentType.
type BulkUpdateDNASequencesJSONRequestBody = DnaSequencesBulkUpdateRequest

// MatchBasesDnaSequencesJSONRequestBody defines body for MatchBasesDnaSequences for application/json ContentType.
type MatchBasesDnaSequencesJSONRequestBody = MatchBasesRequest

// SearchDnaSequencesJSONRequestBody defines body for SearchDnaSequences for application/json ContentType.
type SearchDnaSequencesJSONRequestBody = SearchBasesRequest

// UnarchiveDNASequencesJSONRequestBody defines body for UnarchiveDNASequences for application/json ContentType.
type UnarchiveDNASequencesJSONRequestBody = DnaSequencesUnarchive

// CreateDropdownJSONRequestBody defines body for CreateDropdown for application/json ContentType.
type CreateDropdownJSONRequestBody = DropdownCreate

// UpdateDropdownJSONRequestBody defines body for UpdateDropdown for application/json ContentType.
type UpdateDropdownJSONRequestBody = DropdownUpdate

// ArchiveDropdownOptionsJSONRequestBody defines body for ArchiveDropdownOptions for application/json ContentType.
type ArchiveDropdownOptionsJSONRequestBody = DropdownOptionsArchive

// UnarchiveDropdownOptionsJSONRequestBody defines body for UnarchiveDropdownOptions for application/json ContentType.
type UnarchiveDropdownOptionsJSONRequestBody = DropdownOptionsUnarchive

// CreateEntryJSONRequestBody defines body for CreateEntry for application/json ContentType.
type CreateEntryJSONRequestBody = EntryCreate

// UpdateEntryJSONRequestBody defines body for UpdateEntry for application/json ContentType.
type UpdateEntryJSONRequestBody = EntryUpdate

// ArchiveEntriesJSONRequestBody defines body for ArchiveEntries for application/json ContentType.
type ArchiveEntriesJSONRequestBody = EntriesArchive

// UnarchiveEntriesJSONRequestBody defines body for UnarchiveEntries for application/json ContentType.
type UnarchiveEntriesJSONRequestBody = EntriesUnarchive

// ExportItemJSONRequestBody defines body for ExportItem for application/json ContentType.
type ExportItemJSONRequestBody = ExportItemRequest

// CreateFeatureLibraryJSONRequestBody defines body for CreateFeatureLibrary for application/json ContentType.
type CreateFeatureLibraryJSONRequestBody = FeatureLibraryCreate

// UpdateFeatureLibraryJSONRequestBody defines body for UpdateFeatureLibrary for application/json ContentType.
type UpdateFeatureLibraryJSONRequestBody = FeatureLibraryUpdate

// CreateFeatureJSONRequestBody defines body for CreateFeature for application/json ContentType.
type CreateFeatureJSONRequestBody = FeatureCreate

// UpdateFeatureJSONRequestBody defines body for UpdateFeature for application/json ContentType.
type UpdateFeatureJSONRequestBody = FeatureUpdate

// BulkCreateFeaturesJSONRequestBody defines body for BulkCreateFeatures for application/json ContentType.
type BulkCreateFeaturesJSONRequestBody = FeaturesBulkCreateRequest

// CreateFolderJSONRequestBody defines body for CreateFolder for application/json ContentType.
type CreateFolderJSONRequestBody = FolderCreate

// ArchiveFoldersJSONRequestBody defines body for ArchiveFolders for application/json ContentType.
type ArchiveFoldersJSONRequestBody = FoldersArchive

// UnarchiveFoldersJSONRequestBody defines body for UnarchiveFolders for application/json ContentType.
type UnarchiveFoldersJSONRequestBody = FoldersUnarchive

// UpdateLegacyWorkflowMetadataJSONRequestBody defines body for UpdateLegacyWorkflowMetadata for application/json ContentType.
type UpdateLegacyWorkflowMetadataJSONRequestBody = LegacyWorkflowPatch

// CreateLocationJSONRequestBody defines body for CreateLocation for application/json ContentType.
type CreateLocationJSONRequestBody = LocationCreate

// UpdateLocationJSONRequestBody defines body for UpdateLocation for application/json ContentType.
type UpdateLocationJSONRequestBody = LocationUpdate

// ArchiveLocationsJSONRequestBody defines body for ArchiveLocations for application/json ContentType.
type ArchiveLocationsJSONRequestBody = LocationsArchive

// UnarchiveLocationsJSONRequestBody defines body for UnarchiveLocations for application/json ContentType.
type UnarchiveLocationsJSONRequestBody = LocationsUnarchive

// CreateMixtureJSONRequestBody defines body for CreateMixture for application/json ContentType.
type CreateMixtureJSONRequestBody = MixtureCreate

// UpdateMixtureJSONRequestBody defines body for UpdateMixture for application/json ContentType.
type UpdateMixtureJSONRequestBody = MixtureUpdate

// ArchiveMixturesJSONRequestBody defines body for ArchiveMixtures for application/json ContentType.
type ArchiveMixturesJSONRequestBody = MixturesArchive

// BulkCreateMixturesJSONRequestBody defines body for BulkCreateMixtures for application/json ContentType.
type BulkCreateMixturesJSONRequestBody = MixturesBulkCreateRequest

// BulkUpdateMixturesJSONRequestBody defines body for BulkUpdateMixtures for application/json ContentType.
type BulkUpdateMixturesJSONRequestBody = MixturesBulkUpdateRequest

// UnarchiveMixturesJSONRequestBody defines body for UnarchiveMixtures for application/json ContentType.
type UnarchiveMixturesJSONRequestBody = MixturesUnarchive

// CreateMoleculeJSONRequestBody defines body for CreateMolecule for application/json ContentType.
type CreateMoleculeJSONRequestBody = MoleculeCreate

// UpdateMoleculeJSONRequestBody defines body for UpdateMolecule for application/json ContentType.
type UpdateMoleculeJSONRequestBody = MoleculeUpdate

// ArchiveMoleculesJSONRequestBody defines body for ArchiveMolecules for application/json ContentType.
type ArchiveMoleculesJSONRequestBody = MoleculesArchive

// BulkCreateMoleculesJSONRequestBody defines body for BulkCreateMolecules for application/json ContentType.
type BulkCreateMoleculesJSONRequestBody = MoleculesBulkCreateRequest

// BulkUpdateMoleculesJSONRequestBody defines body for BulkUpdateMolecules for application/json ContentType.
type BulkUpdateMoleculesJSONRequestBody = MoleculesBulkUpdateRequest

// UnarchiveMoleculesJSONRequestBody defines body for UnarchiveMolecules for application/json ContentType.
type UnarchiveMoleculesJSONRequestBody = MoleculesUnarchive

// CreateMonomerJSONRequestBody defines body for CreateMonomer for application/json ContentType.
type CreateMonomerJSONRequestBody = MonomerCreate

// UpdateMonomerJSONRequestBody defines body for UpdateMonomer for application/json ContentType.
type UpdateMonomerJSONRequestBody = MonomerUpdate

// ArchiveMonomersJSONRequestBody defines body for ArchiveMonomers for application/json ContentType.
type ArchiveMonomersJSONRequestBody = MonomersArchive

// UnarchiveMonomersJSONRequestBody defines body for UnarchiveMonomers for application/json ContentType.
type UnarchiveMonomersJSONRequestBody = MonomersUnarchive

// CreateConsensusNucleotideAlignmentJSONRequestBody defines body for CreateConsensusNucleotideAlignment for application/json ContentType.
type CreateConsensusNucleotideAlignmentJSONRequestBody = NucleotideConsensusAlignmentCreate

// CreateTemplateNucleotideAlignmentJSONRequestBody defines body for CreateTemplateNucleotideAlignment for application/json ContentType.
type CreateTemplateNucleotideAlignmentJSONRequestBody = NucleotideTemplateAlignmentCreate

// CreateOligoJSONRequestBody defines body for CreateOligo for application/json ContentType.
type CreateOligoJSONRequestBody = OligoCreate

// UpdateOligoJSONRequestBody defines body for UpdateOligo for application/json ContentType.
type UpdateOligoJSONRequestBody = OligoUpdate

// ArchiveOligosJSONRequestBody defines body for ArchiveOligos for application/json ContentType.
type ArchiveOligosJSONRequestBody = OligosArchive

// BulkCreateOligosJSONRequestBody defines body for BulkCreateOligos for application/json ContentType.
type BulkCreateOligosJSONRequestBody = OligosBulkCreateRequest

// UnarchiveOligosJSONRequestBody defines body for UnarchiveOligos for application/json ContentType.
type UnarchiveOligosJSONRequestBody = OligosUnarchive

// CreatePlateJSONRequestBody defines body for CreatePlate for application/json ContentType.
type CreatePlateJSONRequestBody = PlateCreate

// UpdatePlateJSONRequestBody defines body for UpdatePlate for application/json ContentType.
type UpdatePlateJSONRequestBody = PlateUpdate

// ArchivePlatesJSONRequestBody defines body for ArchivePlates for application/json ContentType.
type ArchivePlatesJSONRequestBody = PlatesArchive

// UnarchivePlatesJSONRequestBody defines body for UnarchivePlates for application/json ContentType.
type UnarchivePlatesJSONRequestBody = PlatesUnarchive

// ArchiveProjectsJSONRequestBody defines body for ArchiveProjects for application/json ContentType.
type ArchiveProjectsJSONRequestBody = ProjectsArchive

// UnarchiveProjectsJSONRequestBody defines body for UnarchiveProjects for application/json ContentType.
type UnarchiveProjectsJSONRequestBody = ProjectsUnarchive

// RegisterEntitiesJSONRequestBody defines body for RegisterEntities for application/json ContentType.
type RegisterEntitiesJSONRequestBody = RegisterEntities

// UnregisterEntitiesJSONRequestBody defines body for UnregisterEntities for application/json ContentType.
type UnregisterEntitiesJSONRequestBody = UnregisterEntities

// ValidateBarcodesJSONRequestBody defines body for ValidateBarcodes for application/json ContentType.
type ValidateBarcodesJSONRequestBody = BarcodesList

// CreateRequestJSONRequestBody defines body for CreateRequest for application/json ContentType.
type CreateRequestJSONRequestBody = RequestCreate

// PatchRequestJSONRequestBody defines body for PatchRequest for application/json ContentType.
type PatchRequestJSONRequestBody = RequestUpdate

// BulkCreateRequestTasksJSONRequestBody defines body for BulkCreateRequestTasks for application/json ContentType.
type BulkCreateRequestTasksJSONRequestBody = RequestTasksBulkCreateRequest

// BulkUpdateRequestTasksJSONRequestBody defines body for BulkUpdateRequestTasks for application/json ContentType.
type BulkUpdateRequestTasksJSONRequestBody = RequestTasksBulkUpdateRequest

// ExecuteRequestsSampleGroupsJSONRequestBody defines body for ExecuteRequestsSampleGroups for application/json ContentType.
type ExecuteRequestsSampleGroupsJSONRequestBody = SampleGroupsStatusUpdate

// CreateAssayResultsInTransactionJSONRequestBody defines body for CreateAssayResultsInTransaction for application/json ContentType.
type CreateAssayResultsInTransactionJSONRequestBody = AssayResultsBulkCreateRequest

// CreateRNAOligoJSONRequestBody defines body for CreateRNAOligo for application/json ContentType.
type CreateRNAOligoJSONRequestBody = RnaOligoCreate

// UpdateRNAOligoJSONRequestBody defines body for UpdateRNAOligo for application/json ContentType.
type UpdateRNAOligoJSONRequestBody = RnaOligoUpdate

// ArchiveRNAOligosJSONRequestBody defines body for ArchiveRNAOligos for application/json ContentType.
type ArchiveRNAOligosJSONRequestBody = RnaOligosArchive

// BulkCreateRNAOligosJSONRequestBody defines body for BulkCreateRNAOligos for application/json ContentType.
type BulkCreateRNAOligosJSONRequestBody = RnaOligosBulkCreateRequest

// BulkUpdateRNAOligosJSONRequestBody defines body for BulkUpdateRNAOligos for application/json ContentType.
type BulkUpdateRNAOligosJSONRequestBody = RnaOligosBulkUpdateRequest

// UnarchiveRNAOligosJSONRequestBody defines body for UnarchiveRNAOligos for application/json ContentType.
type UnarchiveRNAOligosJSONRequestBody = RnaOligosUnarchive

// CreateRNASequenceJSONRequestBody defines body for CreateRNASequence for application/json ContentType.
type CreateRNASequenceJSONRequestBody = RnaSequenceCreate

// UpdateRNASequenceJSONRequestBody defines body for UpdateRNASequence for application/json ContentType.
type UpdateRNASequenceJSONRequestBody = RnaSequenceUpdate

// ArchiveRNASequencesJSONRequestBody defines body for ArchiveRNASequences for application/json ContentType.
type ArchiveRNASequencesJSONRequestBody = RnaSequencesArchive

// AutoAnnotateRnaSequencesJSONRequestBody defines body for AutoAnnotateRnaSequences for application/json ContentType.
type AutoAnnotateRnaSequencesJSONRequestBody = AutoAnnotateRnaSequences

// AutofillRNASequencePartsJSONRequestBody defines body for AutofillRNASequenceParts for application/json ContentType.
type AutofillRNASequencePartsJSONRequestBody = AutofillRnaSequences

// AutofillRNASequenceTranslationsJSONRequestBody defines body for AutofillRNASequenceTranslations for application/json ContentType.
type AutofillRNASequenceTranslationsJSONRequestBody = AutofillRnaSequences

// BulkCreateRNASequencesJSONRequestBody defines body for BulkCreateRNASequences for application/json ContentType.
type BulkCreateRNASequencesJSONRequestBody = RnaSequencesBulkCreateRequest

// BulkUpdateRNASequencesJSONRequestBody defines body for BulkUpdateRNASequences for application/json ContentType.
type BulkUpdateRNASequencesJSONRequestBody = RnaSequencesBulkUpdateRequest

// MatchBasesRnaSequencesJSONRequestBody defines body for MatchBasesRnaSequences for application/json ContentType.
type MatchBasesRnaSequencesJSONRequestBody = MatchBasesRequest

// SearchRnaSequencesJSONRequestBody defines body for SearchRnaSequences for application/json ContentType.
type SearchRnaSequencesJSONRequestBody = SearchBasesRequest

// UnarchiveRNASequencesJSONRequestBody defines body for UnarchiveRNASequences for application/json ContentType.
type UnarchiveRNASequencesJSONRequestBody = RnaSequencesUnarchive

// GenerateTokenFormdataRequestBody defines body for GenerateToken for application/x-www-form-urlencoded ContentType.
type GenerateTokenFormdataRequestBody = TokenCreate

// TransferIntoContainersJSONRequestBody defines body for TransferIntoContainers for application/json ContentType.
type TransferIntoContainersJSONRequestBody = MultipleContainersTransfersList

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = UserCreate

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody = UserUpdate

// BulkCreateUsersJSONRequestBody defines body for BulkCreateUsers for application/json ContentType.
type BulkCreateUsersJSONRequestBody = UserBulkCreateRequest

// BulkUpdateUsersJSONRequestBody defines body for BulkUpdateUsers for application/json ContentType.
type BulkUpdateUsersJSONRequestBody = UserBulkUpdateRequest

// CreateWarehouseCredentialsJSONRequestBody defines body for CreateWarehouseCredentials for application/json ContentType.
type CreateWarehouseCredentialsJSONRequestBody = WarehouseCredentialsCreate

// CreateWorkflowOutputJSONRequestBody defines body for CreateWorkflowOutput for application/json ContentType.
type CreateWorkflowOutputJSONRequestBody = WorkflowOutputCreate

// UpdateWorkflowOutputJSONRequestBody defines body for UpdateWorkflowOutput for application/json ContentType.
type UpdateWorkflowOutputJSONRequestBody = WorkflowOutputUpdate

// ArchiveWorkflowOutputsJSONRequestBody defines body for ArchiveWorkflowOutputs for application/json ContentType.
type ArchiveWorkflowOutputsJSONRequestBody = WorkflowOutputsArchive

// BulkCreateWorkflowOutputsJSONRequestBody defines body for BulkCreateWorkflowOutputs for application/json ContentType.
type BulkCreateWorkflowOutputsJSONRequestBody = WorkflowOutputsBulkCreateRequest

// BulkUpdateWorkflowOutputsJSONRequestBody defines body for BulkUpdateWorkflowOutputs for application/json ContentType.
type BulkUpdateWorkflowOutputsJSONRequestBody = WorkflowOutputsBulkUpdateRequest

// UnarchiveWorkflowOutputsJSONRequestBody defines body for UnarchiveWorkflowOutputs for application/json ContentType.
type UnarchiveWorkflowOutputsJSONRequestBody = WorkflowOutputsUnarchive

// CreateWorkflowTaskGroupJSONRequestBody defines body for CreateWorkflowTaskGroup for application/json ContentType.
type CreateWorkflowTaskGroupJSONRequestBody = WorkflowTaskGroupCreate

// UpdateWorkflowTaskGroupJSONRequestBody defines body for UpdateWorkflowTaskGroup for application/json ContentType.
type UpdateWorkflowTaskGroupJSONRequestBody = WorkflowTaskGroupUpdate

// ArchiveWorkflowTaskGroupsJSONRequestBody defines body for ArchiveWorkflowTaskGroups for application/json ContentType.
type ArchiveWorkflowTaskGroupsJSONRequestBody = WorkflowTaskGroupsArchive

// UnarchiveWorkflowTaskGroupsJSONRequestBody defines body for UnarchiveWorkflowTaskGroups for application/json ContentType.
type UnarchiveWorkflowTaskGroupsJSONRequestBody = WorkflowTaskGroupsUnarchive

// CreateWorkflowTaskJSONRequestBody defines body for CreateWorkflowTask for application/json ContentType.
type CreateWorkflowTaskJSONRequestBody = WorkflowTaskCreate

// UpdateWorkflowTaskJSONRequestBody defines body for UpdateWorkflowTask for application/json ContentType.
type UpdateWorkflowTaskJSONRequestBody = WorkflowTaskUpdate

// ArchiveWorkflowTasksJSONRequestBody defines body for ArchiveWorkflowTasks for application/json ContentType.
type ArchiveWorkflowTasksJSONRequestBody = WorkflowTasksArchive

// BulkCopyWorkflowTasksJSONRequestBody defines body for BulkCopyWorkflowTasks for application/json ContentType.
type BulkCopyWorkflowTasksJSONRequestBody = WorkflowTasksBulkCopyRequest

// BulkCreateWorkflowTasksJSONRequestBody defines body for BulkCreateWorkflowTasks for application/json ContentType.
type BulkCreateWorkflowTasksJSONRequestBody = WorkflowTasksBulkCreateRequest

// BulkUpdateWorkflowTasksJSONRequestBody defines body for BulkUpdateWorkflowTasks for application/json ContentType.
type BulkUpdateWorkflowTasksJSONRequestBody = WorkflowTasksBulkUpdateRequest

// UnarchiveWorkflowTasksJSONRequestBody defines body for UnarchiveWorkflowTasks for application/json ContentType.
type UnarchiveWorkflowTasksJSONRequestBody = WorkflowTasksUnarchive

// UpdateWorkflowMetadataJSONRequestBody defines body for UpdateWorkflowMetadata for application/json ContentType.
type UpdateWorkflowMetadataJSONRequestBody = WorkflowPatch

// AsButtonUiBlock returns the union data inside the AppCanvas_Blocks_Item as a ButtonUiBlock
func (t AppCanvas_Blocks_Item) AsButtonUiBlock() (ButtonUiBlock, error) {
	var body ButtonUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromButtonUiBlock overwrites any union data inside the AppCanvas_Blocks_Item as the provided ButtonUiBlock
func (t *AppCanvas_Blocks_Item) FromButtonUiBlock(v ButtonUiBlock) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeButtonUiBlock performs a merge with any union data inside the AppCanvas_Blocks_Item, using the provided ButtonUiBlock
func (t *AppCanvas_Blocks_Item) MergeButtonUiBlock(v ButtonUiBlock) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsChipUiBlock returns the union data inside the AppCanvas_Blocks_Item as a ChipUiBlock
func (t AppCanvas_Blocks_Item) AsChipUiBlock() (ChipUiBlock, error) {
	var body ChipUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChipUiBlock overwrites any union data inside the AppCanvas_Blocks_Item as the provided ChipUiBlock
func (t *AppCanvas_Blocks_Item) FromChipUiBlock(v ChipUiBlock) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChipUiBlock performs a merge with any union data inside the AppCanvas_Blocks_Item, using the provided ChipUiBlock
func (t *AppCanvas_Blocks_Item) MergeChipUiBlock(v ChipUiBlock) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownUiBlock returns the union data inside the AppCanvas_Blocks_Item as a DropdownUiBlock
func (t AppCanvas_Blocks_Item) AsDropdownUiBlock() (DropdownUiBlock, error) {
	var body DropdownUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownUiBlock overwrites any union data inside the AppCanvas_Blocks_Item as the provided DropdownUiBlock
func (t *AppCanvas_Blocks_Item) FromDropdownUiBlock(v DropdownUiBlock) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownUiBlock performs a merge with any union data inside the AppCanvas_Blocks_Item, using the provided DropdownUiBlock
func (t *AppCanvas_Blocks_Item) MergeDropdownUiBlock(v DropdownUiBlock) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownMultiValueUiBlock returns the union data inside the AppCanvas_Blocks_Item as a DropdownMultiValueUiBlock
func (t AppCanvas_Blocks_Item) AsDropdownMultiValueUiBlock() (DropdownMultiValueUiBlock, error) {
	var body DropdownMultiValueUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownMultiValueUiBlock overwrites any union data inside the AppCanvas_Blocks_Item as the provided DropdownMultiValueUiBlock
func (t *AppCanvas_Blocks_Item) FromDropdownMultiValueUiBlock(v DropdownMultiValueUiBlock) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownMultiValueUiBlock performs a merge with any union data inside the AppCanvas_Blocks_Item, using the provided DropdownMultiValueUiBlock
func (t *AppCanvas_Blocks_Item) MergeDropdownMultiValueUiBlock(v DropdownMultiValueUiBlock) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMarkdownUiBlock returns the union data inside the AppCanvas_Blocks_Item as a MarkdownUiBlock
func (t AppCanvas_Blocks_Item) AsMarkdownUiBlock() (MarkdownUiBlock, error) {
	var body MarkdownUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMarkdownUiBlock overwrites any union data inside the AppCanvas_Blocks_Item as the provided MarkdownUiBlock
func (t *AppCanvas_Blocks_Item) FromMarkdownUiBlock(v MarkdownUiBlock) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMarkdownUiBlock performs a merge with any union data inside the AppCanvas_Blocks_Item, using the provided MarkdownUiBlock
func (t *AppCanvas_Blocks_Item) MergeMarkdownUiBlock(v MarkdownUiBlock) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputUiBlock returns the union data inside the AppCanvas_Blocks_Item as a SearchInputUiBlock
func (t AppCanvas_Blocks_Item) AsSearchInputUiBlock() (SearchInputUiBlock, error) {
	var body SearchInputUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputUiBlock overwrites any union data inside the AppCanvas_Blocks_Item as the provided SearchInputUiBlock
func (t *AppCanvas_Blocks_Item) FromSearchInputUiBlock(v SearchInputUiBlock) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputUiBlock performs a merge with any union data inside the AppCanvas_Blocks_Item, using the provided SearchInputUiBlock
func (t *AppCanvas_Blocks_Item) MergeSearchInputUiBlock(v SearchInputUiBlock) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputMultiValueUiBlock returns the union data inside the AppCanvas_Blocks_Item as a SearchInputMultiValueUiBlock
func (t AppCanvas_Blocks_Item) AsSearchInputMultiValueUiBlock() (SearchInputMultiValueUiBlock, error) {
	var body SearchInputMultiValueUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputMultiValueUiBlock overwrites any union data inside the AppCanvas_Blocks_Item as the provided SearchInputMultiValueUiBlock
func (t *AppCanvas_Blocks_Item) FromSearchInputMultiValueUiBlock(v SearchInputMultiValueUiBlock) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputMultiValueUiBlock performs a merge with any union data inside the AppCanvas_Blocks_Item, using the provided SearchInputMultiValueUiBlock
func (t *AppCanvas_Blocks_Item) MergeSearchInputMultiValueUiBlock(v SearchInputMultiValueUiBlock) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSectionUiBlock returns the union data inside the AppCanvas_Blocks_Item as a SectionUiBlock
func (t AppCanvas_Blocks_Item) AsSectionUiBlock() (SectionUiBlock, error) {
	var body SectionUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSectionUiBlock overwrites any union data inside the AppCanvas_Blocks_Item as the provided SectionUiBlock
func (t *AppCanvas_Blocks_Item) FromSectionUiBlock(v SectionUiBlock) error {
	t.Type = "SECTION"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSectionUiBlock performs a merge with any union data inside the AppCanvas_Blocks_Item, using the provided SectionUiBlock
func (t *AppCanvas_Blocks_Item) MergeSectionUiBlock(v SectionUiBlock) error {
	t.Type = "SECTION"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputUiBlock returns the union data inside the AppCanvas_Blocks_Item as a SelectorInputUiBlock
func (t AppCanvas_Blocks_Item) AsSelectorInputUiBlock() (SelectorInputUiBlock, error) {
	var body SelectorInputUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputUiBlock overwrites any union data inside the AppCanvas_Blocks_Item as the provided SelectorInputUiBlock
func (t *AppCanvas_Blocks_Item) FromSelectorInputUiBlock(v SelectorInputUiBlock) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputUiBlock performs a merge with any union data inside the AppCanvas_Blocks_Item, using the provided SelectorInputUiBlock
func (t *AppCanvas_Blocks_Item) MergeSelectorInputUiBlock(v SelectorInputUiBlock) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputMultiValueUiBlock returns the union data inside the AppCanvas_Blocks_Item as a SelectorInputMultiValueUiBlock
func (t AppCanvas_Blocks_Item) AsSelectorInputMultiValueUiBlock() (SelectorInputMultiValueUiBlock, error) {
	var body SelectorInputMultiValueUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputMultiValueUiBlock overwrites any union data inside the AppCanvas_Blocks_Item as the provided SelectorInputMultiValueUiBlock
func (t *AppCanvas_Blocks_Item) FromSelectorInputMultiValueUiBlock(v SelectorInputMultiValueUiBlock) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputMultiValueUiBlock performs a merge with any union data inside the AppCanvas_Blocks_Item, using the provided SelectorInputMultiValueUiBlock
func (t *AppCanvas_Blocks_Item) MergeSelectorInputMultiValueUiBlock(v SelectorInputMultiValueUiBlock) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTextInputUiBlock returns the union data inside the AppCanvas_Blocks_Item as a TextInputUiBlock
func (t AppCanvas_Blocks_Item) AsTextInputUiBlock() (TextInputUiBlock, error) {
	var body TextInputUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextInputUiBlock overwrites any union data inside the AppCanvas_Blocks_Item as the provided TextInputUiBlock
func (t *AppCanvas_Blocks_Item) FromTextInputUiBlock(v TextInputUiBlock) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextInputUiBlock performs a merge with any union data inside the AppCanvas_Blocks_Item, using the provided TextInputUiBlock
func (t *AppCanvas_Blocks_Item) MergeTextInputUiBlock(v TextInputUiBlock) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTableUiBlock returns the union data inside the AppCanvas_Blocks_Item as a TableUiBlock
func (t AppCanvas_Blocks_Item) AsTableUiBlock() (TableUiBlock, error) {
	var body TableUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTableUiBlock overwrites any union data inside the AppCanvas_Blocks_Item as the provided TableUiBlock
func (t *AppCanvas_Blocks_Item) FromTableUiBlock(v TableUiBlock) error {
	t.Type = "TABLE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTableUiBlock performs a merge with any union data inside the AppCanvas_Blocks_Item, using the provided TableUiBlock
func (t *AppCanvas_Blocks_Item) MergeTableUiBlock(v TableUiBlock) error {
	t.Type = "TABLE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AppCanvas_Blocks_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AppCanvas_Blocks_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BUTTON":
		return t.AsButtonUiBlock()
	case "CHIP":
		return t.AsChipUiBlock()
	case "DROPDOWN":
		return t.AsDropdownUiBlock()
	case "DROPDOWN_MULTIVALUE":
		return t.AsDropdownMultiValueUiBlock()
	case "MARKDOWN":
		return t.AsMarkdownUiBlock()
	case "SEARCH_INPUT":
		return t.AsSearchInputUiBlock()
	case "SEARCH_INPUT_MULTIVALUE":
		return t.AsSearchInputMultiValueUiBlock()
	case "SECTION":
		return t.AsSectionUiBlock()
	case "SELECTOR_INPUT":
		return t.AsSelectorInputUiBlock()
	case "SELECTOR_INPUT_MULTIVALUE":
		return t.AsSelectorInputMultiValueUiBlock()
	case "TABLE":
		return t.AsTableUiBlock()
	case "TEXT_INPUT":
		return t.AsTextInputUiBlock()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AppCanvas_Blocks_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AppCanvas_Blocks_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsButtonUiBlock returns the union data inside the AppCanvasBase_Blocks_Item as a ButtonUiBlock
func (t AppCanvasBase_Blocks_Item) AsButtonUiBlock() (ButtonUiBlock, error) {
	var body ButtonUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromButtonUiBlock overwrites any union data inside the AppCanvasBase_Blocks_Item as the provided ButtonUiBlock
func (t *AppCanvasBase_Blocks_Item) FromButtonUiBlock(v ButtonUiBlock) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeButtonUiBlock performs a merge with any union data inside the AppCanvasBase_Blocks_Item, using the provided ButtonUiBlock
func (t *AppCanvasBase_Blocks_Item) MergeButtonUiBlock(v ButtonUiBlock) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsChipUiBlock returns the union data inside the AppCanvasBase_Blocks_Item as a ChipUiBlock
func (t AppCanvasBase_Blocks_Item) AsChipUiBlock() (ChipUiBlock, error) {
	var body ChipUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChipUiBlock overwrites any union data inside the AppCanvasBase_Blocks_Item as the provided ChipUiBlock
func (t *AppCanvasBase_Blocks_Item) FromChipUiBlock(v ChipUiBlock) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChipUiBlock performs a merge with any union data inside the AppCanvasBase_Blocks_Item, using the provided ChipUiBlock
func (t *AppCanvasBase_Blocks_Item) MergeChipUiBlock(v ChipUiBlock) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownUiBlock returns the union data inside the AppCanvasBase_Blocks_Item as a DropdownUiBlock
func (t AppCanvasBase_Blocks_Item) AsDropdownUiBlock() (DropdownUiBlock, error) {
	var body DropdownUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownUiBlock overwrites any union data inside the AppCanvasBase_Blocks_Item as the provided DropdownUiBlock
func (t *AppCanvasBase_Blocks_Item) FromDropdownUiBlock(v DropdownUiBlock) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownUiBlock performs a merge with any union data inside the AppCanvasBase_Blocks_Item, using the provided DropdownUiBlock
func (t *AppCanvasBase_Blocks_Item) MergeDropdownUiBlock(v DropdownUiBlock) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownMultiValueUiBlock returns the union data inside the AppCanvasBase_Blocks_Item as a DropdownMultiValueUiBlock
func (t AppCanvasBase_Blocks_Item) AsDropdownMultiValueUiBlock() (DropdownMultiValueUiBlock, error) {
	var body DropdownMultiValueUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownMultiValueUiBlock overwrites any union data inside the AppCanvasBase_Blocks_Item as the provided DropdownMultiValueUiBlock
func (t *AppCanvasBase_Blocks_Item) FromDropdownMultiValueUiBlock(v DropdownMultiValueUiBlock) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownMultiValueUiBlock performs a merge with any union data inside the AppCanvasBase_Blocks_Item, using the provided DropdownMultiValueUiBlock
func (t *AppCanvasBase_Blocks_Item) MergeDropdownMultiValueUiBlock(v DropdownMultiValueUiBlock) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMarkdownUiBlock returns the union data inside the AppCanvasBase_Blocks_Item as a MarkdownUiBlock
func (t AppCanvasBase_Blocks_Item) AsMarkdownUiBlock() (MarkdownUiBlock, error) {
	var body MarkdownUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMarkdownUiBlock overwrites any union data inside the AppCanvasBase_Blocks_Item as the provided MarkdownUiBlock
func (t *AppCanvasBase_Blocks_Item) FromMarkdownUiBlock(v MarkdownUiBlock) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMarkdownUiBlock performs a merge with any union data inside the AppCanvasBase_Blocks_Item, using the provided MarkdownUiBlock
func (t *AppCanvasBase_Blocks_Item) MergeMarkdownUiBlock(v MarkdownUiBlock) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputUiBlock returns the union data inside the AppCanvasBase_Blocks_Item as a SearchInputUiBlock
func (t AppCanvasBase_Blocks_Item) AsSearchInputUiBlock() (SearchInputUiBlock, error) {
	var body SearchInputUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputUiBlock overwrites any union data inside the AppCanvasBase_Blocks_Item as the provided SearchInputUiBlock
func (t *AppCanvasBase_Blocks_Item) FromSearchInputUiBlock(v SearchInputUiBlock) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputUiBlock performs a merge with any union data inside the AppCanvasBase_Blocks_Item, using the provided SearchInputUiBlock
func (t *AppCanvasBase_Blocks_Item) MergeSearchInputUiBlock(v SearchInputUiBlock) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputMultiValueUiBlock returns the union data inside the AppCanvasBase_Blocks_Item as a SearchInputMultiValueUiBlock
func (t AppCanvasBase_Blocks_Item) AsSearchInputMultiValueUiBlock() (SearchInputMultiValueUiBlock, error) {
	var body SearchInputMultiValueUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputMultiValueUiBlock overwrites any union data inside the AppCanvasBase_Blocks_Item as the provided SearchInputMultiValueUiBlock
func (t *AppCanvasBase_Blocks_Item) FromSearchInputMultiValueUiBlock(v SearchInputMultiValueUiBlock) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputMultiValueUiBlock performs a merge with any union data inside the AppCanvasBase_Blocks_Item, using the provided SearchInputMultiValueUiBlock
func (t *AppCanvasBase_Blocks_Item) MergeSearchInputMultiValueUiBlock(v SearchInputMultiValueUiBlock) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSectionUiBlock returns the union data inside the AppCanvasBase_Blocks_Item as a SectionUiBlock
func (t AppCanvasBase_Blocks_Item) AsSectionUiBlock() (SectionUiBlock, error) {
	var body SectionUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSectionUiBlock overwrites any union data inside the AppCanvasBase_Blocks_Item as the provided SectionUiBlock
func (t *AppCanvasBase_Blocks_Item) FromSectionUiBlock(v SectionUiBlock) error {
	t.Type = "SECTION"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSectionUiBlock performs a merge with any union data inside the AppCanvasBase_Blocks_Item, using the provided SectionUiBlock
func (t *AppCanvasBase_Blocks_Item) MergeSectionUiBlock(v SectionUiBlock) error {
	t.Type = "SECTION"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputUiBlock returns the union data inside the AppCanvasBase_Blocks_Item as a SelectorInputUiBlock
func (t AppCanvasBase_Blocks_Item) AsSelectorInputUiBlock() (SelectorInputUiBlock, error) {
	var body SelectorInputUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputUiBlock overwrites any union data inside the AppCanvasBase_Blocks_Item as the provided SelectorInputUiBlock
func (t *AppCanvasBase_Blocks_Item) FromSelectorInputUiBlock(v SelectorInputUiBlock) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputUiBlock performs a merge with any union data inside the AppCanvasBase_Blocks_Item, using the provided SelectorInputUiBlock
func (t *AppCanvasBase_Blocks_Item) MergeSelectorInputUiBlock(v SelectorInputUiBlock) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputMultiValueUiBlock returns the union data inside the AppCanvasBase_Blocks_Item as a SelectorInputMultiValueUiBlock
func (t AppCanvasBase_Blocks_Item) AsSelectorInputMultiValueUiBlock() (SelectorInputMultiValueUiBlock, error) {
	var body SelectorInputMultiValueUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputMultiValueUiBlock overwrites any union data inside the AppCanvasBase_Blocks_Item as the provided SelectorInputMultiValueUiBlock
func (t *AppCanvasBase_Blocks_Item) FromSelectorInputMultiValueUiBlock(v SelectorInputMultiValueUiBlock) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputMultiValueUiBlock performs a merge with any union data inside the AppCanvasBase_Blocks_Item, using the provided SelectorInputMultiValueUiBlock
func (t *AppCanvasBase_Blocks_Item) MergeSelectorInputMultiValueUiBlock(v SelectorInputMultiValueUiBlock) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTextInputUiBlock returns the union data inside the AppCanvasBase_Blocks_Item as a TextInputUiBlock
func (t AppCanvasBase_Blocks_Item) AsTextInputUiBlock() (TextInputUiBlock, error) {
	var body TextInputUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextInputUiBlock overwrites any union data inside the AppCanvasBase_Blocks_Item as the provided TextInputUiBlock
func (t *AppCanvasBase_Blocks_Item) FromTextInputUiBlock(v TextInputUiBlock) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextInputUiBlock performs a merge with any union data inside the AppCanvasBase_Blocks_Item, using the provided TextInputUiBlock
func (t *AppCanvasBase_Blocks_Item) MergeTextInputUiBlock(v TextInputUiBlock) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTableUiBlock returns the union data inside the AppCanvasBase_Blocks_Item as a TableUiBlock
func (t AppCanvasBase_Blocks_Item) AsTableUiBlock() (TableUiBlock, error) {
	var body TableUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTableUiBlock overwrites any union data inside the AppCanvasBase_Blocks_Item as the provided TableUiBlock
func (t *AppCanvasBase_Blocks_Item) FromTableUiBlock(v TableUiBlock) error {
	t.Type = "TABLE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTableUiBlock performs a merge with any union data inside the AppCanvasBase_Blocks_Item, using the provided TableUiBlock
func (t *AppCanvasBase_Blocks_Item) MergeTableUiBlock(v TableUiBlock) error {
	t.Type = "TABLE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AppCanvasBase_Blocks_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AppCanvasBase_Blocks_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BUTTON":
		return t.AsButtonUiBlock()
	case "CHIP":
		return t.AsChipUiBlock()
	case "DROPDOWN":
		return t.AsDropdownUiBlock()
	case "DROPDOWN_MULTIVALUE":
		return t.AsDropdownMultiValueUiBlock()
	case "MARKDOWN":
		return t.AsMarkdownUiBlock()
	case "SEARCH_INPUT":
		return t.AsSearchInputUiBlock()
	case "SEARCH_INPUT_MULTIVALUE":
		return t.AsSearchInputMultiValueUiBlock()
	case "SECTION":
		return t.AsSectionUiBlock()
	case "SELECTOR_INPUT":
		return t.AsSelectorInputUiBlock()
	case "SELECTOR_INPUT_MULTIVALUE":
		return t.AsSelectorInputMultiValueUiBlock()
	case "TABLE":
		return t.AsTableUiBlock()
	case "TEXT_INPUT":
		return t.AsTextInputUiBlock()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AppCanvasBase_Blocks_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AppCanvasBase_Blocks_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsButtonUiBlockCreate returns the union data inside the AppCanvasCreate_Blocks_Item as a ButtonUiBlockCreate
func (t AppCanvasCreate_Blocks_Item) AsButtonUiBlockCreate() (ButtonUiBlockCreate, error) {
	var body ButtonUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromButtonUiBlockCreate overwrites any union data inside the AppCanvasCreate_Blocks_Item as the provided ButtonUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) FromButtonUiBlockCreate(v ButtonUiBlockCreate) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeButtonUiBlockCreate performs a merge with any union data inside the AppCanvasCreate_Blocks_Item, using the provided ButtonUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) MergeButtonUiBlockCreate(v ButtonUiBlockCreate) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsChipUiBlockCreate returns the union data inside the AppCanvasCreate_Blocks_Item as a ChipUiBlockCreate
func (t AppCanvasCreate_Blocks_Item) AsChipUiBlockCreate() (ChipUiBlockCreate, error) {
	var body ChipUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChipUiBlockCreate overwrites any union data inside the AppCanvasCreate_Blocks_Item as the provided ChipUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) FromChipUiBlockCreate(v ChipUiBlockCreate) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChipUiBlockCreate performs a merge with any union data inside the AppCanvasCreate_Blocks_Item, using the provided ChipUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) MergeChipUiBlockCreate(v ChipUiBlockCreate) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownUiBlockCreate returns the union data inside the AppCanvasCreate_Blocks_Item as a DropdownUiBlockCreate
func (t AppCanvasCreate_Blocks_Item) AsDropdownUiBlockCreate() (DropdownUiBlockCreate, error) {
	var body DropdownUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownUiBlockCreate overwrites any union data inside the AppCanvasCreate_Blocks_Item as the provided DropdownUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) FromDropdownUiBlockCreate(v DropdownUiBlockCreate) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownUiBlockCreate performs a merge with any union data inside the AppCanvasCreate_Blocks_Item, using the provided DropdownUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) MergeDropdownUiBlockCreate(v DropdownUiBlockCreate) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownMultiValueUiBlockCreate returns the union data inside the AppCanvasCreate_Blocks_Item as a DropdownMultiValueUiBlockCreate
func (t AppCanvasCreate_Blocks_Item) AsDropdownMultiValueUiBlockCreate() (DropdownMultiValueUiBlockCreate, error) {
	var body DropdownMultiValueUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownMultiValueUiBlockCreate overwrites any union data inside the AppCanvasCreate_Blocks_Item as the provided DropdownMultiValueUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) FromDropdownMultiValueUiBlockCreate(v DropdownMultiValueUiBlockCreate) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownMultiValueUiBlockCreate performs a merge with any union data inside the AppCanvasCreate_Blocks_Item, using the provided DropdownMultiValueUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) MergeDropdownMultiValueUiBlockCreate(v DropdownMultiValueUiBlockCreate) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMarkdownUiBlockCreate returns the union data inside the AppCanvasCreate_Blocks_Item as a MarkdownUiBlockCreate
func (t AppCanvasCreate_Blocks_Item) AsMarkdownUiBlockCreate() (MarkdownUiBlockCreate, error) {
	var body MarkdownUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMarkdownUiBlockCreate overwrites any union data inside the AppCanvasCreate_Blocks_Item as the provided MarkdownUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) FromMarkdownUiBlockCreate(v MarkdownUiBlockCreate) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMarkdownUiBlockCreate performs a merge with any union data inside the AppCanvasCreate_Blocks_Item, using the provided MarkdownUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) MergeMarkdownUiBlockCreate(v MarkdownUiBlockCreate) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputUiBlockCreate returns the union data inside the AppCanvasCreate_Blocks_Item as a SearchInputUiBlockCreate
func (t AppCanvasCreate_Blocks_Item) AsSearchInputUiBlockCreate() (SearchInputUiBlockCreate, error) {
	var body SearchInputUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputUiBlockCreate overwrites any union data inside the AppCanvasCreate_Blocks_Item as the provided SearchInputUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) FromSearchInputUiBlockCreate(v SearchInputUiBlockCreate) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputUiBlockCreate performs a merge with any union data inside the AppCanvasCreate_Blocks_Item, using the provided SearchInputUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) MergeSearchInputUiBlockCreate(v SearchInputUiBlockCreate) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputMultiValueUiBlockCreate returns the union data inside the AppCanvasCreate_Blocks_Item as a SearchInputMultiValueUiBlockCreate
func (t AppCanvasCreate_Blocks_Item) AsSearchInputMultiValueUiBlockCreate() (SearchInputMultiValueUiBlockCreate, error) {
	var body SearchInputMultiValueUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputMultiValueUiBlockCreate overwrites any union data inside the AppCanvasCreate_Blocks_Item as the provided SearchInputMultiValueUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) FromSearchInputMultiValueUiBlockCreate(v SearchInputMultiValueUiBlockCreate) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputMultiValueUiBlockCreate performs a merge with any union data inside the AppCanvasCreate_Blocks_Item, using the provided SearchInputMultiValueUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) MergeSearchInputMultiValueUiBlockCreate(v SearchInputMultiValueUiBlockCreate) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSectionUiBlockCreate returns the union data inside the AppCanvasCreate_Blocks_Item as a SectionUiBlockCreate
func (t AppCanvasCreate_Blocks_Item) AsSectionUiBlockCreate() (SectionUiBlockCreate, error) {
	var body SectionUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSectionUiBlockCreate overwrites any union data inside the AppCanvasCreate_Blocks_Item as the provided SectionUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) FromSectionUiBlockCreate(v SectionUiBlockCreate) error {
	t.Type = "SECTION"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSectionUiBlockCreate performs a merge with any union data inside the AppCanvasCreate_Blocks_Item, using the provided SectionUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) MergeSectionUiBlockCreate(v SectionUiBlockCreate) error {
	t.Type = "SECTION"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputUiBlockCreate returns the union data inside the AppCanvasCreate_Blocks_Item as a SelectorInputUiBlockCreate
func (t AppCanvasCreate_Blocks_Item) AsSelectorInputUiBlockCreate() (SelectorInputUiBlockCreate, error) {
	var body SelectorInputUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputUiBlockCreate overwrites any union data inside the AppCanvasCreate_Blocks_Item as the provided SelectorInputUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) FromSelectorInputUiBlockCreate(v SelectorInputUiBlockCreate) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputUiBlockCreate performs a merge with any union data inside the AppCanvasCreate_Blocks_Item, using the provided SelectorInputUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) MergeSelectorInputUiBlockCreate(v SelectorInputUiBlockCreate) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputMultiValueUiBlockCreate returns the union data inside the AppCanvasCreate_Blocks_Item as a SelectorInputMultiValueUiBlockCreate
func (t AppCanvasCreate_Blocks_Item) AsSelectorInputMultiValueUiBlockCreate() (SelectorInputMultiValueUiBlockCreate, error) {
	var body SelectorInputMultiValueUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputMultiValueUiBlockCreate overwrites any union data inside the AppCanvasCreate_Blocks_Item as the provided SelectorInputMultiValueUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) FromSelectorInputMultiValueUiBlockCreate(v SelectorInputMultiValueUiBlockCreate) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputMultiValueUiBlockCreate performs a merge with any union data inside the AppCanvasCreate_Blocks_Item, using the provided SelectorInputMultiValueUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) MergeSelectorInputMultiValueUiBlockCreate(v SelectorInputMultiValueUiBlockCreate) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTextInputUiBlockCreate returns the union data inside the AppCanvasCreate_Blocks_Item as a TextInputUiBlockCreate
func (t AppCanvasCreate_Blocks_Item) AsTextInputUiBlockCreate() (TextInputUiBlockCreate, error) {
	var body TextInputUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextInputUiBlockCreate overwrites any union data inside the AppCanvasCreate_Blocks_Item as the provided TextInputUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) FromTextInputUiBlockCreate(v TextInputUiBlockCreate) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextInputUiBlockCreate performs a merge with any union data inside the AppCanvasCreate_Blocks_Item, using the provided TextInputUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) MergeTextInputUiBlockCreate(v TextInputUiBlockCreate) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTableUiBlockCreate returns the union data inside the AppCanvasCreate_Blocks_Item as a TableUiBlockCreate
func (t AppCanvasCreate_Blocks_Item) AsTableUiBlockCreate() (TableUiBlockCreate, error) {
	var body TableUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTableUiBlockCreate overwrites any union data inside the AppCanvasCreate_Blocks_Item as the provided TableUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) FromTableUiBlockCreate(v TableUiBlockCreate) error {
	t.Type = "TABLE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTableUiBlockCreate performs a merge with any union data inside the AppCanvasCreate_Blocks_Item, using the provided TableUiBlockCreate
func (t *AppCanvasCreate_Blocks_Item) MergeTableUiBlockCreate(v TableUiBlockCreate) error {
	t.Type = "TABLE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AppCanvasCreate_Blocks_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AppCanvasCreate_Blocks_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BUTTON":
		return t.AsButtonUiBlockCreate()
	case "CHIP":
		return t.AsChipUiBlockCreate()
	case "DROPDOWN":
		return t.AsDropdownUiBlockCreate()
	case "DROPDOWN_MULTIVALUE":
		return t.AsDropdownMultiValueUiBlockCreate()
	case "MARKDOWN":
		return t.AsMarkdownUiBlockCreate()
	case "SEARCH_INPUT":
		return t.AsSearchInputUiBlockCreate()
	case "SEARCH_INPUT_MULTIVALUE":
		return t.AsSearchInputMultiValueUiBlockCreate()
	case "SECTION":
		return t.AsSectionUiBlockCreate()
	case "SELECTOR_INPUT":
		return t.AsSelectorInputUiBlockCreate()
	case "SELECTOR_INPUT_MULTIVALUE":
		return t.AsSelectorInputMultiValueUiBlockCreate()
	case "TABLE":
		return t.AsTableUiBlockCreate()
	case "TEXT_INPUT":
		return t.AsTextInputUiBlockCreate()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AppCanvasCreate_Blocks_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AppCanvasCreate_Blocks_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsButtonUiBlockCreate returns the union data inside the AppCanvasCreateBase_Blocks_Item as a ButtonUiBlockCreate
func (t AppCanvasCreateBase_Blocks_Item) AsButtonUiBlockCreate() (ButtonUiBlockCreate, error) {
	var body ButtonUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromButtonUiBlockCreate overwrites any union data inside the AppCanvasCreateBase_Blocks_Item as the provided ButtonUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) FromButtonUiBlockCreate(v ButtonUiBlockCreate) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeButtonUiBlockCreate performs a merge with any union data inside the AppCanvasCreateBase_Blocks_Item, using the provided ButtonUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) MergeButtonUiBlockCreate(v ButtonUiBlockCreate) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsChipUiBlockCreate returns the union data inside the AppCanvasCreateBase_Blocks_Item as a ChipUiBlockCreate
func (t AppCanvasCreateBase_Blocks_Item) AsChipUiBlockCreate() (ChipUiBlockCreate, error) {
	var body ChipUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChipUiBlockCreate overwrites any union data inside the AppCanvasCreateBase_Blocks_Item as the provided ChipUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) FromChipUiBlockCreate(v ChipUiBlockCreate) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChipUiBlockCreate performs a merge with any union data inside the AppCanvasCreateBase_Blocks_Item, using the provided ChipUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) MergeChipUiBlockCreate(v ChipUiBlockCreate) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownUiBlockCreate returns the union data inside the AppCanvasCreateBase_Blocks_Item as a DropdownUiBlockCreate
func (t AppCanvasCreateBase_Blocks_Item) AsDropdownUiBlockCreate() (DropdownUiBlockCreate, error) {
	var body DropdownUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownUiBlockCreate overwrites any union data inside the AppCanvasCreateBase_Blocks_Item as the provided DropdownUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) FromDropdownUiBlockCreate(v DropdownUiBlockCreate) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownUiBlockCreate performs a merge with any union data inside the AppCanvasCreateBase_Blocks_Item, using the provided DropdownUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) MergeDropdownUiBlockCreate(v DropdownUiBlockCreate) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownMultiValueUiBlockCreate returns the union data inside the AppCanvasCreateBase_Blocks_Item as a DropdownMultiValueUiBlockCreate
func (t AppCanvasCreateBase_Blocks_Item) AsDropdownMultiValueUiBlockCreate() (DropdownMultiValueUiBlockCreate, error) {
	var body DropdownMultiValueUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownMultiValueUiBlockCreate overwrites any union data inside the AppCanvasCreateBase_Blocks_Item as the provided DropdownMultiValueUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) FromDropdownMultiValueUiBlockCreate(v DropdownMultiValueUiBlockCreate) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownMultiValueUiBlockCreate performs a merge with any union data inside the AppCanvasCreateBase_Blocks_Item, using the provided DropdownMultiValueUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) MergeDropdownMultiValueUiBlockCreate(v DropdownMultiValueUiBlockCreate) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMarkdownUiBlockCreate returns the union data inside the AppCanvasCreateBase_Blocks_Item as a MarkdownUiBlockCreate
func (t AppCanvasCreateBase_Blocks_Item) AsMarkdownUiBlockCreate() (MarkdownUiBlockCreate, error) {
	var body MarkdownUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMarkdownUiBlockCreate overwrites any union data inside the AppCanvasCreateBase_Blocks_Item as the provided MarkdownUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) FromMarkdownUiBlockCreate(v MarkdownUiBlockCreate) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMarkdownUiBlockCreate performs a merge with any union data inside the AppCanvasCreateBase_Blocks_Item, using the provided MarkdownUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) MergeMarkdownUiBlockCreate(v MarkdownUiBlockCreate) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputUiBlockCreate returns the union data inside the AppCanvasCreateBase_Blocks_Item as a SearchInputUiBlockCreate
func (t AppCanvasCreateBase_Blocks_Item) AsSearchInputUiBlockCreate() (SearchInputUiBlockCreate, error) {
	var body SearchInputUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputUiBlockCreate overwrites any union data inside the AppCanvasCreateBase_Blocks_Item as the provided SearchInputUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) FromSearchInputUiBlockCreate(v SearchInputUiBlockCreate) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputUiBlockCreate performs a merge with any union data inside the AppCanvasCreateBase_Blocks_Item, using the provided SearchInputUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) MergeSearchInputUiBlockCreate(v SearchInputUiBlockCreate) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputMultiValueUiBlockCreate returns the union data inside the AppCanvasCreateBase_Blocks_Item as a SearchInputMultiValueUiBlockCreate
func (t AppCanvasCreateBase_Blocks_Item) AsSearchInputMultiValueUiBlockCreate() (SearchInputMultiValueUiBlockCreate, error) {
	var body SearchInputMultiValueUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputMultiValueUiBlockCreate overwrites any union data inside the AppCanvasCreateBase_Blocks_Item as the provided SearchInputMultiValueUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) FromSearchInputMultiValueUiBlockCreate(v SearchInputMultiValueUiBlockCreate) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputMultiValueUiBlockCreate performs a merge with any union data inside the AppCanvasCreateBase_Blocks_Item, using the provided SearchInputMultiValueUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) MergeSearchInputMultiValueUiBlockCreate(v SearchInputMultiValueUiBlockCreate) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSectionUiBlockCreate returns the union data inside the AppCanvasCreateBase_Blocks_Item as a SectionUiBlockCreate
func (t AppCanvasCreateBase_Blocks_Item) AsSectionUiBlockCreate() (SectionUiBlockCreate, error) {
	var body SectionUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSectionUiBlockCreate overwrites any union data inside the AppCanvasCreateBase_Blocks_Item as the provided SectionUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) FromSectionUiBlockCreate(v SectionUiBlockCreate) error {
	t.Type = "SECTION"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSectionUiBlockCreate performs a merge with any union data inside the AppCanvasCreateBase_Blocks_Item, using the provided SectionUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) MergeSectionUiBlockCreate(v SectionUiBlockCreate) error {
	t.Type = "SECTION"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputUiBlockCreate returns the union data inside the AppCanvasCreateBase_Blocks_Item as a SelectorInputUiBlockCreate
func (t AppCanvasCreateBase_Blocks_Item) AsSelectorInputUiBlockCreate() (SelectorInputUiBlockCreate, error) {
	var body SelectorInputUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputUiBlockCreate overwrites any union data inside the AppCanvasCreateBase_Blocks_Item as the provided SelectorInputUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) FromSelectorInputUiBlockCreate(v SelectorInputUiBlockCreate) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputUiBlockCreate performs a merge with any union data inside the AppCanvasCreateBase_Blocks_Item, using the provided SelectorInputUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) MergeSelectorInputUiBlockCreate(v SelectorInputUiBlockCreate) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputMultiValueUiBlockCreate returns the union data inside the AppCanvasCreateBase_Blocks_Item as a SelectorInputMultiValueUiBlockCreate
func (t AppCanvasCreateBase_Blocks_Item) AsSelectorInputMultiValueUiBlockCreate() (SelectorInputMultiValueUiBlockCreate, error) {
	var body SelectorInputMultiValueUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputMultiValueUiBlockCreate overwrites any union data inside the AppCanvasCreateBase_Blocks_Item as the provided SelectorInputMultiValueUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) FromSelectorInputMultiValueUiBlockCreate(v SelectorInputMultiValueUiBlockCreate) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputMultiValueUiBlockCreate performs a merge with any union data inside the AppCanvasCreateBase_Blocks_Item, using the provided SelectorInputMultiValueUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) MergeSelectorInputMultiValueUiBlockCreate(v SelectorInputMultiValueUiBlockCreate) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTextInputUiBlockCreate returns the union data inside the AppCanvasCreateBase_Blocks_Item as a TextInputUiBlockCreate
func (t AppCanvasCreateBase_Blocks_Item) AsTextInputUiBlockCreate() (TextInputUiBlockCreate, error) {
	var body TextInputUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextInputUiBlockCreate overwrites any union data inside the AppCanvasCreateBase_Blocks_Item as the provided TextInputUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) FromTextInputUiBlockCreate(v TextInputUiBlockCreate) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextInputUiBlockCreate performs a merge with any union data inside the AppCanvasCreateBase_Blocks_Item, using the provided TextInputUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) MergeTextInputUiBlockCreate(v TextInputUiBlockCreate) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTableUiBlockCreate returns the union data inside the AppCanvasCreateBase_Blocks_Item as a TableUiBlockCreate
func (t AppCanvasCreateBase_Blocks_Item) AsTableUiBlockCreate() (TableUiBlockCreate, error) {
	var body TableUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTableUiBlockCreate overwrites any union data inside the AppCanvasCreateBase_Blocks_Item as the provided TableUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) FromTableUiBlockCreate(v TableUiBlockCreate) error {
	t.Type = "TABLE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTableUiBlockCreate performs a merge with any union data inside the AppCanvasCreateBase_Blocks_Item, using the provided TableUiBlockCreate
func (t *AppCanvasCreateBase_Blocks_Item) MergeTableUiBlockCreate(v TableUiBlockCreate) error {
	t.Type = "TABLE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AppCanvasCreateBase_Blocks_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AppCanvasCreateBase_Blocks_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BUTTON":
		return t.AsButtonUiBlockCreate()
	case "CHIP":
		return t.AsChipUiBlockCreate()
	case "DROPDOWN":
		return t.AsDropdownUiBlockCreate()
	case "DROPDOWN_MULTIVALUE":
		return t.AsDropdownMultiValueUiBlockCreate()
	case "MARKDOWN":
		return t.AsMarkdownUiBlockCreate()
	case "SEARCH_INPUT":
		return t.AsSearchInputUiBlockCreate()
	case "SEARCH_INPUT_MULTIVALUE":
		return t.AsSearchInputMultiValueUiBlockCreate()
	case "SECTION":
		return t.AsSectionUiBlockCreate()
	case "SELECTOR_INPUT":
		return t.AsSelectorInputUiBlockCreate()
	case "SELECTOR_INPUT_MULTIVALUE":
		return t.AsSelectorInputMultiValueUiBlockCreate()
	case "TABLE":
		return t.AsTableUiBlockCreate()
	case "TEXT_INPUT":
		return t.AsTextInputUiBlockCreate()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AppCanvasCreateBase_Blocks_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AppCanvasCreateBase_Blocks_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsButtonUiBlockCreate returns the union data inside the AppCanvasCreateUiBlockList_Blocks_Item as a ButtonUiBlockCreate
func (t AppCanvasCreateUiBlockList_Blocks_Item) AsButtonUiBlockCreate() (ButtonUiBlockCreate, error) {
	var body ButtonUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromButtonUiBlockCreate overwrites any union data inside the AppCanvasCreateUiBlockList_Blocks_Item as the provided ButtonUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) FromButtonUiBlockCreate(v ButtonUiBlockCreate) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeButtonUiBlockCreate performs a merge with any union data inside the AppCanvasCreateUiBlockList_Blocks_Item, using the provided ButtonUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) MergeButtonUiBlockCreate(v ButtonUiBlockCreate) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsChipUiBlockCreate returns the union data inside the AppCanvasCreateUiBlockList_Blocks_Item as a ChipUiBlockCreate
func (t AppCanvasCreateUiBlockList_Blocks_Item) AsChipUiBlockCreate() (ChipUiBlockCreate, error) {
	var body ChipUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChipUiBlockCreate overwrites any union data inside the AppCanvasCreateUiBlockList_Blocks_Item as the provided ChipUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) FromChipUiBlockCreate(v ChipUiBlockCreate) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChipUiBlockCreate performs a merge with any union data inside the AppCanvasCreateUiBlockList_Blocks_Item, using the provided ChipUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) MergeChipUiBlockCreate(v ChipUiBlockCreate) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownUiBlockCreate returns the union data inside the AppCanvasCreateUiBlockList_Blocks_Item as a DropdownUiBlockCreate
func (t AppCanvasCreateUiBlockList_Blocks_Item) AsDropdownUiBlockCreate() (DropdownUiBlockCreate, error) {
	var body DropdownUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownUiBlockCreate overwrites any union data inside the AppCanvasCreateUiBlockList_Blocks_Item as the provided DropdownUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) FromDropdownUiBlockCreate(v DropdownUiBlockCreate) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownUiBlockCreate performs a merge with any union data inside the AppCanvasCreateUiBlockList_Blocks_Item, using the provided DropdownUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) MergeDropdownUiBlockCreate(v DropdownUiBlockCreate) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownMultiValueUiBlockCreate returns the union data inside the AppCanvasCreateUiBlockList_Blocks_Item as a DropdownMultiValueUiBlockCreate
func (t AppCanvasCreateUiBlockList_Blocks_Item) AsDropdownMultiValueUiBlockCreate() (DropdownMultiValueUiBlockCreate, error) {
	var body DropdownMultiValueUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownMultiValueUiBlockCreate overwrites any union data inside the AppCanvasCreateUiBlockList_Blocks_Item as the provided DropdownMultiValueUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) FromDropdownMultiValueUiBlockCreate(v DropdownMultiValueUiBlockCreate) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownMultiValueUiBlockCreate performs a merge with any union data inside the AppCanvasCreateUiBlockList_Blocks_Item, using the provided DropdownMultiValueUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) MergeDropdownMultiValueUiBlockCreate(v DropdownMultiValueUiBlockCreate) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMarkdownUiBlockCreate returns the union data inside the AppCanvasCreateUiBlockList_Blocks_Item as a MarkdownUiBlockCreate
func (t AppCanvasCreateUiBlockList_Blocks_Item) AsMarkdownUiBlockCreate() (MarkdownUiBlockCreate, error) {
	var body MarkdownUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMarkdownUiBlockCreate overwrites any union data inside the AppCanvasCreateUiBlockList_Blocks_Item as the provided MarkdownUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) FromMarkdownUiBlockCreate(v MarkdownUiBlockCreate) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMarkdownUiBlockCreate performs a merge with any union data inside the AppCanvasCreateUiBlockList_Blocks_Item, using the provided MarkdownUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) MergeMarkdownUiBlockCreate(v MarkdownUiBlockCreate) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputUiBlockCreate returns the union data inside the AppCanvasCreateUiBlockList_Blocks_Item as a SearchInputUiBlockCreate
func (t AppCanvasCreateUiBlockList_Blocks_Item) AsSearchInputUiBlockCreate() (SearchInputUiBlockCreate, error) {
	var body SearchInputUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputUiBlockCreate overwrites any union data inside the AppCanvasCreateUiBlockList_Blocks_Item as the provided SearchInputUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) FromSearchInputUiBlockCreate(v SearchInputUiBlockCreate) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputUiBlockCreate performs a merge with any union data inside the AppCanvasCreateUiBlockList_Blocks_Item, using the provided SearchInputUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) MergeSearchInputUiBlockCreate(v SearchInputUiBlockCreate) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputMultiValueUiBlockCreate returns the union data inside the AppCanvasCreateUiBlockList_Blocks_Item as a SearchInputMultiValueUiBlockCreate
func (t AppCanvasCreateUiBlockList_Blocks_Item) AsSearchInputMultiValueUiBlockCreate() (SearchInputMultiValueUiBlockCreate, error) {
	var body SearchInputMultiValueUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputMultiValueUiBlockCreate overwrites any union data inside the AppCanvasCreateUiBlockList_Blocks_Item as the provided SearchInputMultiValueUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) FromSearchInputMultiValueUiBlockCreate(v SearchInputMultiValueUiBlockCreate) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputMultiValueUiBlockCreate performs a merge with any union data inside the AppCanvasCreateUiBlockList_Blocks_Item, using the provided SearchInputMultiValueUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) MergeSearchInputMultiValueUiBlockCreate(v SearchInputMultiValueUiBlockCreate) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSectionUiBlockCreate returns the union data inside the AppCanvasCreateUiBlockList_Blocks_Item as a SectionUiBlockCreate
func (t AppCanvasCreateUiBlockList_Blocks_Item) AsSectionUiBlockCreate() (SectionUiBlockCreate, error) {
	var body SectionUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSectionUiBlockCreate overwrites any union data inside the AppCanvasCreateUiBlockList_Blocks_Item as the provided SectionUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) FromSectionUiBlockCreate(v SectionUiBlockCreate) error {
	t.Type = "SECTION"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSectionUiBlockCreate performs a merge with any union data inside the AppCanvasCreateUiBlockList_Blocks_Item, using the provided SectionUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) MergeSectionUiBlockCreate(v SectionUiBlockCreate) error {
	t.Type = "SECTION"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputUiBlockCreate returns the union data inside the AppCanvasCreateUiBlockList_Blocks_Item as a SelectorInputUiBlockCreate
func (t AppCanvasCreateUiBlockList_Blocks_Item) AsSelectorInputUiBlockCreate() (SelectorInputUiBlockCreate, error) {
	var body SelectorInputUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputUiBlockCreate overwrites any union data inside the AppCanvasCreateUiBlockList_Blocks_Item as the provided SelectorInputUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) FromSelectorInputUiBlockCreate(v SelectorInputUiBlockCreate) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputUiBlockCreate performs a merge with any union data inside the AppCanvasCreateUiBlockList_Blocks_Item, using the provided SelectorInputUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) MergeSelectorInputUiBlockCreate(v SelectorInputUiBlockCreate) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputMultiValueUiBlockCreate returns the union data inside the AppCanvasCreateUiBlockList_Blocks_Item as a SelectorInputMultiValueUiBlockCreate
func (t AppCanvasCreateUiBlockList_Blocks_Item) AsSelectorInputMultiValueUiBlockCreate() (SelectorInputMultiValueUiBlockCreate, error) {
	var body SelectorInputMultiValueUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputMultiValueUiBlockCreate overwrites any union data inside the AppCanvasCreateUiBlockList_Blocks_Item as the provided SelectorInputMultiValueUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) FromSelectorInputMultiValueUiBlockCreate(v SelectorInputMultiValueUiBlockCreate) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputMultiValueUiBlockCreate performs a merge with any union data inside the AppCanvasCreateUiBlockList_Blocks_Item, using the provided SelectorInputMultiValueUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) MergeSelectorInputMultiValueUiBlockCreate(v SelectorInputMultiValueUiBlockCreate) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTextInputUiBlockCreate returns the union data inside the AppCanvasCreateUiBlockList_Blocks_Item as a TextInputUiBlockCreate
func (t AppCanvasCreateUiBlockList_Blocks_Item) AsTextInputUiBlockCreate() (TextInputUiBlockCreate, error) {
	var body TextInputUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextInputUiBlockCreate overwrites any union data inside the AppCanvasCreateUiBlockList_Blocks_Item as the provided TextInputUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) FromTextInputUiBlockCreate(v TextInputUiBlockCreate) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextInputUiBlockCreate performs a merge with any union data inside the AppCanvasCreateUiBlockList_Blocks_Item, using the provided TextInputUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) MergeTextInputUiBlockCreate(v TextInputUiBlockCreate) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTableUiBlockCreate returns the union data inside the AppCanvasCreateUiBlockList_Blocks_Item as a TableUiBlockCreate
func (t AppCanvasCreateUiBlockList_Blocks_Item) AsTableUiBlockCreate() (TableUiBlockCreate, error) {
	var body TableUiBlockCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTableUiBlockCreate overwrites any union data inside the AppCanvasCreateUiBlockList_Blocks_Item as the provided TableUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) FromTableUiBlockCreate(v TableUiBlockCreate) error {
	t.Type = "TABLE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTableUiBlockCreate performs a merge with any union data inside the AppCanvasCreateUiBlockList_Blocks_Item, using the provided TableUiBlockCreate
func (t *AppCanvasCreateUiBlockList_Blocks_Item) MergeTableUiBlockCreate(v TableUiBlockCreate) error {
	t.Type = "TABLE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AppCanvasCreateUiBlockList_Blocks_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AppCanvasCreateUiBlockList_Blocks_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BUTTON":
		return t.AsButtonUiBlockCreate()
	case "CHIP":
		return t.AsChipUiBlockCreate()
	case "DROPDOWN":
		return t.AsDropdownUiBlockCreate()
	case "DROPDOWN_MULTIVALUE":
		return t.AsDropdownMultiValueUiBlockCreate()
	case "MARKDOWN":
		return t.AsMarkdownUiBlockCreate()
	case "SEARCH_INPUT":
		return t.AsSearchInputUiBlockCreate()
	case "SEARCH_INPUT_MULTIVALUE":
		return t.AsSearchInputMultiValueUiBlockCreate()
	case "SECTION":
		return t.AsSectionUiBlockCreate()
	case "SELECTOR_INPUT":
		return t.AsSelectorInputUiBlockCreate()
	case "SELECTOR_INPUT_MULTIVALUE":
		return t.AsSelectorInputMultiValueUiBlockCreate()
	case "TABLE":
		return t.AsTableUiBlockCreate()
	case "TEXT_INPUT":
		return t.AsTextInputUiBlockCreate()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AppCanvasCreateUiBlockList_Blocks_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AppCanvasCreateUiBlockList_Blocks_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsButtonUiBlock returns the union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as a ButtonUiBlock
func (t AppCanvasLeafNodeUiBlockList_Children_Item) AsButtonUiBlock() (ButtonUiBlock, error) {
	var body ButtonUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromButtonUiBlock overwrites any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as the provided ButtonUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) FromButtonUiBlock(v ButtonUiBlock) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeButtonUiBlock performs a merge with any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item, using the provided ButtonUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) MergeButtonUiBlock(v ButtonUiBlock) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsChipUiBlock returns the union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as a ChipUiBlock
func (t AppCanvasLeafNodeUiBlockList_Children_Item) AsChipUiBlock() (ChipUiBlock, error) {
	var body ChipUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChipUiBlock overwrites any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as the provided ChipUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) FromChipUiBlock(v ChipUiBlock) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChipUiBlock performs a merge with any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item, using the provided ChipUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) MergeChipUiBlock(v ChipUiBlock) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownUiBlock returns the union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as a DropdownUiBlock
func (t AppCanvasLeafNodeUiBlockList_Children_Item) AsDropdownUiBlock() (DropdownUiBlock, error) {
	var body DropdownUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownUiBlock overwrites any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as the provided DropdownUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) FromDropdownUiBlock(v DropdownUiBlock) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownUiBlock performs a merge with any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item, using the provided DropdownUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) MergeDropdownUiBlock(v DropdownUiBlock) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownMultiValueUiBlock returns the union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as a DropdownMultiValueUiBlock
func (t AppCanvasLeafNodeUiBlockList_Children_Item) AsDropdownMultiValueUiBlock() (DropdownMultiValueUiBlock, error) {
	var body DropdownMultiValueUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownMultiValueUiBlock overwrites any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as the provided DropdownMultiValueUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) FromDropdownMultiValueUiBlock(v DropdownMultiValueUiBlock) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownMultiValueUiBlock performs a merge with any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item, using the provided DropdownMultiValueUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) MergeDropdownMultiValueUiBlock(v DropdownMultiValueUiBlock) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMarkdownUiBlock returns the union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as a MarkdownUiBlock
func (t AppCanvasLeafNodeUiBlockList_Children_Item) AsMarkdownUiBlock() (MarkdownUiBlock, error) {
	var body MarkdownUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMarkdownUiBlock overwrites any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as the provided MarkdownUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) FromMarkdownUiBlock(v MarkdownUiBlock) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMarkdownUiBlock performs a merge with any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item, using the provided MarkdownUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) MergeMarkdownUiBlock(v MarkdownUiBlock) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputUiBlock returns the union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as a SearchInputUiBlock
func (t AppCanvasLeafNodeUiBlockList_Children_Item) AsSearchInputUiBlock() (SearchInputUiBlock, error) {
	var body SearchInputUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputUiBlock overwrites any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as the provided SearchInputUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) FromSearchInputUiBlock(v SearchInputUiBlock) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputUiBlock performs a merge with any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item, using the provided SearchInputUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) MergeSearchInputUiBlock(v SearchInputUiBlock) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputMultiValueUiBlock returns the union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as a SearchInputMultiValueUiBlock
func (t AppCanvasLeafNodeUiBlockList_Children_Item) AsSearchInputMultiValueUiBlock() (SearchInputMultiValueUiBlock, error) {
	var body SearchInputMultiValueUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputMultiValueUiBlock overwrites any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as the provided SearchInputMultiValueUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) FromSearchInputMultiValueUiBlock(v SearchInputMultiValueUiBlock) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputMultiValueUiBlock performs a merge with any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item, using the provided SearchInputMultiValueUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) MergeSearchInputMultiValueUiBlock(v SearchInputMultiValueUiBlock) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputUiBlock returns the union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as a SelectorInputUiBlock
func (t AppCanvasLeafNodeUiBlockList_Children_Item) AsSelectorInputUiBlock() (SelectorInputUiBlock, error) {
	var body SelectorInputUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputUiBlock overwrites any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as the provided SelectorInputUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) FromSelectorInputUiBlock(v SelectorInputUiBlock) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputUiBlock performs a merge with any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item, using the provided SelectorInputUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) MergeSelectorInputUiBlock(v SelectorInputUiBlock) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputMultiValueUiBlock returns the union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as a SelectorInputMultiValueUiBlock
func (t AppCanvasLeafNodeUiBlockList_Children_Item) AsSelectorInputMultiValueUiBlock() (SelectorInputMultiValueUiBlock, error) {
	var body SelectorInputMultiValueUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputMultiValueUiBlock overwrites any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as the provided SelectorInputMultiValueUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) FromSelectorInputMultiValueUiBlock(v SelectorInputMultiValueUiBlock) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputMultiValueUiBlock performs a merge with any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item, using the provided SelectorInputMultiValueUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) MergeSelectorInputMultiValueUiBlock(v SelectorInputMultiValueUiBlock) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTextInputUiBlock returns the union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as a TextInputUiBlock
func (t AppCanvasLeafNodeUiBlockList_Children_Item) AsTextInputUiBlock() (TextInputUiBlock, error) {
	var body TextInputUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextInputUiBlock overwrites any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item as the provided TextInputUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) FromTextInputUiBlock(v TextInputUiBlock) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextInputUiBlock performs a merge with any union data inside the AppCanvasLeafNodeUiBlockList_Children_Item, using the provided TextInputUiBlock
func (t *AppCanvasLeafNodeUiBlockList_Children_Item) MergeTextInputUiBlock(v TextInputUiBlock) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AppCanvasLeafNodeUiBlockList_Children_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AppCanvasLeafNodeUiBlockList_Children_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BUTTON":
		return t.AsButtonUiBlock()
	case "CHIP":
		return t.AsChipUiBlock()
	case "DROPDOWN":
		return t.AsDropdownUiBlock()
	case "DROPDOWN_MULTIVALUE":
		return t.AsDropdownMultiValueUiBlock()
	case "MARKDOWN":
		return t.AsMarkdownUiBlock()
	case "SEARCH_INPUT":
		return t.AsSearchInputUiBlock()
	case "SEARCH_INPUT_MULTIVALUE":
		return t.AsSearchInputMultiValueUiBlock()
	case "SELECTOR_INPUT":
		return t.AsSelectorInputUiBlock()
	case "SELECTOR_INPUT_MULTIVALUE":
		return t.AsSelectorInputMultiValueUiBlock()
	case "TEXT_INPUT":
		return t.AsTextInputUiBlock()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AppCanvasLeafNodeUiBlockList_Children_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AppCanvasLeafNodeUiBlockList_Children_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsButtonUiBlock returns the union data inside the AppCanvasUiBlockList_Blocks_Item as a ButtonUiBlock
func (t AppCanvasUiBlockList_Blocks_Item) AsButtonUiBlock() (ButtonUiBlock, error) {
	var body ButtonUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromButtonUiBlock overwrites any union data inside the AppCanvasUiBlockList_Blocks_Item as the provided ButtonUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) FromButtonUiBlock(v ButtonUiBlock) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeButtonUiBlock performs a merge with any union data inside the AppCanvasUiBlockList_Blocks_Item, using the provided ButtonUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) MergeButtonUiBlock(v ButtonUiBlock) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsChipUiBlock returns the union data inside the AppCanvasUiBlockList_Blocks_Item as a ChipUiBlock
func (t AppCanvasUiBlockList_Blocks_Item) AsChipUiBlock() (ChipUiBlock, error) {
	var body ChipUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChipUiBlock overwrites any union data inside the AppCanvasUiBlockList_Blocks_Item as the provided ChipUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) FromChipUiBlock(v ChipUiBlock) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChipUiBlock performs a merge with any union data inside the AppCanvasUiBlockList_Blocks_Item, using the provided ChipUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) MergeChipUiBlock(v ChipUiBlock) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownUiBlock returns the union data inside the AppCanvasUiBlockList_Blocks_Item as a DropdownUiBlock
func (t AppCanvasUiBlockList_Blocks_Item) AsDropdownUiBlock() (DropdownUiBlock, error) {
	var body DropdownUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownUiBlock overwrites any union data inside the AppCanvasUiBlockList_Blocks_Item as the provided DropdownUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) FromDropdownUiBlock(v DropdownUiBlock) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownUiBlock performs a merge with any union data inside the AppCanvasUiBlockList_Blocks_Item, using the provided DropdownUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) MergeDropdownUiBlock(v DropdownUiBlock) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownMultiValueUiBlock returns the union data inside the AppCanvasUiBlockList_Blocks_Item as a DropdownMultiValueUiBlock
func (t AppCanvasUiBlockList_Blocks_Item) AsDropdownMultiValueUiBlock() (DropdownMultiValueUiBlock, error) {
	var body DropdownMultiValueUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownMultiValueUiBlock overwrites any union data inside the AppCanvasUiBlockList_Blocks_Item as the provided DropdownMultiValueUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) FromDropdownMultiValueUiBlock(v DropdownMultiValueUiBlock) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownMultiValueUiBlock performs a merge with any union data inside the AppCanvasUiBlockList_Blocks_Item, using the provided DropdownMultiValueUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) MergeDropdownMultiValueUiBlock(v DropdownMultiValueUiBlock) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMarkdownUiBlock returns the union data inside the AppCanvasUiBlockList_Blocks_Item as a MarkdownUiBlock
func (t AppCanvasUiBlockList_Blocks_Item) AsMarkdownUiBlock() (MarkdownUiBlock, error) {
	var body MarkdownUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMarkdownUiBlock overwrites any union data inside the AppCanvasUiBlockList_Blocks_Item as the provided MarkdownUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) FromMarkdownUiBlock(v MarkdownUiBlock) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMarkdownUiBlock performs a merge with any union data inside the AppCanvasUiBlockList_Blocks_Item, using the provided MarkdownUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) MergeMarkdownUiBlock(v MarkdownUiBlock) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputUiBlock returns the union data inside the AppCanvasUiBlockList_Blocks_Item as a SearchInputUiBlock
func (t AppCanvasUiBlockList_Blocks_Item) AsSearchInputUiBlock() (SearchInputUiBlock, error) {
	var body SearchInputUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputUiBlock overwrites any union data inside the AppCanvasUiBlockList_Blocks_Item as the provided SearchInputUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) FromSearchInputUiBlock(v SearchInputUiBlock) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputUiBlock performs a merge with any union data inside the AppCanvasUiBlockList_Blocks_Item, using the provided SearchInputUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) MergeSearchInputUiBlock(v SearchInputUiBlock) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputMultiValueUiBlock returns the union data inside the AppCanvasUiBlockList_Blocks_Item as a SearchInputMultiValueUiBlock
func (t AppCanvasUiBlockList_Blocks_Item) AsSearchInputMultiValueUiBlock() (SearchInputMultiValueUiBlock, error) {
	var body SearchInputMultiValueUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputMultiValueUiBlock overwrites any union data inside the AppCanvasUiBlockList_Blocks_Item as the provided SearchInputMultiValueUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) FromSearchInputMultiValueUiBlock(v SearchInputMultiValueUiBlock) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputMultiValueUiBlock performs a merge with any union data inside the AppCanvasUiBlockList_Blocks_Item, using the provided SearchInputMultiValueUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) MergeSearchInputMultiValueUiBlock(v SearchInputMultiValueUiBlock) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSectionUiBlock returns the union data inside the AppCanvasUiBlockList_Blocks_Item as a SectionUiBlock
func (t AppCanvasUiBlockList_Blocks_Item) AsSectionUiBlock() (SectionUiBlock, error) {
	var body SectionUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSectionUiBlock overwrites any union data inside the AppCanvasUiBlockList_Blocks_Item as the provided SectionUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) FromSectionUiBlock(v SectionUiBlock) error {
	t.Type = "SECTION"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSectionUiBlock performs a merge with any union data inside the AppCanvasUiBlockList_Blocks_Item, using the provided SectionUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) MergeSectionUiBlock(v SectionUiBlock) error {
	t.Type = "SECTION"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputUiBlock returns the union data inside the AppCanvasUiBlockList_Blocks_Item as a SelectorInputUiBlock
func (t AppCanvasUiBlockList_Blocks_Item) AsSelectorInputUiBlock() (SelectorInputUiBlock, error) {
	var body SelectorInputUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputUiBlock overwrites any union data inside the AppCanvasUiBlockList_Blocks_Item as the provided SelectorInputUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) FromSelectorInputUiBlock(v SelectorInputUiBlock) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputUiBlock performs a merge with any union data inside the AppCanvasUiBlockList_Blocks_Item, using the provided SelectorInputUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) MergeSelectorInputUiBlock(v SelectorInputUiBlock) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputMultiValueUiBlock returns the union data inside the AppCanvasUiBlockList_Blocks_Item as a SelectorInputMultiValueUiBlock
func (t AppCanvasUiBlockList_Blocks_Item) AsSelectorInputMultiValueUiBlock() (SelectorInputMultiValueUiBlock, error) {
	var body SelectorInputMultiValueUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputMultiValueUiBlock overwrites any union data inside the AppCanvasUiBlockList_Blocks_Item as the provided SelectorInputMultiValueUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) FromSelectorInputMultiValueUiBlock(v SelectorInputMultiValueUiBlock) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputMultiValueUiBlock performs a merge with any union data inside the AppCanvasUiBlockList_Blocks_Item, using the provided SelectorInputMultiValueUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) MergeSelectorInputMultiValueUiBlock(v SelectorInputMultiValueUiBlock) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTextInputUiBlock returns the union data inside the AppCanvasUiBlockList_Blocks_Item as a TextInputUiBlock
func (t AppCanvasUiBlockList_Blocks_Item) AsTextInputUiBlock() (TextInputUiBlock, error) {
	var body TextInputUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextInputUiBlock overwrites any union data inside the AppCanvasUiBlockList_Blocks_Item as the provided TextInputUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) FromTextInputUiBlock(v TextInputUiBlock) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextInputUiBlock performs a merge with any union data inside the AppCanvasUiBlockList_Blocks_Item, using the provided TextInputUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) MergeTextInputUiBlock(v TextInputUiBlock) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTableUiBlock returns the union data inside the AppCanvasUiBlockList_Blocks_Item as a TableUiBlock
func (t AppCanvasUiBlockList_Blocks_Item) AsTableUiBlock() (TableUiBlock, error) {
	var body TableUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTableUiBlock overwrites any union data inside the AppCanvasUiBlockList_Blocks_Item as the provided TableUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) FromTableUiBlock(v TableUiBlock) error {
	t.Type = "TABLE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTableUiBlock performs a merge with any union data inside the AppCanvasUiBlockList_Blocks_Item, using the provided TableUiBlock
func (t *AppCanvasUiBlockList_Blocks_Item) MergeTableUiBlock(v TableUiBlock) error {
	t.Type = "TABLE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AppCanvasUiBlockList_Blocks_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AppCanvasUiBlockList_Blocks_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BUTTON":
		return t.AsButtonUiBlock()
	case "CHIP":
		return t.AsChipUiBlock()
	case "DROPDOWN":
		return t.AsDropdownUiBlock()
	case "DROPDOWN_MULTIVALUE":
		return t.AsDropdownMultiValueUiBlock()
	case "MARKDOWN":
		return t.AsMarkdownUiBlock()
	case "SEARCH_INPUT":
		return t.AsSearchInputUiBlock()
	case "SEARCH_INPUT_MULTIVALUE":
		return t.AsSearchInputMultiValueUiBlock()
	case "SECTION":
		return t.AsSectionUiBlock()
	case "SELECTOR_INPUT":
		return t.AsSelectorInputUiBlock()
	case "SELECTOR_INPUT_MULTIVALUE":
		return t.AsSelectorInputMultiValueUiBlock()
	case "TABLE":
		return t.AsTableUiBlock()
	case "TEXT_INPUT":
		return t.AsTextInputUiBlock()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AppCanvasUiBlockList_Blocks_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AppCanvasUiBlockList_Blocks_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsButtonUiBlockUpdate returns the union data inside the AppCanvasUpdateBase_Blocks_Item as a ButtonUiBlockUpdate
func (t AppCanvasUpdateBase_Blocks_Item) AsButtonUiBlockUpdate() (ButtonUiBlockUpdate, error) {
	var body ButtonUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromButtonUiBlockUpdate overwrites any union data inside the AppCanvasUpdateBase_Blocks_Item as the provided ButtonUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) FromButtonUiBlockUpdate(v ButtonUiBlockUpdate) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeButtonUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateBase_Blocks_Item, using the provided ButtonUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) MergeButtonUiBlockUpdate(v ButtonUiBlockUpdate) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsChipUiBlockUpdate returns the union data inside the AppCanvasUpdateBase_Blocks_Item as a ChipUiBlockUpdate
func (t AppCanvasUpdateBase_Blocks_Item) AsChipUiBlockUpdate() (ChipUiBlockUpdate, error) {
	var body ChipUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChipUiBlockUpdate overwrites any union data inside the AppCanvasUpdateBase_Blocks_Item as the provided ChipUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) FromChipUiBlockUpdate(v ChipUiBlockUpdate) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChipUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateBase_Blocks_Item, using the provided ChipUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) MergeChipUiBlockUpdate(v ChipUiBlockUpdate) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownUiBlockUpdate returns the union data inside the AppCanvasUpdateBase_Blocks_Item as a DropdownUiBlockUpdate
func (t AppCanvasUpdateBase_Blocks_Item) AsDropdownUiBlockUpdate() (DropdownUiBlockUpdate, error) {
	var body DropdownUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownUiBlockUpdate overwrites any union data inside the AppCanvasUpdateBase_Blocks_Item as the provided DropdownUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) FromDropdownUiBlockUpdate(v DropdownUiBlockUpdate) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateBase_Blocks_Item, using the provided DropdownUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) MergeDropdownUiBlockUpdate(v DropdownUiBlockUpdate) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownMultiValueUiBlockUpdate returns the union data inside the AppCanvasUpdateBase_Blocks_Item as a DropdownMultiValueUiBlockUpdate
func (t AppCanvasUpdateBase_Blocks_Item) AsDropdownMultiValueUiBlockUpdate() (DropdownMultiValueUiBlockUpdate, error) {
	var body DropdownMultiValueUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownMultiValueUiBlockUpdate overwrites any union data inside the AppCanvasUpdateBase_Blocks_Item as the provided DropdownMultiValueUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) FromDropdownMultiValueUiBlockUpdate(v DropdownMultiValueUiBlockUpdate) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownMultiValueUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateBase_Blocks_Item, using the provided DropdownMultiValueUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) MergeDropdownMultiValueUiBlockUpdate(v DropdownMultiValueUiBlockUpdate) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMarkdownUiBlockUpdate returns the union data inside the AppCanvasUpdateBase_Blocks_Item as a MarkdownUiBlockUpdate
func (t AppCanvasUpdateBase_Blocks_Item) AsMarkdownUiBlockUpdate() (MarkdownUiBlockUpdate, error) {
	var body MarkdownUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMarkdownUiBlockUpdate overwrites any union data inside the AppCanvasUpdateBase_Blocks_Item as the provided MarkdownUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) FromMarkdownUiBlockUpdate(v MarkdownUiBlockUpdate) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMarkdownUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateBase_Blocks_Item, using the provided MarkdownUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) MergeMarkdownUiBlockUpdate(v MarkdownUiBlockUpdate) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputUiBlockUpdate returns the union data inside the AppCanvasUpdateBase_Blocks_Item as a SearchInputUiBlockUpdate
func (t AppCanvasUpdateBase_Blocks_Item) AsSearchInputUiBlockUpdate() (SearchInputUiBlockUpdate, error) {
	var body SearchInputUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputUiBlockUpdate overwrites any union data inside the AppCanvasUpdateBase_Blocks_Item as the provided SearchInputUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) FromSearchInputUiBlockUpdate(v SearchInputUiBlockUpdate) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateBase_Blocks_Item, using the provided SearchInputUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) MergeSearchInputUiBlockUpdate(v SearchInputUiBlockUpdate) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputMultiValueUiBlockUpdate returns the union data inside the AppCanvasUpdateBase_Blocks_Item as a SearchInputMultiValueUiBlockUpdate
func (t AppCanvasUpdateBase_Blocks_Item) AsSearchInputMultiValueUiBlockUpdate() (SearchInputMultiValueUiBlockUpdate, error) {
	var body SearchInputMultiValueUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputMultiValueUiBlockUpdate overwrites any union data inside the AppCanvasUpdateBase_Blocks_Item as the provided SearchInputMultiValueUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) FromSearchInputMultiValueUiBlockUpdate(v SearchInputMultiValueUiBlockUpdate) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputMultiValueUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateBase_Blocks_Item, using the provided SearchInputMultiValueUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) MergeSearchInputMultiValueUiBlockUpdate(v SearchInputMultiValueUiBlockUpdate) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSectionUiBlockUpdate returns the union data inside the AppCanvasUpdateBase_Blocks_Item as a SectionUiBlockUpdate
func (t AppCanvasUpdateBase_Blocks_Item) AsSectionUiBlockUpdate() (SectionUiBlockUpdate, error) {
	var body SectionUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSectionUiBlockUpdate overwrites any union data inside the AppCanvasUpdateBase_Blocks_Item as the provided SectionUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) FromSectionUiBlockUpdate(v SectionUiBlockUpdate) error {
	t.Type = "SECTION"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSectionUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateBase_Blocks_Item, using the provided SectionUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) MergeSectionUiBlockUpdate(v SectionUiBlockUpdate) error {
	t.Type = "SECTION"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputUiBlockUpdate returns the union data inside the AppCanvasUpdateBase_Blocks_Item as a SelectorInputUiBlockUpdate
func (t AppCanvasUpdateBase_Blocks_Item) AsSelectorInputUiBlockUpdate() (SelectorInputUiBlockUpdate, error) {
	var body SelectorInputUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputUiBlockUpdate overwrites any union data inside the AppCanvasUpdateBase_Blocks_Item as the provided SelectorInputUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) FromSelectorInputUiBlockUpdate(v SelectorInputUiBlockUpdate) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateBase_Blocks_Item, using the provided SelectorInputUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) MergeSelectorInputUiBlockUpdate(v SelectorInputUiBlockUpdate) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputMultiValueUiBlockUpdate returns the union data inside the AppCanvasUpdateBase_Blocks_Item as a SelectorInputMultiValueUiBlockUpdate
func (t AppCanvasUpdateBase_Blocks_Item) AsSelectorInputMultiValueUiBlockUpdate() (SelectorInputMultiValueUiBlockUpdate, error) {
	var body SelectorInputMultiValueUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputMultiValueUiBlockUpdate overwrites any union data inside the AppCanvasUpdateBase_Blocks_Item as the provided SelectorInputMultiValueUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) FromSelectorInputMultiValueUiBlockUpdate(v SelectorInputMultiValueUiBlockUpdate) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputMultiValueUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateBase_Blocks_Item, using the provided SelectorInputMultiValueUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) MergeSelectorInputMultiValueUiBlockUpdate(v SelectorInputMultiValueUiBlockUpdate) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTextInputUiBlockUpdate returns the union data inside the AppCanvasUpdateBase_Blocks_Item as a TextInputUiBlockUpdate
func (t AppCanvasUpdateBase_Blocks_Item) AsTextInputUiBlockUpdate() (TextInputUiBlockUpdate, error) {
	var body TextInputUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextInputUiBlockUpdate overwrites any union data inside the AppCanvasUpdateBase_Blocks_Item as the provided TextInputUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) FromTextInputUiBlockUpdate(v TextInputUiBlockUpdate) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextInputUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateBase_Blocks_Item, using the provided TextInputUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) MergeTextInputUiBlockUpdate(v TextInputUiBlockUpdate) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTableUiBlockUpdate returns the union data inside the AppCanvasUpdateBase_Blocks_Item as a TableUiBlockUpdate
func (t AppCanvasUpdateBase_Blocks_Item) AsTableUiBlockUpdate() (TableUiBlockUpdate, error) {
	var body TableUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTableUiBlockUpdate overwrites any union data inside the AppCanvasUpdateBase_Blocks_Item as the provided TableUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) FromTableUiBlockUpdate(v TableUiBlockUpdate) error {
	t.Type = "TABLE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTableUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateBase_Blocks_Item, using the provided TableUiBlockUpdate
func (t *AppCanvasUpdateBase_Blocks_Item) MergeTableUiBlockUpdate(v TableUiBlockUpdate) error {
	t.Type = "TABLE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AppCanvasUpdateBase_Blocks_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AppCanvasUpdateBase_Blocks_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BUTTON":
		return t.AsButtonUiBlockUpdate()
	case "CHIP":
		return t.AsChipUiBlockUpdate()
	case "DROPDOWN":
		return t.AsDropdownUiBlockUpdate()
	case "DROPDOWN_MULTIVALUE":
		return t.AsDropdownMultiValueUiBlockUpdate()
	case "MARKDOWN":
		return t.AsMarkdownUiBlockUpdate()
	case "SEARCH_INPUT":
		return t.AsSearchInputUiBlockUpdate()
	case "SEARCH_INPUT_MULTIVALUE":
		return t.AsSearchInputMultiValueUiBlockUpdate()
	case "SECTION":
		return t.AsSectionUiBlockUpdate()
	case "SELECTOR_INPUT":
		return t.AsSelectorInputUiBlockUpdate()
	case "SELECTOR_INPUT_MULTIVALUE":
		return t.AsSelectorInputMultiValueUiBlockUpdate()
	case "TABLE":
		return t.AsTableUiBlockUpdate()
	case "TEXT_INPUT":
		return t.AsTextInputUiBlockUpdate()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AppCanvasUpdateBase_Blocks_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AppCanvasUpdateBase_Blocks_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsButtonUiBlockUpdate returns the union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as a ButtonUiBlockUpdate
func (t AppCanvasUpdateUiBlockList_Blocks_Item) AsButtonUiBlockUpdate() (ButtonUiBlockUpdate, error) {
	var body ButtonUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromButtonUiBlockUpdate overwrites any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as the provided ButtonUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) FromButtonUiBlockUpdate(v ButtonUiBlockUpdate) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeButtonUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item, using the provided ButtonUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) MergeButtonUiBlockUpdate(v ButtonUiBlockUpdate) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsChipUiBlockUpdate returns the union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as a ChipUiBlockUpdate
func (t AppCanvasUpdateUiBlockList_Blocks_Item) AsChipUiBlockUpdate() (ChipUiBlockUpdate, error) {
	var body ChipUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChipUiBlockUpdate overwrites any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as the provided ChipUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) FromChipUiBlockUpdate(v ChipUiBlockUpdate) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChipUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item, using the provided ChipUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) MergeChipUiBlockUpdate(v ChipUiBlockUpdate) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownUiBlockUpdate returns the union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as a DropdownUiBlockUpdate
func (t AppCanvasUpdateUiBlockList_Blocks_Item) AsDropdownUiBlockUpdate() (DropdownUiBlockUpdate, error) {
	var body DropdownUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownUiBlockUpdate overwrites any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as the provided DropdownUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) FromDropdownUiBlockUpdate(v DropdownUiBlockUpdate) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item, using the provided DropdownUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) MergeDropdownUiBlockUpdate(v DropdownUiBlockUpdate) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownMultiValueUiBlockUpdate returns the union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as a DropdownMultiValueUiBlockUpdate
func (t AppCanvasUpdateUiBlockList_Blocks_Item) AsDropdownMultiValueUiBlockUpdate() (DropdownMultiValueUiBlockUpdate, error) {
	var body DropdownMultiValueUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownMultiValueUiBlockUpdate overwrites any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as the provided DropdownMultiValueUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) FromDropdownMultiValueUiBlockUpdate(v DropdownMultiValueUiBlockUpdate) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownMultiValueUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item, using the provided DropdownMultiValueUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) MergeDropdownMultiValueUiBlockUpdate(v DropdownMultiValueUiBlockUpdate) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMarkdownUiBlockUpdate returns the union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as a MarkdownUiBlockUpdate
func (t AppCanvasUpdateUiBlockList_Blocks_Item) AsMarkdownUiBlockUpdate() (MarkdownUiBlockUpdate, error) {
	var body MarkdownUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMarkdownUiBlockUpdate overwrites any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as the provided MarkdownUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) FromMarkdownUiBlockUpdate(v MarkdownUiBlockUpdate) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMarkdownUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item, using the provided MarkdownUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) MergeMarkdownUiBlockUpdate(v MarkdownUiBlockUpdate) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputUiBlockUpdate returns the union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as a SearchInputUiBlockUpdate
func (t AppCanvasUpdateUiBlockList_Blocks_Item) AsSearchInputUiBlockUpdate() (SearchInputUiBlockUpdate, error) {
	var body SearchInputUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputUiBlockUpdate overwrites any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as the provided SearchInputUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) FromSearchInputUiBlockUpdate(v SearchInputUiBlockUpdate) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item, using the provided SearchInputUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) MergeSearchInputUiBlockUpdate(v SearchInputUiBlockUpdate) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputMultiValueUiBlockUpdate returns the union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as a SearchInputMultiValueUiBlockUpdate
func (t AppCanvasUpdateUiBlockList_Blocks_Item) AsSearchInputMultiValueUiBlockUpdate() (SearchInputMultiValueUiBlockUpdate, error) {
	var body SearchInputMultiValueUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputMultiValueUiBlockUpdate overwrites any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as the provided SearchInputMultiValueUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) FromSearchInputMultiValueUiBlockUpdate(v SearchInputMultiValueUiBlockUpdate) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputMultiValueUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item, using the provided SearchInputMultiValueUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) MergeSearchInputMultiValueUiBlockUpdate(v SearchInputMultiValueUiBlockUpdate) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSectionUiBlockUpdate returns the union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as a SectionUiBlockUpdate
func (t AppCanvasUpdateUiBlockList_Blocks_Item) AsSectionUiBlockUpdate() (SectionUiBlockUpdate, error) {
	var body SectionUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSectionUiBlockUpdate overwrites any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as the provided SectionUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) FromSectionUiBlockUpdate(v SectionUiBlockUpdate) error {
	t.Type = "SECTION"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSectionUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item, using the provided SectionUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) MergeSectionUiBlockUpdate(v SectionUiBlockUpdate) error {
	t.Type = "SECTION"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputUiBlockUpdate returns the union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as a SelectorInputUiBlockUpdate
func (t AppCanvasUpdateUiBlockList_Blocks_Item) AsSelectorInputUiBlockUpdate() (SelectorInputUiBlockUpdate, error) {
	var body SelectorInputUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputUiBlockUpdate overwrites any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as the provided SelectorInputUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) FromSelectorInputUiBlockUpdate(v SelectorInputUiBlockUpdate) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item, using the provided SelectorInputUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) MergeSelectorInputUiBlockUpdate(v SelectorInputUiBlockUpdate) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputMultiValueUiBlockUpdate returns the union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as a SelectorInputMultiValueUiBlockUpdate
func (t AppCanvasUpdateUiBlockList_Blocks_Item) AsSelectorInputMultiValueUiBlockUpdate() (SelectorInputMultiValueUiBlockUpdate, error) {
	var body SelectorInputMultiValueUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputMultiValueUiBlockUpdate overwrites any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as the provided SelectorInputMultiValueUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) FromSelectorInputMultiValueUiBlockUpdate(v SelectorInputMultiValueUiBlockUpdate) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputMultiValueUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item, using the provided SelectorInputMultiValueUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) MergeSelectorInputMultiValueUiBlockUpdate(v SelectorInputMultiValueUiBlockUpdate) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTextInputUiBlockUpdate returns the union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as a TextInputUiBlockUpdate
func (t AppCanvasUpdateUiBlockList_Blocks_Item) AsTextInputUiBlockUpdate() (TextInputUiBlockUpdate, error) {
	var body TextInputUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextInputUiBlockUpdate overwrites any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as the provided TextInputUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) FromTextInputUiBlockUpdate(v TextInputUiBlockUpdate) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextInputUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item, using the provided TextInputUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) MergeTextInputUiBlockUpdate(v TextInputUiBlockUpdate) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTableUiBlockUpdate returns the union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as a TableUiBlockUpdate
func (t AppCanvasUpdateUiBlockList_Blocks_Item) AsTableUiBlockUpdate() (TableUiBlockUpdate, error) {
	var body TableUiBlockUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTableUiBlockUpdate overwrites any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item as the provided TableUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) FromTableUiBlockUpdate(v TableUiBlockUpdate) error {
	t.Type = "TABLE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTableUiBlockUpdate performs a merge with any union data inside the AppCanvasUpdateUiBlockList_Blocks_Item, using the provided TableUiBlockUpdate
func (t *AppCanvasUpdateUiBlockList_Blocks_Item) MergeTableUiBlockUpdate(v TableUiBlockUpdate) error {
	t.Type = "TABLE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AppCanvasUpdateUiBlockList_Blocks_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AppCanvasUpdateUiBlockList_Blocks_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BUTTON":
		return t.AsButtonUiBlockUpdate()
	case "CHIP":
		return t.AsChipUiBlockUpdate()
	case "DROPDOWN":
		return t.AsDropdownUiBlockUpdate()
	case "DROPDOWN_MULTIVALUE":
		return t.AsDropdownMultiValueUiBlockUpdate()
	case "MARKDOWN":
		return t.AsMarkdownUiBlockUpdate()
	case "SEARCH_INPUT":
		return t.AsSearchInputUiBlockUpdate()
	case "SEARCH_INPUT_MULTIVALUE":
		return t.AsSearchInputMultiValueUiBlockUpdate()
	case "SECTION":
		return t.AsSectionUiBlockUpdate()
	case "SELECTOR_INPUT":
		return t.AsSelectorInputUiBlockUpdate()
	case "SELECTOR_INPUT_MULTIVALUE":
		return t.AsSelectorInputMultiValueUiBlockUpdate()
	case "TABLE":
		return t.AsTableUiBlockUpdate()
	case "TEXT_INPUT":
		return t.AsTextInputUiBlockUpdate()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AppCanvasUpdateUiBlockList_Blocks_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AppCanvasUpdateUiBlockList_Blocks_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsArrayElementAppConfigItem returns the union data inside the AppConfigItem as a ArrayElementAppConfigItem
func (t AppConfigItem) AsArrayElementAppConfigItem() (ArrayElementAppConfigItem, error) {
	var body ArrayElementAppConfigItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArrayElementAppConfigItem overwrites any union data inside the AppConfigItem as the provided ArrayElementAppConfigItem
func (t *AppConfigItem) FromArrayElementAppConfigItem(v ArrayElementAppConfigItem) error {
	t.Type = "array_element"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArrayElementAppConfigItem performs a merge with any union data inside the AppConfigItem, using the provided ArrayElementAppConfigItem
func (t *AppConfigItem) MergeArrayElementAppConfigItem(v ArrayElementAppConfigItem) error {
	t.Type = "array_element"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDateAppConfigItem returns the union data inside the AppConfigItem as a DateAppConfigItem
func (t AppConfigItem) AsDateAppConfigItem() (DateAppConfigItem, error) {
	var body DateAppConfigItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDateAppConfigItem overwrites any union data inside the AppConfigItem as the provided DateAppConfigItem
func (t *AppConfigItem) FromDateAppConfigItem(v DateAppConfigItem) error {
	t.Type = "date"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDateAppConfigItem performs a merge with any union data inside the AppConfigItem, using the provided DateAppConfigItem
func (t *AppConfigItem) MergeDateAppConfigItem(v DateAppConfigItem) error {
	t.Type = "date"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDatetimeAppConfigItem returns the union data inside the AppConfigItem as a DatetimeAppConfigItem
func (t AppConfigItem) AsDatetimeAppConfigItem() (DatetimeAppConfigItem, error) {
	var body DatetimeAppConfigItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDatetimeAppConfigItem overwrites any union data inside the AppConfigItem as the provided DatetimeAppConfigItem
func (t *AppConfigItem) FromDatetimeAppConfigItem(v DatetimeAppConfigItem) error {
	t.Type = "datetime"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDatetimeAppConfigItem performs a merge with any union data inside the AppConfigItem, using the provided DatetimeAppConfigItem
func (t *AppConfigItem) MergeDatetimeAppConfigItem(v DatetimeAppConfigItem) error {
	t.Type = "datetime"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsJsonAppConfigItem returns the union data inside the AppConfigItem as a JsonAppConfigItem
func (t AppConfigItem) AsJsonAppConfigItem() (JsonAppConfigItem, error) {
	var body JsonAppConfigItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJsonAppConfigItem overwrites any union data inside the AppConfigItem as the provided JsonAppConfigItem
func (t *AppConfigItem) FromJsonAppConfigItem(v JsonAppConfigItem) error {
	t.Type = "json"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJsonAppConfigItem performs a merge with any union data inside the AppConfigItem, using the provided JsonAppConfigItem
func (t *AppConfigItem) MergeJsonAppConfigItem(v JsonAppConfigItem) error {
	t.Type = "json"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntitySchemaAppConfigItem returns the union data inside the AppConfigItem as a EntitySchemaAppConfigItem
func (t AppConfigItem) AsEntitySchemaAppConfigItem() (EntitySchemaAppConfigItem, error) {
	var body EntitySchemaAppConfigItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntitySchemaAppConfigItem overwrites any union data inside the AppConfigItem as the provided EntitySchemaAppConfigItem
func (t *AppConfigItem) FromEntitySchemaAppConfigItem(v EntitySchemaAppConfigItem) error {
	t.Type = "entity_schema"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntitySchemaAppConfigItem performs a merge with any union data inside the AppConfigItem, using the provided EntitySchemaAppConfigItem
func (t *AppConfigItem) MergeEntitySchemaAppConfigItem(v EntitySchemaAppConfigItem) error {
	t.Type = "entity_schema"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldAppConfigItem returns the union data inside the AppConfigItem as a FieldAppConfigItem
func (t AppConfigItem) AsFieldAppConfigItem() (FieldAppConfigItem, error) {
	var body FieldAppConfigItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldAppConfigItem overwrites any union data inside the AppConfigItem as the provided FieldAppConfigItem
func (t *AppConfigItem) FromFieldAppConfigItem(v FieldAppConfigItem) error {
	t.Type = "field"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldAppConfigItem performs a merge with any union data inside the AppConfigItem, using the provided FieldAppConfigItem
func (t *AppConfigItem) MergeFieldAppConfigItem(v FieldAppConfigItem) error {
	t.Type = "field"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsBooleanAppConfigItem returns the union data inside the AppConfigItem as a BooleanAppConfigItem
func (t AppConfigItem) AsBooleanAppConfigItem() (BooleanAppConfigItem, error) {
	var body BooleanAppConfigItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBooleanAppConfigItem overwrites any union data inside the AppConfigItem as the provided BooleanAppConfigItem
func (t *AppConfigItem) FromBooleanAppConfigItem(v BooleanAppConfigItem) error {
	t.Type = "boolean"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBooleanAppConfigItem performs a merge with any union data inside the AppConfigItem, using the provided BooleanAppConfigItem
func (t *AppConfigItem) MergeBooleanAppConfigItem(v BooleanAppConfigItem) error {
	t.Type = "boolean"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerAppConfigItem returns the union data inside the AppConfigItem as a IntegerAppConfigItem
func (t AppConfigItem) AsIntegerAppConfigItem() (IntegerAppConfigItem, error) {
	var body IntegerAppConfigItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerAppConfigItem overwrites any union data inside the AppConfigItem as the provided IntegerAppConfigItem
func (t *AppConfigItem) FromIntegerAppConfigItem(v IntegerAppConfigItem) error {
	t.Type = "integer"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerAppConfigItem performs a merge with any union data inside the AppConfigItem, using the provided IntegerAppConfigItem
func (t *AppConfigItem) MergeIntegerAppConfigItem(v IntegerAppConfigItem) error {
	t.Type = "integer"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatAppConfigItem returns the union data inside the AppConfigItem as a FloatAppConfigItem
func (t AppConfigItem) AsFloatAppConfigItem() (FloatAppConfigItem, error) {
	var body FloatAppConfigItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatAppConfigItem overwrites any union data inside the AppConfigItem as the provided FloatAppConfigItem
func (t *AppConfigItem) FromFloatAppConfigItem(v FloatAppConfigItem) error {
	t.Type = "float"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatAppConfigItem performs a merge with any union data inside the AppConfigItem, using the provided FloatAppConfigItem
func (t *AppConfigItem) MergeFloatAppConfigItem(v FloatAppConfigItem) error {
	t.Type = "float"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTextAppConfigItem returns the union data inside the AppConfigItem as a TextAppConfigItem
func (t AppConfigItem) AsTextAppConfigItem() (TextAppConfigItem, error) {
	var body TextAppConfigItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextAppConfigItem overwrites any union data inside the AppConfigItem as the provided TextAppConfigItem
func (t *AppConfigItem) FromTextAppConfigItem(v TextAppConfigItem) error {
	t.Type = "text"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextAppConfigItem performs a merge with any union data inside the AppConfigItem, using the provided TextAppConfigItem
func (t *AppConfigItem) MergeTextAppConfigItem(v TextAppConfigItem) error {
	t.Type = "text"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsGenericApiIdentifiedAppConfigItem returns the union data inside the AppConfigItem as a GenericApiIdentifiedAppConfigItem
func (t AppConfigItem) AsGenericApiIdentifiedAppConfigItem() (GenericApiIdentifiedAppConfigItem, error) {
	var body GenericApiIdentifiedAppConfigItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGenericApiIdentifiedAppConfigItem overwrites any union data inside the AppConfigItem as the provided GenericApiIdentifiedAppConfigItem
func (t *AppConfigItem) FromGenericApiIdentifiedAppConfigItem(v GenericApiIdentifiedAppConfigItem) error {
	t.Type = "molecule"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGenericApiIdentifiedAppConfigItem performs a merge with any union data inside the AppConfigItem, using the provided GenericApiIdentifiedAppConfigItem
func (t *AppConfigItem) MergeGenericApiIdentifiedAppConfigItem(v GenericApiIdentifiedAppConfigItem) error {
	t.Type = "molecule"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecureTextAppConfigItem returns the union data inside the AppConfigItem as a SecureTextAppConfigItem
func (t AppConfigItem) AsSecureTextAppConfigItem() (SecureTextAppConfigItem, error) {
	var body SecureTextAppConfigItem
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecureTextAppConfigItem overwrites any union data inside the AppConfigItem as the provided SecureTextAppConfigItem
func (t *AppConfigItem) FromSecureTextAppConfigItem(v SecureTextAppConfigItem) error {
	t.Type = "secure_text"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecureTextAppConfigItem performs a merge with any union data inside the AppConfigItem, using the provided SecureTextAppConfigItem
func (t *AppConfigItem) MergeSecureTextAppConfigItem(v SecureTextAppConfigItem) error {
	t.Type = "secure_text"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AppConfigItem) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AppConfigItem) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "array_element":
		return t.AsArrayElementAppConfigItem()
	case "boolean":
		return t.AsBooleanAppConfigItem()
	case "date":
		return t.AsDateAppConfigItem()
	case "datetime":
		return t.AsDatetimeAppConfigItem()
	case "entity_schema":
		return t.AsEntitySchemaAppConfigItem()
	case "field":
		return t.AsFieldAppConfigItem()
	case "float":
		return t.AsFloatAppConfigItem()
	case "integer":
		return t.AsIntegerAppConfigItem()
	case "json":
		return t.AsJsonAppConfigItem()
	case "molecule":
		return t.AsGenericApiIdentifiedAppConfigItem()
	case "secure_text":
		return t.AsSecureTextAppConfigItem()
	case "text":
		return t.AsTextAppConfigItem()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AppConfigItem) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AppConfigItem) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsAppConfigItemGenericBulkUpdate returns the union data inside the AppConfigItemBulkUpdate as a AppConfigItemGenericBulkUpdate
func (t AppConfigItemBulkUpdate) AsAppConfigItemGenericBulkUpdate() (AppConfigItemGenericBulkUpdate, error) {
	var body AppConfigItemGenericBulkUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemGenericBulkUpdate overwrites any union data inside the AppConfigItemBulkUpdate as the provided AppConfigItemGenericBulkUpdate
func (t *AppConfigItemBulkUpdate) FromAppConfigItemGenericBulkUpdate(v AppConfigItemGenericBulkUpdate) error {
	t.Type = "box"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemGenericBulkUpdate performs a merge with any union data inside the AppConfigItemBulkUpdate, using the provided AppConfigItemGenericBulkUpdate
func (t *AppConfigItemBulkUpdate) MergeAppConfigItemGenericBulkUpdate(v AppConfigItemGenericBulkUpdate) error {
	t.Type = "box"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemBooleanBulkUpdate returns the union data inside the AppConfigItemBulkUpdate as a AppConfigItemBooleanBulkUpdate
func (t AppConfigItemBulkUpdate) AsAppConfigItemBooleanBulkUpdate() (AppConfigItemBooleanBulkUpdate, error) {
	var body AppConfigItemBooleanBulkUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemBooleanBulkUpdate overwrites any union data inside the AppConfigItemBulkUpdate as the provided AppConfigItemBooleanBulkUpdate
func (t *AppConfigItemBulkUpdate) FromAppConfigItemBooleanBulkUpdate(v AppConfigItemBooleanBulkUpdate) error {
	t.Type = "boolean"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemBooleanBulkUpdate performs a merge with any union data inside the AppConfigItemBulkUpdate, using the provided AppConfigItemBooleanBulkUpdate
func (t *AppConfigItemBulkUpdate) MergeAppConfigItemBooleanBulkUpdate(v AppConfigItemBooleanBulkUpdate) error {
	t.Type = "boolean"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemIntegerBulkUpdate returns the union data inside the AppConfigItemBulkUpdate as a AppConfigItemIntegerBulkUpdate
func (t AppConfigItemBulkUpdate) AsAppConfigItemIntegerBulkUpdate() (AppConfigItemIntegerBulkUpdate, error) {
	var body AppConfigItemIntegerBulkUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemIntegerBulkUpdate overwrites any union data inside the AppConfigItemBulkUpdate as the provided AppConfigItemIntegerBulkUpdate
func (t *AppConfigItemBulkUpdate) FromAppConfigItemIntegerBulkUpdate(v AppConfigItemIntegerBulkUpdate) error {
	t.Type = "integer"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemIntegerBulkUpdate performs a merge with any union data inside the AppConfigItemBulkUpdate, using the provided AppConfigItemIntegerBulkUpdate
func (t *AppConfigItemBulkUpdate) MergeAppConfigItemIntegerBulkUpdate(v AppConfigItemIntegerBulkUpdate) error {
	t.Type = "integer"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemFloatBulkUpdate returns the union data inside the AppConfigItemBulkUpdate as a AppConfigItemFloatBulkUpdate
func (t AppConfigItemBulkUpdate) AsAppConfigItemFloatBulkUpdate() (AppConfigItemFloatBulkUpdate, error) {
	var body AppConfigItemFloatBulkUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemFloatBulkUpdate overwrites any union data inside the AppConfigItemBulkUpdate as the provided AppConfigItemFloatBulkUpdate
func (t *AppConfigItemBulkUpdate) FromAppConfigItemFloatBulkUpdate(v AppConfigItemFloatBulkUpdate) error {
	t.Type = "float"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemFloatBulkUpdate performs a merge with any union data inside the AppConfigItemBulkUpdate, using the provided AppConfigItemFloatBulkUpdate
func (t *AppConfigItemBulkUpdate) MergeAppConfigItemFloatBulkUpdate(v AppConfigItemFloatBulkUpdate) error {
	t.Type = "float"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemDateBulkUpdate returns the union data inside the AppConfigItemBulkUpdate as a AppConfigItemDateBulkUpdate
func (t AppConfigItemBulkUpdate) AsAppConfigItemDateBulkUpdate() (AppConfigItemDateBulkUpdate, error) {
	var body AppConfigItemDateBulkUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemDateBulkUpdate overwrites any union data inside the AppConfigItemBulkUpdate as the provided AppConfigItemDateBulkUpdate
func (t *AppConfigItemBulkUpdate) FromAppConfigItemDateBulkUpdate(v AppConfigItemDateBulkUpdate) error {
	t.Type = "date"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemDateBulkUpdate performs a merge with any union data inside the AppConfigItemBulkUpdate, using the provided AppConfigItemDateBulkUpdate
func (t *AppConfigItemBulkUpdate) MergeAppConfigItemDateBulkUpdate(v AppConfigItemDateBulkUpdate) error {
	t.Type = "date"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemDatetimeBulkUpdate returns the union data inside the AppConfigItemBulkUpdate as a AppConfigItemDatetimeBulkUpdate
func (t AppConfigItemBulkUpdate) AsAppConfigItemDatetimeBulkUpdate() (AppConfigItemDatetimeBulkUpdate, error) {
	var body AppConfigItemDatetimeBulkUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemDatetimeBulkUpdate overwrites any union data inside the AppConfigItemBulkUpdate as the provided AppConfigItemDatetimeBulkUpdate
func (t *AppConfigItemBulkUpdate) FromAppConfigItemDatetimeBulkUpdate(v AppConfigItemDatetimeBulkUpdate) error {
	t.Type = "datetime"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemDatetimeBulkUpdate performs a merge with any union data inside the AppConfigItemBulkUpdate, using the provided AppConfigItemDatetimeBulkUpdate
func (t *AppConfigItemBulkUpdate) MergeAppConfigItemDatetimeBulkUpdate(v AppConfigItemDatetimeBulkUpdate) error {
	t.Type = "datetime"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemJsonBulkUpdate returns the union data inside the AppConfigItemBulkUpdate as a AppConfigItemJsonBulkUpdate
func (t AppConfigItemBulkUpdate) AsAppConfigItemJsonBulkUpdate() (AppConfigItemJsonBulkUpdate, error) {
	var body AppConfigItemJsonBulkUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemJsonBulkUpdate overwrites any union data inside the AppConfigItemBulkUpdate as the provided AppConfigItemJsonBulkUpdate
func (t *AppConfigItemBulkUpdate) FromAppConfigItemJsonBulkUpdate(v AppConfigItemJsonBulkUpdate) error {
	t.Type = "json"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemJsonBulkUpdate performs a merge with any union data inside the AppConfigItemBulkUpdate, using the provided AppConfigItemJsonBulkUpdate
func (t *AppConfigItemBulkUpdate) MergeAppConfigItemJsonBulkUpdate(v AppConfigItemJsonBulkUpdate) error {
	t.Type = "json"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AppConfigItemBulkUpdate) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AppConfigItemBulkUpdate) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "boolean":
		return t.AsAppConfigItemBooleanBulkUpdate()
	case "box":
		return t.AsAppConfigItemGenericBulkUpdate()
	case "date":
		return t.AsAppConfigItemDateBulkUpdate()
	case "datetime":
		return t.AsAppConfigItemDatetimeBulkUpdate()
	case "float":
		return t.AsAppConfigItemFloatBulkUpdate()
	case "integer":
		return t.AsAppConfigItemIntegerBulkUpdate()
	case "json":
		return t.AsAppConfigItemJsonBulkUpdate()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AppConfigItemBulkUpdate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AppConfigItemBulkUpdate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsAppConfigItemGenericCreate returns the union data inside the AppConfigItemCreate as a AppConfigItemGenericCreate
func (t AppConfigItemCreate) AsAppConfigItemGenericCreate() (AppConfigItemGenericCreate, error) {
	var body AppConfigItemGenericCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemGenericCreate overwrites any union data inside the AppConfigItemCreate as the provided AppConfigItemGenericCreate
func (t *AppConfigItemCreate) FromAppConfigItemGenericCreate(v AppConfigItemGenericCreate) error {
	t.Type = "dropdown"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemGenericCreate performs a merge with any union data inside the AppConfigItemCreate, using the provided AppConfigItemGenericCreate
func (t *AppConfigItemCreate) MergeAppConfigItemGenericCreate(v AppConfigItemGenericCreate) error {
	t.Type = "dropdown"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemBooleanCreate returns the union data inside the AppConfigItemCreate as a AppConfigItemBooleanCreate
func (t AppConfigItemCreate) AsAppConfigItemBooleanCreate() (AppConfigItemBooleanCreate, error) {
	var body AppConfigItemBooleanCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemBooleanCreate overwrites any union data inside the AppConfigItemCreate as the provided AppConfigItemBooleanCreate
func (t *AppConfigItemCreate) FromAppConfigItemBooleanCreate(v AppConfigItemBooleanCreate) error {
	t.Type = "boolean"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemBooleanCreate performs a merge with any union data inside the AppConfigItemCreate, using the provided AppConfigItemBooleanCreate
func (t *AppConfigItemCreate) MergeAppConfigItemBooleanCreate(v AppConfigItemBooleanCreate) error {
	t.Type = "boolean"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemIntegerCreate returns the union data inside the AppConfigItemCreate as a AppConfigItemIntegerCreate
func (t AppConfigItemCreate) AsAppConfigItemIntegerCreate() (AppConfigItemIntegerCreate, error) {
	var body AppConfigItemIntegerCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemIntegerCreate overwrites any union data inside the AppConfigItemCreate as the provided AppConfigItemIntegerCreate
func (t *AppConfigItemCreate) FromAppConfigItemIntegerCreate(v AppConfigItemIntegerCreate) error {
	t.Type = "integer"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemIntegerCreate performs a merge with any union data inside the AppConfigItemCreate, using the provided AppConfigItemIntegerCreate
func (t *AppConfigItemCreate) MergeAppConfigItemIntegerCreate(v AppConfigItemIntegerCreate) error {
	t.Type = "integer"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemFloatCreate returns the union data inside the AppConfigItemCreate as a AppConfigItemFloatCreate
func (t AppConfigItemCreate) AsAppConfigItemFloatCreate() (AppConfigItemFloatCreate, error) {
	var body AppConfigItemFloatCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemFloatCreate overwrites any union data inside the AppConfigItemCreate as the provided AppConfigItemFloatCreate
func (t *AppConfigItemCreate) FromAppConfigItemFloatCreate(v AppConfigItemFloatCreate) error {
	t.Type = "float"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemFloatCreate performs a merge with any union data inside the AppConfigItemCreate, using the provided AppConfigItemFloatCreate
func (t *AppConfigItemCreate) MergeAppConfigItemFloatCreate(v AppConfigItemFloatCreate) error {
	t.Type = "float"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemDateCreate returns the union data inside the AppConfigItemCreate as a AppConfigItemDateCreate
func (t AppConfigItemCreate) AsAppConfigItemDateCreate() (AppConfigItemDateCreate, error) {
	var body AppConfigItemDateCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemDateCreate overwrites any union data inside the AppConfigItemCreate as the provided AppConfigItemDateCreate
func (t *AppConfigItemCreate) FromAppConfigItemDateCreate(v AppConfigItemDateCreate) error {
	t.Type = "date"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemDateCreate performs a merge with any union data inside the AppConfigItemCreate, using the provided AppConfigItemDateCreate
func (t *AppConfigItemCreate) MergeAppConfigItemDateCreate(v AppConfigItemDateCreate) error {
	t.Type = "date"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemDatetimeCreate returns the union data inside the AppConfigItemCreate as a AppConfigItemDatetimeCreate
func (t AppConfigItemCreate) AsAppConfigItemDatetimeCreate() (AppConfigItemDatetimeCreate, error) {
	var body AppConfigItemDatetimeCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemDatetimeCreate overwrites any union data inside the AppConfigItemCreate as the provided AppConfigItemDatetimeCreate
func (t *AppConfigItemCreate) FromAppConfigItemDatetimeCreate(v AppConfigItemDatetimeCreate) error {
	t.Type = "datetime"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemDatetimeCreate performs a merge with any union data inside the AppConfigItemCreate, using the provided AppConfigItemDatetimeCreate
func (t *AppConfigItemCreate) MergeAppConfigItemDatetimeCreate(v AppConfigItemDatetimeCreate) error {
	t.Type = "datetime"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemJsonCreate returns the union data inside the AppConfigItemCreate as a AppConfigItemJsonCreate
func (t AppConfigItemCreate) AsAppConfigItemJsonCreate() (AppConfigItemJsonCreate, error) {
	var body AppConfigItemJsonCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemJsonCreate overwrites any union data inside the AppConfigItemCreate as the provided AppConfigItemJsonCreate
func (t *AppConfigItemCreate) FromAppConfigItemJsonCreate(v AppConfigItemJsonCreate) error {
	t.Type = "json"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemJsonCreate performs a merge with any union data inside the AppConfigItemCreate, using the provided AppConfigItemJsonCreate
func (t *AppConfigItemCreate) MergeAppConfigItemJsonCreate(v AppConfigItemJsonCreate) error {
	t.Type = "json"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AppConfigItemCreate) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AppConfigItemCreate) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "boolean":
		return t.AsAppConfigItemBooleanCreate()
	case "date":
		return t.AsAppConfigItemDateCreate()
	case "datetime":
		return t.AsAppConfigItemDatetimeCreate()
	case "dropdown":
		return t.AsAppConfigItemGenericCreate()
	case "float":
		return t.AsAppConfigItemFloatCreate()
	case "integer":
		return t.AsAppConfigItemIntegerCreate()
	case "json":
		return t.AsAppConfigItemJsonCreate()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AppConfigItemCreate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AppConfigItemCreate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsAppConfigItemGenericUpdate returns the union data inside the AppConfigItemUpdate as a AppConfigItemGenericUpdate
func (t AppConfigItemUpdate) AsAppConfigItemGenericUpdate() (AppConfigItemGenericUpdate, error) {
	var body AppConfigItemGenericUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemGenericUpdate overwrites any union data inside the AppConfigItemUpdate as the provided AppConfigItemGenericUpdate
func (t *AppConfigItemUpdate) FromAppConfigItemGenericUpdate(v AppConfigItemGenericUpdate) error {
	t.Type = "aa_sequence"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemGenericUpdate performs a merge with any union data inside the AppConfigItemUpdate, using the provided AppConfigItemGenericUpdate
func (t *AppConfigItemUpdate) MergeAppConfigItemGenericUpdate(v AppConfigItemGenericUpdate) error {
	t.Type = "aa_sequence"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemBooleanUpdate returns the union data inside the AppConfigItemUpdate as a AppConfigItemBooleanUpdate
func (t AppConfigItemUpdate) AsAppConfigItemBooleanUpdate() (AppConfigItemBooleanUpdate, error) {
	var body AppConfigItemBooleanUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemBooleanUpdate overwrites any union data inside the AppConfigItemUpdate as the provided AppConfigItemBooleanUpdate
func (t *AppConfigItemUpdate) FromAppConfigItemBooleanUpdate(v AppConfigItemBooleanUpdate) error {
	t.Type = "boolean"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemBooleanUpdate performs a merge with any union data inside the AppConfigItemUpdate, using the provided AppConfigItemBooleanUpdate
func (t *AppConfigItemUpdate) MergeAppConfigItemBooleanUpdate(v AppConfigItemBooleanUpdate) error {
	t.Type = "boolean"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemIntegerUpdate returns the union data inside the AppConfigItemUpdate as a AppConfigItemIntegerUpdate
func (t AppConfigItemUpdate) AsAppConfigItemIntegerUpdate() (AppConfigItemIntegerUpdate, error) {
	var body AppConfigItemIntegerUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemIntegerUpdate overwrites any union data inside the AppConfigItemUpdate as the provided AppConfigItemIntegerUpdate
func (t *AppConfigItemUpdate) FromAppConfigItemIntegerUpdate(v AppConfigItemIntegerUpdate) error {
	t.Type = "integer"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemIntegerUpdate performs a merge with any union data inside the AppConfigItemUpdate, using the provided AppConfigItemIntegerUpdate
func (t *AppConfigItemUpdate) MergeAppConfigItemIntegerUpdate(v AppConfigItemIntegerUpdate) error {
	t.Type = "integer"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemFloatUpdate returns the union data inside the AppConfigItemUpdate as a AppConfigItemFloatUpdate
func (t AppConfigItemUpdate) AsAppConfigItemFloatUpdate() (AppConfigItemFloatUpdate, error) {
	var body AppConfigItemFloatUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemFloatUpdate overwrites any union data inside the AppConfigItemUpdate as the provided AppConfigItemFloatUpdate
func (t *AppConfigItemUpdate) FromAppConfigItemFloatUpdate(v AppConfigItemFloatUpdate) error {
	t.Type = "float"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemFloatUpdate performs a merge with any union data inside the AppConfigItemUpdate, using the provided AppConfigItemFloatUpdate
func (t *AppConfigItemUpdate) MergeAppConfigItemFloatUpdate(v AppConfigItemFloatUpdate) error {
	t.Type = "float"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemDateUpdate returns the union data inside the AppConfigItemUpdate as a AppConfigItemDateUpdate
func (t AppConfigItemUpdate) AsAppConfigItemDateUpdate() (AppConfigItemDateUpdate, error) {
	var body AppConfigItemDateUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemDateUpdate overwrites any union data inside the AppConfigItemUpdate as the provided AppConfigItemDateUpdate
func (t *AppConfigItemUpdate) FromAppConfigItemDateUpdate(v AppConfigItemDateUpdate) error {
	t.Type = "date"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemDateUpdate performs a merge with any union data inside the AppConfigItemUpdate, using the provided AppConfigItemDateUpdate
func (t *AppConfigItemUpdate) MergeAppConfigItemDateUpdate(v AppConfigItemDateUpdate) error {
	t.Type = "date"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemDatetimeUpdate returns the union data inside the AppConfigItemUpdate as a AppConfigItemDatetimeUpdate
func (t AppConfigItemUpdate) AsAppConfigItemDatetimeUpdate() (AppConfigItemDatetimeUpdate, error) {
	var body AppConfigItemDatetimeUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemDatetimeUpdate overwrites any union data inside the AppConfigItemUpdate as the provided AppConfigItemDatetimeUpdate
func (t *AppConfigItemUpdate) FromAppConfigItemDatetimeUpdate(v AppConfigItemDatetimeUpdate) error {
	t.Type = "datetime"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemDatetimeUpdate performs a merge with any union data inside the AppConfigItemUpdate, using the provided AppConfigItemDatetimeUpdate
func (t *AppConfigItemUpdate) MergeAppConfigItemDatetimeUpdate(v AppConfigItemDatetimeUpdate) error {
	t.Type = "datetime"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAppConfigItemJsonUpdate returns the union data inside the AppConfigItemUpdate as a AppConfigItemJsonUpdate
func (t AppConfigItemUpdate) AsAppConfigItemJsonUpdate() (AppConfigItemJsonUpdate, error) {
	var body AppConfigItemJsonUpdate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAppConfigItemJsonUpdate overwrites any union data inside the AppConfigItemUpdate as the provided AppConfigItemJsonUpdate
func (t *AppConfigItemUpdate) FromAppConfigItemJsonUpdate(v AppConfigItemJsonUpdate) error {
	t.Type = "json"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAppConfigItemJsonUpdate performs a merge with any union data inside the AppConfigItemUpdate, using the provided AppConfigItemJsonUpdate
func (t *AppConfigItemUpdate) MergeAppConfigItemJsonUpdate(v AppConfigItemJsonUpdate) error {
	t.Type = "json"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AppConfigItemUpdate) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t AppConfigItemUpdate) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "aa_sequence":
		return t.AsAppConfigItemGenericUpdate()
	case "boolean":
		return t.AsAppConfigItemBooleanUpdate()
	case "date":
		return t.AsAppConfigItemDateUpdate()
	case "datetime":
		return t.AsAppConfigItemDatetimeUpdate()
	case "float":
		return t.AsAppConfigItemFloatUpdate()
	case "integer":
		return t.AsAppConfigItemIntegerUpdate()
	case "json":
		return t.AsAppConfigItemJsonUpdate()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t AppConfigItemUpdate) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AppConfigItemUpdate) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsFields returns the union data inside the AssayResultCreate_Fields as a Fields
func (t AssayResultCreate_Fields) AsFields() (Fields, error) {
	var body Fields
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFields overwrites any union data inside the AssayResultCreate_Fields as the provided Fields
func (t *AssayResultCreate_Fields) FromFields(v Fields) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFields performs a merge with any union data inside the AssayResultCreate_Fields, using the provided Fields
func (t *AssayResultCreate_Fields) MergeFields(v Fields) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssayFieldsCreate returns the union data inside the AssayResultCreate_Fields as a AssayFieldsCreate
func (t AssayResultCreate_Fields) AsAssayFieldsCreate() (AssayFieldsCreate, error) {
	var body AssayFieldsCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssayFieldsCreate overwrites any union data inside the AssayResultCreate_Fields as the provided AssayFieldsCreate
func (t *AssayResultCreate_Fields) FromAssayFieldsCreate(v AssayFieldsCreate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssayFieldsCreate performs a merge with any union data inside the AssayResultCreate_Fields, using the provided AssayFieldsCreate
func (t *AssayResultCreate_Fields) MergeAssayFieldsCreate(v AssayFieldsCreate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AssayResultCreate_Fields) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AssayResultCreate_Fields) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSimpleFieldDefinition returns the union data inside the AssayResultSchema_FieldDefinitions_Item as a SimpleFieldDefinition
func (t AssayResultSchema_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the AssayResultSchema_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *AssayResultSchema_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the AssayResultSchema_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *AssayResultSchema_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the AssayResultSchema_FieldDefinitions_Item as a IntegerFieldDefinition
func (t AssayResultSchema_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the AssayResultSchema_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *AssayResultSchema_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the AssayResultSchema_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *AssayResultSchema_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the AssayResultSchema_FieldDefinitions_Item as a FloatFieldDefinition
func (t AssayResultSchema_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the AssayResultSchema_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *AssayResultSchema_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the AssayResultSchema_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *AssayResultSchema_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the AssayResultSchema_FieldDefinitions_Item as a DropdownFieldDefinition
func (t AssayResultSchema_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the AssayResultSchema_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *AssayResultSchema_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the AssayResultSchema_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *AssayResultSchema_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the AssayResultSchema_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t AssayResultSchema_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the AssayResultSchema_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *AssayResultSchema_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the AssayResultSchema_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *AssayResultSchema_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AssayResultSchema_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AssayResultSchema_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFields returns the union data inside the AssayRunCreate_Fields as a Fields
func (t AssayRunCreate_Fields) AsFields() (Fields, error) {
	var body Fields
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFields overwrites any union data inside the AssayRunCreate_Fields as the provided Fields
func (t *AssayRunCreate_Fields) FromFields(v Fields) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFields performs a merge with any union data inside the AssayRunCreate_Fields, using the provided Fields
func (t *AssayRunCreate_Fields) MergeFields(v Fields) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssayFieldsCreate returns the union data inside the AssayRunCreate_Fields as a AssayFieldsCreate
func (t AssayRunCreate_Fields) AsAssayFieldsCreate() (AssayFieldsCreate, error) {
	var body AssayFieldsCreate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssayFieldsCreate overwrites any union data inside the AssayRunCreate_Fields as the provided AssayFieldsCreate
func (t *AssayRunCreate_Fields) FromAssayFieldsCreate(v AssayFieldsCreate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssayFieldsCreate performs a merge with any union data inside the AssayRunCreate_Fields, using the provided AssayFieldsCreate
func (t *AssayRunCreate_Fields) MergeAssayFieldsCreate(v AssayFieldsCreate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AssayRunCreate_Fields) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AssayRunCreate_Fields) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSimpleFieldDefinition returns the union data inside the AssayRunSchema_FieldDefinitions_Item as a SimpleFieldDefinition
func (t AssayRunSchema_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the AssayRunSchema_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *AssayRunSchema_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the AssayRunSchema_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *AssayRunSchema_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the AssayRunSchema_FieldDefinitions_Item as a IntegerFieldDefinition
func (t AssayRunSchema_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the AssayRunSchema_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *AssayRunSchema_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the AssayRunSchema_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *AssayRunSchema_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the AssayRunSchema_FieldDefinitions_Item as a FloatFieldDefinition
func (t AssayRunSchema_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the AssayRunSchema_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *AssayRunSchema_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the AssayRunSchema_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *AssayRunSchema_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the AssayRunSchema_FieldDefinitions_Item as a DropdownFieldDefinition
func (t AssayRunSchema_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the AssayRunSchema_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *AssayRunSchema_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the AssayRunSchema_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *AssayRunSchema_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the AssayRunSchema_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t AssayRunSchema_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the AssayRunSchema_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *AssayRunSchema_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the AssayRunSchema_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *AssayRunSchema_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t AssayRunSchema_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AssayRunSchema_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSimpleFieldDefinition returns the union data inside the BaseAssaySchema_FieldDefinitions_Item as a SimpleFieldDefinition
func (t BaseAssaySchema_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the BaseAssaySchema_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *BaseAssaySchema_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the BaseAssaySchema_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *BaseAssaySchema_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the BaseAssaySchema_FieldDefinitions_Item as a IntegerFieldDefinition
func (t BaseAssaySchema_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the BaseAssaySchema_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *BaseAssaySchema_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the BaseAssaySchema_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *BaseAssaySchema_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the BaseAssaySchema_FieldDefinitions_Item as a FloatFieldDefinition
func (t BaseAssaySchema_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the BaseAssaySchema_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *BaseAssaySchema_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the BaseAssaySchema_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *BaseAssaySchema_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the BaseAssaySchema_FieldDefinitions_Item as a DropdownFieldDefinition
func (t BaseAssaySchema_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the BaseAssaySchema_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *BaseAssaySchema_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the BaseAssaySchema_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *BaseAssaySchema_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the BaseAssaySchema_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t BaseAssaySchema_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the BaseAssaySchema_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *BaseAssaySchema_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the BaseAssaySchema_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *BaseAssaySchema_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t BaseAssaySchema_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BaseAssaySchema_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDnaSequenceSummary returns the union data inside the Batch_Entity as a DnaSequenceSummary
func (t Batch_Entity) AsDnaSequenceSummary() (DnaSequenceSummary, error) {
	var body DnaSequenceSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnaSequenceSummary overwrites any union data inside the Batch_Entity as the provided DnaSequenceSummary
func (t *Batch_Entity) FromDnaSequenceSummary(v DnaSequenceSummary) error {
	t.EntityType = "dna_sequence"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnaSequenceSummary performs a merge with any union data inside the Batch_Entity, using the provided DnaSequenceSummary
func (t *Batch_Entity) MergeDnaSequenceSummary(v DnaSequenceSummary) error {
	t.EntityType = "dna_sequence"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAaSequenceSummary returns the union data inside the Batch_Entity as a AaSequenceSummary
func (t Batch_Entity) AsAaSequenceSummary() (AaSequenceSummary, error) {
	var body AaSequenceSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAaSequenceSummary overwrites any union data inside the Batch_Entity as the provided AaSequenceSummary
func (t *Batch_Entity) FromAaSequenceSummary(v AaSequenceSummary) error {
	t.EntityType = "aa_sequence"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAaSequenceSummary performs a merge with any union data inside the Batch_Entity, using the provided AaSequenceSummary
func (t *Batch_Entity) MergeAaSequenceSummary(v AaSequenceSummary) error {
	t.EntityType = "aa_sequence"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomEntitySummary returns the union data inside the Batch_Entity as a CustomEntitySummary
func (t Batch_Entity) AsCustomEntitySummary() (CustomEntitySummary, error) {
	var body CustomEntitySummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomEntitySummary overwrites any union data inside the Batch_Entity as the provided CustomEntitySummary
func (t *Batch_Entity) FromCustomEntitySummary(v CustomEntitySummary) error {
	t.EntityType = "custom_entity"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomEntitySummary performs a merge with any union data inside the Batch_Entity, using the provided CustomEntitySummary
func (t *Batch_Entity) MergeCustomEntitySummary(v CustomEntitySummary) error {
	t.EntityType = "custom_entity"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Batch_Entity) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"entityType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Batch_Entity) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "aa_sequence":
		return t.AsAaSequenceSummary()
	case "custom_entity":
		return t.AsCustomEntitySummary()
	case "dna_sequence":
		return t.AsDnaSequenceSummary()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Batch_Entity) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["entityType"], err = json.Marshal(t.EntityType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'entityType': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Batch_Entity) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["entityType"]; found {
		err = json.Unmarshal(raw, &t.EntityType)
		if err != nil {
			return fmt.Errorf("error reading 'entityType': %w", err)
		}
	}

	return err
}

// AsBatch returns the union data inside the BatchOrInaccessibleResource as a Batch
func (t BatchOrInaccessibleResource) AsBatch() (Batch, error) {
	var body Batch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBatch overwrites any union data inside the BatchOrInaccessibleResource as the provided Batch
func (t *BatchOrInaccessibleResource) FromBatch(v Batch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBatch performs a merge with any union data inside the BatchOrInaccessibleResource, using the provided Batch
func (t *BatchOrInaccessibleResource) MergeBatch(v Batch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsInaccessibleResource returns the union data inside the BatchOrInaccessibleResource as a InaccessibleResource
func (t BatchOrInaccessibleResource) AsInaccessibleResource() (InaccessibleResource, error) {
	var body InaccessibleResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInaccessibleResource overwrites any union data inside the BatchOrInaccessibleResource as the provided InaccessibleResource
func (t *BatchOrInaccessibleResource) FromInaccessibleResource(v InaccessibleResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInaccessibleResource performs a merge with any union data inside the BatchOrInaccessibleResource, using the provided InaccessibleResource
func (t *BatchOrInaccessibleResource) MergeInaccessibleResource(v InaccessibleResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t BatchOrInaccessibleResource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BatchOrInaccessibleResource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSimpleFieldDefinition returns the union data inside the BatchSchema_FieldDefinitions_Item as a SimpleFieldDefinition
func (t BatchSchema_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the BatchSchema_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *BatchSchema_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the BatchSchema_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *BatchSchema_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the BatchSchema_FieldDefinitions_Item as a IntegerFieldDefinition
func (t BatchSchema_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the BatchSchema_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *BatchSchema_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the BatchSchema_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *BatchSchema_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the BatchSchema_FieldDefinitions_Item as a FloatFieldDefinition
func (t BatchSchema_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the BatchSchema_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *BatchSchema_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the BatchSchema_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *BatchSchema_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the BatchSchema_FieldDefinitions_Item as a DropdownFieldDefinition
func (t BatchSchema_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the BatchSchema_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *BatchSchema_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the BatchSchema_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *BatchSchema_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the BatchSchema_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t BatchSchema_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the BatchSchema_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *BatchSchema_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the BatchSchema_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *BatchSchema_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t BatchSchema_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BatchSchema_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSimpleFieldDefinition returns the union data inside the BoxSchema_FieldDefinitions_Item as a SimpleFieldDefinition
func (t BoxSchema_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the BoxSchema_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *BoxSchema_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the BoxSchema_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *BoxSchema_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the BoxSchema_FieldDefinitions_Item as a IntegerFieldDefinition
func (t BoxSchema_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the BoxSchema_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *BoxSchema_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the BoxSchema_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *BoxSchema_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the BoxSchema_FieldDefinitions_Item as a FloatFieldDefinition
func (t BoxSchema_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the BoxSchema_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *BoxSchema_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the BoxSchema_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *BoxSchema_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the BoxSchema_FieldDefinitions_Item as a DropdownFieldDefinition
func (t BoxSchema_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the BoxSchema_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *BoxSchema_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the BoxSchema_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *BoxSchema_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the BoxSchema_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t BoxSchema_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the BoxSchema_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *BoxSchema_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the BoxSchema_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *BoxSchema_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t BoxSchema_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *BoxSchema_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUserSummary returns the union data inside the CheckoutRecord_Assignee as a UserSummary
func (t CheckoutRecord_Assignee) AsUserSummary() (UserSummary, error) {
	var body UserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserSummary overwrites any union data inside the CheckoutRecord_Assignee as the provided UserSummary
func (t *CheckoutRecord_Assignee) FromUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserSummary performs a merge with any union data inside the CheckoutRecord_Assignee, using the provided UserSummary
func (t *CheckoutRecord_Assignee) MergeUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTeamSummary returns the union data inside the CheckoutRecord_Assignee as a TeamSummary
func (t CheckoutRecord_Assignee) AsTeamSummary() (TeamSummary, error) {
	var body TeamSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTeamSummary overwrites any union data inside the CheckoutRecord_Assignee as the provided TeamSummary
func (t *CheckoutRecord_Assignee) FromTeamSummary(v TeamSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTeamSummary performs a merge with any union data inside the CheckoutRecord_Assignee, using the provided TeamSummary
func (t *CheckoutRecord_Assignee) MergeTeamSummary(v TeamSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t CheckoutRecord_Assignee) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CheckoutRecord_Assignee) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUserSummary returns the union data inside the Container_RestrictedSampleParties_Item as a UserSummary
func (t Container_RestrictedSampleParties_Item) AsUserSummary() (UserSummary, error) {
	var body UserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserSummary overwrites any union data inside the Container_RestrictedSampleParties_Item as the provided UserSummary
func (t *Container_RestrictedSampleParties_Item) FromUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserSummary performs a merge with any union data inside the Container_RestrictedSampleParties_Item, using the provided UserSummary
func (t *Container_RestrictedSampleParties_Item) MergeUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTeamSummary returns the union data inside the Container_RestrictedSampleParties_Item as a TeamSummary
func (t Container_RestrictedSampleParties_Item) AsTeamSummary() (TeamSummary, error) {
	var body TeamSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTeamSummary overwrites any union data inside the Container_RestrictedSampleParties_Item as the provided TeamSummary
func (t *Container_RestrictedSampleParties_Item) FromTeamSummary(v TeamSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTeamSummary performs a merge with any union data inside the Container_RestrictedSampleParties_Item, using the provided TeamSummary
func (t *Container_RestrictedSampleParties_Item) MergeTeamSummary(v TeamSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Container_RestrictedSampleParties_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Container_RestrictedSampleParties_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUserSummary returns the union data inside the Container_SampleOwners_Item as a UserSummary
func (t Container_SampleOwners_Item) AsUserSummary() (UserSummary, error) {
	var body UserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserSummary overwrites any union data inside the Container_SampleOwners_Item as the provided UserSummary
func (t *Container_SampleOwners_Item) FromUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserSummary performs a merge with any union data inside the Container_SampleOwners_Item, using the provided UserSummary
func (t *Container_SampleOwners_Item) MergeUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTeamSummary returns the union data inside the Container_SampleOwners_Item as a TeamSummary
func (t Container_SampleOwners_Item) AsTeamSummary() (TeamSummary, error) {
	var body TeamSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTeamSummary overwrites any union data inside the Container_SampleOwners_Item as the provided TeamSummary
func (t *Container_SampleOwners_Item) FromTeamSummary(v TeamSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTeamSummary performs a merge with any union data inside the Container_SampleOwners_Item, using the provided TeamSummary
func (t *Container_SampleOwners_Item) MergeTeamSummary(v TeamSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Container_SampleOwners_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Container_SampleOwners_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSimpleFieldDefinition returns the union data inside the ContainerSchema_FieldDefinitions_Item as a SimpleFieldDefinition
func (t ContainerSchema_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the ContainerSchema_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *ContainerSchema_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the ContainerSchema_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *ContainerSchema_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the ContainerSchema_FieldDefinitions_Item as a IntegerFieldDefinition
func (t ContainerSchema_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the ContainerSchema_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *ContainerSchema_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the ContainerSchema_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *ContainerSchema_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the ContainerSchema_FieldDefinitions_Item as a FloatFieldDefinition
func (t ContainerSchema_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the ContainerSchema_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *ContainerSchema_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the ContainerSchema_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *ContainerSchema_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the ContainerSchema_FieldDefinitions_Item as a DropdownFieldDefinition
func (t ContainerSchema_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the ContainerSchema_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *ContainerSchema_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the ContainerSchema_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *ContainerSchema_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the ContainerSchema_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t ContainerSchema_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the ContainerSchema_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *ContainerSchema_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the ContainerSchema_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *ContainerSchema_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContainerSchema_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContainerSchema_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUserSummary returns the union data inside the ContainerWithCoordinates_RestrictedSampleParties_Item as a UserSummary
func (t ContainerWithCoordinates_RestrictedSampleParties_Item) AsUserSummary() (UserSummary, error) {
	var body UserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserSummary overwrites any union data inside the ContainerWithCoordinates_RestrictedSampleParties_Item as the provided UserSummary
func (t *ContainerWithCoordinates_RestrictedSampleParties_Item) FromUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserSummary performs a merge with any union data inside the ContainerWithCoordinates_RestrictedSampleParties_Item, using the provided UserSummary
func (t *ContainerWithCoordinates_RestrictedSampleParties_Item) MergeUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTeamSummary returns the union data inside the ContainerWithCoordinates_RestrictedSampleParties_Item as a TeamSummary
func (t ContainerWithCoordinates_RestrictedSampleParties_Item) AsTeamSummary() (TeamSummary, error) {
	var body TeamSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTeamSummary overwrites any union data inside the ContainerWithCoordinates_RestrictedSampleParties_Item as the provided TeamSummary
func (t *ContainerWithCoordinates_RestrictedSampleParties_Item) FromTeamSummary(v TeamSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTeamSummary performs a merge with any union data inside the ContainerWithCoordinates_RestrictedSampleParties_Item, using the provided TeamSummary
func (t *ContainerWithCoordinates_RestrictedSampleParties_Item) MergeTeamSummary(v TeamSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContainerWithCoordinates_RestrictedSampleParties_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContainerWithCoordinates_RestrictedSampleParties_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUserSummary returns the union data inside the ContainerWithCoordinates_SampleOwners_Item as a UserSummary
func (t ContainerWithCoordinates_SampleOwners_Item) AsUserSummary() (UserSummary, error) {
	var body UserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserSummary overwrites any union data inside the ContainerWithCoordinates_SampleOwners_Item as the provided UserSummary
func (t *ContainerWithCoordinates_SampleOwners_Item) FromUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserSummary performs a merge with any union data inside the ContainerWithCoordinates_SampleOwners_Item, using the provided UserSummary
func (t *ContainerWithCoordinates_SampleOwners_Item) MergeUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTeamSummary returns the union data inside the ContainerWithCoordinates_SampleOwners_Item as a TeamSummary
func (t ContainerWithCoordinates_SampleOwners_Item) AsTeamSummary() (TeamSummary, error) {
	var body TeamSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTeamSummary overwrites any union data inside the ContainerWithCoordinates_SampleOwners_Item as the provided TeamSummary
func (t *ContainerWithCoordinates_SampleOwners_Item) FromTeamSummary(v TeamSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTeamSummary performs a merge with any union data inside the ContainerWithCoordinates_SampleOwners_Item, using the provided TeamSummary
func (t *ContainerWithCoordinates_SampleOwners_Item) MergeTeamSummary(v TeamSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t ContainerWithCoordinates_SampleOwners_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ContainerWithCoordinates_SampleOwners_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSimpleFieldDefinition returns the union data inside the DeprecatedEntitySchema_FieldDefinitions_Item as a SimpleFieldDefinition
func (t DeprecatedEntitySchema_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the DeprecatedEntitySchema_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *DeprecatedEntitySchema_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the DeprecatedEntitySchema_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *DeprecatedEntitySchema_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the DeprecatedEntitySchema_FieldDefinitions_Item as a IntegerFieldDefinition
func (t DeprecatedEntitySchema_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the DeprecatedEntitySchema_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *DeprecatedEntitySchema_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the DeprecatedEntitySchema_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *DeprecatedEntitySchema_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the DeprecatedEntitySchema_FieldDefinitions_Item as a FloatFieldDefinition
func (t DeprecatedEntitySchema_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the DeprecatedEntitySchema_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *DeprecatedEntitySchema_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the DeprecatedEntitySchema_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *DeprecatedEntitySchema_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the DeprecatedEntitySchema_FieldDefinitions_Item as a DropdownFieldDefinition
func (t DeprecatedEntitySchema_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the DeprecatedEntitySchema_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *DeprecatedEntitySchema_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the DeprecatedEntitySchema_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *DeprecatedEntitySchema_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the DeprecatedEntitySchema_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t DeprecatedEntitySchema_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the DeprecatedEntitySchema_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *DeprecatedEntitySchema_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the DeprecatedEntitySchema_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *DeprecatedEntitySchema_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t DeprecatedEntitySchema_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DeprecatedEntitySchema_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDnaAlignmentBaseFiles0 returns the union data inside the DnaAlignmentBase_Files_Item as a DnaAlignmentBaseFiles0
func (t DnaAlignmentBase_Files_Item) AsDnaAlignmentBaseFiles0() (DnaAlignmentBaseFiles0, error) {
	var body DnaAlignmentBaseFiles0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnaAlignmentBaseFiles0 overwrites any union data inside the DnaAlignmentBase_Files_Item as the provided DnaAlignmentBaseFiles0
func (t *DnaAlignmentBase_Files_Item) FromDnaAlignmentBaseFiles0(v DnaAlignmentBaseFiles0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnaAlignmentBaseFiles0 performs a merge with any union data inside the DnaAlignmentBase_Files_Item, using the provided DnaAlignmentBaseFiles0
func (t *DnaAlignmentBase_Files_Item) MergeDnaAlignmentBaseFiles0(v DnaAlignmentBaseFiles0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDnaTemplateAlignmentFile returns the union data inside the DnaAlignmentBase_Files_Item as a DnaTemplateAlignmentFile
func (t DnaAlignmentBase_Files_Item) AsDnaTemplateAlignmentFile() (DnaTemplateAlignmentFile, error) {
	var body DnaTemplateAlignmentFile
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnaTemplateAlignmentFile overwrites any union data inside the DnaAlignmentBase_Files_Item as the provided DnaTemplateAlignmentFile
func (t *DnaAlignmentBase_Files_Item) FromDnaTemplateAlignmentFile(v DnaTemplateAlignmentFile) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnaTemplateAlignmentFile performs a merge with any union data inside the DnaAlignmentBase_Files_Item, using the provided DnaTemplateAlignmentFile
func (t *DnaAlignmentBase_Files_Item) MergeDnaTemplateAlignmentFile(v DnaTemplateAlignmentFile) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t DnaAlignmentBase_Files_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DnaAlignmentBase_Files_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDnaConsensusAlignmentCreateFiles0 returns the union data inside the DnaConsensusAlignmentCreate_Files_Item as a DnaConsensusAlignmentCreateFiles0
func (t DnaConsensusAlignmentCreate_Files_Item) AsDnaConsensusAlignmentCreateFiles0() (DnaConsensusAlignmentCreateFiles0, error) {
	var body DnaConsensusAlignmentCreateFiles0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnaConsensusAlignmentCreateFiles0 overwrites any union data inside the DnaConsensusAlignmentCreate_Files_Item as the provided DnaConsensusAlignmentCreateFiles0
func (t *DnaConsensusAlignmentCreate_Files_Item) FromDnaConsensusAlignmentCreateFiles0(v DnaConsensusAlignmentCreateFiles0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnaConsensusAlignmentCreateFiles0 performs a merge with any union data inside the DnaConsensusAlignmentCreate_Files_Item, using the provided DnaConsensusAlignmentCreateFiles0
func (t *DnaConsensusAlignmentCreate_Files_Item) MergeDnaConsensusAlignmentCreateFiles0(v DnaConsensusAlignmentCreateFiles0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDnaTemplateAlignmentFile returns the union data inside the DnaConsensusAlignmentCreate_Files_Item as a DnaTemplateAlignmentFile
func (t DnaConsensusAlignmentCreate_Files_Item) AsDnaTemplateAlignmentFile() (DnaTemplateAlignmentFile, error) {
	var body DnaTemplateAlignmentFile
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnaTemplateAlignmentFile overwrites any union data inside the DnaConsensusAlignmentCreate_Files_Item as the provided DnaTemplateAlignmentFile
func (t *DnaConsensusAlignmentCreate_Files_Item) FromDnaTemplateAlignmentFile(v DnaTemplateAlignmentFile) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnaTemplateAlignmentFile performs a merge with any union data inside the DnaConsensusAlignmentCreate_Files_Item, using the provided DnaTemplateAlignmentFile
func (t *DnaConsensusAlignmentCreate_Files_Item) MergeDnaTemplateAlignmentFile(v DnaTemplateAlignmentFile) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t DnaConsensusAlignmentCreate_Files_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DnaConsensusAlignmentCreate_Files_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDnaTemplateAlignmentCreateFiles0 returns the union data inside the DnaTemplateAlignmentCreate_Files_Item as a DnaTemplateAlignmentCreateFiles0
func (t DnaTemplateAlignmentCreate_Files_Item) AsDnaTemplateAlignmentCreateFiles0() (DnaTemplateAlignmentCreateFiles0, error) {
	var body DnaTemplateAlignmentCreateFiles0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnaTemplateAlignmentCreateFiles0 overwrites any union data inside the DnaTemplateAlignmentCreate_Files_Item as the provided DnaTemplateAlignmentCreateFiles0
func (t *DnaTemplateAlignmentCreate_Files_Item) FromDnaTemplateAlignmentCreateFiles0(v DnaTemplateAlignmentCreateFiles0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnaTemplateAlignmentCreateFiles0 performs a merge with any union data inside the DnaTemplateAlignmentCreate_Files_Item, using the provided DnaTemplateAlignmentCreateFiles0
func (t *DnaTemplateAlignmentCreate_Files_Item) MergeDnaTemplateAlignmentCreateFiles0(v DnaTemplateAlignmentCreateFiles0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDnaTemplateAlignmentFile returns the union data inside the DnaTemplateAlignmentCreate_Files_Item as a DnaTemplateAlignmentFile
func (t DnaTemplateAlignmentCreate_Files_Item) AsDnaTemplateAlignmentFile() (DnaTemplateAlignmentFile, error) {
	var body DnaTemplateAlignmentFile
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnaTemplateAlignmentFile overwrites any union data inside the DnaTemplateAlignmentCreate_Files_Item as the provided DnaTemplateAlignmentFile
func (t *DnaTemplateAlignmentCreate_Files_Item) FromDnaTemplateAlignmentFile(v DnaTemplateAlignmentFile) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnaTemplateAlignmentFile performs a merge with any union data inside the DnaTemplateAlignmentCreate_Files_Item, using the provided DnaTemplateAlignmentFile
func (t *DnaTemplateAlignmentCreate_Files_Item) MergeDnaTemplateAlignmentFile(v DnaTemplateAlignmentFile) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t DnaTemplateAlignmentCreate_Files_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DnaTemplateAlignmentCreate_Files_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDnaSequence returns the union data inside the Entity as a DnaSequence
func (t Entity) AsDnaSequence() (DnaSequence, error) {
	var body DnaSequence
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnaSequence overwrites any union data inside the Entity as the provided DnaSequence
func (t *Entity) FromDnaSequence(v DnaSequence) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnaSequence performs a merge with any union data inside the Entity, using the provided DnaSequence
func (t *Entity) MergeDnaSequence(v DnaSequence) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAaSequence returns the union data inside the Entity as a AaSequence
func (t Entity) AsAaSequence() (AaSequence, error) {
	var body AaSequence
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAaSequence overwrites any union data inside the Entity as the provided AaSequence
func (t *Entity) FromAaSequence(v AaSequence) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAaSequence performs a merge with any union data inside the Entity, using the provided AaSequence
func (t *Entity) MergeAaSequence(v AaSequence) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMixture returns the union data inside the Entity as a Mixture
func (t Entity) AsMixture() (Mixture, error) {
	var body Mixture
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMixture overwrites any union data inside the Entity as the provided Mixture
func (t *Entity) FromMixture(v Mixture) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMixture performs a merge with any union data inside the Entity, using the provided Mixture
func (t *Entity) MergeMixture(v Mixture) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDnaOligo returns the union data inside the Entity as a DnaOligo
func (t Entity) AsDnaOligo() (DnaOligo, error) {
	var body DnaOligo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnaOligo overwrites any union data inside the Entity as the provided DnaOligo
func (t *Entity) FromDnaOligo(v DnaOligo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnaOligo performs a merge with any union data inside the Entity, using the provided DnaOligo
func (t *Entity) MergeDnaOligo(v DnaOligo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRnaOligo returns the union data inside the Entity as a RnaOligo
func (t Entity) AsRnaOligo() (RnaOligo, error) {
	var body RnaOligo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRnaOligo overwrites any union data inside the Entity as the provided RnaOligo
func (t *Entity) FromRnaOligo(v RnaOligo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRnaOligo performs a merge with any union data inside the Entity, using the provided RnaOligo
func (t *Entity) MergeRnaOligo(v RnaOligo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomEntity returns the union data inside the Entity as a CustomEntity
func (t Entity) AsCustomEntity() (CustomEntity, error) {
	var body CustomEntity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomEntity overwrites any union data inside the Entity as the provided CustomEntity
func (t *Entity) FromCustomEntity(v CustomEntity) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomEntity performs a merge with any union data inside the Entity, using the provided CustomEntity
func (t *Entity) MergeCustomEntity(v CustomEntity) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Entity) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Entity) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEntity returns the union data inside the EntityOrInaccessibleResource as a Entity
func (t EntityOrInaccessibleResource) AsEntity() (Entity, error) {
	var body Entity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntity overwrites any union data inside the EntityOrInaccessibleResource as the provided Entity
func (t *EntityOrInaccessibleResource) FromEntity(v Entity) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntity performs a merge with any union data inside the EntityOrInaccessibleResource, using the provided Entity
func (t *EntityOrInaccessibleResource) MergeEntity(v Entity) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsInaccessibleResource returns the union data inside the EntityOrInaccessibleResource as a InaccessibleResource
func (t EntityOrInaccessibleResource) AsInaccessibleResource() (InaccessibleResource, error) {
	var body InaccessibleResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInaccessibleResource overwrites any union data inside the EntityOrInaccessibleResource as the provided InaccessibleResource
func (t *EntityOrInaccessibleResource) FromInaccessibleResource(v InaccessibleResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInaccessibleResource performs a merge with any union data inside the EntityOrInaccessibleResource, using the provided InaccessibleResource
func (t *EntityOrInaccessibleResource) MergeInaccessibleResource(v InaccessibleResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t EntityOrInaccessibleResource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EntityOrInaccessibleResource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSimpleFieldDefinition returns the union data inside the EntitySchema_FieldDefinitions_Item as a SimpleFieldDefinition
func (t EntitySchema_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the EntitySchema_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *EntitySchema_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the EntitySchema_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *EntitySchema_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the EntitySchema_FieldDefinitions_Item as a IntegerFieldDefinition
func (t EntitySchema_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the EntitySchema_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *EntitySchema_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the EntitySchema_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *EntitySchema_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the EntitySchema_FieldDefinitions_Item as a FloatFieldDefinition
func (t EntitySchema_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the EntitySchema_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *EntitySchema_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the EntitySchema_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *EntitySchema_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the EntitySchema_FieldDefinitions_Item as a DropdownFieldDefinition
func (t EntitySchema_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the EntitySchema_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *EntitySchema_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the EntitySchema_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *EntitySchema_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the EntitySchema_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t EntitySchema_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the EntitySchema_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *EntitySchema_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the EntitySchema_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *EntitySchema_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t EntitySchema_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EntitySchema_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEntryCreateAuthorIds0 returns the union data inside the EntryCreate_AuthorIds as a EntryCreateAuthorIds0
func (t EntryCreate_AuthorIds) AsEntryCreateAuthorIds0() (EntryCreateAuthorIds0, error) {
	var body EntryCreateAuthorIds0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntryCreateAuthorIds0 overwrites any union data inside the EntryCreate_AuthorIds as the provided EntryCreateAuthorIds0
func (t *EntryCreate_AuthorIds) FromEntryCreateAuthorIds0(v EntryCreateAuthorIds0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntryCreateAuthorIds0 performs a merge with any union data inside the EntryCreate_AuthorIds, using the provided EntryCreateAuthorIds0
func (t *EntryCreate_AuthorIds) MergeEntryCreateAuthorIds0(v EntryCreateAuthorIds0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntryCreateAuthorIds1 returns the union data inside the EntryCreate_AuthorIds as a EntryCreateAuthorIds1
func (t EntryCreate_AuthorIds) AsEntryCreateAuthorIds1() (EntryCreateAuthorIds1, error) {
	var body EntryCreateAuthorIds1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntryCreateAuthorIds1 overwrites any union data inside the EntryCreate_AuthorIds as the provided EntryCreateAuthorIds1
func (t *EntryCreate_AuthorIds) FromEntryCreateAuthorIds1(v EntryCreateAuthorIds1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntryCreateAuthorIds1 performs a merge with any union data inside the EntryCreate_AuthorIds, using the provided EntryCreateAuthorIds1
func (t *EntryCreate_AuthorIds) MergeEntryCreateAuthorIds1(v EntryCreateAuthorIds1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t EntryCreate_AuthorIds) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EntryCreate_AuthorIds) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSimpleNotePart returns the union data inside the EntryNotePart as a SimpleNotePart
func (t EntryNotePart) AsSimpleNotePart() (SimpleNotePart, error) {
	var body SimpleNotePart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleNotePart overwrites any union data inside the EntryNotePart as the provided SimpleNotePart
func (t *EntryNotePart) FromSimpleNotePart(v SimpleNotePart) error {
	t.Type = "code"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleNotePart performs a merge with any union data inside the EntryNotePart, using the provided SimpleNotePart
func (t *EntryNotePart) MergeSimpleNotePart(v SimpleNotePart) error {
	t.Type = "code"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTableNotePart returns the union data inside the EntryNotePart as a TableNotePart
func (t EntryNotePart) AsTableNotePart() (TableNotePart, error) {
	var body TableNotePart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTableNotePart overwrites any union data inside the EntryNotePart as the provided TableNotePart
func (t *EntryNotePart) FromTableNotePart(v TableNotePart) error {
	t.Type = "table"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTableNotePart performs a merge with any union data inside the EntryNotePart, using the provided TableNotePart
func (t *EntryNotePart) MergeTableNotePart(v TableNotePart) error {
	t.Type = "table"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTextBoxNotePart returns the union data inside the EntryNotePart as a TextBoxNotePart
func (t EntryNotePart) AsTextBoxNotePart() (TextBoxNotePart, error) {
	var body TextBoxNotePart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextBoxNotePart overwrites any union data inside the EntryNotePart as the provided TextBoxNotePart
func (t *EntryNotePart) FromTextBoxNotePart(v TextBoxNotePart) error {
	t.Type = "text_box"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextBoxNotePart performs a merge with any union data inside the EntryNotePart, using the provided TextBoxNotePart
func (t *EntryNotePart) MergeTextBoxNotePart(v TextBoxNotePart) error {
	t.Type = "text_box"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCheckboxNotePart returns the union data inside the EntryNotePart as a CheckboxNotePart
func (t EntryNotePart) AsCheckboxNotePart() (CheckboxNotePart, error) {
	var body CheckboxNotePart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCheckboxNotePart overwrites any union data inside the EntryNotePart as the provided CheckboxNotePart
func (t *EntryNotePart) FromCheckboxNotePart(v CheckboxNotePart) error {
	t.Type = "list_checkbox"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCheckboxNotePart performs a merge with any union data inside the EntryNotePart, using the provided CheckboxNotePart
func (t *EntryNotePart) MergeCheckboxNotePart(v CheckboxNotePart) error {
	t.Type = "list_checkbox"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsExternalFileNotePart returns the union data inside the EntryNotePart as a ExternalFileNotePart
func (t EntryNotePart) AsExternalFileNotePart() (ExternalFileNotePart, error) {
	var body ExternalFileNotePart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromExternalFileNotePart overwrites any union data inside the EntryNotePart as the provided ExternalFileNotePart
func (t *EntryNotePart) FromExternalFileNotePart(v ExternalFileNotePart) error {
	t.Type = "external_file"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeExternalFileNotePart performs a merge with any union data inside the EntryNotePart, using the provided ExternalFileNotePart
func (t *EntryNotePart) MergeExternalFileNotePart(v ExternalFileNotePart) error {
	t.Type = "external_file"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssayRunNotePart returns the union data inside the EntryNotePart as a AssayRunNotePart
func (t EntryNotePart) AsAssayRunNotePart() (AssayRunNotePart, error) {
	var body AssayRunNotePart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssayRunNotePart overwrites any union data inside the EntryNotePart as the provided AssayRunNotePart
func (t *EntryNotePart) FromAssayRunNotePart(v AssayRunNotePart) error {
	t.Type = "assay_run"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssayRunNotePart performs a merge with any union data inside the EntryNotePart, using the provided AssayRunNotePart
func (t *EntryNotePart) MergeAssayRunNotePart(v AssayRunNotePart) error {
	t.Type = "assay_run"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsLookupTableNotePart returns the union data inside the EntryNotePart as a LookupTableNotePart
func (t EntryNotePart) AsLookupTableNotePart() (LookupTableNotePart, error) {
	var body LookupTableNotePart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLookupTableNotePart overwrites any union data inside the EntryNotePart as the provided LookupTableNotePart
func (t *EntryNotePart) FromLookupTableNotePart(v LookupTableNotePart) error {
	t.Type = "lookup_table"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLookupTableNotePart performs a merge with any union data inside the EntryNotePart, using the provided LookupTableNotePart
func (t *EntryNotePart) MergeLookupTableNotePart(v LookupTableNotePart) error {
	t.Type = "lookup_table"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsResultsTableNotePart returns the union data inside the EntryNotePart as a ResultsTableNotePart
func (t EntryNotePart) AsResultsTableNotePart() (ResultsTableNotePart, error) {
	var body ResultsTableNotePart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResultsTableNotePart overwrites any union data inside the EntryNotePart as the provided ResultsTableNotePart
func (t *EntryNotePart) FromResultsTableNotePart(v ResultsTableNotePart) error {
	t.Type = "results_table"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResultsTableNotePart performs a merge with any union data inside the EntryNotePart, using the provided ResultsTableNotePart
func (t *EntryNotePart) MergeResultsTableNotePart(v ResultsTableNotePart) error {
	t.Type = "results_table"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRegistrationTableNotePart returns the union data inside the EntryNotePart as a RegistrationTableNotePart
func (t EntryNotePart) AsRegistrationTableNotePart() (RegistrationTableNotePart, error) {
	var body RegistrationTableNotePart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRegistrationTableNotePart overwrites any union data inside the EntryNotePart as the provided RegistrationTableNotePart
func (t *EntryNotePart) FromRegistrationTableNotePart(v RegistrationTableNotePart) error {
	t.Type = "registration_table"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRegistrationTableNotePart performs a merge with any union data inside the EntryNotePart, using the provided RegistrationTableNotePart
func (t *EntryNotePart) MergeRegistrationTableNotePart(v RegistrationTableNotePart) error {
	t.Type = "registration_table"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlateCreationTableNotePart returns the union data inside the EntryNotePart as a PlateCreationTableNotePart
func (t EntryNotePart) AsPlateCreationTableNotePart() (PlateCreationTableNotePart, error) {
	var body PlateCreationTableNotePart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlateCreationTableNotePart overwrites any union data inside the EntryNotePart as the provided PlateCreationTableNotePart
func (t *EntryNotePart) FromPlateCreationTableNotePart(v PlateCreationTableNotePart) error {
	t.Type = "plate_creation_table"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlateCreationTableNotePart performs a merge with any union data inside the EntryNotePart, using the provided PlateCreationTableNotePart
func (t *EntryNotePart) MergePlateCreationTableNotePart(v PlateCreationTableNotePart) error {
	t.Type = "plate_creation_table"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsBoxCreationTableNotePart returns the union data inside the EntryNotePart as a BoxCreationTableNotePart
func (t EntryNotePart) AsBoxCreationTableNotePart() (BoxCreationTableNotePart, error) {
	var body BoxCreationTableNotePart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBoxCreationTableNotePart overwrites any union data inside the EntryNotePart as the provided BoxCreationTableNotePart
func (t *EntryNotePart) FromBoxCreationTableNotePart(v BoxCreationTableNotePart) error {
	t.Type = "box_creation_table"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBoxCreationTableNotePart performs a merge with any union data inside the EntryNotePart, using the provided BoxCreationTableNotePart
func (t *EntryNotePart) MergeBoxCreationTableNotePart(v BoxCreationTableNotePart) error {
	t.Type = "box_creation_table"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMixturePrepTableNotePart returns the union data inside the EntryNotePart as a MixturePrepTableNotePart
func (t EntryNotePart) AsMixturePrepTableNotePart() (MixturePrepTableNotePart, error) {
	var body MixturePrepTableNotePart
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMixturePrepTableNotePart overwrites any union data inside the EntryNotePart as the provided MixturePrepTableNotePart
func (t *EntryNotePart) FromMixturePrepTableNotePart(v MixturePrepTableNotePart) error {
	t.Type = "mixture_prep_table"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMixturePrepTableNotePart performs a merge with any union data inside the EntryNotePart, using the provided MixturePrepTableNotePart
func (t *EntryNotePart) MergeMixturePrepTableNotePart(v MixturePrepTableNotePart) error {
	t.Type = "mixture_prep_table"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t EntryNotePart) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t EntryNotePart) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "assay_run":
		return t.AsAssayRunNotePart()
	case "box_creation_table":
		return t.AsBoxCreationTableNotePart()
	case "code":
		return t.AsSimpleNotePart()
	case "external_file":
		return t.AsExternalFileNotePart()
	case "list_checkbox":
		return t.AsCheckboxNotePart()
	case "lookup_table":
		return t.AsLookupTableNotePart()
	case "mixture_prep_table":
		return t.AsMixturePrepTableNotePart()
	case "plate_creation_table":
		return t.AsPlateCreationTableNotePart()
	case "registration_table":
		return t.AsRegistrationTableNotePart()
	case "results_table":
		return t.AsResultsTableNotePart()
	case "table":
		return t.AsTableNotePart()
	case "text_box":
		return t.AsTextBoxNotePart()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t EntryNotePart) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *EntryNotePart) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsSimpleFieldDefinition returns the union data inside the EntrySchemaDetailed_FieldDefinitions_Item as a SimpleFieldDefinition
func (t EntrySchemaDetailed_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the EntrySchemaDetailed_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *EntrySchemaDetailed_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the EntrySchemaDetailed_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *EntrySchemaDetailed_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the EntrySchemaDetailed_FieldDefinitions_Item as a IntegerFieldDefinition
func (t EntrySchemaDetailed_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the EntrySchemaDetailed_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *EntrySchemaDetailed_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the EntrySchemaDetailed_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *EntrySchemaDetailed_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the EntrySchemaDetailed_FieldDefinitions_Item as a FloatFieldDefinition
func (t EntrySchemaDetailed_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the EntrySchemaDetailed_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *EntrySchemaDetailed_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the EntrySchemaDetailed_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *EntrySchemaDetailed_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the EntrySchemaDetailed_FieldDefinitions_Item as a DropdownFieldDefinition
func (t EntrySchemaDetailed_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the EntrySchemaDetailed_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *EntrySchemaDetailed_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the EntrySchemaDetailed_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *EntrySchemaDetailed_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the EntrySchemaDetailed_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t EntrySchemaDetailed_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the EntrySchemaDetailed_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *EntrySchemaDetailed_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the EntrySchemaDetailed_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *EntrySchemaDetailed_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t EntrySchemaDetailed_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EntrySchemaDetailed_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsEntityRegisteredEvent returns the union data inside the Event as a EntityRegisteredEvent
func (t Event) AsEntityRegisteredEvent() (EntityRegisteredEvent, error) {
	var body EntityRegisteredEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntityRegisteredEvent overwrites any union data inside the Event as the provided EntityRegisteredEvent
func (t *Event) FromEntityRegisteredEvent(v EntityRegisteredEvent) error {
	t.EventType = "v2.entity.registered"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntityRegisteredEvent performs a merge with any union data inside the Event, using the provided EntityRegisteredEvent
func (t *Event) MergeEntityRegisteredEvent(v EntityRegisteredEvent) error {
	t.EventType = "v2.entity.registered"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntryCreatedEvent returns the union data inside the Event as a EntryCreatedEvent
func (t Event) AsEntryCreatedEvent() (EntryCreatedEvent, error) {
	var body EntryCreatedEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntryCreatedEvent overwrites any union data inside the Event as the provided EntryCreatedEvent
func (t *Event) FromEntryCreatedEvent(v EntryCreatedEvent) error {
	t.EventType = "v2.entry.created"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntryCreatedEvent performs a merge with any union data inside the Event, using the provided EntryCreatedEvent
func (t *Event) MergeEntryCreatedEvent(v EntryCreatedEvent) error {
	t.EventType = "v2.entry.created"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntryUpdatedFieldsEvent returns the union data inside the Event as a EntryUpdatedFieldsEvent
func (t Event) AsEntryUpdatedFieldsEvent() (EntryUpdatedFieldsEvent, error) {
	var body EntryUpdatedFieldsEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntryUpdatedFieldsEvent overwrites any union data inside the Event as the provided EntryUpdatedFieldsEvent
func (t *Event) FromEntryUpdatedFieldsEvent(v EntryUpdatedFieldsEvent) error {
	t.EventType = "v2.entry.updated.fields"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntryUpdatedFieldsEvent performs a merge with any union data inside the Event, using the provided EntryUpdatedFieldsEvent
func (t *Event) MergeEntryUpdatedFieldsEvent(v EntryUpdatedFieldsEvent) error {
	t.EventType = "v2.entry.updated.fields"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsEntryUpdatedReviewRecordEvent returns the union data inside the Event as a EntryUpdatedReviewRecordEvent
func (t Event) AsEntryUpdatedReviewRecordEvent() (EntryUpdatedReviewRecordEvent, error) {
	var body EntryUpdatedReviewRecordEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEntryUpdatedReviewRecordEvent overwrites any union data inside the Event as the provided EntryUpdatedReviewRecordEvent
func (t *Event) FromEntryUpdatedReviewRecordEvent(v EntryUpdatedReviewRecordEvent) error {
	t.EventType = "v2.entry.updated.reviewRecord"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEntryUpdatedReviewRecordEvent performs a merge with any union data inside the Event, using the provided EntryUpdatedReviewRecordEvent
func (t *Event) MergeEntryUpdatedReviewRecordEvent(v EntryUpdatedReviewRecordEvent) error {
	t.EventType = "v2.entry.updated.reviewRecord"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStageEntryCreatedEvent returns the union data inside the Event as a StageEntryCreatedEvent
func (t Event) AsStageEntryCreatedEvent() (StageEntryCreatedEvent, error) {
	var body StageEntryCreatedEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStageEntryCreatedEvent overwrites any union data inside the Event as the provided StageEntryCreatedEvent
func (t *Event) FromStageEntryCreatedEvent(v StageEntryCreatedEvent) error {
	t.EventType = "v2-alpha.stageEntry.created"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStageEntryCreatedEvent performs a merge with any union data inside the Event, using the provided StageEntryCreatedEvent
func (t *Event) MergeStageEntryCreatedEvent(v StageEntryCreatedEvent) error {
	t.EventType = "v2-alpha.stageEntry.created"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStageEntryUpdatedFieldsEvent returns the union data inside the Event as a StageEntryUpdatedFieldsEvent
func (t Event) AsStageEntryUpdatedFieldsEvent() (StageEntryUpdatedFieldsEvent, error) {
	var body StageEntryUpdatedFieldsEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStageEntryUpdatedFieldsEvent overwrites any union data inside the Event as the provided StageEntryUpdatedFieldsEvent
func (t *Event) FromStageEntryUpdatedFieldsEvent(v StageEntryUpdatedFieldsEvent) error {
	t.EventType = "StageEntryUpdatedFieldsEvent"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStageEntryUpdatedFieldsEvent performs a merge with any union data inside the Event, using the provided StageEntryUpdatedFieldsEvent
func (t *Event) MergeStageEntryUpdatedFieldsEvent(v StageEntryUpdatedFieldsEvent) error {
	t.EventType = "StageEntryUpdatedFieldsEvent"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsStageEntryUpdatedReviewRecordEvent returns the union data inside the Event as a StageEntryUpdatedReviewRecordEvent
func (t Event) AsStageEntryUpdatedReviewRecordEvent() (StageEntryUpdatedReviewRecordEvent, error) {
	var body StageEntryUpdatedReviewRecordEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStageEntryUpdatedReviewRecordEvent overwrites any union data inside the Event as the provided StageEntryUpdatedReviewRecordEvent
func (t *Event) FromStageEntryUpdatedReviewRecordEvent(v StageEntryUpdatedReviewRecordEvent) error {
	t.EventType = "StageEntryUpdatedReviewRecordEvent"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStageEntryUpdatedReviewRecordEvent performs a merge with any union data inside the Event, using the provided StageEntryUpdatedReviewRecordEvent
func (t *Event) MergeStageEntryUpdatedReviewRecordEvent(v StageEntryUpdatedReviewRecordEvent) error {
	t.EventType = "StageEntryUpdatedReviewRecordEvent"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRequestCreatedEvent returns the union data inside the Event as a RequestCreatedEvent
func (t Event) AsRequestCreatedEvent() (RequestCreatedEvent, error) {
	var body RequestCreatedEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestCreatedEvent overwrites any union data inside the Event as the provided RequestCreatedEvent
func (t *Event) FromRequestCreatedEvent(v RequestCreatedEvent) error {
	t.EventType = "v2.request.created"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestCreatedEvent performs a merge with any union data inside the Event, using the provided RequestCreatedEvent
func (t *Event) MergeRequestCreatedEvent(v RequestCreatedEvent) error {
	t.EventType = "v2.request.created"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRequestUpdatedFieldsEvent returns the union data inside the Event as a RequestUpdatedFieldsEvent
func (t Event) AsRequestUpdatedFieldsEvent() (RequestUpdatedFieldsEvent, error) {
	var body RequestUpdatedFieldsEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestUpdatedFieldsEvent overwrites any union data inside the Event as the provided RequestUpdatedFieldsEvent
func (t *Event) FromRequestUpdatedFieldsEvent(v RequestUpdatedFieldsEvent) error {
	t.EventType = "v2.request.updated.fields"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestUpdatedFieldsEvent performs a merge with any union data inside the Event, using the provided RequestUpdatedFieldsEvent
func (t *Event) MergeRequestUpdatedFieldsEvent(v RequestUpdatedFieldsEvent) error {
	t.EventType = "v2.request.updated.fields"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssayRunCreatedEvent returns the union data inside the Event as a AssayRunCreatedEvent
func (t Event) AsAssayRunCreatedEvent() (AssayRunCreatedEvent, error) {
	var body AssayRunCreatedEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssayRunCreatedEvent overwrites any union data inside the Event as the provided AssayRunCreatedEvent
func (t *Event) FromAssayRunCreatedEvent(v AssayRunCreatedEvent) error {
	t.EventType = "v2.assayRun.created"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssayRunCreatedEvent performs a merge with any union data inside the Event, using the provided AssayRunCreatedEvent
func (t *Event) MergeAssayRunCreatedEvent(v AssayRunCreatedEvent) error {
	t.EventType = "v2.assayRun.created"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAssayRunUpdatedFieldsEvent returns the union data inside the Event as a AssayRunUpdatedFieldsEvent
func (t Event) AsAssayRunUpdatedFieldsEvent() (AssayRunUpdatedFieldsEvent, error) {
	var body AssayRunUpdatedFieldsEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAssayRunUpdatedFieldsEvent overwrites any union data inside the Event as the provided AssayRunUpdatedFieldsEvent
func (t *Event) FromAssayRunUpdatedFieldsEvent(v AssayRunUpdatedFieldsEvent) error {
	t.EventType = "v2.assayRun.updated.fields"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAssayRunUpdatedFieldsEvent performs a merge with any union data inside the Event, using the provided AssayRunUpdatedFieldsEvent
func (t *Event) MergeAssayRunUpdatedFieldsEvent(v AssayRunUpdatedFieldsEvent) error {
	t.EventType = "v2.assayRun.updated.fields"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAutomationInputGeneratorCompletedV2BetaEvent returns the union data inside the Event as a AutomationInputGeneratorCompletedV2BetaEvent
func (t Event) AsAutomationInputGeneratorCompletedV2BetaEvent() (AutomationInputGeneratorCompletedV2BetaEvent, error) {
	var body AutomationInputGeneratorCompletedV2BetaEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAutomationInputGeneratorCompletedV2BetaEvent overwrites any union data inside the Event as the provided AutomationInputGeneratorCompletedV2BetaEvent
func (t *Event) FromAutomationInputGeneratorCompletedV2BetaEvent(v AutomationInputGeneratorCompletedV2BetaEvent) error {
	t.EventType = "v2-beta.automationInputGenerator.completed"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAutomationInputGeneratorCompletedV2BetaEvent performs a merge with any union data inside the Event, using the provided AutomationInputGeneratorCompletedV2BetaEvent
func (t *Event) MergeAutomationInputGeneratorCompletedV2BetaEvent(v AutomationInputGeneratorCompletedV2BetaEvent) error {
	t.EventType = "v2-beta.automationInputGenerator.completed"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAutomationOutputProcessorCompletedV2BetaEvent returns the union data inside the Event as a AutomationOutputProcessorCompletedV2BetaEvent
func (t Event) AsAutomationOutputProcessorCompletedV2BetaEvent() (AutomationOutputProcessorCompletedV2BetaEvent, error) {
	var body AutomationOutputProcessorCompletedV2BetaEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAutomationOutputProcessorCompletedV2BetaEvent overwrites any union data inside the Event as the provided AutomationOutputProcessorCompletedV2BetaEvent
func (t *Event) FromAutomationOutputProcessorCompletedV2BetaEvent(v AutomationOutputProcessorCompletedV2BetaEvent) error {
	t.EventType = "v2-beta.automationOutputProcessor.completed"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAutomationOutputProcessorCompletedV2BetaEvent performs a merge with any union data inside the Event, using the provided AutomationOutputProcessorCompletedV2BetaEvent
func (t *Event) MergeAutomationOutputProcessorCompletedV2BetaEvent(v AutomationOutputProcessorCompletedV2BetaEvent) error {
	t.EventType = "v2-beta.automationOutputProcessor.completed"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAutomationOutputProcessorUploadedV2BetaEvent returns the union data inside the Event as a AutomationOutputProcessorUploadedV2BetaEvent
func (t Event) AsAutomationOutputProcessorUploadedV2BetaEvent() (AutomationOutputProcessorUploadedV2BetaEvent, error) {
	var body AutomationOutputProcessorUploadedV2BetaEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAutomationOutputProcessorUploadedV2BetaEvent overwrites any union data inside the Event as the provided AutomationOutputProcessorUploadedV2BetaEvent
func (t *Event) FromAutomationOutputProcessorUploadedV2BetaEvent(v AutomationOutputProcessorUploadedV2BetaEvent) error {
	t.EventType = "v2-beta.automationOutputProcessor.uploaded"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAutomationOutputProcessorUploadedV2BetaEvent performs a merge with any union data inside the Event, using the provided AutomationOutputProcessorUploadedV2BetaEvent
func (t *Event) MergeAutomationOutputProcessorUploadedV2BetaEvent(v AutomationOutputProcessorUploadedV2BetaEvent) error {
	t.EventType = "v2-beta.automationOutputProcessor.uploaded"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorkflowTaskGroupCreatedEvent returns the union data inside the Event as a WorkflowTaskGroupCreatedEvent
func (t Event) AsWorkflowTaskGroupCreatedEvent() (WorkflowTaskGroupCreatedEvent, error) {
	var body WorkflowTaskGroupCreatedEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkflowTaskGroupCreatedEvent overwrites any union data inside the Event as the provided WorkflowTaskGroupCreatedEvent
func (t *Event) FromWorkflowTaskGroupCreatedEvent(v WorkflowTaskGroupCreatedEvent) error {
	t.EventType = "v2.workflowTaskGroup.created"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkflowTaskGroupCreatedEvent performs a merge with any union data inside the Event, using the provided WorkflowTaskGroupCreatedEvent
func (t *Event) MergeWorkflowTaskGroupCreatedEvent(v WorkflowTaskGroupCreatedEvent) error {
	t.EventType = "v2.workflowTaskGroup.created"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorkflowTaskCreatedEvent returns the union data inside the Event as a WorkflowTaskCreatedEvent
func (t Event) AsWorkflowTaskCreatedEvent() (WorkflowTaskCreatedEvent, error) {
	var body WorkflowTaskCreatedEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkflowTaskCreatedEvent overwrites any union data inside the Event as the provided WorkflowTaskCreatedEvent
func (t *Event) FromWorkflowTaskCreatedEvent(v WorkflowTaskCreatedEvent) error {
	t.EventType = "v2.workflowTask.created"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkflowTaskCreatedEvent performs a merge with any union data inside the Event, using the provided WorkflowTaskCreatedEvent
func (t *Event) MergeWorkflowTaskCreatedEvent(v WorkflowTaskCreatedEvent) error {
	t.EventType = "v2.workflowTask.created"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorkflowTaskUpdatedFieldsEvent returns the union data inside the Event as a WorkflowTaskUpdatedFieldsEvent
func (t Event) AsWorkflowTaskUpdatedFieldsEvent() (WorkflowTaskUpdatedFieldsEvent, error) {
	var body WorkflowTaskUpdatedFieldsEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkflowTaskUpdatedFieldsEvent overwrites any union data inside the Event as the provided WorkflowTaskUpdatedFieldsEvent
func (t *Event) FromWorkflowTaskUpdatedFieldsEvent(v WorkflowTaskUpdatedFieldsEvent) error {
	t.EventType = "v2.workflowTask.updated.fields"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkflowTaskUpdatedFieldsEvent performs a merge with any union data inside the Event, using the provided WorkflowTaskUpdatedFieldsEvent
func (t *Event) MergeWorkflowTaskUpdatedFieldsEvent(v WorkflowTaskUpdatedFieldsEvent) error {
	t.EventType = "v2.workflowTask.updated.fields"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorkflowTaskUpdatedStatusEvent returns the union data inside the Event as a WorkflowTaskUpdatedStatusEvent
func (t Event) AsWorkflowTaskUpdatedStatusEvent() (WorkflowTaskUpdatedStatusEvent, error) {
	var body WorkflowTaskUpdatedStatusEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkflowTaskUpdatedStatusEvent overwrites any union data inside the Event as the provided WorkflowTaskUpdatedStatusEvent
func (t *Event) FromWorkflowTaskUpdatedStatusEvent(v WorkflowTaskUpdatedStatusEvent) error {
	t.EventType = "v2.workflowTask.updated.status"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkflowTaskUpdatedStatusEvent performs a merge with any union data inside the Event, using the provided WorkflowTaskUpdatedStatusEvent
func (t *Event) MergeWorkflowTaskUpdatedStatusEvent(v WorkflowTaskUpdatedStatusEvent) error {
	t.EventType = "v2.workflowTask.updated.status"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorkflowTaskUpdatedAssigneeEvent returns the union data inside the Event as a WorkflowTaskUpdatedAssigneeEvent
func (t Event) AsWorkflowTaskUpdatedAssigneeEvent() (WorkflowTaskUpdatedAssigneeEvent, error) {
	var body WorkflowTaskUpdatedAssigneeEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkflowTaskUpdatedAssigneeEvent overwrites any union data inside the Event as the provided WorkflowTaskUpdatedAssigneeEvent
func (t *Event) FromWorkflowTaskUpdatedAssigneeEvent(v WorkflowTaskUpdatedAssigneeEvent) error {
	t.EventType = "v2.workflowTask.updated.assignee"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkflowTaskUpdatedAssigneeEvent performs a merge with any union data inside the Event, using the provided WorkflowTaskUpdatedAssigneeEvent
func (t *Event) MergeWorkflowTaskUpdatedAssigneeEvent(v WorkflowTaskUpdatedAssigneeEvent) error {
	t.EventType = "v2.workflowTask.updated.assignee"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorkflowTaskUpdatedScheduledOnEvent returns the union data inside the Event as a WorkflowTaskUpdatedScheduledOnEvent
func (t Event) AsWorkflowTaskUpdatedScheduledOnEvent() (WorkflowTaskUpdatedScheduledOnEvent, error) {
	var body WorkflowTaskUpdatedScheduledOnEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkflowTaskUpdatedScheduledOnEvent overwrites any union data inside the Event as the provided WorkflowTaskUpdatedScheduledOnEvent
func (t *Event) FromWorkflowTaskUpdatedScheduledOnEvent(v WorkflowTaskUpdatedScheduledOnEvent) error {
	t.EventType = "v2.workflowTask.updated.scheduledOn"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkflowTaskUpdatedScheduledOnEvent performs a merge with any union data inside the Event, using the provided WorkflowTaskUpdatedScheduledOnEvent
func (t *Event) MergeWorkflowTaskUpdatedScheduledOnEvent(v WorkflowTaskUpdatedScheduledOnEvent) error {
	t.EventType = "v2.workflowTask.updated.scheduledOn"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorkflowTaskGroupUpdatedWatchersEvent returns the union data inside the Event as a WorkflowTaskGroupUpdatedWatchersEvent
func (t Event) AsWorkflowTaskGroupUpdatedWatchersEvent() (WorkflowTaskGroupUpdatedWatchersEvent, error) {
	var body WorkflowTaskGroupUpdatedWatchersEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkflowTaskGroupUpdatedWatchersEvent overwrites any union data inside the Event as the provided WorkflowTaskGroupUpdatedWatchersEvent
func (t *Event) FromWorkflowTaskGroupUpdatedWatchersEvent(v WorkflowTaskGroupUpdatedWatchersEvent) error {
	t.EventType = "v2.workflowTaskGroup.updated.watchers"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkflowTaskGroupUpdatedWatchersEvent performs a merge with any union data inside the Event, using the provided WorkflowTaskGroupUpdatedWatchersEvent
func (t *Event) MergeWorkflowTaskGroupUpdatedWatchersEvent(v WorkflowTaskGroupUpdatedWatchersEvent) error {
	t.EventType = "v2.workflowTaskGroup.updated.watchers"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorkflowOutputCreatedEvent returns the union data inside the Event as a WorkflowOutputCreatedEvent
func (t Event) AsWorkflowOutputCreatedEvent() (WorkflowOutputCreatedEvent, error) {
	var body WorkflowOutputCreatedEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkflowOutputCreatedEvent overwrites any union data inside the Event as the provided WorkflowOutputCreatedEvent
func (t *Event) FromWorkflowOutputCreatedEvent(v WorkflowOutputCreatedEvent) error {
	t.EventType = "v2.workflowOutput.created"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkflowOutputCreatedEvent performs a merge with any union data inside the Event, using the provided WorkflowOutputCreatedEvent
func (t *Event) MergeWorkflowOutputCreatedEvent(v WorkflowOutputCreatedEvent) error {
	t.EventType = "v2.workflowOutput.created"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorkflowOutputUpdatedFieldsEvent returns the union data inside the Event as a WorkflowOutputUpdatedFieldsEvent
func (t Event) AsWorkflowOutputUpdatedFieldsEvent() (WorkflowOutputUpdatedFieldsEvent, error) {
	var body WorkflowOutputUpdatedFieldsEvent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkflowOutputUpdatedFieldsEvent overwrites any union data inside the Event as the provided WorkflowOutputUpdatedFieldsEvent
func (t *Event) FromWorkflowOutputUpdatedFieldsEvent(v WorkflowOutputUpdatedFieldsEvent) error {
	t.EventType = "v2.workflowOutput.updated.fields"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkflowOutputUpdatedFieldsEvent performs a merge with any union data inside the Event, using the provided WorkflowOutputUpdatedFieldsEvent
func (t *Event) MergeWorkflowOutputUpdatedFieldsEvent(v WorkflowOutputUpdatedFieldsEvent) error {
	t.EventType = "v2.workflowOutput.updated.fields"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Event) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"eventType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Event) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "StageEntryUpdatedFieldsEvent":
		return t.AsStageEntryUpdatedFieldsEvent()
	case "StageEntryUpdatedReviewRecordEvent":
		return t.AsStageEntryUpdatedReviewRecordEvent()
	case "v2-alpha.stageEntry.created":
		return t.AsStageEntryCreatedEvent()
	case "v2-beta.automationInputGenerator.completed":
		return t.AsAutomationInputGeneratorCompletedV2BetaEvent()
	case "v2-beta.automationOutputProcessor.completed":
		return t.AsAutomationOutputProcessorCompletedV2BetaEvent()
	case "v2-beta.automationOutputProcessor.uploaded":
		return t.AsAutomationOutputProcessorUploadedV2BetaEvent()
	case "v2.assayRun.created":
		return t.AsAssayRunCreatedEvent()
	case "v2.assayRun.updated.fields":
		return t.AsAssayRunUpdatedFieldsEvent()
	case "v2.entity.registered":
		return t.AsEntityRegisteredEvent()
	case "v2.entry.created":
		return t.AsEntryCreatedEvent()
	case "v2.entry.updated.fields":
		return t.AsEntryUpdatedFieldsEvent()
	case "v2.entry.updated.reviewRecord":
		return t.AsEntryUpdatedReviewRecordEvent()
	case "v2.request.created":
		return t.AsRequestCreatedEvent()
	case "v2.request.updated.fields":
		return t.AsRequestUpdatedFieldsEvent()
	case "v2.workflowOutput.created":
		return t.AsWorkflowOutputCreatedEvent()
	case "v2.workflowOutput.updated.fields":
		return t.AsWorkflowOutputUpdatedFieldsEvent()
	case "v2.workflowTask.created":
		return t.AsWorkflowTaskCreatedEvent()
	case "v2.workflowTask.updated.assignee":
		return t.AsWorkflowTaskUpdatedAssigneeEvent()
	case "v2.workflowTask.updated.fields":
		return t.AsWorkflowTaskUpdatedFieldsEvent()
	case "v2.workflowTask.updated.scheduledOn":
		return t.AsWorkflowTaskUpdatedScheduledOnEvent()
	case "v2.workflowTask.updated.status":
		return t.AsWorkflowTaskUpdatedStatusEvent()
	case "v2.workflowTaskGroup.created":
		return t.AsWorkflowTaskGroupCreatedEvent()
	case "v2.workflowTaskGroup.updated.watchers":
		return t.AsWorkflowTaskGroupUpdatedWatchersEvent()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Event) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["eventType"], err = json.Marshal(t.EventType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'eventType': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Event) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["eventType"]; found {
		err = json.Unmarshal(raw, &t.EventType)
		if err != nil {
			return fmt.Errorf("error reading 'eventType': %w", err)
		}
	}

	return err
}

// AsOrganization returns the union data inside the FeatureLibrary_Owner as a Organization
func (t FeatureLibrary_Owner) AsOrganization() (Organization, error) {
	var body Organization
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrganization overwrites any union data inside the FeatureLibrary_Owner as the provided Organization
func (t *FeatureLibrary_Owner) FromOrganization(v Organization) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrganization performs a merge with any union data inside the FeatureLibrary_Owner, using the provided Organization
func (t *FeatureLibrary_Owner) MergeOrganization(v Organization) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUserSummary returns the union data inside the FeatureLibrary_Owner as a UserSummary
func (t FeatureLibrary_Owner) AsUserSummary() (UserSummary, error) {
	var body UserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserSummary overwrites any union data inside the FeatureLibrary_Owner as the provided UserSummary
func (t *FeatureLibrary_Owner) FromUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserSummary performs a merge with any union data inside the FeatureLibrary_Owner, using the provided UserSummary
func (t *FeatureLibrary_Owner) MergeUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t FeatureLibrary_Owner) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FeatureLibrary_Owner) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFieldValue0 returns the union data inside the Field_Value as a FieldValue0
func (t Field_Value) AsFieldValue0() (FieldValue0, error) {
	var body FieldValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValue0 overwrites any union data inside the Field_Value as the provided FieldValue0
func (t *Field_Value) FromFieldValue0(v FieldValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValue0 performs a merge with any union data inside the Field_Value, using the provided FieldValue0
func (t *Field_Value) MergeFieldValue0(v FieldValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValue1 returns the union data inside the Field_Value as a FieldValue1
func (t Field_Value) AsFieldValue1() (FieldValue1, error) {
	var body FieldValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValue1 overwrites any union data inside the Field_Value as the provided FieldValue1
func (t *Field_Value) FromFieldValue1(v FieldValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValue1 performs a merge with any union data inside the Field_Value, using the provided FieldValue1
func (t *Field_Value) MergeFieldValue1(v FieldValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValue2 returns the union data inside the Field_Value as a FieldValue2
func (t Field_Value) AsFieldValue2() (FieldValue2, error) {
	var body FieldValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValue2 overwrites any union data inside the Field_Value as the provided FieldValue2
func (t *Field_Value) FromFieldValue2(v FieldValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValue2 performs a merge with any union data inside the Field_Value, using the provided FieldValue2
func (t *Field_Value) MergeFieldValue2(v FieldValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValue3 returns the union data inside the Field_Value as a FieldValue3
func (t Field_Value) AsFieldValue3() (FieldValue3, error) {
	var body FieldValue3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValue3 overwrites any union data inside the Field_Value as the provided FieldValue3
func (t *Field_Value) FromFieldValue3(v FieldValue3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValue3 performs a merge with any union data inside the Field_Value, using the provided FieldValue3
func (t *Field_Value) MergeFieldValue3(v FieldValue3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValue4 returns the union data inside the Field_Value as a FieldValue4
func (t Field_Value) AsFieldValue4() (FieldValue4, error) {
	var body FieldValue4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValue4 overwrites any union data inside the Field_Value as the provided FieldValue4
func (t *Field_Value) FromFieldValue4(v FieldValue4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValue4 performs a merge with any union data inside the Field_Value, using the provided FieldValue4
func (t *Field_Value) MergeFieldValue4(v FieldValue4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Field_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Field_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLinkedAppConfigResourceSummary returns the union data inside the LinkedAppConfigResource as a LinkedAppConfigResourceSummary
func (t LinkedAppConfigResource) AsLinkedAppConfigResourceSummary() (LinkedAppConfigResourceSummary, error) {
	var body LinkedAppConfigResourceSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkedAppConfigResourceSummary overwrites any union data inside the LinkedAppConfigResource as the provided LinkedAppConfigResourceSummary
func (t *LinkedAppConfigResource) FromLinkedAppConfigResourceSummary(v LinkedAppConfigResourceSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkedAppConfigResourceSummary performs a merge with any union data inside the LinkedAppConfigResource, using the provided LinkedAppConfigResourceSummary
func (t *LinkedAppConfigResource) MergeLinkedAppConfigResourceSummary(v LinkedAppConfigResourceSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsInaccessibleResource returns the union data inside the LinkedAppConfigResource as a InaccessibleResource
func (t LinkedAppConfigResource) AsInaccessibleResource() (InaccessibleResource, error) {
	var body InaccessibleResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInaccessibleResource overwrites any union data inside the LinkedAppConfigResource as the provided InaccessibleResource
func (t *LinkedAppConfigResource) FromInaccessibleResource(v InaccessibleResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInaccessibleResource performs a merge with any union data inside the LinkedAppConfigResource, using the provided InaccessibleResource
func (t *LinkedAppConfigResource) MergeInaccessibleResource(v InaccessibleResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t LinkedAppConfigResource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LinkedAppConfigResource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSimpleFieldDefinition returns the union data inside the LocationSchema_FieldDefinitions_Item as a SimpleFieldDefinition
func (t LocationSchema_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the LocationSchema_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *LocationSchema_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the LocationSchema_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *LocationSchema_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the LocationSchema_FieldDefinitions_Item as a IntegerFieldDefinition
func (t LocationSchema_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the LocationSchema_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *LocationSchema_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the LocationSchema_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *LocationSchema_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the LocationSchema_FieldDefinitions_Item as a FloatFieldDefinition
func (t LocationSchema_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the LocationSchema_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *LocationSchema_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the LocationSchema_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *LocationSchema_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the LocationSchema_FieldDefinitions_Item as a DropdownFieldDefinition
func (t LocationSchema_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the LocationSchema_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *LocationSchema_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the LocationSchema_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *LocationSchema_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the LocationSchema_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t LocationSchema_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the LocationSchema_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *LocationSchema_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the LocationSchema_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *LocationSchema_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t LocationSchema_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LocationSchema_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNucleotideAlignmentBaseFiles0 returns the union data inside the NucleotideAlignmentBase_Files_Item as a NucleotideAlignmentBaseFiles0
func (t NucleotideAlignmentBase_Files_Item) AsNucleotideAlignmentBaseFiles0() (NucleotideAlignmentBaseFiles0, error) {
	var body NucleotideAlignmentBaseFiles0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNucleotideAlignmentBaseFiles0 overwrites any union data inside the NucleotideAlignmentBase_Files_Item as the provided NucleotideAlignmentBaseFiles0
func (t *NucleotideAlignmentBase_Files_Item) FromNucleotideAlignmentBaseFiles0(v NucleotideAlignmentBaseFiles0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNucleotideAlignmentBaseFiles0 performs a merge with any union data inside the NucleotideAlignmentBase_Files_Item, using the provided NucleotideAlignmentBaseFiles0
func (t *NucleotideAlignmentBase_Files_Item) MergeNucleotideAlignmentBaseFiles0(v NucleotideAlignmentBaseFiles0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNucleotideAlignmentFile returns the union data inside the NucleotideAlignmentBase_Files_Item as a NucleotideAlignmentFile
func (t NucleotideAlignmentBase_Files_Item) AsNucleotideAlignmentFile() (NucleotideAlignmentFile, error) {
	var body NucleotideAlignmentFile
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNucleotideAlignmentFile overwrites any union data inside the NucleotideAlignmentBase_Files_Item as the provided NucleotideAlignmentFile
func (t *NucleotideAlignmentBase_Files_Item) FromNucleotideAlignmentFile(v NucleotideAlignmentFile) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNucleotideAlignmentFile performs a merge with any union data inside the NucleotideAlignmentBase_Files_Item, using the provided NucleotideAlignmentFile
func (t *NucleotideAlignmentBase_Files_Item) MergeNucleotideAlignmentFile(v NucleotideAlignmentFile) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t NucleotideAlignmentBase_Files_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NucleotideAlignmentBase_Files_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNucleotideConsensusAlignmentCreateFiles0 returns the union data inside the NucleotideConsensusAlignmentCreate_Files_Item as a NucleotideConsensusAlignmentCreateFiles0
func (t NucleotideConsensusAlignmentCreate_Files_Item) AsNucleotideConsensusAlignmentCreateFiles0() (NucleotideConsensusAlignmentCreateFiles0, error) {
	var body NucleotideConsensusAlignmentCreateFiles0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNucleotideConsensusAlignmentCreateFiles0 overwrites any union data inside the NucleotideConsensusAlignmentCreate_Files_Item as the provided NucleotideConsensusAlignmentCreateFiles0
func (t *NucleotideConsensusAlignmentCreate_Files_Item) FromNucleotideConsensusAlignmentCreateFiles0(v NucleotideConsensusAlignmentCreateFiles0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNucleotideConsensusAlignmentCreateFiles0 performs a merge with any union data inside the NucleotideConsensusAlignmentCreate_Files_Item, using the provided NucleotideConsensusAlignmentCreateFiles0
func (t *NucleotideConsensusAlignmentCreate_Files_Item) MergeNucleotideConsensusAlignmentCreateFiles0(v NucleotideConsensusAlignmentCreateFiles0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNucleotideAlignmentFile returns the union data inside the NucleotideConsensusAlignmentCreate_Files_Item as a NucleotideAlignmentFile
func (t NucleotideConsensusAlignmentCreate_Files_Item) AsNucleotideAlignmentFile() (NucleotideAlignmentFile, error) {
	var body NucleotideAlignmentFile
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNucleotideAlignmentFile overwrites any union data inside the NucleotideConsensusAlignmentCreate_Files_Item as the provided NucleotideAlignmentFile
func (t *NucleotideConsensusAlignmentCreate_Files_Item) FromNucleotideAlignmentFile(v NucleotideAlignmentFile) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNucleotideAlignmentFile performs a merge with any union data inside the NucleotideConsensusAlignmentCreate_Files_Item, using the provided NucleotideAlignmentFile
func (t *NucleotideConsensusAlignmentCreate_Files_Item) MergeNucleotideAlignmentFile(v NucleotideAlignmentFile) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t NucleotideConsensusAlignmentCreate_Files_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NucleotideConsensusAlignmentCreate_Files_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNucleotideTemplateAlignmentCreateFiles0 returns the union data inside the NucleotideTemplateAlignmentCreate_Files_Item as a NucleotideTemplateAlignmentCreateFiles0
func (t NucleotideTemplateAlignmentCreate_Files_Item) AsNucleotideTemplateAlignmentCreateFiles0() (NucleotideTemplateAlignmentCreateFiles0, error) {
	var body NucleotideTemplateAlignmentCreateFiles0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNucleotideTemplateAlignmentCreateFiles0 overwrites any union data inside the NucleotideTemplateAlignmentCreate_Files_Item as the provided NucleotideTemplateAlignmentCreateFiles0
func (t *NucleotideTemplateAlignmentCreate_Files_Item) FromNucleotideTemplateAlignmentCreateFiles0(v NucleotideTemplateAlignmentCreateFiles0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNucleotideTemplateAlignmentCreateFiles0 performs a merge with any union data inside the NucleotideTemplateAlignmentCreate_Files_Item, using the provided NucleotideTemplateAlignmentCreateFiles0
func (t *NucleotideTemplateAlignmentCreate_Files_Item) MergeNucleotideTemplateAlignmentCreateFiles0(v NucleotideTemplateAlignmentCreateFiles0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsNucleotideAlignmentFile returns the union data inside the NucleotideTemplateAlignmentCreate_Files_Item as a NucleotideAlignmentFile
func (t NucleotideTemplateAlignmentCreate_Files_Item) AsNucleotideAlignmentFile() (NucleotideAlignmentFile, error) {
	var body NucleotideAlignmentFile
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNucleotideAlignmentFile overwrites any union data inside the NucleotideTemplateAlignmentCreate_Files_Item as the provided NucleotideAlignmentFile
func (t *NucleotideTemplateAlignmentCreate_Files_Item) FromNucleotideAlignmentFile(v NucleotideAlignmentFile) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNucleotideAlignmentFile performs a merge with any union data inside the NucleotideTemplateAlignmentCreate_Files_Item, using the provided NucleotideAlignmentFile
func (t *NucleotideTemplateAlignmentCreate_Files_Item) MergeNucleotideAlignmentFile(v NucleotideAlignmentFile) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t NucleotideTemplateAlignmentCreate_Files_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NucleotideTemplateAlignmentCreate_Files_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDnaOligo returns the union data inside the OligosBulkGet_Oligos_Item as a DnaOligo
func (t OligosBulkGet_Oligos_Item) AsDnaOligo() (DnaOligo, error) {
	var body DnaOligo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnaOligo overwrites any union data inside the OligosBulkGet_Oligos_Item as the provided DnaOligo
func (t *OligosBulkGet_Oligos_Item) FromDnaOligo(v DnaOligo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnaOligo performs a merge with any union data inside the OligosBulkGet_Oligos_Item, using the provided DnaOligo
func (t *OligosBulkGet_Oligos_Item) MergeDnaOligo(v DnaOligo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRnaOligo returns the union data inside the OligosBulkGet_Oligos_Item as a RnaOligo
func (t OligosBulkGet_Oligos_Item) AsRnaOligo() (RnaOligo, error) {
	var body RnaOligo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRnaOligo overwrites any union data inside the OligosBulkGet_Oligos_Item as the provided RnaOligo
func (t *OligosBulkGet_Oligos_Item) FromRnaOligo(v RnaOligo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRnaOligo performs a merge with any union data inside the OligosBulkGet_Oligos_Item, using the provided RnaOligo
func (t *OligosBulkGet_Oligos_Item) MergeRnaOligo(v RnaOligo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t OligosBulkGet_Oligos_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OligosBulkGet_Oligos_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSimpleFieldDefinition returns the union data inside the PlateSchema_FieldDefinitions_Item as a SimpleFieldDefinition
func (t PlateSchema_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the PlateSchema_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *PlateSchema_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the PlateSchema_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *PlateSchema_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the PlateSchema_FieldDefinitions_Item as a IntegerFieldDefinition
func (t PlateSchema_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the PlateSchema_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *PlateSchema_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the PlateSchema_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *PlateSchema_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the PlateSchema_FieldDefinitions_Item as a FloatFieldDefinition
func (t PlateSchema_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the PlateSchema_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *PlateSchema_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the PlateSchema_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *PlateSchema_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the PlateSchema_FieldDefinitions_Item as a DropdownFieldDefinition
func (t PlateSchema_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the PlateSchema_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *PlateSchema_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the PlateSchema_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *PlateSchema_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the PlateSchema_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t PlateSchema_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the PlateSchema_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *PlateSchema_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the PlateSchema_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *PlateSchema_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t PlateSchema_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PlateSchema_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOrganization returns the union data inside the Project_Owner as a Organization
func (t Project_Owner) AsOrganization() (Organization, error) {
	var body Organization
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOrganization overwrites any union data inside the Project_Owner as the provided Organization
func (t *Project_Owner) FromOrganization(v Organization) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOrganization performs a merge with any union data inside the Project_Owner, using the provided Organization
func (t *Project_Owner) MergeOrganization(v Organization) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsUserSummary returns the union data inside the Project_Owner as a UserSummary
func (t Project_Owner) AsUserSummary() (UserSummary, error) {
	var body UserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserSummary overwrites any union data inside the Project_Owner as the provided UserSummary
func (t *Project_Owner) FromUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserSummary performs a merge with any union data inside the Project_Owner, using the provided UserSummary
func (t *Project_Owner) MergeUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Project_Owner) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Project_Owner) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDnaSequenceWithEntityType returns the union data inside the RegisteredEntitiesList_Entities_Item as a DnaSequenceWithEntityType
func (t RegisteredEntitiesList_Entities_Item) AsDnaSequenceWithEntityType() (DnaSequenceWithEntityType, error) {
	var body DnaSequenceWithEntityType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnaSequenceWithEntityType overwrites any union data inside the RegisteredEntitiesList_Entities_Item as the provided DnaSequenceWithEntityType
func (t *RegisteredEntitiesList_Entities_Item) FromDnaSequenceWithEntityType(v DnaSequenceWithEntityType) error {
	t.EntityType = "dna_sequence"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnaSequenceWithEntityType performs a merge with any union data inside the RegisteredEntitiesList_Entities_Item, using the provided DnaSequenceWithEntityType
func (t *RegisteredEntitiesList_Entities_Item) MergeDnaSequenceWithEntityType(v DnaSequenceWithEntityType) error {
	t.EntityType = "dna_sequence"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsCustomEntityWithEntityType returns the union data inside the RegisteredEntitiesList_Entities_Item as a CustomEntityWithEntityType
func (t RegisteredEntitiesList_Entities_Item) AsCustomEntityWithEntityType() (CustomEntityWithEntityType, error) {
	var body CustomEntityWithEntityType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCustomEntityWithEntityType overwrites any union data inside the RegisteredEntitiesList_Entities_Item as the provided CustomEntityWithEntityType
func (t *RegisteredEntitiesList_Entities_Item) FromCustomEntityWithEntityType(v CustomEntityWithEntityType) error {
	t.EntityType = "custom_entity"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCustomEntityWithEntityType performs a merge with any union data inside the RegisteredEntitiesList_Entities_Item, using the provided CustomEntityWithEntityType
func (t *RegisteredEntitiesList_Entities_Item) MergeCustomEntityWithEntityType(v CustomEntityWithEntityType) error {
	t.EntityType = "custom_entity"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsAaSequenceWithEntityType returns the union data inside the RegisteredEntitiesList_Entities_Item as a AaSequenceWithEntityType
func (t RegisteredEntitiesList_Entities_Item) AsAaSequenceWithEntityType() (AaSequenceWithEntityType, error) {
	var body AaSequenceWithEntityType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAaSequenceWithEntityType overwrites any union data inside the RegisteredEntitiesList_Entities_Item as the provided AaSequenceWithEntityType
func (t *RegisteredEntitiesList_Entities_Item) FromAaSequenceWithEntityType(v AaSequenceWithEntityType) error {
	t.EntityType = "aa_sequence"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAaSequenceWithEntityType performs a merge with any union data inside the RegisteredEntitiesList_Entities_Item, using the provided AaSequenceWithEntityType
func (t *RegisteredEntitiesList_Entities_Item) MergeAaSequenceWithEntityType(v AaSequenceWithEntityType) error {
	t.EntityType = "aa_sequence"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMixtureWithEntityType returns the union data inside the RegisteredEntitiesList_Entities_Item as a MixtureWithEntityType
func (t RegisteredEntitiesList_Entities_Item) AsMixtureWithEntityType() (MixtureWithEntityType, error) {
	var body MixtureWithEntityType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMixtureWithEntityType overwrites any union data inside the RegisteredEntitiesList_Entities_Item as the provided MixtureWithEntityType
func (t *RegisteredEntitiesList_Entities_Item) FromMixtureWithEntityType(v MixtureWithEntityType) error {
	t.EntityType = "mixture"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMixtureWithEntityType performs a merge with any union data inside the RegisteredEntitiesList_Entities_Item, using the provided MixtureWithEntityType
func (t *RegisteredEntitiesList_Entities_Item) MergeMixtureWithEntityType(v MixtureWithEntityType) error {
	t.EntityType = "mixture"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDnaOligoWithEntityType returns the union data inside the RegisteredEntitiesList_Entities_Item as a DnaOligoWithEntityType
func (t RegisteredEntitiesList_Entities_Item) AsDnaOligoWithEntityType() (DnaOligoWithEntityType, error) {
	var body DnaOligoWithEntityType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDnaOligoWithEntityType overwrites any union data inside the RegisteredEntitiesList_Entities_Item as the provided DnaOligoWithEntityType
func (t *RegisteredEntitiesList_Entities_Item) FromDnaOligoWithEntityType(v DnaOligoWithEntityType) error {
	t.EntityType = "dna_oligo"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDnaOligoWithEntityType performs a merge with any union data inside the RegisteredEntitiesList_Entities_Item, using the provided DnaOligoWithEntityType
func (t *RegisteredEntitiesList_Entities_Item) MergeDnaOligoWithEntityType(v DnaOligoWithEntityType) error {
	t.EntityType = "dna_oligo"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRnaOligoWithEntityType returns the union data inside the RegisteredEntitiesList_Entities_Item as a RnaOligoWithEntityType
func (t RegisteredEntitiesList_Entities_Item) AsRnaOligoWithEntityType() (RnaOligoWithEntityType, error) {
	var body RnaOligoWithEntityType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRnaOligoWithEntityType overwrites any union data inside the RegisteredEntitiesList_Entities_Item as the provided RnaOligoWithEntityType
func (t *RegisteredEntitiesList_Entities_Item) FromRnaOligoWithEntityType(v RnaOligoWithEntityType) error {
	t.EntityType = "rna_oligo"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRnaOligoWithEntityType performs a merge with any union data inside the RegisteredEntitiesList_Entities_Item, using the provided RnaOligoWithEntityType
func (t *RegisteredEntitiesList_Entities_Item) MergeRnaOligoWithEntityType(v RnaOligoWithEntityType) error {
	t.EntityType = "rna_oligo"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t RegisteredEntitiesList_Entities_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"entityType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RegisteredEntitiesList_Entities_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "aa_sequence":
		return t.AsAaSequenceWithEntityType()
	case "custom_entity":
		return t.AsCustomEntityWithEntityType()
	case "dna_oligo":
		return t.AsDnaOligoWithEntityType()
	case "dna_sequence":
		return t.AsDnaSequenceWithEntityType()
	case "mixture":
		return t.AsMixtureWithEntityType()
	case "rna_oligo":
		return t.AsRnaOligoWithEntityType()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RegisteredEntitiesList_Entities_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["entityType"], err = json.Marshal(t.EntityType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'entityType': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *RegisteredEntitiesList_Entities_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["entityType"]; found {
		err = json.Unmarshal(raw, &t.EntityType)
		if err != nil {
			return fmt.Errorf("error reading 'entityType': %w", err)
		}
	}

	return err
}

// AsSimpleFieldDefinition returns the union data inside the RegistrySchema_FieldDefinitions_Item as a SimpleFieldDefinition
func (t RegistrySchema_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the RegistrySchema_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *RegistrySchema_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the RegistrySchema_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *RegistrySchema_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the RegistrySchema_FieldDefinitions_Item as a IntegerFieldDefinition
func (t RegistrySchema_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the RegistrySchema_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *RegistrySchema_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the RegistrySchema_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *RegistrySchema_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the RegistrySchema_FieldDefinitions_Item as a FloatFieldDefinition
func (t RegistrySchema_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the RegistrySchema_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *RegistrySchema_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the RegistrySchema_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *RegistrySchema_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the RegistrySchema_FieldDefinitions_Item as a DropdownFieldDefinition
func (t RegistrySchema_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the RegistrySchema_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *RegistrySchema_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the RegistrySchema_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *RegistrySchema_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the RegistrySchema_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t RegistrySchema_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the RegistrySchema_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *RegistrySchema_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the RegistrySchema_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *RegistrySchema_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t RegistrySchema_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RegistrySchema_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRequestUserAssignee returns the union data inside the Request_Assignees_Item as a RequestUserAssignee
func (t Request_Assignees_Item) AsRequestUserAssignee() (RequestUserAssignee, error) {
	var body RequestUserAssignee
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestUserAssignee overwrites any union data inside the Request_Assignees_Item as the provided RequestUserAssignee
func (t *Request_Assignees_Item) FromRequestUserAssignee(v RequestUserAssignee) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestUserAssignee performs a merge with any union data inside the Request_Assignees_Item, using the provided RequestUserAssignee
func (t *Request_Assignees_Item) MergeRequestUserAssignee(v RequestUserAssignee) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRequestTeamAssignee returns the union data inside the Request_Assignees_Item as a RequestTeamAssignee
func (t Request_Assignees_Item) AsRequestTeamAssignee() (RequestTeamAssignee, error) {
	var body RequestTeamAssignee
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestTeamAssignee overwrites any union data inside the Request_Assignees_Item as the provided RequestTeamAssignee
func (t *Request_Assignees_Item) FromRequestTeamAssignee(v RequestTeamAssignee) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestTeamAssignee performs a merge with any union data inside the Request_Assignees_Item, using the provided RequestTeamAssignee
func (t *Request_Assignees_Item) MergeRequestTeamAssignee(v RequestTeamAssignee) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Request_Assignees_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Request_Assignees_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRequestWriteUserAssignee returns the union data inside the RequestCreate_Assignees_Item as a RequestWriteUserAssignee
func (t RequestCreate_Assignees_Item) AsRequestWriteUserAssignee() (RequestWriteUserAssignee, error) {
	var body RequestWriteUserAssignee
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestWriteUserAssignee overwrites any union data inside the RequestCreate_Assignees_Item as the provided RequestWriteUserAssignee
func (t *RequestCreate_Assignees_Item) FromRequestWriteUserAssignee(v RequestWriteUserAssignee) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestWriteUserAssignee performs a merge with any union data inside the RequestCreate_Assignees_Item, using the provided RequestWriteUserAssignee
func (t *RequestCreate_Assignees_Item) MergeRequestWriteUserAssignee(v RequestWriteUserAssignee) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRequestWriteTeamAssignee returns the union data inside the RequestCreate_Assignees_Item as a RequestWriteTeamAssignee
func (t RequestCreate_Assignees_Item) AsRequestWriteTeamAssignee() (RequestWriteTeamAssignee, error) {
	var body RequestWriteTeamAssignee
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestWriteTeamAssignee overwrites any union data inside the RequestCreate_Assignees_Item as the provided RequestWriteTeamAssignee
func (t *RequestCreate_Assignees_Item) FromRequestWriteTeamAssignee(v RequestWriteTeamAssignee) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestWriteTeamAssignee performs a merge with any union data inside the RequestCreate_Assignees_Item, using the provided RequestWriteTeamAssignee
func (t *RequestCreate_Assignees_Item) MergeRequestWriteTeamAssignee(v RequestWriteTeamAssignee) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t RequestCreate_Assignees_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RequestCreate_Assignees_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRequestSampleWithEntity returns the union data inside the RequestSampleGroupSamples_AdditionalProperties as a RequestSampleWithEntity
func (t RequestSampleGroupSamples_AdditionalProperties) AsRequestSampleWithEntity() (RequestSampleWithEntity, error) {
	var body RequestSampleWithEntity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestSampleWithEntity overwrites any union data inside the RequestSampleGroupSamples_AdditionalProperties as the provided RequestSampleWithEntity
func (t *RequestSampleGroupSamples_AdditionalProperties) FromRequestSampleWithEntity(v RequestSampleWithEntity) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestSampleWithEntity performs a merge with any union data inside the RequestSampleGroupSamples_AdditionalProperties, using the provided RequestSampleWithEntity
func (t *RequestSampleGroupSamples_AdditionalProperties) MergeRequestSampleWithEntity(v RequestSampleWithEntity) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRequestSampleWithBatch returns the union data inside the RequestSampleGroupSamples_AdditionalProperties as a RequestSampleWithBatch
func (t RequestSampleGroupSamples_AdditionalProperties) AsRequestSampleWithBatch() (RequestSampleWithBatch, error) {
	var body RequestSampleWithBatch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestSampleWithBatch overwrites any union data inside the RequestSampleGroupSamples_AdditionalProperties as the provided RequestSampleWithBatch
func (t *RequestSampleGroupSamples_AdditionalProperties) FromRequestSampleWithBatch(v RequestSampleWithBatch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestSampleWithBatch performs a merge with any union data inside the RequestSampleGroupSamples_AdditionalProperties, using the provided RequestSampleWithBatch
func (t *RequestSampleGroupSamples_AdditionalProperties) MergeRequestSampleWithBatch(v RequestSampleWithBatch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t RequestSampleGroupSamples_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RequestSampleGroupSamples_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSimpleFieldDefinition returns the union data inside the RequestSchema_FieldDefinitions_Item as a SimpleFieldDefinition
func (t RequestSchema_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the RequestSchema_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *RequestSchema_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the RequestSchema_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *RequestSchema_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the RequestSchema_FieldDefinitions_Item as a IntegerFieldDefinition
func (t RequestSchema_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the RequestSchema_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *RequestSchema_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the RequestSchema_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *RequestSchema_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the RequestSchema_FieldDefinitions_Item as a FloatFieldDefinition
func (t RequestSchema_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the RequestSchema_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *RequestSchema_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the RequestSchema_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *RequestSchema_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the RequestSchema_FieldDefinitions_Item as a DropdownFieldDefinition
func (t RequestSchema_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the RequestSchema_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *RequestSchema_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the RequestSchema_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *RequestSchema_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the RequestSchema_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t RequestSchema_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the RequestSchema_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *RequestSchema_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the RequestSchema_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *RequestSchema_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t RequestSchema_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RequestSchema_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSimpleFieldDefinition returns the union data inside the RequestTaskSchema_FieldDefinitions_Item as a SimpleFieldDefinition
func (t RequestTaskSchema_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the RequestTaskSchema_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *RequestTaskSchema_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the RequestTaskSchema_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *RequestTaskSchema_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the RequestTaskSchema_FieldDefinitions_Item as a IntegerFieldDefinition
func (t RequestTaskSchema_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the RequestTaskSchema_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *RequestTaskSchema_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the RequestTaskSchema_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *RequestTaskSchema_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the RequestTaskSchema_FieldDefinitions_Item as a FloatFieldDefinition
func (t RequestTaskSchema_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the RequestTaskSchema_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *RequestTaskSchema_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the RequestTaskSchema_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *RequestTaskSchema_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the RequestTaskSchema_FieldDefinitions_Item as a DropdownFieldDefinition
func (t RequestTaskSchema_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the RequestTaskSchema_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *RequestTaskSchema_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the RequestTaskSchema_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *RequestTaskSchema_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the RequestTaskSchema_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t RequestTaskSchema_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the RequestTaskSchema_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *RequestTaskSchema_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the RequestTaskSchema_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *RequestTaskSchema_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t RequestTaskSchema_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RequestTaskSchema_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRequestWriteUserAssignee returns the union data inside the RequestUpdate_Assignees_Item as a RequestWriteUserAssignee
func (t RequestUpdate_Assignees_Item) AsRequestWriteUserAssignee() (RequestWriteUserAssignee, error) {
	var body RequestWriteUserAssignee
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestWriteUserAssignee overwrites any union data inside the RequestUpdate_Assignees_Item as the provided RequestWriteUserAssignee
func (t *RequestUpdate_Assignees_Item) FromRequestWriteUserAssignee(v RequestWriteUserAssignee) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestWriteUserAssignee performs a merge with any union data inside the RequestUpdate_Assignees_Item, using the provided RequestWriteUserAssignee
func (t *RequestUpdate_Assignees_Item) MergeRequestWriteUserAssignee(v RequestWriteUserAssignee) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRequestWriteTeamAssignee returns the union data inside the RequestUpdate_Assignees_Item as a RequestWriteTeamAssignee
func (t RequestUpdate_Assignees_Item) AsRequestWriteTeamAssignee() (RequestWriteTeamAssignee, error) {
	var body RequestWriteTeamAssignee
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestWriteTeamAssignee overwrites any union data inside the RequestUpdate_Assignees_Item as the provided RequestWriteTeamAssignee
func (t *RequestUpdate_Assignees_Item) FromRequestWriteTeamAssignee(v RequestWriteTeamAssignee) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestWriteTeamAssignee performs a merge with any union data inside the RequestUpdate_Assignees_Item, using the provided RequestWriteTeamAssignee
func (t *RequestUpdate_Assignees_Item) MergeRequestWriteTeamAssignee(v RequestWriteTeamAssignee) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t RequestUpdate_Assignees_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RequestUpdate_Assignees_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRequestWriteUserAssignee returns the union data inside the RequestWriteBase_Assignees_Item as a RequestWriteUserAssignee
func (t RequestWriteBase_Assignees_Item) AsRequestWriteUserAssignee() (RequestWriteUserAssignee, error) {
	var body RequestWriteUserAssignee
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestWriteUserAssignee overwrites any union data inside the RequestWriteBase_Assignees_Item as the provided RequestWriteUserAssignee
func (t *RequestWriteBase_Assignees_Item) FromRequestWriteUserAssignee(v RequestWriteUserAssignee) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestWriteUserAssignee performs a merge with any union data inside the RequestWriteBase_Assignees_Item, using the provided RequestWriteUserAssignee
func (t *RequestWriteBase_Assignees_Item) MergeRequestWriteUserAssignee(v RequestWriteUserAssignee) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsRequestWriteTeamAssignee returns the union data inside the RequestWriteBase_Assignees_Item as a RequestWriteTeamAssignee
func (t RequestWriteBase_Assignees_Item) AsRequestWriteTeamAssignee() (RequestWriteTeamAssignee, error) {
	var body RequestWriteTeamAssignee
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestWriteTeamAssignee overwrites any union data inside the RequestWriteBase_Assignees_Item as the provided RequestWriteTeamAssignee
func (t *RequestWriteBase_Assignees_Item) FromRequestWriteTeamAssignee(v RequestWriteTeamAssignee) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestWriteTeamAssignee performs a merge with any union data inside the RequestWriteBase_Assignees_Item, using the provided RequestWriteTeamAssignee
func (t *RequestWriteBase_Assignees_Item) MergeRequestWriteTeamAssignee(v RequestWriteTeamAssignee) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t RequestWriteBase_Assignees_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RequestWriteBase_Assignees_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSimpleFieldDefinition returns the union data inside the Schema_FieldDefinitions_Item as a SimpleFieldDefinition
func (t Schema_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the Schema_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *Schema_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the Schema_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *Schema_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the Schema_FieldDefinitions_Item as a IntegerFieldDefinition
func (t Schema_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the Schema_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *Schema_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the Schema_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *Schema_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the Schema_FieldDefinitions_Item as a FloatFieldDefinition
func (t Schema_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the Schema_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *Schema_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the Schema_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *Schema_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the Schema_FieldDefinitions_Item as a DropdownFieldDefinition
func (t Schema_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the Schema_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *Schema_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the Schema_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *Schema_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the Schema_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t Schema_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the Schema_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *Schema_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the Schema_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *Schema_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Schema_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Schema_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsButtonUiBlock returns the union data inside the SectionUiBlock_Children_Item as a ButtonUiBlock
func (t SectionUiBlock_Children_Item) AsButtonUiBlock() (ButtonUiBlock, error) {
	var body ButtonUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromButtonUiBlock overwrites any union data inside the SectionUiBlock_Children_Item as the provided ButtonUiBlock
func (t *SectionUiBlock_Children_Item) FromButtonUiBlock(v ButtonUiBlock) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeButtonUiBlock performs a merge with any union data inside the SectionUiBlock_Children_Item, using the provided ButtonUiBlock
func (t *SectionUiBlock_Children_Item) MergeButtonUiBlock(v ButtonUiBlock) error {
	t.Type = "BUTTON"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsChipUiBlock returns the union data inside the SectionUiBlock_Children_Item as a ChipUiBlock
func (t SectionUiBlock_Children_Item) AsChipUiBlock() (ChipUiBlock, error) {
	var body ChipUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChipUiBlock overwrites any union data inside the SectionUiBlock_Children_Item as the provided ChipUiBlock
func (t *SectionUiBlock_Children_Item) FromChipUiBlock(v ChipUiBlock) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChipUiBlock performs a merge with any union data inside the SectionUiBlock_Children_Item, using the provided ChipUiBlock
func (t *SectionUiBlock_Children_Item) MergeChipUiBlock(v ChipUiBlock) error {
	t.Type = "CHIP"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownUiBlock returns the union data inside the SectionUiBlock_Children_Item as a DropdownUiBlock
func (t SectionUiBlock_Children_Item) AsDropdownUiBlock() (DropdownUiBlock, error) {
	var body DropdownUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownUiBlock overwrites any union data inside the SectionUiBlock_Children_Item as the provided DropdownUiBlock
func (t *SectionUiBlock_Children_Item) FromDropdownUiBlock(v DropdownUiBlock) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownUiBlock performs a merge with any union data inside the SectionUiBlock_Children_Item, using the provided DropdownUiBlock
func (t *SectionUiBlock_Children_Item) MergeDropdownUiBlock(v DropdownUiBlock) error {
	t.Type = "DROPDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownMultiValueUiBlock returns the union data inside the SectionUiBlock_Children_Item as a DropdownMultiValueUiBlock
func (t SectionUiBlock_Children_Item) AsDropdownMultiValueUiBlock() (DropdownMultiValueUiBlock, error) {
	var body DropdownMultiValueUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownMultiValueUiBlock overwrites any union data inside the SectionUiBlock_Children_Item as the provided DropdownMultiValueUiBlock
func (t *SectionUiBlock_Children_Item) FromDropdownMultiValueUiBlock(v DropdownMultiValueUiBlock) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownMultiValueUiBlock performs a merge with any union data inside the SectionUiBlock_Children_Item, using the provided DropdownMultiValueUiBlock
func (t *SectionUiBlock_Children_Item) MergeDropdownMultiValueUiBlock(v DropdownMultiValueUiBlock) error {
	t.Type = "DROPDOWN_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsMarkdownUiBlock returns the union data inside the SectionUiBlock_Children_Item as a MarkdownUiBlock
func (t SectionUiBlock_Children_Item) AsMarkdownUiBlock() (MarkdownUiBlock, error) {
	var body MarkdownUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMarkdownUiBlock overwrites any union data inside the SectionUiBlock_Children_Item as the provided MarkdownUiBlock
func (t *SectionUiBlock_Children_Item) FromMarkdownUiBlock(v MarkdownUiBlock) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMarkdownUiBlock performs a merge with any union data inside the SectionUiBlock_Children_Item, using the provided MarkdownUiBlock
func (t *SectionUiBlock_Children_Item) MergeMarkdownUiBlock(v MarkdownUiBlock) error {
	t.Type = "MARKDOWN"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputUiBlock returns the union data inside the SectionUiBlock_Children_Item as a SearchInputUiBlock
func (t SectionUiBlock_Children_Item) AsSearchInputUiBlock() (SearchInputUiBlock, error) {
	var body SearchInputUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputUiBlock overwrites any union data inside the SectionUiBlock_Children_Item as the provided SearchInputUiBlock
func (t *SectionUiBlock_Children_Item) FromSearchInputUiBlock(v SearchInputUiBlock) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputUiBlock performs a merge with any union data inside the SectionUiBlock_Children_Item, using the provided SearchInputUiBlock
func (t *SectionUiBlock_Children_Item) MergeSearchInputUiBlock(v SearchInputUiBlock) error {
	t.Type = "SEARCH_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchInputMultiValueUiBlock returns the union data inside the SectionUiBlock_Children_Item as a SearchInputMultiValueUiBlock
func (t SectionUiBlock_Children_Item) AsSearchInputMultiValueUiBlock() (SearchInputMultiValueUiBlock, error) {
	var body SearchInputMultiValueUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchInputMultiValueUiBlock overwrites any union data inside the SectionUiBlock_Children_Item as the provided SearchInputMultiValueUiBlock
func (t *SectionUiBlock_Children_Item) FromSearchInputMultiValueUiBlock(v SearchInputMultiValueUiBlock) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchInputMultiValueUiBlock performs a merge with any union data inside the SectionUiBlock_Children_Item, using the provided SearchInputMultiValueUiBlock
func (t *SectionUiBlock_Children_Item) MergeSearchInputMultiValueUiBlock(v SearchInputMultiValueUiBlock) error {
	t.Type = "SEARCH_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputUiBlock returns the union data inside the SectionUiBlock_Children_Item as a SelectorInputUiBlock
func (t SectionUiBlock_Children_Item) AsSelectorInputUiBlock() (SelectorInputUiBlock, error) {
	var body SelectorInputUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputUiBlock overwrites any union data inside the SectionUiBlock_Children_Item as the provided SelectorInputUiBlock
func (t *SectionUiBlock_Children_Item) FromSelectorInputUiBlock(v SelectorInputUiBlock) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputUiBlock performs a merge with any union data inside the SectionUiBlock_Children_Item, using the provided SelectorInputUiBlock
func (t *SectionUiBlock_Children_Item) MergeSelectorInputUiBlock(v SelectorInputUiBlock) error {
	t.Type = "SELECTOR_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSelectorInputMultiValueUiBlock returns the union data inside the SectionUiBlock_Children_Item as a SelectorInputMultiValueUiBlock
func (t SectionUiBlock_Children_Item) AsSelectorInputMultiValueUiBlock() (SelectorInputMultiValueUiBlock, error) {
	var body SelectorInputMultiValueUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSelectorInputMultiValueUiBlock overwrites any union data inside the SectionUiBlock_Children_Item as the provided SelectorInputMultiValueUiBlock
func (t *SectionUiBlock_Children_Item) FromSelectorInputMultiValueUiBlock(v SelectorInputMultiValueUiBlock) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSelectorInputMultiValueUiBlock performs a merge with any union data inside the SectionUiBlock_Children_Item, using the provided SelectorInputMultiValueUiBlock
func (t *SectionUiBlock_Children_Item) MergeSelectorInputMultiValueUiBlock(v SelectorInputMultiValueUiBlock) error {
	t.Type = "SELECTOR_INPUT_MULTIVALUE"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTextInputUiBlock returns the union data inside the SectionUiBlock_Children_Item as a TextInputUiBlock
func (t SectionUiBlock_Children_Item) AsTextInputUiBlock() (TextInputUiBlock, error) {
	var body TextInputUiBlock
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTextInputUiBlock overwrites any union data inside the SectionUiBlock_Children_Item as the provided TextInputUiBlock
func (t *SectionUiBlock_Children_Item) FromTextInputUiBlock(v TextInputUiBlock) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTextInputUiBlock performs a merge with any union data inside the SectionUiBlock_Children_Item, using the provided TextInputUiBlock
func (t *SectionUiBlock_Children_Item) MergeTextInputUiBlock(v TextInputUiBlock) error {
	t.Type = "TEXT_INPUT"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t SectionUiBlock_Children_Item) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SectionUiBlock_Children_Item) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "BUTTON":
		return t.AsButtonUiBlock()
	case "CHIP":
		return t.AsChipUiBlock()
	case "DROPDOWN":
		return t.AsDropdownUiBlock()
	case "DROPDOWN_MULTIVALUE":
		return t.AsDropdownMultiValueUiBlock()
	case "MARKDOWN":
		return t.AsMarkdownUiBlock()
	case "SEARCH_INPUT":
		return t.AsSearchInputUiBlock()
	case "SEARCH_INPUT_MULTIVALUE":
		return t.AsSearchInputMultiValueUiBlock()
	case "SELECTOR_INPUT":
		return t.AsSelectorInputUiBlock()
	case "SELECTOR_INPUT_MULTIVALUE":
		return t.AsSelectorInputMultiValueUiBlock()
	case "TEXT_INPUT":
		return t.AsTextInputUiBlock()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SectionUiBlock_Children_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *SectionUiBlock_Children_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsTableUiBlockDatasetSource returns the union data inside the TableUiBlockSource as a TableUiBlockDatasetSource
func (t TableUiBlockSource) AsTableUiBlockDatasetSource() (TableUiBlockDatasetSource, error) {
	var body TableUiBlockDatasetSource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTableUiBlockDatasetSource overwrites any union data inside the TableUiBlockSource as the provided TableUiBlockDatasetSource
func (t *TableUiBlockSource) FromTableUiBlockDatasetSource(v TableUiBlockDatasetSource) error {
	t.Type = "DATASET"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTableUiBlockDatasetSource performs a merge with any union data inside the TableUiBlockSource, using the provided TableUiBlockDatasetSource
func (t *TableUiBlockSource) MergeTableUiBlockDatasetSource(v TableUiBlockDatasetSource) error {
	t.Type = "DATASET"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTableUiBlockDataFrameSource returns the union data inside the TableUiBlockSource as a TableUiBlockDataFrameSource
func (t TableUiBlockSource) AsTableUiBlockDataFrameSource() (TableUiBlockDataFrameSource, error) {
	var body TableUiBlockDataFrameSource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTableUiBlockDataFrameSource overwrites any union data inside the TableUiBlockSource as the provided TableUiBlockDataFrameSource
func (t *TableUiBlockSource) FromTableUiBlockDataFrameSource(v TableUiBlockDataFrameSource) error {
	t.Type = "DATA_FRAME"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTableUiBlockDataFrameSource performs a merge with any union data inside the TableUiBlockSource, using the provided TableUiBlockDataFrameSource
func (t *TableUiBlockSource) MergeTableUiBlockDataFrameSource(v TableUiBlockDataFrameSource) error {
	t.Type = "DATA_FRAME"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t TableUiBlockSource) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t TableUiBlockSource) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "DATASET":
		return t.AsTableUiBlockDatasetSource()
	case "DATA_FRAME":
		return t.AsTableUiBlockDataFrameSource()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t TableUiBlockSource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["type"], err = json.Marshal(t.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *TableUiBlockSource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &t.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
	}

	return err
}

// AsUserSummary returns the union data inside the Well_RestrictedSampleParties_Item as a UserSummary
func (t Well_RestrictedSampleParties_Item) AsUserSummary() (UserSummary, error) {
	var body UserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserSummary overwrites any union data inside the Well_RestrictedSampleParties_Item as the provided UserSummary
func (t *Well_RestrictedSampleParties_Item) FromUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserSummary performs a merge with any union data inside the Well_RestrictedSampleParties_Item, using the provided UserSummary
func (t *Well_RestrictedSampleParties_Item) MergeUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTeamSummary returns the union data inside the Well_RestrictedSampleParties_Item as a TeamSummary
func (t Well_RestrictedSampleParties_Item) AsTeamSummary() (TeamSummary, error) {
	var body TeamSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTeamSummary overwrites any union data inside the Well_RestrictedSampleParties_Item as the provided TeamSummary
func (t *Well_RestrictedSampleParties_Item) FromTeamSummary(v TeamSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTeamSummary performs a merge with any union data inside the Well_RestrictedSampleParties_Item, using the provided TeamSummary
func (t *Well_RestrictedSampleParties_Item) MergeTeamSummary(v TeamSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Well_RestrictedSampleParties_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Well_RestrictedSampleParties_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUserSummary returns the union data inside the Well_SampleOwners_Item as a UserSummary
func (t Well_SampleOwners_Item) AsUserSummary() (UserSummary, error) {
	var body UserSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUserSummary overwrites any union data inside the Well_SampleOwners_Item as the provided UserSummary
func (t *Well_SampleOwners_Item) FromUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUserSummary performs a merge with any union data inside the Well_SampleOwners_Item, using the provided UserSummary
func (t *Well_SampleOwners_Item) MergeUserSummary(v UserSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsTeamSummary returns the union data inside the Well_SampleOwners_Item as a TeamSummary
func (t Well_SampleOwners_Item) AsTeamSummary() (TeamSummary, error) {
	var body TeamSummary
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTeamSummary overwrites any union data inside the Well_SampleOwners_Item as the provided TeamSummary
func (t *Well_SampleOwners_Item) FromTeamSummary(v TeamSummary) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTeamSummary performs a merge with any union data inside the Well_SampleOwners_Item, using the provided TeamSummary
func (t *Well_SampleOwners_Item) MergeTeamSummary(v TeamSummary) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Well_SampleOwners_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Well_SampleOwners_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsWell returns the union data inside the WellOrInaccessibleResource as a Well
func (t WellOrInaccessibleResource) AsWell() (Well, error) {
	var body Well
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWell overwrites any union data inside the WellOrInaccessibleResource as the provided Well
func (t *WellOrInaccessibleResource) FromWell(v Well) error {
	t.ResourceType = "container"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWell performs a merge with any union data inside the WellOrInaccessibleResource, using the provided Well
func (t *WellOrInaccessibleResource) MergeWell(v Well) error {
	t.ResourceType = "container"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsInaccessibleResource returns the union data inside the WellOrInaccessibleResource as a InaccessibleResource
func (t WellOrInaccessibleResource) AsInaccessibleResource() (InaccessibleResource, error) {
	var body InaccessibleResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromInaccessibleResource overwrites any union data inside the WellOrInaccessibleResource as the provided InaccessibleResource
func (t *WellOrInaccessibleResource) FromInaccessibleResource(v InaccessibleResource) error {
	t.ResourceType = "inaccessible_resource"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeInaccessibleResource performs a merge with any union data inside the WellOrInaccessibleResource, using the provided InaccessibleResource
func (t *WellOrInaccessibleResource) MergeInaccessibleResource(v InaccessibleResource) error {
	t.ResourceType = "inaccessible_resource"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t WellOrInaccessibleResource) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"resourceType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t WellOrInaccessibleResource) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "container":
		return t.AsWell()
	case "inaccessible_resource":
		return t.AsInaccessibleResource()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t WellOrInaccessibleResource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["resourceType"], err = json.Marshal(t.ResourceType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'resourceType': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *WellOrInaccessibleResource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["resourceType"]; found {
		err = json.Unmarshal(raw, &t.ResourceType)
		if err != nil {
			return fmt.Errorf("error reading 'resourceType': %w", err)
		}
	}

	return err
}

// AsSimpleFieldDefinition returns the union data inside the WorkflowOutputSchema_FieldDefinitions_Item as a SimpleFieldDefinition
func (t WorkflowOutputSchema_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the WorkflowOutputSchema_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *WorkflowOutputSchema_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the WorkflowOutputSchema_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *WorkflowOutputSchema_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the WorkflowOutputSchema_FieldDefinitions_Item as a IntegerFieldDefinition
func (t WorkflowOutputSchema_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the WorkflowOutputSchema_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *WorkflowOutputSchema_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the WorkflowOutputSchema_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *WorkflowOutputSchema_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the WorkflowOutputSchema_FieldDefinitions_Item as a FloatFieldDefinition
func (t WorkflowOutputSchema_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the WorkflowOutputSchema_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *WorkflowOutputSchema_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the WorkflowOutputSchema_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *WorkflowOutputSchema_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the WorkflowOutputSchema_FieldDefinitions_Item as a DropdownFieldDefinition
func (t WorkflowOutputSchema_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the WorkflowOutputSchema_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *WorkflowOutputSchema_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the WorkflowOutputSchema_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *WorkflowOutputSchema_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the WorkflowOutputSchema_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t WorkflowOutputSchema_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the WorkflowOutputSchema_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *WorkflowOutputSchema_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the WorkflowOutputSchema_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *WorkflowOutputSchema_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t WorkflowOutputSchema_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *WorkflowOutputSchema_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSimpleFieldDefinition returns the union data inside the WorkflowTaskSchema_FieldDefinitions_Item as a SimpleFieldDefinition
func (t WorkflowTaskSchema_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the WorkflowTaskSchema_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *WorkflowTaskSchema_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the WorkflowTaskSchema_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *WorkflowTaskSchema_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the WorkflowTaskSchema_FieldDefinitions_Item as a IntegerFieldDefinition
func (t WorkflowTaskSchema_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the WorkflowTaskSchema_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *WorkflowTaskSchema_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the WorkflowTaskSchema_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *WorkflowTaskSchema_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the WorkflowTaskSchema_FieldDefinitions_Item as a FloatFieldDefinition
func (t WorkflowTaskSchema_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the WorkflowTaskSchema_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *WorkflowTaskSchema_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the WorkflowTaskSchema_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *WorkflowTaskSchema_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the WorkflowTaskSchema_FieldDefinitions_Item as a DropdownFieldDefinition
func (t WorkflowTaskSchema_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the WorkflowTaskSchema_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *WorkflowTaskSchema_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the WorkflowTaskSchema_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *WorkflowTaskSchema_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the WorkflowTaskSchema_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t WorkflowTaskSchema_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the WorkflowTaskSchema_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *WorkflowTaskSchema_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the WorkflowTaskSchema_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *WorkflowTaskSchema_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t WorkflowTaskSchema_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *WorkflowTaskSchema_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSimpleFieldDefinition returns the union data inside the WorkflowTaskSchemaBase_FieldDefinitions_Item as a SimpleFieldDefinition
func (t WorkflowTaskSchemaBase_FieldDefinitions_Item) AsSimpleFieldDefinition() (SimpleFieldDefinition, error) {
	var body SimpleFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSimpleFieldDefinition overwrites any union data inside the WorkflowTaskSchemaBase_FieldDefinitions_Item as the provided SimpleFieldDefinition
func (t *WorkflowTaskSchemaBase_FieldDefinitions_Item) FromSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSimpleFieldDefinition performs a merge with any union data inside the WorkflowTaskSchemaBase_FieldDefinitions_Item, using the provided SimpleFieldDefinition
func (t *WorkflowTaskSchemaBase_FieldDefinitions_Item) MergeSimpleFieldDefinition(v SimpleFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsIntegerFieldDefinition returns the union data inside the WorkflowTaskSchemaBase_FieldDefinitions_Item as a IntegerFieldDefinition
func (t WorkflowTaskSchemaBase_FieldDefinitions_Item) AsIntegerFieldDefinition() (IntegerFieldDefinition, error) {
	var body IntegerFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIntegerFieldDefinition overwrites any union data inside the WorkflowTaskSchemaBase_FieldDefinitions_Item as the provided IntegerFieldDefinition
func (t *WorkflowTaskSchemaBase_FieldDefinitions_Item) FromIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIntegerFieldDefinition performs a merge with any union data inside the WorkflowTaskSchemaBase_FieldDefinitions_Item, using the provided IntegerFieldDefinition
func (t *WorkflowTaskSchemaBase_FieldDefinitions_Item) MergeIntegerFieldDefinition(v IntegerFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFloatFieldDefinition returns the union data inside the WorkflowTaskSchemaBase_FieldDefinitions_Item as a FloatFieldDefinition
func (t WorkflowTaskSchemaBase_FieldDefinitions_Item) AsFloatFieldDefinition() (FloatFieldDefinition, error) {
	var body FloatFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFloatFieldDefinition overwrites any union data inside the WorkflowTaskSchemaBase_FieldDefinitions_Item as the provided FloatFieldDefinition
func (t *WorkflowTaskSchemaBase_FieldDefinitions_Item) FromFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFloatFieldDefinition performs a merge with any union data inside the WorkflowTaskSchemaBase_FieldDefinitions_Item, using the provided FloatFieldDefinition
func (t *WorkflowTaskSchemaBase_FieldDefinitions_Item) MergeFloatFieldDefinition(v FloatFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDropdownFieldDefinition returns the union data inside the WorkflowTaskSchemaBase_FieldDefinitions_Item as a DropdownFieldDefinition
func (t WorkflowTaskSchemaBase_FieldDefinitions_Item) AsDropdownFieldDefinition() (DropdownFieldDefinition, error) {
	var body DropdownFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDropdownFieldDefinition overwrites any union data inside the WorkflowTaskSchemaBase_FieldDefinitions_Item as the provided DropdownFieldDefinition
func (t *WorkflowTaskSchemaBase_FieldDefinitions_Item) FromDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDropdownFieldDefinition performs a merge with any union data inside the WorkflowTaskSchemaBase_FieldDefinitions_Item, using the provided DropdownFieldDefinition
func (t *WorkflowTaskSchemaBase_FieldDefinitions_Item) MergeDropdownFieldDefinition(v DropdownFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsSchemaLinkFieldDefinition returns the union data inside the WorkflowTaskSchemaBase_FieldDefinitions_Item as a SchemaLinkFieldDefinition
func (t WorkflowTaskSchemaBase_FieldDefinitions_Item) AsSchemaLinkFieldDefinition() (SchemaLinkFieldDefinition, error) {
	var body SchemaLinkFieldDefinition
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSchemaLinkFieldDefinition overwrites any union data inside the WorkflowTaskSchemaBase_FieldDefinitions_Item as the provided SchemaLinkFieldDefinition
func (t *WorkflowTaskSchemaBase_FieldDefinitions_Item) FromSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSchemaLinkFieldDefinition performs a merge with any union data inside the WorkflowTaskSchemaBase_FieldDefinitions_Item, using the provided SchemaLinkFieldDefinition
func (t *WorkflowTaskSchemaBase_FieldDefinitions_Item) MergeSchemaLinkFieldDefinition(v SchemaLinkFieldDefinition) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t WorkflowTaskSchemaBase_FieldDefinitions_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *WorkflowTaskSchemaBase_FieldDefinitions_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListAASequences request
	ListAASequences(ctx context.Context, params *ListAASequencesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAASequenceWithBody request with any body
	CreateAASequenceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAASequence(ctx context.Context, body CreateAASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAASequence request
	GetAASequence(ctx context.Context, aaSequenceId string, params *GetAASequenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAASequenceWithBody request with any body
	UpdateAASequenceWithBody(ctx context.Context, aaSequenceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAASequence(ctx context.Context, aaSequenceId string, body UpdateAASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveAASequencesWithBody request with any body
	ArchiveAASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveAASequences(ctx context.Context, body ArchiveAASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AutoAnnotateAaSequencesWithBody request with any body
	AutoAnnotateAaSequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AutoAnnotateAaSequences(ctx context.Context, body AutoAnnotateAaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateAASequencesWithBody request with any body
	BulkCreateAASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateAASequences(ctx context.Context, body BulkCreateAASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkGetAASequences request
	BulkGetAASequences(ctx context.Context, params *BulkGetAASequencesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateAASequencesWithBody request with any body
	BulkUpdateAASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateAASequences(ctx context.Context, body BulkUpdateAASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveAASequencesWithBody request with any body
	UnarchiveAASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveAASequences(ctx context.Context, body UnarchiveAASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAppCanvasWithBody request with any body
	CreateAppCanvasWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAppCanvas(ctx context.Context, body CreateAppCanvasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppCanvas request
	GetAppCanvas(ctx context.Context, canvasId string, params *GetAppCanvasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppCanvasWithBody request with any body
	UpdateAppCanvasWithBody(ctx context.Context, canvasId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAppCanvas(ctx context.Context, canvasId string, body UpdateAppCanvasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveAppCanvasesWithBody request with any body
	ArchiveAppCanvasesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveAppCanvases(ctx context.Context, body ArchiveAppCanvasesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveAppCanvasesWithBody request with any body
	UnarchiveAppCanvasesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveAppCanvases(ctx context.Context, body UnarchiveAppCanvasesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAppConfigurationItems request
	ListAppConfigurationItems(ctx context.Context, params *ListAppConfigurationItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAppConfigurationItemWithBody request with any body
	CreateAppConfigurationItemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAppConfigurationItem(ctx context.Context, body CreateAppConfigurationItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppConfigurationItemById request
	GetAppConfigurationItemById(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppConfigurationItemWithBody request with any body
	UpdateAppConfigurationItemWithBody(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAppConfigurationItem(ctx context.Context, itemId string, body UpdateAppConfigurationItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateAppConfigurationItemsWithBody request with any body
	BulkCreateAppConfigurationItemsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateAppConfigurationItems(ctx context.Context, body BulkCreateAppConfigurationItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateAppConfigurationItemsWithBody request with any body
	BulkUpdateAppConfigurationItemsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateAppConfigurationItems(ctx context.Context, body BulkUpdateAppConfigurationItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAppSessionWithBody request with any body
	CreateAppSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAppSession(ctx context.Context, body CreateAppSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppSessionById request
	GetAppSessionById(ctx context.Context, id string, params *GetAppSessionByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppSessionWithBody request with any body
	UpdateAppSessionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAppSession(ctx context.Context, id string, body UpdateAppSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBenchlingApps request
	ListBenchlingApps(ctx context.Context, params *ListBenchlingAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBenchlingAppWithBody request with any body
	CreateBenchlingAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBenchlingApp(ctx context.Context, body CreateBenchlingAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBenchlingAppByID request
	GetBenchlingAppByID(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchBenchlingAppWithBody request with any body
	PatchBenchlingAppWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchBenchlingApp(ctx context.Context, appId string, body PatchBenchlingAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveBenchlingAppsWithBody request with any body
	ArchiveBenchlingAppsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveBenchlingApps(ctx context.Context, body ArchiveBenchlingAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveBenchlingAppsWithBody request with any body
	UnarchiveBenchlingAppsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveBenchlingApps(ctx context.Context, body UnarchiveBenchlingAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssayResultSchemas request
	ListAssayResultSchemas(ctx context.Context, params *ListAssayResultSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResultSchema request
	GetResultSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssayResults request
	ListAssayResults(ctx context.Context, params *ListAssayResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAssayResultsWithBody request with any body
	CreateAssayResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAssayResults(ctx context.Context, body CreateAssayResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssayResult request
	GetAssayResult(ctx context.Context, assayResultId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveAssayResultsWithBody request with any body
	ArchiveAssayResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveAssayResults(ctx context.Context, body ArchiveAssayResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateAssayResultsWithBody request with any body
	BulkCreateAssayResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateAssayResults(ctx context.Context, body BulkCreateAssayResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkGetAssayResults request
	BulkGetAssayResults(ctx context.Context, params *BulkGetAssayResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveAssayResultsWithBody request with any body
	UnarchiveAssayResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveAssayResults(ctx context.Context, body UnarchiveAssayResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssayRunSchemas request
	ListAssayRunSchemas(ctx context.Context, params *ListAssayRunSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRunSchema request
	GetRunSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssayRuns request
	ListAssayRuns(ctx context.Context, params *ListAssayRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAssayRunsWithBody request with any body
	CreateAssayRunsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAssayRuns(ctx context.Context, body CreateAssayRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssayRun request
	GetAssayRun(ctx context.Context, assayRunId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAssayRunWithBody request with any body
	UpdateAssayRunWithBody(ctx context.Context, assayRunId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAssayRun(ctx context.Context, assayRunId string, body UpdateAssayRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAutomationInputGenerators request
	ListAutomationInputGenerators(ctx context.Context, assayRunId string, params *ListAutomationInputGeneratorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAutomationOutputProcessorsDeprecated request
	ListAutomationOutputProcessorsDeprecated(ctx context.Context, assayRunId string, params *ListAutomationOutputProcessorsDeprecatedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveAssayRunsWithBody request with any body
	ArchiveAssayRunsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveAssayRuns(ctx context.Context, body ArchiveAssayRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkGetAssayRuns request
	BulkGetAssayRuns(ctx context.Context, params *BulkGetAssayRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveAssayRunsWithBody request with any body
	UnarchiveAssayRunsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveAssayRuns(ctx context.Context, body UnarchiveAssayRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLabAutomationTransform request
	GetLabAutomationTransform(ctx context.Context, transformId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLabAutomationTransformWithBody request with any body
	UpdateLabAutomationTransformWithBody(ctx context.Context, transformId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLabAutomationTransform(ctx context.Context, transformId string, body UpdateLabAutomationTransformJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutomationInputGenerator request
	GetAutomationInputGenerator(ctx context.Context, inputGeneratorId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAutomationInputGeneratorWithBody request with any body
	UpdateAutomationInputGeneratorWithBody(ctx context.Context, inputGeneratorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAutomationInputGenerator(ctx context.Context, inputGeneratorId string, body UpdateAutomationInputGeneratorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateInputWithAutomationInputGenerator request
	GenerateInputWithAutomationInputGenerator(ctx context.Context, inputGeneratorId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAutomationOutputProcessors request
	ListAutomationOutputProcessors(ctx context.Context, params *ListAutomationOutputProcessorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAutomationOutputProcessorWithBody request with any body
	CreateAutomationOutputProcessorWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAutomationOutputProcessor(ctx context.Context, body CreateAutomationOutputProcessorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutomationOutputProcessor request
	GetAutomationOutputProcessor(ctx context.Context, outputProcessorId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAutomationOutputProcessorWithBody request with any body
	UpdateAutomationOutputProcessorWithBody(ctx context.Context, outputProcessorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAutomationOutputProcessor(ctx context.Context, outputProcessorId string, body UpdateAutomationOutputProcessorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProcessOutputWithAutomationOutputProcessor request
	ProcessOutputWithAutomationOutputProcessor(ctx context.Context, outputProcessorId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveAutomationOutputProcessorsWithBody request with any body
	ArchiveAutomationOutputProcessorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveAutomationOutputProcessors(ctx context.Context, body ArchiveAutomationOutputProcessorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveAutomationOutputProcessorsWithBody request with any body
	UnarchiveAutomationOutputProcessorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveAutomationOutputProcessors(ctx context.Context, body UnarchiveAutomationOutputProcessorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatchSchemas request
	ListBatchSchemas(ctx context.Context, params *ListBatchSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBatchSchema request
	GetBatchSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatches request
	ListBatches(ctx context.Context, params *ListBatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBatchWithBody request with any body
	CreateBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBatch(ctx context.Context, body CreateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBatch request
	GetBatch(ctx context.Context, batchId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBatchWithBody request with any body
	UpdateBatchWithBody(ctx context.Context, batchId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBatch(ctx context.Context, batchId string, body UpdateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveBatchesWithBody request with any body
	ArchiveBatchesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveBatches(ctx context.Context, body ArchiveBatchesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkGetBatches request
	BulkGetBatches(ctx context.Context, params *BulkGetBatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveBatchesWithBody request with any body
	UnarchiveBatchesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveBatches(ctx context.Context, body UnarchiveBatchesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBlobWithBody request with any body
	CreateBlobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBlob(ctx context.Context, body CreateBlobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlob request
	GetBlob(ctx context.Context, blobId string, params *GetBlobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlobFile request
	GetBlobFile(ctx context.Context, blobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlobUrl request
	GetBlobUrl(ctx context.Context, blobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBlobPartWithBody request with any body
	CreateBlobPartWithBody(ctx context.Context, blobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBlobPart(ctx context.Context, blobId string, body CreateBlobPartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AbortMultipartBlob request
	AbortMultipartBlob(ctx context.Context, blobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CompleteMultipartBlobWithBody request with any body
	CompleteMultipartBlobWithBody(ctx context.Context, blobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CompleteMultipartBlob(ctx context.Context, blobId string, body CompleteMultipartBlobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkGetBlobs request
	BulkGetBlobs(ctx context.Context, params *BulkGetBlobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMultipartBlobWithBody request with any body
	CreateMultipartBlobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMultipartBlob(ctx context.Context, body CreateMultipartBlobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBoxSchemas request
	ListBoxSchemas(ctx context.Context, params *ListBoxSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBoxSchema request
	GetBoxSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBoxes request
	ListBoxes(ctx context.Context, params *ListBoxesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBoxWithBody request with any body
	CreateBoxWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBox(ctx context.Context, body CreateBoxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBox request
	GetBox(ctx context.Context, boxId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateBoxWithBody request with any body
	UpdateBoxWithBody(ctx context.Context, boxId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateBox(ctx context.Context, boxId string, body UpdateBoxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBoxContents request
	ListBoxContents(ctx context.Context, boxId string, params *ListBoxContentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveBoxesWithBody request with any body
	ArchiveBoxesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveBoxes(ctx context.Context, body ArchiveBoxesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkGetBoxes request
	BulkGetBoxes(ctx context.Context, params *BulkGetBoxesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveBoxesWithBody request with any body
	UnarchiveBoxesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveBoxes(ctx context.Context, body UnarchiveBoxesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListContainerSchemas request
	ListContainerSchemas(ctx context.Context, params *ListContainerSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainerSchema request
	GetContainerSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListContainers request
	ListContainers(ctx context.Context, params *ListContainersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateContainerWithBody request with any body
	CreateContainerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateContainer(ctx context.Context, body CreateContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainer request
	GetContainer(ctx context.Context, containerId string, params *GetContainerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateContainerWithBody request with any body
	UpdateContainerWithBody(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateContainer(ctx context.Context, containerId string, body UpdateContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListContainerContents request
	ListContainerContents(ctx context.Context, containerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteContainerContent request
	DeleteContainerContent(ctx context.Context, containerId string, containableId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainerContent request
	GetContainerContent(ctx context.Context, containerId string, containableId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateContainerContentWithBody request with any body
	UpdateContainerContentWithBody(ctx context.Context, containerId string, containableId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateContainerContent(ctx context.Context, containerId string, containableId string, body UpdateContainerContentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferIntoContainerWithBody request with any body
	TransferIntoContainerWithBody(ctx context.Context, destinationContainerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TransferIntoContainer(ctx context.Context, destinationContainerId string, body TransferIntoContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveContainersWithBody request with any body
	ArchiveContainersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveContainers(ctx context.Context, body ArchiveContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateContainersWithBody request with any body
	BulkCreateContainersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateContainers(ctx context.Context, body BulkCreateContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkGetContainers request
	BulkGetContainers(ctx context.Context, params *BulkGetContainersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateContainersWithBody request with any body
	BulkUpdateContainersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateContainers(ctx context.Context, body BulkUpdateContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckinContainersWithBody request with any body
	CheckinContainersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckinContainers(ctx context.Context, body CheckinContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckoutContainersWithBody request with any body
	CheckoutContainersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckoutContainers(ctx context.Context, body CheckoutContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PrintLabelsWithBody request with any body
	PrintLabelsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PrintLabels(ctx context.Context, body PrintLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReserveContainersWithBody request with any body
	ReserveContainersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReserveContainers(ctx context.Context, body ReserveContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveContainersWithBody request with any body
	UnarchiveContainersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveContainers(ctx context.Context, body UnarchiveContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomEntities request
	ListCustomEntities(ctx context.Context, params *ListCustomEntitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomEntityWithBody request with any body
	CreateCustomEntityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomEntity(ctx context.Context, body CreateCustomEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomEntity request
	GetCustomEntity(ctx context.Context, customEntityId string, params *GetCustomEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomEntityWithBody request with any body
	UpdateCustomEntityWithBody(ctx context.Context, customEntityId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomEntity(ctx context.Context, customEntityId string, body UpdateCustomEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveCustomEntitiesWithBody request with any body
	ArchiveCustomEntitiesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveCustomEntities(ctx context.Context, body ArchiveCustomEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateCustomEntitiesWithBody request with any body
	BulkCreateCustomEntitiesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateCustomEntities(ctx context.Context, body BulkCreateCustomEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkGetCustomEntities request
	BulkGetCustomEntities(ctx context.Context, params *BulkGetCustomEntitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateCustomEntitiesWithBody request with any body
	BulkUpdateCustomEntitiesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateCustomEntities(ctx context.Context, body BulkUpdateCustomEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveCustomEntitiesWithBody request with any body
	UnarchiveCustomEntitiesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveCustomEntities(ctx context.Context, body UnarchiveCustomEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomNotations request
	ListCustomNotations(ctx context.Context, params *ListCustomNotationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDNAAlignments request
	ListDNAAlignments(ctx context.Context, params *ListDNAAlignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDNAAlignment request
	DeleteDNAAlignment(ctx context.Context, dnaAlignmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDNAAlignment request
	GetDNAAlignment(ctx context.Context, dnaAlignmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDnaConsensusAlignmentWithBody request with any body
	CreateDnaConsensusAlignmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDnaConsensusAlignment(ctx context.Context, body CreateDnaConsensusAlignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDnaTemplateAlignmentWithBody request with any body
	CreateDnaTemplateAlignmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDnaTemplateAlignment(ctx context.Context, body CreateDnaTemplateAlignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDNAOligos request
	ListDNAOligos(ctx context.Context, params *ListDNAOligosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDNAOligoWithBody request with any body
	CreateDNAOligoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDNAOligo(ctx context.Context, body CreateDNAOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDNAOligo request
	GetDNAOligo(ctx context.Context, oligoId string, params *GetDNAOligoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDNAOligoWithBody request with any body
	UpdateDNAOligoWithBody(ctx context.Context, oligoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDNAOligo(ctx context.Context, oligoId string, body UpdateDNAOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveDNAOligosWithBody request with any body
	ArchiveDNAOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveDNAOligos(ctx context.Context, body ArchiveDNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateDNAOligosWithBody request with any body
	BulkCreateDNAOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateDNAOligos(ctx context.Context, body BulkCreateDNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateDNAOligosWithBody request with any body
	BulkUpdateDNAOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateDNAOligos(ctx context.Context, body BulkUpdateDNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveDNAOligosWithBody request with any body
	UnarchiveDNAOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveDNAOligos(ctx context.Context, body UnarchiveDNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDNASequences request
	ListDNASequences(ctx context.Context, params *ListDNASequencesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDNASequenceWithBody request with any body
	CreateDNASequenceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDNASequence(ctx context.Context, body CreateDNASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDNASequence request
	GetDNASequence(ctx context.Context, dnaSequenceId string, params *GetDNASequenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDNASequenceWithBody request with any body
	UpdateDNASequenceWithBody(ctx context.Context, dnaSequenceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDNASequence(ctx context.Context, dnaSequenceId string, body UpdateDNASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveDNASequencesWithBody request with any body
	ArchiveDNASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveDNASequences(ctx context.Context, body ArchiveDNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AutoAnnotateDnaSequencesWithBody request with any body
	AutoAnnotateDnaSequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AutoAnnotateDnaSequences(ctx context.Context, body AutoAnnotateDnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AutofillDNASequencePartsWithBody request with any body
	AutofillDNASequencePartsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AutofillDNASequenceParts(ctx context.Context, body AutofillDNASequencePartsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AutofillDNASequenceTranslationsWithBody request with any body
	AutofillDNASequenceTranslationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AutofillDNASequenceTranslations(ctx context.Context, body AutofillDNASequenceTranslationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateDNASequencesWithBody request with any body
	BulkCreateDNASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateDNASequences(ctx context.Context, body BulkCreateDNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkGetDNASequences request
	BulkGetDNASequences(ctx context.Context, params *BulkGetDNASequencesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateDNASequencesWithBody request with any body
	BulkUpdateDNASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateDNASequences(ctx context.Context, body BulkUpdateDNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MatchBasesDnaSequencesWithBody request with any body
	MatchBasesDnaSequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MatchBasesDnaSequences(ctx context.Context, body MatchBasesDnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDnaSequencesWithBody request with any body
	SearchDnaSequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDnaSequences(ctx context.Context, body SearchDnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveDNASequencesWithBody request with any body
	UnarchiveDNASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveDNASequences(ctx context.Context, body UnarchiveDNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDropdowns request
	ListDropdowns(ctx context.Context, params *ListDropdownsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDropdownWithBody request with any body
	CreateDropdownWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDropdown(ctx context.Context, body CreateDropdownJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDropdown request
	GetDropdown(ctx context.Context, dropdownId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDropdownWithBody request with any body
	UpdateDropdownWithBody(ctx context.Context, dropdownId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDropdown(ctx context.Context, dropdownId string, body UpdateDropdownJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveDropdownOptionsWithBody request with any body
	ArchiveDropdownOptionsWithBody(ctx context.Context, dropdownId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveDropdownOptions(ctx context.Context, dropdownId string, body ArchiveDropdownOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveDropdownOptionsWithBody request with any body
	UnarchiveDropdownOptionsWithBody(ctx context.Context, dropdownId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveDropdownOptions(ctx context.Context, dropdownId string, body UnarchiveDropdownOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnitityBatches request
	GetEnitityBatches(ctx context.Context, entityId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEntitySchemas request
	ListEntitySchemas(ctx context.Context, params *ListEntitySchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntitySchema request
	GetEntitySchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEntries request
	ListEntries(ctx context.Context, params *ListEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEntryWithBody request with any body
	CreateEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEntry(ctx context.Context, body CreateEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntry request
	GetEntry(ctx context.Context, entryId string, params *GetEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEntryWithBody request with any body
	UpdateEntryWithBody(ctx context.Context, entryId string, params *UpdateEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEntry(ctx context.Context, entryId string, params *UpdateEntryParams, body UpdateEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExternalFileMetadata request
	GetExternalFileMetadata(ctx context.Context, entryId string, externalFileId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveEntriesWithBody request with any body
	ArchiveEntriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveEntries(ctx context.Context, body ArchiveEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkGetEntries request
	BulkGetEntries(ctx context.Context, params *BulkGetEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveEntriesWithBody request with any body
	UnarchiveEntriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveEntries(ctx context.Context, body UnarchiveEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEntrySchemas request
	ListEntrySchemas(ctx context.Context, params *ListEntrySchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntrySchema request
	GetEntrySchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEntryTemplates request
	ListEntryTemplates(ctx context.Context, params *ListEntryTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEntryTemplate request
	GetEntryTemplate(ctx context.Context, entryTemplateId string, params *GetEntryTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEvents request
	ListEvents(ctx context.Context, params *ListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportItemWithBody request with any body
	ExportItemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExportItem(ctx context.Context, body ExportItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFeatureLibraries request
	ListFeatureLibraries(ctx context.Context, params *ListFeatureLibrariesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFeatureLibraryWithBody request with any body
	CreateFeatureLibraryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFeatureLibrary(ctx context.Context, body CreateFeatureLibraryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeatureLibrary request
	GetFeatureLibrary(ctx context.Context, featureLibraryId string, params *GetFeatureLibraryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFeatureLibraryWithBody request with any body
	UpdateFeatureLibraryWithBody(ctx context.Context, featureLibraryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFeatureLibrary(ctx context.Context, featureLibraryId string, body UpdateFeatureLibraryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFeatures request
	ListFeatures(ctx context.Context, params *ListFeaturesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFeatureWithBody request with any body
	CreateFeatureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFeature(ctx context.Context, body CreateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFeature request
	GetFeature(ctx context.Context, featureId string, params *GetFeatureParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFeatureWithBody request with any body
	UpdateFeatureWithBody(ctx context.Context, featureId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFeature(ctx context.Context, featureId string, body UpdateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateFeaturesWithBody request with any body
	BulkCreateFeaturesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateFeatures(ctx context.Context, body BulkCreateFeaturesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFolders request
	ListFolders(ctx context.Context, params *ListFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFolderWithBody request with any body
	CreateFolderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFolder(ctx context.Context, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFolder request
	GetFolder(ctx context.Context, folderId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveFoldersWithBody request with any body
	ArchiveFoldersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveFolders(ctx context.Context, body ArchiveFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveFoldersWithBody request with any body
	UnarchiveFoldersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveFolders(ctx context.Context, body UnarchiveFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLegacyWorkflowStageRunInputSamples request
	ListLegacyWorkflowStageRunInputSamples(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLegacyWorkflowStageRunOutputSamples request
	ListLegacyWorkflowStageRunOutputSamples(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLegacyWorkflowStageRunRegisteredSamples request
	ListLegacyWorkflowStageRunRegisteredSamples(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLegacyWorkflowStageRuns request
	ListLegacyWorkflowStageRuns(ctx context.Context, stageId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLegacyWorkflows request
	ListLegacyWorkflows(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLegacyWorkflowMetadataWithBody request with any body
	UpdateLegacyWorkflowMetadataWithBody(ctx context.Context, legacyWorkflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLegacyWorkflowMetadata(ctx context.Context, legacyWorkflowId string, body UpdateLegacyWorkflowMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLegacyWorkflowStages request
	ListLegacyWorkflowStages(ctx context.Context, legacyWorkflowId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLocationSchemas request
	ListLocationSchemas(ctx context.Context, params *ListLocationSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocationSchema request
	GetLocationSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLocations request
	ListLocations(ctx context.Context, params *ListLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLocationWithBody request with any body
	CreateLocationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLocation(ctx context.Context, body CreateLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocation request
	GetLocation(ctx context.Context, locationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateLocationWithBody request with any body
	UpdateLocationWithBody(ctx context.Context, locationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateLocation(ctx context.Context, locationId string, body UpdateLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveLocationsWithBody request with any body
	ArchiveLocationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveLocations(ctx context.Context, body ArchiveLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkGetLocations request
	BulkGetLocations(ctx context.Context, params *BulkGetLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveLocationsWithBody request with any body
	UnarchiveLocationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveLocations(ctx context.Context, body UnarchiveLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMixtures request
	ListMixtures(ctx context.Context, params *ListMixturesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMixtureWithBody request with any body
	CreateMixtureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMixture(ctx context.Context, body CreateMixtureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMixture request
	GetMixture(ctx context.Context, mixtureId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMixtureWithBody request with any body
	UpdateMixtureWithBody(ctx context.Context, mixtureId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMixture(ctx context.Context, mixtureId string, body UpdateMixtureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveMixturesWithBody request with any body
	ArchiveMixturesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveMixtures(ctx context.Context, body ArchiveMixturesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateMixturesWithBody request with any body
	BulkCreateMixturesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateMixtures(ctx context.Context, body BulkCreateMixturesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateMixturesWithBody request with any body
	BulkUpdateMixturesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateMixtures(ctx context.Context, body BulkUpdateMixturesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveMixturesWithBody request with any body
	UnarchiveMixturesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveMixtures(ctx context.Context, body UnarchiveMixturesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMolecules request
	ListMolecules(ctx context.Context, params *ListMoleculesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMoleculeWithBody request with any body
	CreateMoleculeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMolecule(ctx context.Context, body CreateMoleculeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMolecule request
	GetMolecule(ctx context.Context, moleculeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMoleculeWithBody request with any body
	UpdateMoleculeWithBody(ctx context.Context, moleculeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMolecule(ctx context.Context, moleculeId string, body UpdateMoleculeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveMoleculesWithBody request with any body
	ArchiveMoleculesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveMolecules(ctx context.Context, body ArchiveMoleculesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateMoleculesWithBody request with any body
	BulkCreateMoleculesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateMolecules(ctx context.Context, body BulkCreateMoleculesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateMoleculesWithBody request with any body
	BulkUpdateMoleculesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateMolecules(ctx context.Context, body BulkUpdateMoleculesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveMoleculesWithBody request with any body
	UnarchiveMoleculesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveMolecules(ctx context.Context, body UnarchiveMoleculesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMonomers request
	ListMonomers(ctx context.Context, params *ListMonomersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMonomerWithBody request with any body
	CreateMonomerWithBody(ctx context.Context, params *CreateMonomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMonomer(ctx context.Context, params *CreateMonomerParams, body CreateMonomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMonomerWithBody request with any body
	UpdateMonomerWithBody(ctx context.Context, monomerId string, params *UpdateMonomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMonomer(ctx context.Context, monomerId string, params *UpdateMonomerParams, body UpdateMonomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveMonomersWithBody request with any body
	ArchiveMonomersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveMonomers(ctx context.Context, body ArchiveMonomersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveMonomersWithBody request with any body
	UnarchiveMonomersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveMonomers(ctx context.Context, body UnarchiveMonomersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNucleotideAlignments request
	ListNucleotideAlignments(ctx context.Context, params *ListNucleotideAlignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNucleotideAlignment request
	DeleteNucleotideAlignment(ctx context.Context, alignmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNucleotideAlignment request
	GetNucleotideAlignment(ctx context.Context, alignmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateConsensusNucleotideAlignmentWithBody request with any body
	CreateConsensusNucleotideAlignmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateConsensusNucleotideAlignment(ctx context.Context, body CreateConsensusNucleotideAlignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTemplateNucleotideAlignmentWithBody request with any body
	CreateTemplateNucleotideAlignmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTemplateNucleotideAlignment(ctx context.Context, body CreateTemplateNucleotideAlignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOligos request
	ListOligos(ctx context.Context, params *ListOligosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOligoWithBody request with any body
	CreateOligoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOligo(ctx context.Context, body CreateOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOligo request
	GetOligo(ctx context.Context, oligoId string, params *GetOligoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOligoWithBody request with any body
	UpdateOligoWithBody(ctx context.Context, oligoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOligo(ctx context.Context, oligoId string, body UpdateOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveOligosWithBody request with any body
	ArchiveOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveOligos(ctx context.Context, body ArchiveOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateOligosWithBody request with any body
	BulkCreateOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateOligos(ctx context.Context, body BulkCreateOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkGetOligos request
	BulkGetOligos(ctx context.Context, params *BulkGetOligosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveOligosWithBody request with any body
	UnarchiveOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveOligos(ctx context.Context, body UnarchiveOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOrganizations request
	ListOrganizations(ctx context.Context, params *ListOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganization request
	GetOrganization(ctx context.Context, organizationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlateSchemas request
	ListPlateSchemas(ctx context.Context, params *ListPlateSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlateSchema request
	GetPlateSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlates request
	ListPlates(ctx context.Context, params *ListPlatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePlateWithBody request with any body
	CreatePlateWithBody(ctx context.Context, params *CreatePlateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePlate(ctx context.Context, params *CreatePlateParams, body CreatePlateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlate request
	GetPlate(ctx context.Context, plateId string, params *GetPlateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePlateWithBody request with any body
	UpdatePlateWithBody(ctx context.Context, plateId string, params *UpdatePlateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePlate(ctx context.Context, plateId string, params *UpdatePlateParams, body UpdatePlateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchivePlatesWithBody request with any body
	ArchivePlatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchivePlates(ctx context.Context, body ArchivePlatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkGetPlates request
	BulkGetPlates(ctx context.Context, params *BulkGetPlatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchivePlatesWithBody request with any body
	UnarchivePlatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchivePlates(ctx context.Context, body UnarchivePlatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListProjects request
	ListProjects(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProject request
	GetProject(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveProjectsWithBody request with any body
	ArchiveProjectsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveProjects(ctx context.Context, body ArchiveProjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveProjectsWithBody request with any body
	UnarchiveProjectsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveProjects(ctx context.Context, body UnarchiveProjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRegistries request
	ListRegistries(ctx context.Context, params *ListRegistriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistry request
	GetRegistry(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBatchSchemasByRegistry request
	ListBatchSchemasByRegistry(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBoxSchemasByRegistry request
	ListBoxSchemasByRegistry(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListContainerSchemasByRegistry request
	ListContainerSchemasByRegistry(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDropdownsByRegistry request
	ListDropdownsByRegistry(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEntitySchemasByRegistry request
	ListEntitySchemasByRegistry(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPrinters request
	ListPrinters(ctx context.Context, registryId string, params *ListPrintersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLabelTemplates request
	ListLabelTemplates(ctx context.Context, registryId string, params *ListLabelTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListLocationSchemasByRegistry request
	ListLocationSchemasByRegistry(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlateSchemasByRegistry request
	ListPlateSchemasByRegistry(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkGetRegisteredEntities request
	BulkGetRegisteredEntities(ctx context.Context, registryId string, params *BulkGetRegisteredEntitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterEntitiesWithBody request with any body
	RegisterEntitiesWithBody(ctx context.Context, registryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterEntities(ctx context.Context, registryId string, body RegisterEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnregisterEntitiesWithBody request with any body
	UnregisterEntitiesWithBody(ctx context.Context, registryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnregisterEntities(ctx context.Context, registryId string, body UnregisterEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ValidateBarcodesWithBody request with any body
	ValidateBarcodesWithBody(ctx context.Context, registryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ValidateBarcodes(ctx context.Context, registryId string, body ValidateBarcodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRequestFulfillments request
	ListRequestFulfillments(ctx context.Context, params *ListRequestFulfillmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRequestFulfillment request
	GetRequestFulfillment(ctx context.Context, requestFulfillmentId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRequestSchemas request
	ListRequestSchemas(ctx context.Context, params *ListRequestSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRequestSchema request
	GetRequestSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRequestTaskSchemas request
	ListRequestTaskSchemas(ctx context.Context, params *ListRequestTaskSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRequestTaskSchema request
	GetRequestTaskSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRequests request
	ListRequests(ctx context.Context, params *ListRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRequestWithBody request with any body
	CreateRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRequest(ctx context.Context, body CreateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRequest request
	GetRequest(ctx context.Context, requestId string, params *GetRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchRequestWithBody request with any body
	PatchRequestWithBody(ctx context.Context, requestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchRequest(ctx context.Context, requestId string, body PatchRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRequestResponse request
	GetRequestResponse(ctx context.Context, requestId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateRequestTasksWithBody request with any body
	BulkCreateRequestTasksWithBody(ctx context.Context, requestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateRequestTasks(ctx context.Context, requestId string, body BulkCreateRequestTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateRequestTasksWithBody request with any body
	BulkUpdateRequestTasksWithBody(ctx context.Context, requestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateRequestTasks(ctx context.Context, requestId string, body BulkUpdateRequestTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecuteRequestsSampleGroupsWithBody request with any body
	ExecuteRequestsSampleGroupsWithBody(ctx context.Context, requestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExecuteRequestsSampleGroups(ctx context.Context, requestId string, body ExecuteRequestsSampleGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkGetRequests request
	BulkGetRequests(ctx context.Context, params *BulkGetRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAssayResultsTransaction request
	CreateAssayResultsTransaction(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAssayResultsInTransactionWithBody request with any body
	CreateAssayResultsInTransactionWithBody(ctx context.Context, transactionId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAssayResultsInTransaction(ctx context.Context, transactionId openapi_types.UUID, body CreateAssayResultsInTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AbortAssayResultsTransaction request
	AbortAssayResultsTransaction(ctx context.Context, transactionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitAssayResultsTransaction request
	CommitAssayResultsTransaction(ctx context.Context, transactionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRNAOligos request
	ListRNAOligos(ctx context.Context, params *ListRNAOligosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRNAOligoWithBody request with any body
	CreateRNAOligoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRNAOligo(ctx context.Context, body CreateRNAOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRNAOligo request
	GetRNAOligo(ctx context.Context, oligoId string, params *GetRNAOligoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRNAOligoWithBody request with any body
	UpdateRNAOligoWithBody(ctx context.Context, oligoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRNAOligo(ctx context.Context, oligoId string, body UpdateRNAOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveRNAOligosWithBody request with any body
	ArchiveRNAOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveRNAOligos(ctx context.Context, body ArchiveRNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateRNAOligosWithBody request with any body
	BulkCreateRNAOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateRNAOligos(ctx context.Context, body BulkCreateRNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateRNAOligosWithBody request with any body
	BulkUpdateRNAOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateRNAOligos(ctx context.Context, body BulkUpdateRNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveRNAOligosWithBody request with any body
	UnarchiveRNAOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveRNAOligos(ctx context.Context, body UnarchiveRNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListRNASequences request
	ListRNASequences(ctx context.Context, params *ListRNASequencesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRNASequenceWithBody request with any body
	CreateRNASequenceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRNASequence(ctx context.Context, body CreateRNASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRNASequence request
	GetRNASequence(ctx context.Context, rnaSequenceId string, params *GetRNASequenceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRNASequenceWithBody request with any body
	UpdateRNASequenceWithBody(ctx context.Context, rnaSequenceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRNASequence(ctx context.Context, rnaSequenceId string, body UpdateRNASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveRNASequencesWithBody request with any body
	ArchiveRNASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveRNASequences(ctx context.Context, body ArchiveRNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AutoAnnotateRnaSequencesWithBody request with any body
	AutoAnnotateRnaSequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AutoAnnotateRnaSequences(ctx context.Context, body AutoAnnotateRnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AutofillRNASequencePartsWithBody request with any body
	AutofillRNASequencePartsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AutofillRNASequenceParts(ctx context.Context, body AutofillRNASequencePartsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AutofillRNASequenceTranslationsWithBody request with any body
	AutofillRNASequenceTranslationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AutofillRNASequenceTranslations(ctx context.Context, body AutofillRNASequenceTranslationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateRNASequencesWithBody request with any body
	BulkCreateRNASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateRNASequences(ctx context.Context, body BulkCreateRNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkGetRNASequences request
	BulkGetRNASequences(ctx context.Context, params *BulkGetRNASequencesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateRNASequencesWithBody request with any body
	BulkUpdateRNASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateRNASequences(ctx context.Context, body BulkUpdateRNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MatchBasesRnaSequencesWithBody request with any body
	MatchBasesRnaSequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MatchBasesRnaSequences(ctx context.Context, body MatchBasesRnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchRnaSequencesWithBody request with any body
	SearchRnaSequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchRnaSequences(ctx context.Context, body SearchRnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveRNASequencesWithBody request with any body
	UnarchiveRNASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveRNASequences(ctx context.Context, body UnarchiveRNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTask request
	GetTask(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTeams request
	ListTeams(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeam request
	GetTeam(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateTokenWithBody request with any body
	GenerateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GenerateTokenWithFormdataBody(ctx context.Context, body GenerateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferIntoContainersWithBody request with any body
	TransferIntoContainersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TransferIntoContainers(ctx context.Context, body TransferIntoContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListUsers request
	ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWithBody request with any body
	UpdateUserWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUser(ctx context.Context, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserActivity request
	GetUserActivity(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateUsersWithBody request with any body
	BulkCreateUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateUsers(ctx context.Context, body BulkCreateUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateUsersWithBody request with any body
	BulkUpdateUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateUsers(ctx context.Context, body BulkUpdateUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWarehouseCredentialsWithBody request with any body
	CreateWarehouseCredentialsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWarehouseCredentials(ctx context.Context, body CreateWarehouseCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkflowOutputs request
	ListWorkflowOutputs(ctx context.Context, params *ListWorkflowOutputsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkflowOutputWithBody request with any body
	CreateWorkflowOutputWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkflowOutput(ctx context.Context, body CreateWorkflowOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkflowOutput request
	GetWorkflowOutput(ctx context.Context, workflowOutputId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWorkflowOutputWithBody request with any body
	UpdateWorkflowOutputWithBody(ctx context.Context, workflowOutputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWorkflowOutput(ctx context.Context, workflowOutputId string, body UpdateWorkflowOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveWorkflowOutputsWithBody request with any body
	ArchiveWorkflowOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveWorkflowOutputs(ctx context.Context, body ArchiveWorkflowOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateWorkflowOutputsWithBody request with any body
	BulkCreateWorkflowOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateWorkflowOutputs(ctx context.Context, body BulkCreateWorkflowOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateWorkflowOutputsWithBody request with any body
	BulkUpdateWorkflowOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateWorkflowOutputs(ctx context.Context, body BulkUpdateWorkflowOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveWorkflowOutputsWithBody request with any body
	UnarchiveWorkflowOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveWorkflowOutputs(ctx context.Context, body UnarchiveWorkflowOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStageRunInputSamples request
	ListStageRunInputSamples(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStageRunOutputSamples request
	ListStageRunOutputSamples(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStageRunRegisteredSamples request
	ListStageRunRegisteredSamples(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkflowStageRuns request
	ListWorkflowStageRuns(ctx context.Context, stageId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkflowTaskGroups request
	ListWorkflowTaskGroups(ctx context.Context, params *ListWorkflowTaskGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkflowTaskGroupWithBody request with any body
	CreateWorkflowTaskGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkflowTaskGroup(ctx context.Context, body CreateWorkflowTaskGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkflowTaskGroup request
	GetWorkflowTaskGroup(ctx context.Context, workflowTaskGroupId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWorkflowTaskGroupWithBody request with any body
	UpdateWorkflowTaskGroupWithBody(ctx context.Context, workflowTaskGroupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWorkflowTaskGroup(ctx context.Context, workflowTaskGroupId string, body UpdateWorkflowTaskGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveWorkflowTaskGroupsWithBody request with any body
	ArchiveWorkflowTaskGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveWorkflowTaskGroups(ctx context.Context, body ArchiveWorkflowTaskGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveWorkflowTaskGroupsWithBody request with any body
	UnarchiveWorkflowTaskGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveWorkflowTaskGroups(ctx context.Context, body UnarchiveWorkflowTaskGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkflowTaskSchemas request
	ListWorkflowTaskSchemas(ctx context.Context, params *ListWorkflowTaskSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkflowTaskSchema request
	GetWorkflowTaskSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkflowTasks request
	ListWorkflowTasks(ctx context.Context, params *ListWorkflowTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWorkflowTaskWithBody request with any body
	CreateWorkflowTaskWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWorkflowTask(ctx context.Context, body CreateWorkflowTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkflowTask request
	GetWorkflowTask(ctx context.Context, workflowTaskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWorkflowTaskWithBody request with any body
	UpdateWorkflowTaskWithBody(ctx context.Context, workflowTaskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWorkflowTask(ctx context.Context, workflowTaskId string, body UpdateWorkflowTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CopyWorkflowTask request
	CopyWorkflowTask(ctx context.Context, workflowTaskId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ArchiveWorkflowTasksWithBody request with any body
	ArchiveWorkflowTasksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveWorkflowTasks(ctx context.Context, body ArchiveWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCopyWorkflowTasksWithBody request with any body
	BulkCopyWorkflowTasksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCopyWorkflowTasks(ctx context.Context, body BulkCopyWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkCreateWorkflowTasksWithBody request with any body
	BulkCreateWorkflowTasksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkCreateWorkflowTasks(ctx context.Context, body BulkCreateWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateWorkflowTasksWithBody request with any body
	BulkUpdateWorkflowTasksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateWorkflowTasks(ctx context.Context, body BulkUpdateWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnarchiveWorkflowTasksWithBody request with any body
	UnarchiveWorkflowTasksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnarchiveWorkflowTasks(ctx context.Context, body UnarchiveWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkflows request
	ListWorkflows(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWorkflowMetadataWithBody request with any body
	UpdateWorkflowMetadataWithBody(ctx context.Context, workflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWorkflowMetadata(ctx context.Context, workflowId string, body UpdateWorkflowMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListWorkflowStages request
	ListWorkflowStages(ctx context.Context, workflowId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListAASequences(ctx context.Context, params *ListAASequencesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAASequencesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAASequenceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAASequenceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAASequence(ctx context.Context, body CreateAASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAASequenceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAASequence(ctx context.Context, aaSequenceId string, params *GetAASequenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAASequenceRequest(c.Server, aaSequenceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAASequenceWithBody(ctx context.Context, aaSequenceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAASequenceRequestWithBody(c.Server, aaSequenceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAASequence(ctx context.Context, aaSequenceId string, body UpdateAASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAASequenceRequest(c.Server, aaSequenceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveAASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveAASequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveAASequences(ctx context.Context, body ArchiveAASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveAASequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutoAnnotateAaSequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutoAnnotateAaSequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutoAnnotateAaSequences(ctx context.Context, body AutoAnnotateAaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutoAnnotateAaSequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateAASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateAASequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateAASequences(ctx context.Context, body BulkCreateAASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateAASequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkGetAASequences(ctx context.Context, params *BulkGetAASequencesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkGetAASequencesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateAASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateAASequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateAASequences(ctx context.Context, body BulkUpdateAASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateAASequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveAASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveAASequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveAASequences(ctx context.Context, body UnarchiveAASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveAASequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppCanvasWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppCanvasRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppCanvas(ctx context.Context, body CreateAppCanvasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppCanvasRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppCanvas(ctx context.Context, canvasId string, params *GetAppCanvasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppCanvasRequest(c.Server, canvasId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppCanvasWithBody(ctx context.Context, canvasId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppCanvasRequestWithBody(c.Server, canvasId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppCanvas(ctx context.Context, canvasId string, body UpdateAppCanvasJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppCanvasRequest(c.Server, canvasId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveAppCanvasesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveAppCanvasesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveAppCanvases(ctx context.Context, body ArchiveAppCanvasesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveAppCanvasesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveAppCanvasesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveAppCanvasesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveAppCanvases(ctx context.Context, body UnarchiveAppCanvasesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveAppCanvasesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAppConfigurationItems(ctx context.Context, params *ListAppConfigurationItemsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAppConfigurationItemsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppConfigurationItemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppConfigurationItemRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppConfigurationItem(ctx context.Context, body CreateAppConfigurationItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppConfigurationItemRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppConfigurationItemById(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppConfigurationItemByIdRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppConfigurationItemWithBody(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppConfigurationItemRequestWithBody(c.Server, itemId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppConfigurationItem(ctx context.Context, itemId string, body UpdateAppConfigurationItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppConfigurationItemRequest(c.Server, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateAppConfigurationItemsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateAppConfigurationItemsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateAppConfigurationItems(ctx context.Context, body BulkCreateAppConfigurationItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateAppConfigurationItemsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateAppConfigurationItemsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateAppConfigurationItemsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateAppConfigurationItems(ctx context.Context, body BulkUpdateAppConfigurationItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateAppConfigurationItemsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppSessionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppSession(ctx context.Context, body CreateAppSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppSessionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppSessionById(ctx context.Context, id string, params *GetAppSessionByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppSessionByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppSessionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppSessionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppSession(ctx context.Context, id string, body UpdateAppSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppSessionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBenchlingApps(ctx context.Context, params *ListBenchlingAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBenchlingAppsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBenchlingAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBenchlingAppRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBenchlingApp(ctx context.Context, body CreateBenchlingAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBenchlingAppRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBenchlingAppByID(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBenchlingAppByIDRequest(c.Server, appId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchBenchlingAppWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchBenchlingAppRequestWithBody(c.Server, appId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchBenchlingApp(ctx context.Context, appId string, body PatchBenchlingAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchBenchlingAppRequest(c.Server, appId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveBenchlingAppsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveBenchlingAppsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveBenchlingApps(ctx context.Context, body ArchiveBenchlingAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveBenchlingAppsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveBenchlingAppsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveBenchlingAppsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveBenchlingApps(ctx context.Context, body UnarchiveBenchlingAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveBenchlingAppsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssayResultSchemas(ctx context.Context, params *ListAssayResultSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssayResultSchemasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResultSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResultSchemaRequest(c.Server, schemaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssayResults(ctx context.Context, params *ListAssayResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssayResultsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssayResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssayResultsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssayResults(ctx context.Context, body CreateAssayResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssayResultsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssayResult(ctx context.Context, assayResultId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssayResultRequest(c.Server, assayResultId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveAssayResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveAssayResultsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveAssayResults(ctx context.Context, body ArchiveAssayResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveAssayResultsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateAssayResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateAssayResultsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateAssayResults(ctx context.Context, body BulkCreateAssayResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateAssayResultsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkGetAssayResults(ctx context.Context, params *BulkGetAssayResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkGetAssayResultsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveAssayResultsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveAssayResultsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveAssayResults(ctx context.Context, body UnarchiveAssayResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveAssayResultsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssayRunSchemas(ctx context.Context, params *ListAssayRunSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssayRunSchemasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRunSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRunSchemaRequest(c.Server, schemaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssayRuns(ctx context.Context, params *ListAssayRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssayRunsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssayRunsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssayRunsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssayRuns(ctx context.Context, body CreateAssayRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssayRunsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssayRun(ctx context.Context, assayRunId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssayRunRequest(c.Server, assayRunId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssayRunWithBody(ctx context.Context, assayRunId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssayRunRequestWithBody(c.Server, assayRunId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssayRun(ctx context.Context, assayRunId string, body UpdateAssayRunJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssayRunRequest(c.Server, assayRunId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAutomationInputGenerators(ctx context.Context, assayRunId string, params *ListAutomationInputGeneratorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAutomationInputGeneratorsRequest(c.Server, assayRunId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAutomationOutputProcessorsDeprecated(ctx context.Context, assayRunId string, params *ListAutomationOutputProcessorsDeprecatedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAutomationOutputProcessorsDeprecatedRequest(c.Server, assayRunId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveAssayRunsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveAssayRunsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveAssayRuns(ctx context.Context, body ArchiveAssayRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveAssayRunsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkGetAssayRuns(ctx context.Context, params *BulkGetAssayRunsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkGetAssayRunsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveAssayRunsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveAssayRunsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveAssayRuns(ctx context.Context, body UnarchiveAssayRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveAssayRunsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLabAutomationTransform(ctx context.Context, transformId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLabAutomationTransformRequest(c.Server, transformId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLabAutomationTransformWithBody(ctx context.Context, transformId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLabAutomationTransformRequestWithBody(c.Server, transformId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLabAutomationTransform(ctx context.Context, transformId string, body UpdateLabAutomationTransformJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLabAutomationTransformRequest(c.Server, transformId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutomationInputGenerator(ctx context.Context, inputGeneratorId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutomationInputGeneratorRequest(c.Server, inputGeneratorId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutomationInputGeneratorWithBody(ctx context.Context, inputGeneratorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutomationInputGeneratorRequestWithBody(c.Server, inputGeneratorId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutomationInputGenerator(ctx context.Context, inputGeneratorId string, body UpdateAutomationInputGeneratorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutomationInputGeneratorRequest(c.Server, inputGeneratorId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateInputWithAutomationInputGenerator(ctx context.Context, inputGeneratorId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateInputWithAutomationInputGeneratorRequest(c.Server, inputGeneratorId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAutomationOutputProcessors(ctx context.Context, params *ListAutomationOutputProcessorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAutomationOutputProcessorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAutomationOutputProcessorWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAutomationOutputProcessorRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAutomationOutputProcessor(ctx context.Context, body CreateAutomationOutputProcessorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAutomationOutputProcessorRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutomationOutputProcessor(ctx context.Context, outputProcessorId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutomationOutputProcessorRequest(c.Server, outputProcessorId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutomationOutputProcessorWithBody(ctx context.Context, outputProcessorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutomationOutputProcessorRequestWithBody(c.Server, outputProcessorId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutomationOutputProcessor(ctx context.Context, outputProcessorId string, body UpdateAutomationOutputProcessorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutomationOutputProcessorRequest(c.Server, outputProcessorId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProcessOutputWithAutomationOutputProcessor(ctx context.Context, outputProcessorId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProcessOutputWithAutomationOutputProcessorRequest(c.Server, outputProcessorId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveAutomationOutputProcessorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveAutomationOutputProcessorsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveAutomationOutputProcessors(ctx context.Context, body ArchiveAutomationOutputProcessorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveAutomationOutputProcessorsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveAutomationOutputProcessorsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveAutomationOutputProcessorsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveAutomationOutputProcessors(ctx context.Context, body UnarchiveAutomationOutputProcessorsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveAutomationOutputProcessorsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatchSchemas(ctx context.Context, params *ListBatchSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchSchemasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBatchSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBatchSchemaRequest(c.Server, schemaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatches(ctx context.Context, params *ListBatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBatchWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBatchRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBatch(ctx context.Context, body CreateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBatchRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBatch(ctx context.Context, batchId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBatchRequest(c.Server, batchId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBatchWithBody(ctx context.Context, batchId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBatchRequestWithBody(c.Server, batchId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBatch(ctx context.Context, batchId string, body UpdateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBatchRequest(c.Server, batchId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveBatchesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveBatchesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveBatches(ctx context.Context, body ArchiveBatchesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveBatchesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkGetBatches(ctx context.Context, params *BulkGetBatchesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkGetBatchesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveBatchesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveBatchesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveBatches(ctx context.Context, body UnarchiveBatchesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveBatchesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBlobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBlobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBlob(ctx context.Context, body CreateBlobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBlobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlob(ctx context.Context, blobId string, params *GetBlobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlobRequest(c.Server, blobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlobFile(ctx context.Context, blobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlobFileRequest(c.Server, blobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlobUrl(ctx context.Context, blobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlobUrlRequest(c.Server, blobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBlobPartWithBody(ctx context.Context, blobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBlobPartRequestWithBody(c.Server, blobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBlobPart(ctx context.Context, blobId string, body CreateBlobPartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBlobPartRequest(c.Server, blobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AbortMultipartBlob(ctx context.Context, blobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAbortMultipartBlobRequest(c.Server, blobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteMultipartBlobWithBody(ctx context.Context, blobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteMultipartBlobRequestWithBody(c.Server, blobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CompleteMultipartBlob(ctx context.Context, blobId string, body CompleteMultipartBlobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompleteMultipartBlobRequest(c.Server, blobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkGetBlobs(ctx context.Context, params *BulkGetBlobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkGetBlobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMultipartBlobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMultipartBlobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMultipartBlob(ctx context.Context, body CreateMultipartBlobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMultipartBlobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBoxSchemas(ctx context.Context, params *ListBoxSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBoxSchemasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBoxSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBoxSchemaRequest(c.Server, schemaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBoxes(ctx context.Context, params *ListBoxesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBoxesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBoxWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBoxRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBox(ctx context.Context, body CreateBoxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBoxRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBox(ctx context.Context, boxId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBoxRequest(c.Server, boxId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBoxWithBody(ctx context.Context, boxId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBoxRequestWithBody(c.Server, boxId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateBox(ctx context.Context, boxId string, body UpdateBoxJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateBoxRequest(c.Server, boxId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBoxContents(ctx context.Context, boxId string, params *ListBoxContentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBoxContentsRequest(c.Server, boxId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveBoxesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveBoxesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveBoxes(ctx context.Context, body ArchiveBoxesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveBoxesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkGetBoxes(ctx context.Context, params *BulkGetBoxesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkGetBoxesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveBoxesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveBoxesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveBoxes(ctx context.Context, body UnarchiveBoxesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveBoxesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListContainerSchemas(ctx context.Context, params *ListContainerSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListContainerSchemasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainerSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerSchemaRequest(c.Server, schemaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListContainers(ctx context.Context, params *ListContainersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListContainersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContainerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateContainerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateContainer(ctx context.Context, body CreateContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateContainerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainer(ctx context.Context, containerId string, params *GetContainerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerRequest(c.Server, containerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateContainerWithBody(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateContainerRequestWithBody(c.Server, containerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateContainer(ctx context.Context, containerId string, body UpdateContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateContainerRequest(c.Server, containerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListContainerContents(ctx context.Context, containerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListContainerContentsRequest(c.Server, containerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteContainerContent(ctx context.Context, containerId string, containableId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteContainerContentRequest(c.Server, containerId, containableId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainerContent(ctx context.Context, containerId string, containableId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerContentRequest(c.Server, containerId, containableId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateContainerContentWithBody(ctx context.Context, containerId string, containableId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateContainerContentRequestWithBody(c.Server, containerId, containableId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateContainerContent(ctx context.Context, containerId string, containableId string, body UpdateContainerContentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateContainerContentRequest(c.Server, containerId, containableId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferIntoContainerWithBody(ctx context.Context, destinationContainerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferIntoContainerRequestWithBody(c.Server, destinationContainerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferIntoContainer(ctx context.Context, destinationContainerId string, body TransferIntoContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferIntoContainerRequest(c.Server, destinationContainerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveContainersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveContainersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveContainers(ctx context.Context, body ArchiveContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveContainersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateContainersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateContainersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateContainers(ctx context.Context, body BulkCreateContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateContainersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkGetContainers(ctx context.Context, params *BulkGetContainersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkGetContainersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateContainersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateContainersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateContainers(ctx context.Context, body BulkUpdateContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateContainersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckinContainersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckinContainersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckinContainers(ctx context.Context, body CheckinContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckinContainersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckoutContainersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckoutContainersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckoutContainers(ctx context.Context, body CheckoutContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckoutContainersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrintLabelsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrintLabelsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PrintLabels(ctx context.Context, body PrintLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPrintLabelsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReserveContainersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReserveContainersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReserveContainers(ctx context.Context, body ReserveContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReserveContainersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveContainersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveContainersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveContainers(ctx context.Context, body UnarchiveContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveContainersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomEntities(ctx context.Context, params *ListCustomEntitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomEntitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomEntityWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomEntityRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomEntity(ctx context.Context, body CreateCustomEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomEntityRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomEntity(ctx context.Context, customEntityId string, params *GetCustomEntityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomEntityRequest(c.Server, customEntityId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomEntityWithBody(ctx context.Context, customEntityId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomEntityRequestWithBody(c.Server, customEntityId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomEntity(ctx context.Context, customEntityId string, body UpdateCustomEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomEntityRequest(c.Server, customEntityId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveCustomEntitiesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveCustomEntitiesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveCustomEntities(ctx context.Context, body ArchiveCustomEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveCustomEntitiesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateCustomEntitiesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateCustomEntitiesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateCustomEntities(ctx context.Context, body BulkCreateCustomEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateCustomEntitiesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkGetCustomEntities(ctx context.Context, params *BulkGetCustomEntitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkGetCustomEntitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateCustomEntitiesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateCustomEntitiesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateCustomEntities(ctx context.Context, body BulkUpdateCustomEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateCustomEntitiesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveCustomEntitiesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveCustomEntitiesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveCustomEntities(ctx context.Context, body UnarchiveCustomEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveCustomEntitiesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomNotations(ctx context.Context, params *ListCustomNotationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomNotationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDNAAlignments(ctx context.Context, params *ListDNAAlignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDNAAlignmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDNAAlignment(ctx context.Context, dnaAlignmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDNAAlignmentRequest(c.Server, dnaAlignmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDNAAlignment(ctx context.Context, dnaAlignmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDNAAlignmentRequest(c.Server, dnaAlignmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDnaConsensusAlignmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDnaConsensusAlignmentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDnaConsensusAlignment(ctx context.Context, body CreateDnaConsensusAlignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDnaConsensusAlignmentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDnaTemplateAlignmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDnaTemplateAlignmentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDnaTemplateAlignment(ctx context.Context, body CreateDnaTemplateAlignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDnaTemplateAlignmentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDNAOligos(ctx context.Context, params *ListDNAOligosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDNAOligosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDNAOligoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDNAOligoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDNAOligo(ctx context.Context, body CreateDNAOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDNAOligoRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDNAOligo(ctx context.Context, oligoId string, params *GetDNAOligoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDNAOligoRequest(c.Server, oligoId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDNAOligoWithBody(ctx context.Context, oligoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDNAOligoRequestWithBody(c.Server, oligoId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDNAOligo(ctx context.Context, oligoId string, body UpdateDNAOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDNAOligoRequest(c.Server, oligoId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveDNAOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveDNAOligosRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveDNAOligos(ctx context.Context, body ArchiveDNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveDNAOligosRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateDNAOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateDNAOligosRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateDNAOligos(ctx context.Context, body BulkCreateDNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateDNAOligosRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateDNAOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateDNAOligosRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateDNAOligos(ctx context.Context, body BulkUpdateDNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateDNAOligosRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveDNAOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveDNAOligosRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveDNAOligos(ctx context.Context, body UnarchiveDNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveDNAOligosRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDNASequences(ctx context.Context, params *ListDNASequencesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDNASequencesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDNASequenceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDNASequenceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDNASequence(ctx context.Context, body CreateDNASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDNASequenceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDNASequence(ctx context.Context, dnaSequenceId string, params *GetDNASequenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDNASequenceRequest(c.Server, dnaSequenceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDNASequenceWithBody(ctx context.Context, dnaSequenceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDNASequenceRequestWithBody(c.Server, dnaSequenceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDNASequence(ctx context.Context, dnaSequenceId string, body UpdateDNASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDNASequenceRequest(c.Server, dnaSequenceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveDNASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveDNASequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveDNASequences(ctx context.Context, body ArchiveDNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveDNASequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutoAnnotateDnaSequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutoAnnotateDnaSequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutoAnnotateDnaSequences(ctx context.Context, body AutoAnnotateDnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutoAnnotateDnaSequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutofillDNASequencePartsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutofillDNASequencePartsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutofillDNASequenceParts(ctx context.Context, body AutofillDNASequencePartsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutofillDNASequencePartsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutofillDNASequenceTranslationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutofillDNASequenceTranslationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutofillDNASequenceTranslations(ctx context.Context, body AutofillDNASequenceTranslationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutofillDNASequenceTranslationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateDNASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateDNASequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateDNASequences(ctx context.Context, body BulkCreateDNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateDNASequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkGetDNASequences(ctx context.Context, params *BulkGetDNASequencesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkGetDNASequencesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateDNASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateDNASequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateDNASequences(ctx context.Context, body BulkUpdateDNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateDNASequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MatchBasesDnaSequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMatchBasesDnaSequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MatchBasesDnaSequences(ctx context.Context, body MatchBasesDnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMatchBasesDnaSequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDnaSequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDnaSequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDnaSequences(ctx context.Context, body SearchDnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDnaSequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveDNASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveDNASequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveDNASequences(ctx context.Context, body UnarchiveDNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveDNASequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDropdowns(ctx context.Context, params *ListDropdownsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDropdownsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDropdownWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDropdownRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDropdown(ctx context.Context, body CreateDropdownJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDropdownRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDropdown(ctx context.Context, dropdownId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDropdownRequest(c.Server, dropdownId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDropdownWithBody(ctx context.Context, dropdownId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDropdownRequestWithBody(c.Server, dropdownId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDropdown(ctx context.Context, dropdownId string, body UpdateDropdownJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDropdownRequest(c.Server, dropdownId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveDropdownOptionsWithBody(ctx context.Context, dropdownId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveDropdownOptionsRequestWithBody(c.Server, dropdownId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveDropdownOptions(ctx context.Context, dropdownId string, body ArchiveDropdownOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveDropdownOptionsRequest(c.Server, dropdownId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveDropdownOptionsWithBody(ctx context.Context, dropdownId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveDropdownOptionsRequestWithBody(c.Server, dropdownId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveDropdownOptions(ctx context.Context, dropdownId string, body UnarchiveDropdownOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveDropdownOptionsRequest(c.Server, dropdownId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnitityBatches(ctx context.Context, entityId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnitityBatchesRequest(c.Server, entityId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEntitySchemas(ctx context.Context, params *ListEntitySchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEntitySchemasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntitySchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntitySchemaRequest(c.Server, schemaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEntries(ctx context.Context, params *ListEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEntriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEntryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEntry(ctx context.Context, body CreateEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEntryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntry(ctx context.Context, entryId string, params *GetEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntryRequest(c.Server, entryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEntryWithBody(ctx context.Context, entryId string, params *UpdateEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEntryRequestWithBody(c.Server, entryId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEntry(ctx context.Context, entryId string, params *UpdateEntryParams, body UpdateEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEntryRequest(c.Server, entryId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExternalFileMetadata(ctx context.Context, entryId string, externalFileId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExternalFileMetadataRequest(c.Server, entryId, externalFileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveEntriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveEntriesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveEntries(ctx context.Context, body ArchiveEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveEntriesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkGetEntries(ctx context.Context, params *BulkGetEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkGetEntriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveEntriesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveEntriesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveEntries(ctx context.Context, body UnarchiveEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveEntriesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEntrySchemas(ctx context.Context, params *ListEntrySchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEntrySchemasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntrySchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntrySchemaRequest(c.Server, schemaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEntryTemplates(ctx context.Context, params *ListEntryTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEntryTemplatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEntryTemplate(ctx context.Context, entryTemplateId string, params *GetEntryTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEntryTemplateRequest(c.Server, entryTemplateId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEvents(ctx context.Context, params *ListEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportItemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportItemRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportItem(ctx context.Context, body ExportItemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportItemRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFeatureLibraries(ctx context.Context, params *ListFeatureLibrariesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFeatureLibrariesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFeatureLibraryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFeatureLibraryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFeatureLibrary(ctx context.Context, body CreateFeatureLibraryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFeatureLibraryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeatureLibrary(ctx context.Context, featureLibraryId string, params *GetFeatureLibraryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeatureLibraryRequest(c.Server, featureLibraryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFeatureLibraryWithBody(ctx context.Context, featureLibraryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFeatureLibraryRequestWithBody(c.Server, featureLibraryId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFeatureLibrary(ctx context.Context, featureLibraryId string, body UpdateFeatureLibraryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFeatureLibraryRequest(c.Server, featureLibraryId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFeatures(ctx context.Context, params *ListFeaturesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFeaturesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFeatureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFeatureRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFeature(ctx context.Context, body CreateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFeatureRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFeature(ctx context.Context, featureId string, params *GetFeatureParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFeatureRequest(c.Server, featureId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFeatureWithBody(ctx context.Context, featureId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFeatureRequestWithBody(c.Server, featureId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFeature(ctx context.Context, featureId string, body UpdateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFeatureRequest(c.Server, featureId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateFeaturesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateFeaturesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateFeatures(ctx context.Context, body BulkCreateFeaturesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateFeaturesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFolders(ctx context.Context, params *ListFoldersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFoldersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFolderWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFolderRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFolder(ctx context.Context, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFolderRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFolder(ctx context.Context, folderId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFolderRequest(c.Server, folderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveFoldersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveFoldersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveFolders(ctx context.Context, body ArchiveFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveFoldersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveFoldersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveFoldersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveFolders(ctx context.Context, body UnarchiveFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveFoldersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLegacyWorkflowStageRunInputSamples(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLegacyWorkflowStageRunInputSamplesRequest(c.Server, stageRunId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLegacyWorkflowStageRunOutputSamples(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLegacyWorkflowStageRunOutputSamplesRequest(c.Server, stageRunId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLegacyWorkflowStageRunRegisteredSamples(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLegacyWorkflowStageRunRegisteredSamplesRequest(c.Server, stageRunId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLegacyWorkflowStageRuns(ctx context.Context, stageId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLegacyWorkflowStageRunsRequest(c.Server, stageId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLegacyWorkflows(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLegacyWorkflowsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLegacyWorkflowMetadataWithBody(ctx context.Context, legacyWorkflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLegacyWorkflowMetadataRequestWithBody(c.Server, legacyWorkflowId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLegacyWorkflowMetadata(ctx context.Context, legacyWorkflowId string, body UpdateLegacyWorkflowMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLegacyWorkflowMetadataRequest(c.Server, legacyWorkflowId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLegacyWorkflowStages(ctx context.Context, legacyWorkflowId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLegacyWorkflowStagesRequest(c.Server, legacyWorkflowId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLocationSchemas(ctx context.Context, params *ListLocationSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLocationSchemasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocationSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationSchemaRequest(c.Server, schemaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLocations(ctx context.Context, params *ListLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLocationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLocationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLocationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLocation(ctx context.Context, body CreateLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLocationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocation(ctx context.Context, locationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationRequest(c.Server, locationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLocationWithBody(ctx context.Context, locationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLocationRequestWithBody(c.Server, locationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateLocation(ctx context.Context, locationId string, body UpdateLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateLocationRequest(c.Server, locationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveLocationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveLocationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveLocations(ctx context.Context, body ArchiveLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveLocationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkGetLocations(ctx context.Context, params *BulkGetLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkGetLocationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveLocationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveLocationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveLocations(ctx context.Context, body UnarchiveLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveLocationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMixtures(ctx context.Context, params *ListMixturesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMixturesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMixtureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMixtureRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMixture(ctx context.Context, body CreateMixtureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMixtureRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMixture(ctx context.Context, mixtureId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMixtureRequest(c.Server, mixtureId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMixtureWithBody(ctx context.Context, mixtureId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMixtureRequestWithBody(c.Server, mixtureId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMixture(ctx context.Context, mixtureId string, body UpdateMixtureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMixtureRequest(c.Server, mixtureId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveMixturesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveMixturesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveMixtures(ctx context.Context, body ArchiveMixturesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveMixturesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateMixturesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateMixturesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateMixtures(ctx context.Context, body BulkCreateMixturesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateMixturesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateMixturesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateMixturesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateMixtures(ctx context.Context, body BulkUpdateMixturesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateMixturesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveMixturesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveMixturesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveMixtures(ctx context.Context, body UnarchiveMixturesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveMixturesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMolecules(ctx context.Context, params *ListMoleculesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMoleculesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMoleculeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMoleculeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMolecule(ctx context.Context, body CreateMoleculeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMoleculeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMolecule(ctx context.Context, moleculeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMoleculeRequest(c.Server, moleculeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMoleculeWithBody(ctx context.Context, moleculeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMoleculeRequestWithBody(c.Server, moleculeId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMolecule(ctx context.Context, moleculeId string, body UpdateMoleculeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMoleculeRequest(c.Server, moleculeId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveMoleculesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveMoleculesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveMolecules(ctx context.Context, body ArchiveMoleculesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveMoleculesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateMoleculesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateMoleculesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateMolecules(ctx context.Context, body BulkCreateMoleculesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateMoleculesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateMoleculesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateMoleculesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateMolecules(ctx context.Context, body BulkUpdateMoleculesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateMoleculesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveMoleculesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveMoleculesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveMolecules(ctx context.Context, body UnarchiveMoleculesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveMoleculesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMonomers(ctx context.Context, params *ListMonomersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMonomersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMonomerWithBody(ctx context.Context, params *CreateMonomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMonomerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMonomer(ctx context.Context, params *CreateMonomerParams, body CreateMonomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMonomerRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMonomerWithBody(ctx context.Context, monomerId string, params *UpdateMonomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMonomerRequestWithBody(c.Server, monomerId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMonomer(ctx context.Context, monomerId string, params *UpdateMonomerParams, body UpdateMonomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMonomerRequest(c.Server, monomerId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveMonomersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveMonomersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveMonomers(ctx context.Context, body ArchiveMonomersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveMonomersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveMonomersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveMonomersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveMonomers(ctx context.Context, body UnarchiveMonomersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveMonomersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNucleotideAlignments(ctx context.Context, params *ListNucleotideAlignmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNucleotideAlignmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNucleotideAlignment(ctx context.Context, alignmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNucleotideAlignmentRequest(c.Server, alignmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNucleotideAlignment(ctx context.Context, alignmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNucleotideAlignmentRequest(c.Server, alignmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConsensusNucleotideAlignmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConsensusNucleotideAlignmentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConsensusNucleotideAlignment(ctx context.Context, body CreateConsensusNucleotideAlignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConsensusNucleotideAlignmentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTemplateNucleotideAlignmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTemplateNucleotideAlignmentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTemplateNucleotideAlignment(ctx context.Context, body CreateTemplateNucleotideAlignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTemplateNucleotideAlignmentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOligos(ctx context.Context, params *ListOligosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOligosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOligoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOligoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOligo(ctx context.Context, body CreateOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOligoRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOligo(ctx context.Context, oligoId string, params *GetOligoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOligoRequest(c.Server, oligoId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOligoWithBody(ctx context.Context, oligoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOligoRequestWithBody(c.Server, oligoId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOligo(ctx context.Context, oligoId string, body UpdateOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOligoRequest(c.Server, oligoId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveOligosRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveOligos(ctx context.Context, body ArchiveOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveOligosRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateOligosRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateOligos(ctx context.Context, body BulkCreateOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateOligosRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkGetOligos(ctx context.Context, params *BulkGetOligosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkGetOligosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveOligosRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveOligos(ctx context.Context, body UnarchiveOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveOligosRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOrganizations(ctx context.Context, params *ListOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOrganizationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganization(ctx context.Context, organizationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationRequest(c.Server, organizationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlateSchemas(ctx context.Context, params *ListPlateSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPlateSchemasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlateSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlateSchemaRequest(c.Server, schemaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlates(ctx context.Context, params *ListPlatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPlatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlateWithBody(ctx context.Context, params *CreatePlateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePlate(ctx context.Context, params *CreatePlateParams, body CreatePlateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePlateRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlate(ctx context.Context, plateId string, params *GetPlateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlateRequest(c.Server, plateId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlateWithBody(ctx context.Context, plateId string, params *UpdatePlateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlateRequestWithBody(c.Server, plateId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePlate(ctx context.Context, plateId string, params *UpdatePlateParams, body UpdatePlateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePlateRequest(c.Server, plateId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchivePlatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchivePlatesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchivePlates(ctx context.Context, body ArchivePlatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchivePlatesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkGetPlates(ctx context.Context, params *BulkGetPlatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkGetPlatesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchivePlatesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchivePlatesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchivePlates(ctx context.Context, body UnarchivePlatesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchivePlatesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListProjects(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListProjectsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProject(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProjectRequest(c.Server, projectId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveProjectsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveProjectsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveProjects(ctx context.Context, body ArchiveProjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveProjectsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveProjectsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveProjectsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveProjects(ctx context.Context, body UnarchiveProjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveProjectsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRegistries(ctx context.Context, params *ListRegistriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRegistriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistry(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryRequest(c.Server, registryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBatchSchemasByRegistry(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBatchSchemasByRegistryRequest(c.Server, registryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBoxSchemasByRegistry(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBoxSchemasByRegistryRequest(c.Server, registryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListContainerSchemasByRegistry(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListContainerSchemasByRegistryRequest(c.Server, registryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDropdownsByRegistry(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDropdownsByRegistryRequest(c.Server, registryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEntitySchemasByRegistry(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEntitySchemasByRegistryRequest(c.Server, registryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPrinters(ctx context.Context, registryId string, params *ListPrintersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPrintersRequest(c.Server, registryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLabelTemplates(ctx context.Context, registryId string, params *ListLabelTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLabelTemplatesRequest(c.Server, registryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListLocationSchemasByRegistry(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListLocationSchemasByRegistryRequest(c.Server, registryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlateSchemasByRegistry(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPlateSchemasByRegistryRequest(c.Server, registryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkGetRegisteredEntities(ctx context.Context, registryId string, params *BulkGetRegisteredEntitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkGetRegisteredEntitiesRequest(c.Server, registryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterEntitiesWithBody(ctx context.Context, registryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterEntitiesRequestWithBody(c.Server, registryId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterEntities(ctx context.Context, registryId string, body RegisterEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterEntitiesRequest(c.Server, registryId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnregisterEntitiesWithBody(ctx context.Context, registryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnregisterEntitiesRequestWithBody(c.Server, registryId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnregisterEntities(ctx context.Context, registryId string, body UnregisterEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnregisterEntitiesRequest(c.Server, registryId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateBarcodesWithBody(ctx context.Context, registryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateBarcodesRequestWithBody(c.Server, registryId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ValidateBarcodes(ctx context.Context, registryId string, body ValidateBarcodesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewValidateBarcodesRequest(c.Server, registryId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRequestFulfillments(ctx context.Context, params *ListRequestFulfillmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRequestFulfillmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRequestFulfillment(ctx context.Context, requestFulfillmentId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequestFulfillmentRequest(c.Server, requestFulfillmentId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRequestSchemas(ctx context.Context, params *ListRequestSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRequestSchemasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRequestSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequestSchemaRequest(c.Server, schemaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRequestTaskSchemas(ctx context.Context, params *ListRequestTaskSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRequestTaskSchemasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRequestTaskSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequestTaskSchemaRequest(c.Server, schemaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRequests(ctx context.Context, params *ListRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRequestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRequest(ctx context.Context, body CreateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRequest(ctx context.Context, requestId string, params *GetRequestParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequestRequest(c.Server, requestId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchRequestWithBody(ctx context.Context, requestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchRequestRequestWithBody(c.Server, requestId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchRequest(ctx context.Context, requestId string, body PatchRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchRequestRequest(c.Server, requestId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRequestResponse(ctx context.Context, requestId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRequestResponseRequest(c.Server, requestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateRequestTasksWithBody(ctx context.Context, requestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateRequestTasksRequestWithBody(c.Server, requestId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateRequestTasks(ctx context.Context, requestId string, body BulkCreateRequestTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateRequestTasksRequest(c.Server, requestId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateRequestTasksWithBody(ctx context.Context, requestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateRequestTasksRequestWithBody(c.Server, requestId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateRequestTasks(ctx context.Context, requestId string, body BulkUpdateRequestTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateRequestTasksRequest(c.Server, requestId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteRequestsSampleGroupsWithBody(ctx context.Context, requestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteRequestsSampleGroupsRequestWithBody(c.Server, requestId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteRequestsSampleGroups(ctx context.Context, requestId string, body ExecuteRequestsSampleGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteRequestsSampleGroupsRequest(c.Server, requestId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkGetRequests(ctx context.Context, params *BulkGetRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkGetRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssayResultsTransaction(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssayResultsTransactionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssayResultsInTransactionWithBody(ctx context.Context, transactionId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssayResultsInTransactionRequestWithBody(c.Server, transactionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssayResultsInTransaction(ctx context.Context, transactionId openapi_types.UUID, body CreateAssayResultsInTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssayResultsInTransactionRequest(c.Server, transactionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AbortAssayResultsTransaction(ctx context.Context, transactionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAbortAssayResultsTransactionRequest(c.Server, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitAssayResultsTransaction(ctx context.Context, transactionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitAssayResultsTransactionRequest(c.Server, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRNAOligos(ctx context.Context, params *ListRNAOligosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRNAOligosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRNAOligoWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRNAOligoRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRNAOligo(ctx context.Context, body CreateRNAOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRNAOligoRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRNAOligo(ctx context.Context, oligoId string, params *GetRNAOligoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRNAOligoRequest(c.Server, oligoId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRNAOligoWithBody(ctx context.Context, oligoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRNAOligoRequestWithBody(c.Server, oligoId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRNAOligo(ctx context.Context, oligoId string, body UpdateRNAOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRNAOligoRequest(c.Server, oligoId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveRNAOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveRNAOligosRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveRNAOligos(ctx context.Context, body ArchiveRNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveRNAOligosRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateRNAOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateRNAOligosRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateRNAOligos(ctx context.Context, body BulkCreateRNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateRNAOligosRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateRNAOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateRNAOligosRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateRNAOligos(ctx context.Context, body BulkUpdateRNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateRNAOligosRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveRNAOligosWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveRNAOligosRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveRNAOligos(ctx context.Context, body UnarchiveRNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveRNAOligosRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListRNASequences(ctx context.Context, params *ListRNASequencesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListRNASequencesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRNASequenceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRNASequenceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRNASequence(ctx context.Context, body CreateRNASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRNASequenceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRNASequence(ctx context.Context, rnaSequenceId string, params *GetRNASequenceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRNASequenceRequest(c.Server, rnaSequenceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRNASequenceWithBody(ctx context.Context, rnaSequenceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRNASequenceRequestWithBody(c.Server, rnaSequenceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRNASequence(ctx context.Context, rnaSequenceId string, body UpdateRNASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRNASequenceRequest(c.Server, rnaSequenceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveRNASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveRNASequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveRNASequences(ctx context.Context, body ArchiveRNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveRNASequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutoAnnotateRnaSequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutoAnnotateRnaSequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutoAnnotateRnaSequences(ctx context.Context, body AutoAnnotateRnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutoAnnotateRnaSequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutofillRNASequencePartsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutofillRNASequencePartsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutofillRNASequenceParts(ctx context.Context, body AutofillRNASequencePartsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutofillRNASequencePartsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutofillRNASequenceTranslationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutofillRNASequenceTranslationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AutofillRNASequenceTranslations(ctx context.Context, body AutofillRNASequenceTranslationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAutofillRNASequenceTranslationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateRNASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateRNASequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateRNASequences(ctx context.Context, body BulkCreateRNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateRNASequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkGetRNASequences(ctx context.Context, params *BulkGetRNASequencesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkGetRNASequencesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateRNASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateRNASequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateRNASequences(ctx context.Context, body BulkUpdateRNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateRNASequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MatchBasesRnaSequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMatchBasesRnaSequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MatchBasesRnaSequences(ctx context.Context, body MatchBasesRnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMatchBasesRnaSequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRnaSequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRnaSequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRnaSequences(ctx context.Context, body SearchRnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRnaSequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveRNASequencesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveRNASequencesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveRNASequences(ctx context.Context, body UnarchiveRNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveRNASequencesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTask(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTaskRequest(c.Server, taskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTeams(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeam(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamRequest(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateTokenWithFormdataBody(ctx context.Context, body GenerateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateTokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferIntoContainersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferIntoContainersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferIntoContainers(ctx context.Context, body TransferIntoContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferIntoContainersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListUsers(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserActivity(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserActivityRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateUsers(ctx context.Context, body BulkCreateUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateUsers(ctx context.Context, body BulkUpdateUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWarehouseCredentialsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWarehouseCredentialsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWarehouseCredentials(ctx context.Context, body CreateWarehouseCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWarehouseCredentialsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkflowOutputs(ctx context.Context, params *ListWorkflowOutputsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkflowOutputsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkflowOutputWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkflowOutputRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkflowOutput(ctx context.Context, body CreateWorkflowOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkflowOutputRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkflowOutput(ctx context.Context, workflowOutputId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkflowOutputRequest(c.Server, workflowOutputId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkflowOutputWithBody(ctx context.Context, workflowOutputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkflowOutputRequestWithBody(c.Server, workflowOutputId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkflowOutput(ctx context.Context, workflowOutputId string, body UpdateWorkflowOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkflowOutputRequest(c.Server, workflowOutputId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveWorkflowOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveWorkflowOutputsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveWorkflowOutputs(ctx context.Context, body ArchiveWorkflowOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveWorkflowOutputsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateWorkflowOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateWorkflowOutputsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateWorkflowOutputs(ctx context.Context, body BulkCreateWorkflowOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateWorkflowOutputsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateWorkflowOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateWorkflowOutputsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateWorkflowOutputs(ctx context.Context, body BulkUpdateWorkflowOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateWorkflowOutputsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveWorkflowOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveWorkflowOutputsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveWorkflowOutputs(ctx context.Context, body UnarchiveWorkflowOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveWorkflowOutputsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStageRunInputSamples(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStageRunInputSamplesRequest(c.Server, stageRunId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStageRunOutputSamples(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStageRunOutputSamplesRequest(c.Server, stageRunId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStageRunRegisteredSamples(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStageRunRegisteredSamplesRequest(c.Server, stageRunId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkflowStageRuns(ctx context.Context, stageId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkflowStageRunsRequest(c.Server, stageId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkflowTaskGroups(ctx context.Context, params *ListWorkflowTaskGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkflowTaskGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkflowTaskGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkflowTaskGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkflowTaskGroup(ctx context.Context, body CreateWorkflowTaskGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkflowTaskGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkflowTaskGroup(ctx context.Context, workflowTaskGroupId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkflowTaskGroupRequest(c.Server, workflowTaskGroupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkflowTaskGroupWithBody(ctx context.Context, workflowTaskGroupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkflowTaskGroupRequestWithBody(c.Server, workflowTaskGroupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkflowTaskGroup(ctx context.Context, workflowTaskGroupId string, body UpdateWorkflowTaskGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkflowTaskGroupRequest(c.Server, workflowTaskGroupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveWorkflowTaskGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveWorkflowTaskGroupsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveWorkflowTaskGroups(ctx context.Context, body ArchiveWorkflowTaskGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveWorkflowTaskGroupsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveWorkflowTaskGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveWorkflowTaskGroupsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveWorkflowTaskGroups(ctx context.Context, body UnarchiveWorkflowTaskGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveWorkflowTaskGroupsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkflowTaskSchemas(ctx context.Context, params *ListWorkflowTaskSchemasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkflowTaskSchemasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkflowTaskSchema(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkflowTaskSchemaRequest(c.Server, schemaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkflowTasks(ctx context.Context, params *ListWorkflowTasksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkflowTasksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkflowTaskWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkflowTaskRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWorkflowTask(ctx context.Context, body CreateWorkflowTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWorkflowTaskRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkflowTask(ctx context.Context, workflowTaskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkflowTaskRequest(c.Server, workflowTaskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkflowTaskWithBody(ctx context.Context, workflowTaskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkflowTaskRequestWithBody(c.Server, workflowTaskId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkflowTask(ctx context.Context, workflowTaskId string, body UpdateWorkflowTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkflowTaskRequest(c.Server, workflowTaskId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyWorkflowTask(ctx context.Context, workflowTaskId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyWorkflowTaskRequest(c.Server, workflowTaskId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveWorkflowTasksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveWorkflowTasksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveWorkflowTasks(ctx context.Context, body ArchiveWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveWorkflowTasksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCopyWorkflowTasksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCopyWorkflowTasksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCopyWorkflowTasks(ctx context.Context, body BulkCopyWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCopyWorkflowTasksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateWorkflowTasksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateWorkflowTasksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkCreateWorkflowTasks(ctx context.Context, body BulkCreateWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkCreateWorkflowTasksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateWorkflowTasksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateWorkflowTasksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateWorkflowTasks(ctx context.Context, body BulkUpdateWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateWorkflowTasksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveWorkflowTasksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveWorkflowTasksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnarchiveWorkflowTasks(ctx context.Context, body UnarchiveWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnarchiveWorkflowTasksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkflows(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkflowsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkflowMetadataWithBody(ctx context.Context, workflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkflowMetadataRequestWithBody(c.Server, workflowId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWorkflowMetadata(ctx context.Context, workflowId string, body UpdateWorkflowMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWorkflowMetadataRequest(c.Server, workflowId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListWorkflowStages(ctx context.Context, workflowId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListWorkflowStagesRequest(c.Server, workflowId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListAASequencesRequest generates requests for ListAASequences
func NewListAASequencesRequest(server string, params *ListAASequencesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aa-sequences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AminoAcids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aminoAcids", runtime.ParamLocationQuery, *params.AminoAcids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FolderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "folderId", runtime.ParamLocationQuery, *params.FolderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MentionedIn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentionedIn", runtime.ParamLocationQuery, *params.MentionedIn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegistryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "registryId", runtime.ParamLocationQuery, *params.RegistryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaFields", runtime.ParamLocationQuery, *params.SchemaFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mentions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentions", runtime.ParamLocationQuery, *params.Mentions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntityRegistryIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entityRegistryIds.anyOf", runtime.ParamLocationQuery, *params.EntityRegistryIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authorIds.anyOf", runtime.ParamLocationQuery, *params.AuthorIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAASequenceRequest calls the generic CreateAASequence builder with application/json body
func NewCreateAASequenceRequest(server string, body CreateAASequenceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAASequenceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAASequenceRequestWithBody generates requests for CreateAASequence with any type of body
func NewCreateAASequenceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aa-sequences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAASequenceRequest generates requests for GetAASequence
func NewGetAASequenceRequest(server string, aaSequenceId string, params *GetAASequenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "aa_sequence_id", runtime.ParamLocationPath, aaSequenceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aa-sequences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAASequenceRequest calls the generic UpdateAASequence builder with application/json body
func NewUpdateAASequenceRequest(server string, aaSequenceId string, body UpdateAASequenceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAASequenceRequestWithBody(server, aaSequenceId, "application/json", bodyReader)
}

// NewUpdateAASequenceRequestWithBody generates requests for UpdateAASequence with any type of body
func NewUpdateAASequenceRequestWithBody(server string, aaSequenceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "aa_sequence_id", runtime.ParamLocationPath, aaSequenceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aa-sequences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveAASequencesRequest calls the generic ArchiveAASequences builder with application/json body
func NewArchiveAASequencesRequest(server string, body ArchiveAASequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveAASequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveAASequencesRequestWithBody generates requests for ArchiveAASequences with any type of body
func NewArchiveAASequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aa-sequences:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAutoAnnotateAaSequencesRequest calls the generic AutoAnnotateAaSequences builder with application/json body
func NewAutoAnnotateAaSequencesRequest(server string, body AutoAnnotateAaSequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAutoAnnotateAaSequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewAutoAnnotateAaSequencesRequestWithBody generates requests for AutoAnnotateAaSequences with any type of body
func NewAutoAnnotateAaSequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aa-sequences:auto-annotate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkCreateAASequencesRequest calls the generic BulkCreateAASequences builder with application/json body
func NewBulkCreateAASequencesRequest(server string, body BulkCreateAASequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateAASequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateAASequencesRequestWithBody generates requests for BulkCreateAASequences with any type of body
func NewBulkCreateAASequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aa-sequences:bulk-create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkGetAASequencesRequest generates requests for BulkGetAASequences
func NewBulkGetAASequencesRequest(server string, params *BulkGetAASequencesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aa-sequences:bulk-get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "aaSequenceIds", runtime.ParamLocationQuery, params.AaSequenceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkUpdateAASequencesRequest calls the generic BulkUpdateAASequences builder with application/json body
func NewBulkUpdateAASequencesRequest(server string, body BulkUpdateAASequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateAASequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateAASequencesRequestWithBody generates requests for BulkUpdateAASequences with any type of body
func NewBulkUpdateAASequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aa-sequences:bulk-update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveAASequencesRequest calls the generic UnarchiveAASequences builder with application/json body
func NewUnarchiveAASequencesRequest(server string, body UnarchiveAASequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveAASequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveAASequencesRequestWithBody generates requests for UnarchiveAASequences with any type of body
func NewUnarchiveAASequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aa-sequences:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAppCanvasRequest calls the generic CreateAppCanvas builder with application/json body
func NewCreateAppCanvasRequest(server string, body CreateAppCanvasJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAppCanvasRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAppCanvasRequestWithBody generates requests for CreateAppCanvas with any type of body
func NewCreateAppCanvasRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app-canvases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppCanvasRequest generates requests for GetAppCanvas
func NewGetAppCanvasRequest(server string, canvasId string, params *GetAppCanvasParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "canvas_id", runtime.ParamLocationPath, canvasId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app-canvases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppCanvasRequest calls the generic UpdateAppCanvas builder with application/json body
func NewUpdateAppCanvasRequest(server string, canvasId string, body UpdateAppCanvasJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppCanvasRequestWithBody(server, canvasId, "application/json", bodyReader)
}

// NewUpdateAppCanvasRequestWithBody generates requests for UpdateAppCanvas with any type of body
func NewUpdateAppCanvasRequestWithBody(server string, canvasId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "canvas_id", runtime.ParamLocationPath, canvasId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app-canvases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveAppCanvasesRequest calls the generic ArchiveAppCanvases builder with application/json body
func NewArchiveAppCanvasesRequest(server string, body ArchiveAppCanvasesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveAppCanvasesRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveAppCanvasesRequestWithBody generates requests for ArchiveAppCanvases with any type of body
func NewArchiveAppCanvasesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app-canvases:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveAppCanvasesRequest calls the generic UnarchiveAppCanvases builder with application/json body
func NewUnarchiveAppCanvasesRequest(server string, body UnarchiveAppCanvasesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveAppCanvasesRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveAppCanvasesRequestWithBody generates requests for UnarchiveAppCanvases with any type of body
func NewUnarchiveAppCanvasesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app-canvases:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAppConfigurationItemsRequest generates requests for ListAppConfigurationItems
func NewListAppConfigurationItemsRequest(server string, params *ListAppConfigurationItemsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app-configuration-items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AppId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "appId", runtime.ParamLocationQuery, *params.AppId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAppConfigurationItemRequest calls the generic CreateAppConfigurationItem builder with application/json body
func NewCreateAppConfigurationItemRequest(server string, body CreateAppConfigurationItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAppConfigurationItemRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAppConfigurationItemRequestWithBody generates requests for CreateAppConfigurationItem with any type of body
func NewCreateAppConfigurationItemRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app-configuration-items")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppConfigurationItemByIdRequest generates requests for GetAppConfigurationItemById
func NewGetAppConfigurationItemByIdRequest(server string, itemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "item_id", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app-configuration-items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppConfigurationItemRequest calls the generic UpdateAppConfigurationItem builder with application/json body
func NewUpdateAppConfigurationItemRequest(server string, itemId string, body UpdateAppConfigurationItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppConfigurationItemRequestWithBody(server, itemId, "application/json", bodyReader)
}

// NewUpdateAppConfigurationItemRequestWithBody generates requests for UpdateAppConfigurationItem with any type of body
func NewUpdateAppConfigurationItemRequestWithBody(server string, itemId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "item_id", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app-configuration-items/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkCreateAppConfigurationItemsRequest calls the generic BulkCreateAppConfigurationItems builder with application/json body
func NewBulkCreateAppConfigurationItemsRequest(server string, body BulkCreateAppConfigurationItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateAppConfigurationItemsRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateAppConfigurationItemsRequestWithBody generates requests for BulkCreateAppConfigurationItems with any type of body
func NewBulkCreateAppConfigurationItemsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app-configuration-items:bulk-create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkUpdateAppConfigurationItemsRequest calls the generic BulkUpdateAppConfigurationItems builder with application/json body
func NewBulkUpdateAppConfigurationItemsRequest(server string, body BulkUpdateAppConfigurationItemsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateAppConfigurationItemsRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateAppConfigurationItemsRequestWithBody generates requests for BulkUpdateAppConfigurationItems with any type of body
func NewBulkUpdateAppConfigurationItemsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app-configuration-items:bulk-update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAppSessionRequest calls the generic CreateAppSession builder with application/json body
func NewCreateAppSessionRequest(server string, body CreateAppSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAppSessionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAppSessionRequestWithBody generates requests for CreateAppSession with any type of body
func NewCreateAppSessionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app-sessions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppSessionByIdRequest generates requests for GetAppSessionById
func NewGetAppSessionByIdRequest(server string, id string, params *GetAppSessionByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app-sessions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppSessionRequest calls the generic UpdateAppSession builder with application/json body
func NewUpdateAppSessionRequest(server string, id string, body UpdateAppSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppSessionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateAppSessionRequestWithBody generates requests for UpdateAppSession with any type of body
func NewUpdateAppSessionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app-sessions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBenchlingAppsRequest generates requests for ListBenchlingApps
func NewListBenchlingAppsRequest(server string, params *ListBenchlingAppsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memberOf", runtime.ParamLocationQuery, *params.MemberOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdminOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adminOf", runtime.ParamLocationQuery, *params.AdminOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBenchlingAppRequest calls the generic CreateBenchlingApp builder with application/json body
func NewCreateBenchlingAppRequest(server string, body CreateBenchlingAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBenchlingAppRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBenchlingAppRequestWithBody generates requests for CreateBenchlingApp with any type of body
func NewCreateBenchlingAppRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBenchlingAppByIDRequest generates requests for GetBenchlingAppByID
func NewGetBenchlingAppByIDRequest(server string, appId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_id", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchBenchlingAppRequest calls the generic PatchBenchlingApp builder with application/json body
func NewPatchBenchlingAppRequest(server string, appId string, body PatchBenchlingAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchBenchlingAppRequestWithBody(server, appId, "application/json", bodyReader)
}

// NewPatchBenchlingAppRequestWithBody generates requests for PatchBenchlingApp with any type of body
func NewPatchBenchlingAppRequestWithBody(server string, appId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "app_id", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveBenchlingAppsRequest calls the generic ArchiveBenchlingApps builder with application/json body
func NewArchiveBenchlingAppsRequest(server string, body ArchiveBenchlingAppsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveBenchlingAppsRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveBenchlingAppsRequestWithBody generates requests for ArchiveBenchlingApps with any type of body
func NewArchiveBenchlingAppsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveBenchlingAppsRequest calls the generic UnarchiveBenchlingApps builder with application/json body
func NewUnarchiveBenchlingAppsRequest(server string, body UnarchiveBenchlingAppsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveBenchlingAppsRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveBenchlingAppsRequestWithBody generates requests for UnarchiveBenchlingApps with any type of body
func NewUnarchiveBenchlingAppsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAssayResultSchemasRequest generates requests for ListAssayResultSchemas
func NewListAssayResultSchemasRequest(server string, params *ListAssayResultSchemasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-result-schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResultSchemaRequest generates requests for GetResultSchema
func NewGetResultSchemaRequest(server string, schemaId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-result-schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAssayResultsRequest generates requests for ListAssayResults
func NewListAssayResultsRequest(server string, params *ListAssayResultsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-results")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAtLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAt.lt", runtime.ParamLocationQuery, *params.CreatedAtLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAtGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAt.gt", runtime.ParamLocationQuery, *params.CreatedAtGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAtLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAt.lte", runtime.ParamLocationQuery, *params.CreatedAtLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAtGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAt.gte", runtime.ParamLocationQuery, *params.CreatedAtGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCreatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCreatedTime", runtime.ParamLocationQuery, *params.MinCreatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxCreatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxCreatedTime", runtime.ParamLocationQuery, *params.MaxCreatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntityIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entityIds", runtime.ParamLocationQuery, *params.EntityIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StorageIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storageIds", runtime.ParamLocationQuery, *params.StorageIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssayRunIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assayRunIds", runtime.ParamLocationQuery, *params.AssayRunIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AutomationOutputProcessorId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "automationOutputProcessorId", runtime.ParamLocationQuery, *params.AutomationOutputProcessorId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAtLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt.lt", runtime.ParamLocationQuery, *params.ModifiedAtLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAtGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt.gt", runtime.ParamLocationQuery, *params.ModifiedAtGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAtLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt.lte", runtime.ParamLocationQuery, *params.ModifiedAtLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAtGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt.gte", runtime.ParamLocationQuery, *params.ModifiedAtGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAssayResultsRequest calls the generic CreateAssayResults builder with application/json body
func NewCreateAssayResultsRequest(server string, body CreateAssayResultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAssayResultsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAssayResultsRequestWithBody generates requests for CreateAssayResults with any type of body
func NewCreateAssayResultsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-results")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAssayResultRequest generates requests for GetAssayResult
func NewGetAssayResultRequest(server string, assayResultId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assay_result_id", runtime.ParamLocationPath, assayResultId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-results/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveAssayResultsRequest calls the generic ArchiveAssayResults builder with application/json body
func NewArchiveAssayResultsRequest(server string, body ArchiveAssayResultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveAssayResultsRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveAssayResultsRequestWithBody generates requests for ArchiveAssayResults with any type of body
func NewArchiveAssayResultsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-results:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkCreateAssayResultsRequest calls the generic BulkCreateAssayResults builder with application/json body
func NewBulkCreateAssayResultsRequest(server string, body BulkCreateAssayResultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateAssayResultsRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateAssayResultsRequestWithBody generates requests for BulkCreateAssayResults with any type of body
func NewBulkCreateAssayResultsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-results:bulk-create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkGetAssayResultsRequest generates requests for BulkGetAssayResults
func NewBulkGetAssayResultsRequest(server string, params *BulkGetAssayResultsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-results:bulk-get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assayResultIds", runtime.ParamLocationQuery, params.AssayResultIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnarchiveAssayResultsRequest calls the generic UnarchiveAssayResults builder with application/json body
func NewUnarchiveAssayResultsRequest(server string, body UnarchiveAssayResultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveAssayResultsRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveAssayResultsRequestWithBody generates requests for UnarchiveAssayResults with any type of body
func NewUnarchiveAssayResultsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-results:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAssayRunSchemasRequest generates requests for ListAssayRunSchemas
func NewListAssayRunSchemasRequest(server string, params *ListAssayRunSchemasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-run-schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRunSchemaRequest generates requests for GetRunSchema
func NewGetRunSchemaRequest(server string, schemaId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-run-schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAssayRunsRequest generates requests for ListAssayRuns
func NewListAssayRunsRequest(server string, params *ListAssayRunsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-runs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, params.SchemaId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.MinCreatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCreatedTime", runtime.ParamLocationQuery, *params.MinCreatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxCreatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxCreatedTime", runtime.ParamLocationQuery, *params.MaxCreatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAssayRunsRequest calls the generic CreateAssayRuns builder with application/json body
func NewCreateAssayRunsRequest(server string, body CreateAssayRunsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAssayRunsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAssayRunsRequestWithBody generates requests for CreateAssayRuns with any type of body
func NewCreateAssayRunsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-runs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAssayRunRequest generates requests for GetAssayRun
func NewGetAssayRunRequest(server string, assayRunId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assay_run_id", runtime.ParamLocationPath, assayRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-runs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAssayRunRequest calls the generic UpdateAssayRun builder with application/json body
func NewUpdateAssayRunRequest(server string, assayRunId string, body UpdateAssayRunJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAssayRunRequestWithBody(server, assayRunId, "application/json", bodyReader)
}

// NewUpdateAssayRunRequestWithBody generates requests for UpdateAssayRun with any type of body
func NewUpdateAssayRunRequestWithBody(server string, assayRunId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assay_run_id", runtime.ParamLocationPath, assayRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-runs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAutomationInputGeneratorsRequest generates requests for ListAutomationInputGenerators
func NewListAutomationInputGeneratorsRequest(server string, assayRunId string, params *ListAutomationInputGeneratorsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assay_run_id", runtime.ParamLocationPath, assayRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-runs/%s/automation-input-generators", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAutomationOutputProcessorsDeprecatedRequest generates requests for ListAutomationOutputProcessorsDeprecated
func NewListAutomationOutputProcessorsDeprecatedRequest(server string, assayRunId string, params *ListAutomationOutputProcessorsDeprecatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "assay_run_id", runtime.ParamLocationPath, assayRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-runs/%s/automation-output-processors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveAssayRunsRequest calls the generic ArchiveAssayRuns builder with application/json body
func NewArchiveAssayRunsRequest(server string, body ArchiveAssayRunsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveAssayRunsRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveAssayRunsRequestWithBody generates requests for ArchiveAssayRuns with any type of body
func NewArchiveAssayRunsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-runs:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkGetAssayRunsRequest generates requests for BulkGetAssayRuns
func NewBulkGetAssayRunsRequest(server string, params *BulkGetAssayRunsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-runs:bulk-get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assayRunIds", runtime.ParamLocationQuery, params.AssayRunIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnarchiveAssayRunsRequest calls the generic UnarchiveAssayRuns builder with application/json body
func NewUnarchiveAssayRunsRequest(server string, body UnarchiveAssayRunsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveAssayRunsRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveAssayRunsRequestWithBody generates requests for UnarchiveAssayRuns with any type of body
func NewUnarchiveAssayRunsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/assay-runs:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLabAutomationTransformRequest generates requests for GetLabAutomationTransform
func NewGetLabAutomationTransformRequest(server string, transformId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transform_id", runtime.ParamLocationPath, transformId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-file-transforms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLabAutomationTransformRequest calls the generic UpdateLabAutomationTransform builder with application/json body
func NewUpdateLabAutomationTransformRequest(server string, transformId string, body UpdateLabAutomationTransformJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLabAutomationTransformRequestWithBody(server, transformId, "application/json", bodyReader)
}

// NewUpdateLabAutomationTransformRequestWithBody generates requests for UpdateLabAutomationTransform with any type of body
func NewUpdateLabAutomationTransformRequestWithBody(server string, transformId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transform_id", runtime.ParamLocationPath, transformId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-file-transforms/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAutomationInputGeneratorRequest generates requests for GetAutomationInputGenerator
func NewGetAutomationInputGeneratorRequest(server string, inputGeneratorId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "input_generator_id", runtime.ParamLocationPath, inputGeneratorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-input-generators/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAutomationInputGeneratorRequest calls the generic UpdateAutomationInputGenerator builder with application/json body
func NewUpdateAutomationInputGeneratorRequest(server string, inputGeneratorId string, body UpdateAutomationInputGeneratorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAutomationInputGeneratorRequestWithBody(server, inputGeneratorId, "application/json", bodyReader)
}

// NewUpdateAutomationInputGeneratorRequestWithBody generates requests for UpdateAutomationInputGenerator with any type of body
func NewUpdateAutomationInputGeneratorRequestWithBody(server string, inputGeneratorId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "input_generator_id", runtime.ParamLocationPath, inputGeneratorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-input-generators/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGenerateInputWithAutomationInputGeneratorRequest generates requests for GenerateInputWithAutomationInputGenerator
func NewGenerateInputWithAutomationInputGeneratorRequest(server string, inputGeneratorId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "input_generator_id", runtime.ParamLocationPath, inputGeneratorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-input-generators/%s:generate-input", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListAutomationOutputProcessorsRequest generates requests for ListAutomationOutputProcessors
func NewListAutomationOutputProcessorsRequest(server string, params *ListAutomationOutputProcessorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-output-processors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AssayRunId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assayRunId", runtime.ParamLocationQuery, *params.AssayRunId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AutomationFileConfigName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "automationFileConfigName", runtime.ParamLocationQuery, *params.AutomationFileConfigName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAutomationOutputProcessorRequest calls the generic CreateAutomationOutputProcessor builder with application/json body
func NewCreateAutomationOutputProcessorRequest(server string, body CreateAutomationOutputProcessorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAutomationOutputProcessorRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAutomationOutputProcessorRequestWithBody generates requests for CreateAutomationOutputProcessor with any type of body
func NewCreateAutomationOutputProcessorRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-output-processors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAutomationOutputProcessorRequest generates requests for GetAutomationOutputProcessor
func NewGetAutomationOutputProcessorRequest(server string, outputProcessorId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "output_processor_id", runtime.ParamLocationPath, outputProcessorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-output-processors/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAutomationOutputProcessorRequest calls the generic UpdateAutomationOutputProcessor builder with application/json body
func NewUpdateAutomationOutputProcessorRequest(server string, outputProcessorId string, body UpdateAutomationOutputProcessorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAutomationOutputProcessorRequestWithBody(server, outputProcessorId, "application/json", bodyReader)
}

// NewUpdateAutomationOutputProcessorRequestWithBody generates requests for UpdateAutomationOutputProcessor with any type of body
func NewUpdateAutomationOutputProcessorRequestWithBody(server string, outputProcessorId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "output_processor_id", runtime.ParamLocationPath, outputProcessorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-output-processors/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewProcessOutputWithAutomationOutputProcessorRequest generates requests for ProcessOutputWithAutomationOutputProcessor
func NewProcessOutputWithAutomationOutputProcessorRequest(server string, outputProcessorId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "output_processor_id", runtime.ParamLocationPath, outputProcessorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-output-processors/%s:process-output", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveAutomationOutputProcessorsRequest calls the generic ArchiveAutomationOutputProcessors builder with application/json body
func NewArchiveAutomationOutputProcessorsRequest(server string, body ArchiveAutomationOutputProcessorsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveAutomationOutputProcessorsRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveAutomationOutputProcessorsRequestWithBody generates requests for ArchiveAutomationOutputProcessors with any type of body
func NewArchiveAutomationOutputProcessorsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-output-processors:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveAutomationOutputProcessorsRequest calls the generic UnarchiveAutomationOutputProcessors builder with application/json body
func NewUnarchiveAutomationOutputProcessorsRequest(server string, body UnarchiveAutomationOutputProcessorsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveAutomationOutputProcessorsRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveAutomationOutputProcessorsRequestWithBody generates requests for UnarchiveAutomationOutputProcessors with any type of body
func NewUnarchiveAutomationOutputProcessorsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/automation-output-processors:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBatchSchemasRequest generates requests for ListBatchSchemas
func NewListBatchSchemasRequest(server string, params *ListBatchSchemasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch-schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBatchSchemaRequest generates requests for GetBatchSchema
func NewGetBatchSchemaRequest(server string, schemaId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batch-schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBatchesRequest generates requests for ListBatches
func NewListBatchesRequest(server string, params *ListBatchesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaFields", runtime.ParamLocationQuery, *params.SchemaFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBatchRequest calls the generic CreateBatch builder with application/json body
func NewCreateBatchRequest(server string, body CreateBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBatchRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBatchRequestWithBody generates requests for CreateBatch with any type of body
func NewCreateBatchRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBatchRequest generates requests for GetBatch
func NewGetBatchRequest(server string, batchId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batch_id", runtime.ParamLocationPath, batchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBatchRequest calls the generic UpdateBatch builder with application/json body
func NewUpdateBatchRequest(server string, batchId string, body UpdateBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBatchRequestWithBody(server, batchId, "application/json", bodyReader)
}

// NewUpdateBatchRequestWithBody generates requests for UpdateBatch with any type of body
func NewUpdateBatchRequestWithBody(server string, batchId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "batch_id", runtime.ParamLocationPath, batchId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveBatchesRequest calls the generic ArchiveBatches builder with application/json body
func NewArchiveBatchesRequest(server string, body ArchiveBatchesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveBatchesRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveBatchesRequestWithBody generates requests for ArchiveBatches with any type of body
func NewArchiveBatchesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkGetBatchesRequest generates requests for BulkGetBatches
func NewBulkGetBatchesRequest(server string, params *BulkGetBatchesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches:bulk-get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BatchIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batchIds", runtime.ParamLocationQuery, *params.BatchIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BatchNames != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "batchNames", runtime.ParamLocationQuery, *params.BatchNames); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegistryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "registryId", runtime.ParamLocationQuery, *params.RegistryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnarchiveBatchesRequest calls the generic UnarchiveBatches builder with application/json body
func NewUnarchiveBatchesRequest(server string, body UnarchiveBatchesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveBatchesRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveBatchesRequestWithBody generates requests for UnarchiveBatches with any type of body
func NewUnarchiveBatchesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/batches:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateBlobRequest calls the generic CreateBlob builder with application/json body
func NewCreateBlobRequest(server string, body CreateBlobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBlobRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBlobRequestWithBody generates requests for CreateBlob with any type of body
func NewCreateBlobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBlobRequest generates requests for GetBlob
func NewGetBlobRequest(server string, blobId string, params *GetBlobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "blob_id", runtime.ParamLocationPath, blobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlobFileRequest generates requests for GetBlobFile
func NewGetBlobFileRequest(server string, blobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "blob_id", runtime.ParamLocationPath, blobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blobs/%s/download", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlobUrlRequest generates requests for GetBlobUrl
func NewGetBlobUrlRequest(server string, blobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "blob_id", runtime.ParamLocationPath, blobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blobs/%s/download-url", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBlobPartRequest calls the generic CreateBlobPart builder with application/json body
func NewCreateBlobPartRequest(server string, blobId string, body CreateBlobPartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBlobPartRequestWithBody(server, blobId, "application/json", bodyReader)
}

// NewCreateBlobPartRequestWithBody generates requests for CreateBlobPart with any type of body
func NewCreateBlobPartRequestWithBody(server string, blobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "blob_id", runtime.ParamLocationPath, blobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blobs/%s/parts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAbortMultipartBlobRequest generates requests for AbortMultipartBlob
func NewAbortMultipartBlobRequest(server string, blobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "blob_id", runtime.ParamLocationPath, blobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blobs/%s:abort-upload", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCompleteMultipartBlobRequest calls the generic CompleteMultipartBlob builder with application/json body
func NewCompleteMultipartBlobRequest(server string, blobId string, body CompleteMultipartBlobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCompleteMultipartBlobRequestWithBody(server, blobId, "application/json", bodyReader)
}

// NewCompleteMultipartBlobRequestWithBody generates requests for CompleteMultipartBlob with any type of body
func NewCompleteMultipartBlobRequestWithBody(server string, blobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "blob_id", runtime.ParamLocationPath, blobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blobs/%s:complete-upload", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkGetBlobsRequest generates requests for BulkGetBlobs
func NewBulkGetBlobsRequest(server string, params *BulkGetBlobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blobs:bulk-get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BlobIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "blobIds", runtime.ParamLocationQuery, *params.BlobIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMultipartBlobRequest calls the generic CreateMultipartBlob builder with application/json body
func NewCreateMultipartBlobRequest(server string, body CreateMultipartBlobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMultipartBlobRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateMultipartBlobRequestWithBody generates requests for CreateMultipartBlob with any type of body
func NewCreateMultipartBlobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/blobs:start-multipart-upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBoxSchemasRequest generates requests for ListBoxSchemas
func NewListBoxSchemasRequest(server string, params *ListBoxSchemasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/box-schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBoxSchemaRequest generates requests for GetBoxSchema
func NewGetBoxSchemaRequest(server string, schemaId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/box-schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBoxesRequest generates requests for ListBoxes
func NewListBoxesRequest(server string, params *ListBoxesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/boxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaFields", runtime.ParamLocationQuery, *params.SchemaFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmptyPositions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "emptyPositions", runtime.ParamLocationQuery, *params.EmptyPositions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmptyPositionsGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "emptyPositions.gte", runtime.ParamLocationQuery, *params.EmptyPositionsGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmptyPositionsGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "emptyPositions.gt", runtime.ParamLocationQuery, *params.EmptyPositionsGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmptyPositionsLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "emptyPositions.lte", runtime.ParamLocationQuery, *params.EmptyPositionsLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmptyPositionsLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "emptyPositions.lt", runtime.ParamLocationQuery, *params.EmptyPositionsLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmptyContainers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "emptyContainers", runtime.ParamLocationQuery, *params.EmptyContainers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmptyContainersGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "emptyContainers.gte", runtime.ParamLocationQuery, *params.EmptyContainersGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmptyContainersGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "emptyContainers.gt", runtime.ParamLocationQuery, *params.EmptyContainersGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmptyContainersLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "emptyContainers.lte", runtime.ParamLocationQuery, *params.EmptyContainersLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmptyContainersLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "emptyContainers.lt", runtime.ParamLocationQuery, *params.EmptyContainersLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AncestorStorageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ancestorStorageId", runtime.ParamLocationQuery, *params.AncestorStorageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StorageContentsId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storageContentsId", runtime.ParamLocationQuery, *params.StorageContentsId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StorageContentsIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storageContentsIds", runtime.ParamLocationQuery, *params.StorageContentsIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Barcodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "barcodes", runtime.ParamLocationQuery, *params.Barcodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBoxRequest calls the generic CreateBox builder with application/json body
func NewCreateBoxRequest(server string, body CreateBoxJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBoxRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateBoxRequestWithBody generates requests for CreateBox with any type of body
func NewCreateBoxRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/boxes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBoxRequest generates requests for GetBox
func NewGetBoxRequest(server string, boxId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "box_id", runtime.ParamLocationPath, boxId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/boxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateBoxRequest calls the generic UpdateBox builder with application/json body
func NewUpdateBoxRequest(server string, boxId string, body UpdateBoxJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateBoxRequestWithBody(server, boxId, "application/json", bodyReader)
}

// NewUpdateBoxRequestWithBody generates requests for UpdateBox with any type of body
func NewUpdateBoxRequestWithBody(server string, boxId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "box_id", runtime.ParamLocationPath, boxId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/boxes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListBoxContentsRequest generates requests for ListBoxContents
func NewListBoxContentsRequest(server string, boxId string, params *ListBoxContentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "box_id", runtime.ParamLocationPath, boxId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/boxes/%s/contents", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveBoxesRequest calls the generic ArchiveBoxes builder with application/json body
func NewArchiveBoxesRequest(server string, body ArchiveBoxesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveBoxesRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveBoxesRequestWithBody generates requests for ArchiveBoxes with any type of body
func NewArchiveBoxesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/boxes:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkGetBoxesRequest generates requests for BulkGetBoxes
func NewBulkGetBoxesRequest(server string, params *BulkGetBoxesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/boxes:bulk-get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BoxIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "boxIds", runtime.ParamLocationQuery, *params.BoxIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Barcodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "barcodes", runtime.ParamLocationQuery, *params.Barcodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnarchiveBoxesRequest calls the generic UnarchiveBoxes builder with application/json body
func NewUnarchiveBoxesRequest(server string, body UnarchiveBoxesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveBoxesRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveBoxesRequestWithBody generates requests for UnarchiveBoxes with any type of body
func NewUnarchiveBoxesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/boxes:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListContainerSchemasRequest generates requests for ListContainerSchemas
func NewListContainerSchemasRequest(server string, params *ListContainerSchemasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/container-schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContainerSchemaRequest generates requests for GetContainerSchema
func NewGetContainerSchemaRequest(server string, schemaId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/container-schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListContainersRequest generates requests for ListContainers
func NewListContainersRequest(server string, params *ListContainersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaFields", runtime.ParamLocationQuery, *params.SchemaFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AncestorStorageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ancestorStorageId", runtime.ParamLocationQuery, *params.AncestorStorageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StorageContentsId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storageContentsId", runtime.ParamLocationQuery, *params.StorageContentsId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StorageContentsIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storageContentsIds", runtime.ParamLocationQuery, *params.StorageContentsIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CheckoutStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "checkoutStatus", runtime.ParamLocationQuery, *params.CheckoutStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CheckoutAssigneeIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "checkoutAssigneeIds.anyOf", runtime.ParamLocationQuery, *params.CheckoutAssigneeIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RestrictionStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "restrictionStatus", runtime.ParamLocationQuery, *params.RestrictionStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SampleOwnerIdsAllOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sampleOwnerIds.allOf", runtime.ParamLocationQuery, *params.SampleOwnerIdsAllOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SampleOwnerIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sampleOwnerIds.anyOf", runtime.ParamLocationQuery, *params.SampleOwnerIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SampleOwnerIdsNoneOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sampleOwnerIds.noneOf", runtime.ParamLocationQuery, *params.SampleOwnerIdsNoneOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RestrictedSamplePartyIdsAllOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "restrictedSamplePartyIds.allOf", runtime.ParamLocationQuery, *params.RestrictedSamplePartyIdsAllOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RestrictedSamplePartyIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "restrictedSamplePartyIds.anyOf", runtime.ParamLocationQuery, *params.RestrictedSamplePartyIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RestrictedSamplePartyIdsNoneOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "restrictedSamplePartyIds.noneOf", runtime.ParamLocationQuery, *params.RestrictedSamplePartyIdsNoneOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Barcodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "barcodes", runtime.ParamLocationQuery, *params.Barcodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateContainerRequest calls the generic CreateContainer builder with application/json body
func NewCreateContainerRequest(server string, body CreateContainerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateContainerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateContainerRequestWithBody generates requests for CreateContainer with any type of body
func NewCreateContainerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetContainerRequest generates requests for GetContainer
func NewGetContainerRequest(server string, containerId string, params *GetContainerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "container_id", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateContainerRequest calls the generic UpdateContainer builder with application/json body
func NewUpdateContainerRequest(server string, containerId string, body UpdateContainerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateContainerRequestWithBody(server, containerId, "application/json", bodyReader)
}

// NewUpdateContainerRequestWithBody generates requests for UpdateContainer with any type of body
func NewUpdateContainerRequestWithBody(server string, containerId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "container_id", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListContainerContentsRequest generates requests for ListContainerContents
func NewListContainerContentsRequest(server string, containerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "container_id", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers/%s/contents", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteContainerContentRequest generates requests for DeleteContainerContent
func NewDeleteContainerContentRequest(server string, containerId string, containableId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "container_id", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "containable_id", runtime.ParamLocationPath, containableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers/%s/contents/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContainerContentRequest generates requests for GetContainerContent
func NewGetContainerContentRequest(server string, containerId string, containableId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "container_id", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "containable_id", runtime.ParamLocationPath, containableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers/%s/contents/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateContainerContentRequest calls the generic UpdateContainerContent builder with application/json body
func NewUpdateContainerContentRequest(server string, containerId string, containableId string, body UpdateContainerContentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateContainerContentRequestWithBody(server, containerId, containableId, "application/json", bodyReader)
}

// NewUpdateContainerContentRequestWithBody generates requests for UpdateContainerContent with any type of body
func NewUpdateContainerContentRequestWithBody(server string, containerId string, containableId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "container_id", runtime.ParamLocationPath, containerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "containable_id", runtime.ParamLocationPath, containableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers/%s/contents/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTransferIntoContainerRequest calls the generic TransferIntoContainer builder with application/json body
func NewTransferIntoContainerRequest(server string, destinationContainerId string, body TransferIntoContainerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTransferIntoContainerRequestWithBody(server, destinationContainerId, "application/json", bodyReader)
}

// NewTransferIntoContainerRequestWithBody generates requests for TransferIntoContainer with any type of body
func NewTransferIntoContainerRequestWithBody(server string, destinationContainerId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "destination_container_id", runtime.ParamLocationPath, destinationContainerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers/%s:transfer", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveContainersRequest calls the generic ArchiveContainers builder with application/json body
func NewArchiveContainersRequest(server string, body ArchiveContainersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveContainersRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveContainersRequestWithBody generates requests for ArchiveContainers with any type of body
func NewArchiveContainersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkCreateContainersRequest calls the generic BulkCreateContainers builder with application/json body
func NewBulkCreateContainersRequest(server string, body BulkCreateContainersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateContainersRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateContainersRequestWithBody generates requests for BulkCreateContainers with any type of body
func NewBulkCreateContainersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers:bulk-create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkGetContainersRequest generates requests for BulkGetContainers
func NewBulkGetContainersRequest(server string, params *BulkGetContainersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers:bulk-get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ContainerIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "containerIds", runtime.ParamLocationQuery, *params.ContainerIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Barcodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "barcodes", runtime.ParamLocationQuery, *params.Barcodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkUpdateContainersRequest calls the generic BulkUpdateContainers builder with application/json body
func NewBulkUpdateContainersRequest(server string, body BulkUpdateContainersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateContainersRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateContainersRequestWithBody generates requests for BulkUpdateContainers with any type of body
func NewBulkUpdateContainersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers:bulk-update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckinContainersRequest calls the generic CheckinContainers builder with application/json body
func NewCheckinContainersRequest(server string, body CheckinContainersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckinContainersRequestWithBody(server, "application/json", bodyReader)
}

// NewCheckinContainersRequestWithBody generates requests for CheckinContainers with any type of body
func NewCheckinContainersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers:check-in")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCheckoutContainersRequest calls the generic CheckoutContainers builder with application/json body
func NewCheckoutContainersRequest(server string, body CheckoutContainersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckoutContainersRequestWithBody(server, "application/json", bodyReader)
}

// NewCheckoutContainersRequestWithBody generates requests for CheckoutContainers with any type of body
func NewCheckoutContainersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers:check-out")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPrintLabelsRequest calls the generic PrintLabels builder with application/json body
func NewPrintLabelsRequest(server string, body PrintLabelsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPrintLabelsRequestWithBody(server, "application/json", bodyReader)
}

// NewPrintLabelsRequestWithBody generates requests for PrintLabels with any type of body
func NewPrintLabelsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers:print-labels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReserveContainersRequest calls the generic ReserveContainers builder with application/json body
func NewReserveContainersRequest(server string, body ReserveContainersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReserveContainersRequestWithBody(server, "application/json", bodyReader)
}

// NewReserveContainersRequestWithBody generates requests for ReserveContainers with any type of body
func NewReserveContainersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers:reserve")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveContainersRequest calls the generic UnarchiveContainers builder with application/json body
func NewUnarchiveContainersRequest(server string, body UnarchiveContainersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveContainersRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveContainersRequestWithBody generates requests for UnarchiveContainers with any type of body
func NewUnarchiveContainersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/containers:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCustomEntitiesRequest generates requests for ListCustomEntities
func NewListCustomEntitiesRequest(server string, params *ListCustomEntitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-entities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FolderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "folderId", runtime.ParamLocationQuery, *params.FolderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MentionedIn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentionedIn", runtime.ParamLocationQuery, *params.MentionedIn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegistryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "registryId", runtime.ParamLocationQuery, *params.RegistryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaFields", runtime.ParamLocationQuery, *params.SchemaFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mentions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentions", runtime.ParamLocationQuery, *params.Mentions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntityRegistryIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entityRegistryIds.anyOf", runtime.ParamLocationQuery, *params.EntityRegistryIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authorIds.anyOf", runtime.ParamLocationQuery, *params.AuthorIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCustomEntityRequest calls the generic CreateCustomEntity builder with application/json body
func NewCreateCustomEntityRequest(server string, body CreateCustomEntityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomEntityRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCustomEntityRequestWithBody generates requests for CreateCustomEntity with any type of body
func NewCreateCustomEntityRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-entities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomEntityRequest generates requests for GetCustomEntity
func NewGetCustomEntityRequest(server string, customEntityId string, params *GetCustomEntityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom_entity_id", runtime.ParamLocationPath, customEntityId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-entities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomEntityRequest calls the generic UpdateCustomEntity builder with application/json body
func NewUpdateCustomEntityRequest(server string, customEntityId string, body UpdateCustomEntityJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomEntityRequestWithBody(server, customEntityId, "application/json", bodyReader)
}

// NewUpdateCustomEntityRequestWithBody generates requests for UpdateCustomEntity with any type of body
func NewUpdateCustomEntityRequestWithBody(server string, customEntityId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "custom_entity_id", runtime.ParamLocationPath, customEntityId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-entities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveCustomEntitiesRequest calls the generic ArchiveCustomEntities builder with application/json body
func NewArchiveCustomEntitiesRequest(server string, body ArchiveCustomEntitiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveCustomEntitiesRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveCustomEntitiesRequestWithBody generates requests for ArchiveCustomEntities with any type of body
func NewArchiveCustomEntitiesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-entities:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkCreateCustomEntitiesRequest calls the generic BulkCreateCustomEntities builder with application/json body
func NewBulkCreateCustomEntitiesRequest(server string, body BulkCreateCustomEntitiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateCustomEntitiesRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateCustomEntitiesRequestWithBody generates requests for BulkCreateCustomEntities with any type of body
func NewBulkCreateCustomEntitiesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-entities:bulk-create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkGetCustomEntitiesRequest generates requests for BulkGetCustomEntities
func NewBulkGetCustomEntitiesRequest(server string, params *BulkGetCustomEntitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-entities:bulk-get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customEntityIds", runtime.ParamLocationQuery, params.CustomEntityIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkUpdateCustomEntitiesRequest calls the generic BulkUpdateCustomEntities builder with application/json body
func NewBulkUpdateCustomEntitiesRequest(server string, body BulkUpdateCustomEntitiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateCustomEntitiesRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateCustomEntitiesRequestWithBody generates requests for BulkUpdateCustomEntities with any type of body
func NewBulkUpdateCustomEntitiesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-entities:bulk-update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveCustomEntitiesRequest calls the generic UnarchiveCustomEntities builder with application/json body
func NewUnarchiveCustomEntitiesRequest(server string, body UnarchiveCustomEntitiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveCustomEntitiesRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveCustomEntitiesRequestWithBody generates requests for UnarchiveCustomEntities with any type of body
func NewUnarchiveCustomEntitiesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-entities:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCustomNotationsRequest generates requests for ListCustomNotations
func NewListCustomNotationsRequest(server string, params *ListCustomNotationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/custom-notations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDNAAlignmentsRequest generates requests for ListDNAAlignments
func NewListDNAAlignmentsRequest(server string, params *ListDNAAlignmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-alignments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SequenceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sequenceIds", runtime.ParamLocationQuery, *params.SequenceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteDNAAlignmentRequest generates requests for DeleteDNAAlignment
func NewDeleteDNAAlignmentRequest(server string, dnaAlignmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dna_alignment_id", runtime.ParamLocationPath, dnaAlignmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-alignments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDNAAlignmentRequest generates requests for GetDNAAlignment
func NewGetDNAAlignmentRequest(server string, dnaAlignmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dna_alignment_id", runtime.ParamLocationPath, dnaAlignmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-alignments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDnaConsensusAlignmentRequest calls the generic CreateDnaConsensusAlignment builder with application/json body
func NewCreateDnaConsensusAlignmentRequest(server string, body CreateDnaConsensusAlignmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDnaConsensusAlignmentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDnaConsensusAlignmentRequestWithBody generates requests for CreateDnaConsensusAlignment with any type of body
func NewCreateDnaConsensusAlignmentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-alignments:create-consensus-alignment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDnaTemplateAlignmentRequest calls the generic CreateDnaTemplateAlignment builder with application/json body
func NewCreateDnaTemplateAlignmentRequest(server string, body CreateDnaTemplateAlignmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDnaTemplateAlignmentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDnaTemplateAlignmentRequestWithBody generates requests for CreateDnaTemplateAlignment with any type of body
func NewCreateDnaTemplateAlignmentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-alignments:create-template-alignment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListDNAOligosRequest generates requests for ListDNAOligos
func NewListDNAOligosRequest(server string, params *ListDNAOligosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-oligos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bases != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bases", runtime.ParamLocationQuery, *params.Bases); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FolderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "folderId", runtime.ParamLocationQuery, *params.FolderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MentionedIn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentionedIn", runtime.ParamLocationQuery, *params.MentionedIn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegistryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "registryId", runtime.ParamLocationQuery, *params.RegistryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaFields", runtime.ParamLocationQuery, *params.SchemaFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mentions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentions", runtime.ParamLocationQuery, *params.Mentions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntityRegistryIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entityRegistryIds.anyOf", runtime.ParamLocationQuery, *params.EntityRegistryIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authorIds.anyOf", runtime.ParamLocationQuery, *params.AuthorIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomNotationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customNotationId", runtime.ParamLocationQuery, *params.CustomNotationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDNAOligoRequest calls the generic CreateDNAOligo builder with application/json body
func NewCreateDNAOligoRequest(server string, body CreateDNAOligoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDNAOligoRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDNAOligoRequestWithBody generates requests for CreateDNAOligo with any type of body
func NewCreateDNAOligoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-oligos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDNAOligoRequest generates requests for GetDNAOligo
func NewGetDNAOligoRequest(server string, oligoId string, params *GetDNAOligoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "oligo_id", runtime.ParamLocationPath, oligoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-oligos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CustomNotationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customNotationId", runtime.ParamLocationQuery, *params.CustomNotationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDNAOligoRequest calls the generic UpdateDNAOligo builder with application/json body
func NewUpdateDNAOligoRequest(server string, oligoId string, body UpdateDNAOligoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDNAOligoRequestWithBody(server, oligoId, "application/json", bodyReader)
}

// NewUpdateDNAOligoRequestWithBody generates requests for UpdateDNAOligo with any type of body
func NewUpdateDNAOligoRequestWithBody(server string, oligoId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "oligo_id", runtime.ParamLocationPath, oligoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-oligos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveDNAOligosRequest calls the generic ArchiveDNAOligos builder with application/json body
func NewArchiveDNAOligosRequest(server string, body ArchiveDNAOligosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveDNAOligosRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveDNAOligosRequestWithBody generates requests for ArchiveDNAOligos with any type of body
func NewArchiveDNAOligosRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-oligos:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkCreateDNAOligosRequest calls the generic BulkCreateDNAOligos builder with application/json body
func NewBulkCreateDNAOligosRequest(server string, body BulkCreateDNAOligosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateDNAOligosRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateDNAOligosRequestWithBody generates requests for BulkCreateDNAOligos with any type of body
func NewBulkCreateDNAOligosRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-oligos:bulk-create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkUpdateDNAOligosRequest calls the generic BulkUpdateDNAOligos builder with application/json body
func NewBulkUpdateDNAOligosRequest(server string, body BulkUpdateDNAOligosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateDNAOligosRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateDNAOligosRequestWithBody generates requests for BulkUpdateDNAOligos with any type of body
func NewBulkUpdateDNAOligosRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-oligos:bulk-update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveDNAOligosRequest calls the generic UnarchiveDNAOligos builder with application/json body
func NewUnarchiveDNAOligosRequest(server string, body UnarchiveDNAOligosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveDNAOligosRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveDNAOligosRequestWithBody generates requests for UnarchiveDNAOligos with any type of body
func NewUnarchiveDNAOligosRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-oligos:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListDNASequencesRequest generates requests for ListDNASequences
func NewListDNASequencesRequest(server string, params *ListDNASequencesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-sequences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bases != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bases", runtime.ParamLocationQuery, *params.Bases); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FolderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "folderId", runtime.ParamLocationQuery, *params.FolderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MentionedIn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentionedIn", runtime.ParamLocationQuery, *params.MentionedIn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegistryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "registryId", runtime.ParamLocationQuery, *params.RegistryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaFields", runtime.ParamLocationQuery, *params.SchemaFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mentions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentions", runtime.ParamLocationQuery, *params.Mentions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntityRegistryIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entityRegistryIds.anyOf", runtime.ParamLocationQuery, *params.EntityRegistryIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authorIds.anyOf", runtime.ParamLocationQuery, *params.AuthorIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDNASequenceRequest calls the generic CreateDNASequence builder with application/json body
func NewCreateDNASequenceRequest(server string, body CreateDNASequenceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDNASequenceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDNASequenceRequestWithBody generates requests for CreateDNASequence with any type of body
func NewCreateDNASequenceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-sequences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDNASequenceRequest generates requests for GetDNASequence
func NewGetDNASequenceRequest(server string, dnaSequenceId string, params *GetDNASequenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dna_sequence_id", runtime.ParamLocationPath, dnaSequenceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-sequences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDNASequenceRequest calls the generic UpdateDNASequence builder with application/json body
func NewUpdateDNASequenceRequest(server string, dnaSequenceId string, body UpdateDNASequenceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDNASequenceRequestWithBody(server, dnaSequenceId, "application/json", bodyReader)
}

// NewUpdateDNASequenceRequestWithBody generates requests for UpdateDNASequence with any type of body
func NewUpdateDNASequenceRequestWithBody(server string, dnaSequenceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dna_sequence_id", runtime.ParamLocationPath, dnaSequenceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-sequences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveDNASequencesRequest calls the generic ArchiveDNASequences builder with application/json body
func NewArchiveDNASequencesRequest(server string, body ArchiveDNASequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveDNASequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveDNASequencesRequestWithBody generates requests for ArchiveDNASequences with any type of body
func NewArchiveDNASequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-sequences:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAutoAnnotateDnaSequencesRequest calls the generic AutoAnnotateDnaSequences builder with application/json body
func NewAutoAnnotateDnaSequencesRequest(server string, body AutoAnnotateDnaSequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAutoAnnotateDnaSequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewAutoAnnotateDnaSequencesRequestWithBody generates requests for AutoAnnotateDnaSequences with any type of body
func NewAutoAnnotateDnaSequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-sequences:auto-annotate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAutofillDNASequencePartsRequest calls the generic AutofillDNASequenceParts builder with application/json body
func NewAutofillDNASequencePartsRequest(server string, body AutofillDNASequencePartsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAutofillDNASequencePartsRequestWithBody(server, "application/json", bodyReader)
}

// NewAutofillDNASequencePartsRequestWithBody generates requests for AutofillDNASequenceParts with any type of body
func NewAutofillDNASequencePartsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-sequences:autofill-parts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAutofillDNASequenceTranslationsRequest calls the generic AutofillDNASequenceTranslations builder with application/json body
func NewAutofillDNASequenceTranslationsRequest(server string, body AutofillDNASequenceTranslationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAutofillDNASequenceTranslationsRequestWithBody(server, "application/json", bodyReader)
}

// NewAutofillDNASequenceTranslationsRequestWithBody generates requests for AutofillDNASequenceTranslations with any type of body
func NewAutofillDNASequenceTranslationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-sequences:autofill-translations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkCreateDNASequencesRequest calls the generic BulkCreateDNASequences builder with application/json body
func NewBulkCreateDNASequencesRequest(server string, body BulkCreateDNASequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateDNASequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateDNASequencesRequestWithBody generates requests for BulkCreateDNASequences with any type of body
func NewBulkCreateDNASequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-sequences:bulk-create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkGetDNASequencesRequest generates requests for BulkGetDNASequences
func NewBulkGetDNASequencesRequest(server string, params *BulkGetDNASequencesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-sequences:bulk-get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dnaSequenceIds", runtime.ParamLocationQuery, params.DnaSequenceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkUpdateDNASequencesRequest calls the generic BulkUpdateDNASequences builder with application/json body
func NewBulkUpdateDNASequencesRequest(server string, body BulkUpdateDNASequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateDNASequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateDNASequencesRequestWithBody generates requests for BulkUpdateDNASequences with any type of body
func NewBulkUpdateDNASequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-sequences:bulk-update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMatchBasesDnaSequencesRequest calls the generic MatchBasesDnaSequences builder with application/json body
func NewMatchBasesDnaSequencesRequest(server string, body MatchBasesDnaSequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMatchBasesDnaSequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewMatchBasesDnaSequencesRequestWithBody generates requests for MatchBasesDnaSequences with any type of body
func NewMatchBasesDnaSequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-sequences:match-bases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchDnaSequencesRequest calls the generic SearchDnaSequences builder with application/json body
func NewSearchDnaSequencesRequest(server string, body SearchDnaSequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchDnaSequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchDnaSequencesRequestWithBody generates requests for SearchDnaSequences with any type of body
func NewSearchDnaSequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-sequences:search-bases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveDNASequencesRequest calls the generic UnarchiveDNASequences builder with application/json body
func NewUnarchiveDNASequencesRequest(server string, body UnarchiveDNASequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveDNASequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveDNASequencesRequestWithBody generates requests for UnarchiveDNASequences with any type of body
func NewUnarchiveDNASequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dna-sequences:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListDropdownsRequest generates requests for ListDropdowns
func NewListDropdownsRequest(server string, params *ListDropdownsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dropdowns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDropdownRequest calls the generic CreateDropdown builder with application/json body
func NewCreateDropdownRequest(server string, body CreateDropdownJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDropdownRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDropdownRequestWithBody generates requests for CreateDropdown with any type of body
func NewCreateDropdownRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dropdowns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDropdownRequest generates requests for GetDropdown
func NewGetDropdownRequest(server string, dropdownId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dropdown_id", runtime.ParamLocationPath, dropdownId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dropdowns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDropdownRequest calls the generic UpdateDropdown builder with application/json body
func NewUpdateDropdownRequest(server string, dropdownId string, body UpdateDropdownJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDropdownRequestWithBody(server, dropdownId, "application/json", bodyReader)
}

// NewUpdateDropdownRequestWithBody generates requests for UpdateDropdown with any type of body
func NewUpdateDropdownRequestWithBody(server string, dropdownId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dropdown_id", runtime.ParamLocationPath, dropdownId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dropdowns/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveDropdownOptionsRequest calls the generic ArchiveDropdownOptions builder with application/json body
func NewArchiveDropdownOptionsRequest(server string, dropdownId string, body ArchiveDropdownOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveDropdownOptionsRequestWithBody(server, dropdownId, "application/json", bodyReader)
}

// NewArchiveDropdownOptionsRequestWithBody generates requests for ArchiveDropdownOptions with any type of body
func NewArchiveDropdownOptionsRequestWithBody(server string, dropdownId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dropdown_id", runtime.ParamLocationPath, dropdownId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dropdowns/%s/options:archive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveDropdownOptionsRequest calls the generic UnarchiveDropdownOptions builder with application/json body
func NewUnarchiveDropdownOptionsRequest(server string, dropdownId string, body UnarchiveDropdownOptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveDropdownOptionsRequestWithBody(server, dropdownId, "application/json", bodyReader)
}

// NewUnarchiveDropdownOptionsRequestWithBody generates requests for UnarchiveDropdownOptions with any type of body
func NewUnarchiveDropdownOptionsRequestWithBody(server string, dropdownId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dropdown_id", runtime.ParamLocationPath, dropdownId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dropdowns/%s/options:unarchive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEnitityBatchesRequest generates requests for GetEnitityBatches
func NewGetEnitityBatchesRequest(server string, entityId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entity_id", runtime.ParamLocationPath, entityId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entities/%s/batches", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEntitySchemasRequest generates requests for ListEntitySchemas
func NewListEntitySchemasRequest(server string, params *ListEntitySchemasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entity-schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntitySchemaRequest generates requests for GetEntitySchema
func NewGetEntitySchemaRequest(server string, schemaId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entity-schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEntriesRequest generates requests for ListEntries
func NewListEntriesRequest(server string, params *ListEntriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReviewStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reviewStatus", runtime.ParamLocationQuery, *params.ReviewStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MentionedIn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentionedIn", runtime.ParamLocationQuery, *params.MentionedIn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mentions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentions", runtime.ParamLocationQuery, *params.Mentions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssignedReviewerIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assignedReviewerIds.anyOf", runtime.ParamLocationQuery, *params.AssignedReviewerIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authorIds.anyOf", runtime.ParamLocationQuery, *params.AuthorIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisplayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "displayIds", runtime.ParamLocationQuery, *params.DisplayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEntryRequest calls the generic CreateEntry builder with application/json body
func NewCreateEntryRequest(server string, body CreateEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEntryRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEntryRequestWithBody generates requests for CreateEntry with any type of body
func NewCreateEntryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEntryRequest generates requests for GetEntry
func NewGetEntryRequest(server string, entryId string, params *GetEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entry_id", runtime.ParamLocationPath, entryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEntryRequest calls the generic UpdateEntry builder with application/json body
func NewUpdateEntryRequest(server string, entryId string, params *UpdateEntryParams, body UpdateEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEntryRequestWithBody(server, entryId, params, "application/json", bodyReader)
}

// NewUpdateEntryRequestWithBody generates requests for UpdateEntry with any type of body
func NewUpdateEntryRequestWithBody(server string, entryId string, params *UpdateEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entry_id", runtime.ParamLocationPath, entryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExternalFileMetadataRequest generates requests for GetExternalFileMetadata
func NewGetExternalFileMetadataRequest(server string, entryId string, externalFileId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entry_id", runtime.ParamLocationPath, entryId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "external_file_id", runtime.ParamLocationPath, externalFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entries/%s/external-files/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveEntriesRequest calls the generic ArchiveEntries builder with application/json body
func NewArchiveEntriesRequest(server string, body ArchiveEntriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveEntriesRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveEntriesRequestWithBody generates requests for ArchiveEntries with any type of body
func NewArchiveEntriesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entries:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkGetEntriesRequest generates requests for BulkGetEntries
func NewBulkGetEntriesRequest(server string, params *BulkGetEntriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entries:bulk-get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.EntryIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entryIds", runtime.ParamLocationQuery, *params.EntryIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisplayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "displayIds", runtime.ParamLocationQuery, *params.DisplayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnarchiveEntriesRequest calls the generic UnarchiveEntries builder with application/json body
func NewUnarchiveEntriesRequest(server string, body UnarchiveEntriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveEntriesRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveEntriesRequestWithBody generates requests for UnarchiveEntries with any type of body
func NewUnarchiveEntriesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entries:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEntrySchemasRequest generates requests for ListEntrySchemas
func NewListEntrySchemasRequest(server string, params *ListEntrySchemasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entry-schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntrySchemaRequest generates requests for GetEntrySchema
func NewGetEntrySchemaRequest(server string, schemaId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entry-schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEntryTemplatesRequest generates requests for ListEntryTemplates
func NewListEntryTemplatesRequest(server string, params *ListEntryTemplatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entry-templates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TemplateCollectionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "templateCollectionId", runtime.ParamLocationQuery, *params.TemplateCollectionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEntryTemplateRequest generates requests for GetEntryTemplate
func NewGetEntryTemplateRequest(server string, entryTemplateId string, params *GetEntryTemplateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entry_template_id", runtime.ParamLocationPath, entryTemplateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entry-templates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEventsRequest generates requests for ListEvents
func NewListEventsRequest(server string, params *ListEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAtGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAt.gte", runtime.ParamLocationQuery, *params.CreatedAtGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startingAfter", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EventTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "eventTypes", runtime.ParamLocationQuery, *params.EventTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Poll != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poll", runtime.ParamLocationQuery, *params.Poll); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportItemRequest calls the generic ExportItem builder with application/json body
func NewExportItemRequest(server string, body ExportItemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExportItemRequestWithBody(server, "application/json", bodyReader)
}

// NewExportItemRequestWithBody generates requests for ExportItem with any type of body
func NewExportItemRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/exports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFeatureLibrariesRequest generates requests for ListFeatureLibraries
func NewListFeatureLibrariesRequest(server string, params *ListFeatureLibrariesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feature-libraries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFeatureLibraryRequest calls the generic CreateFeatureLibrary builder with application/json body
func NewCreateFeatureLibraryRequest(server string, body CreateFeatureLibraryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFeatureLibraryRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFeatureLibraryRequestWithBody generates requests for CreateFeatureLibrary with any type of body
func NewCreateFeatureLibraryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feature-libraries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFeatureLibraryRequest generates requests for GetFeatureLibrary
func NewGetFeatureLibraryRequest(server string, featureLibraryId string, params *GetFeatureLibraryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "feature_library_id", runtime.ParamLocationPath, featureLibraryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feature-libraries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFeatureLibraryRequest calls the generic UpdateFeatureLibrary builder with application/json body
func NewUpdateFeatureLibraryRequest(server string, featureLibraryId string, body UpdateFeatureLibraryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFeatureLibraryRequestWithBody(server, featureLibraryId, "application/json", bodyReader)
}

// NewUpdateFeatureLibraryRequestWithBody generates requests for UpdateFeatureLibrary with any type of body
func NewUpdateFeatureLibraryRequestWithBody(server string, featureLibraryId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "feature_library_id", runtime.ParamLocationPath, featureLibraryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/feature-libraries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFeaturesRequest generates requests for ListFeatures
func NewListFeaturesRequest(server string, params *ListFeaturesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/features")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FeatureLibraryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "featureLibraryId", runtime.ParamLocationQuery, *params.FeatureLibraryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FeatureType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "featureType", runtime.ParamLocationQuery, *params.FeatureType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MatchType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "matchType", runtime.ParamLocationQuery, *params.MatchType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFeatureRequest calls the generic CreateFeature builder with application/json body
func NewCreateFeatureRequest(server string, body CreateFeatureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFeatureRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFeatureRequestWithBody generates requests for CreateFeature with any type of body
func NewCreateFeatureRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/features")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFeatureRequest generates requests for GetFeature
func NewGetFeatureRequest(server string, featureId string, params *GetFeatureParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "feature_id", runtime.ParamLocationPath, featureId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/features/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFeatureRequest calls the generic UpdateFeature builder with application/json body
func NewUpdateFeatureRequest(server string, featureId string, body UpdateFeatureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFeatureRequestWithBody(server, featureId, "application/json", bodyReader)
}

// NewUpdateFeatureRequestWithBody generates requests for UpdateFeature with any type of body
func NewUpdateFeatureRequestWithBody(server string, featureId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "feature_id", runtime.ParamLocationPath, featureId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/features/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkCreateFeaturesRequest calls the generic BulkCreateFeatures builder with application/json body
func NewBulkCreateFeaturesRequest(server string, body BulkCreateFeaturesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateFeaturesRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateFeaturesRequestWithBody generates requests for BulkCreateFeatures with any type of body
func NewBulkCreateFeaturesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/features:bulk-create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFoldersRequest generates requests for ListFolders
func NewListFoldersRequest(server string, params *ListFoldersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentFolderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parentFolderId", runtime.ParamLocationQuery, *params.ParentFolderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Section != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "section", runtime.ParamLocationQuery, *params.Section); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFolderRequest calls the generic CreateFolder builder with application/json body
func NewCreateFolderRequest(server string, body CreateFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFolderRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFolderRequestWithBody generates requests for CreateFolder with any type of body
func NewCreateFolderRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFolderRequest generates requests for GetFolder
func NewGetFolderRequest(server string, folderId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "folder_id", runtime.ParamLocationPath, folderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveFoldersRequest calls the generic ArchiveFolders builder with application/json body
func NewArchiveFoldersRequest(server string, body ArchiveFoldersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveFoldersRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveFoldersRequestWithBody generates requests for ArchiveFolders with any type of body
func NewArchiveFoldersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveFoldersRequest calls the generic UnarchiveFolders builder with application/json body
func NewUnarchiveFoldersRequest(server string, body UnarchiveFoldersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveFoldersRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveFoldersRequestWithBody generates requests for UnarchiveFolders with any type of body
func NewUnarchiveFoldersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/folders:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListLegacyWorkflowStageRunInputSamplesRequest generates requests for ListLegacyWorkflowStageRunInputSamples
func NewListLegacyWorkflowStageRunInputSamplesRequest(server string, stageRunId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stage_run_id", runtime.ParamLocationPath, stageRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacy-workflow-stage-runs/%s/input-samples", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLegacyWorkflowStageRunOutputSamplesRequest generates requests for ListLegacyWorkflowStageRunOutputSamples
func NewListLegacyWorkflowStageRunOutputSamplesRequest(server string, stageRunId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stage_run_id", runtime.ParamLocationPath, stageRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacy-workflow-stage-runs/%s/output-samples", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLegacyWorkflowStageRunRegisteredSamplesRequest generates requests for ListLegacyWorkflowStageRunRegisteredSamples
func NewListLegacyWorkflowStageRunRegisteredSamplesRequest(server string, stageRunId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stage_run_id", runtime.ParamLocationPath, stageRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacy-workflow-stage-runs/%s/registered-samples", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLegacyWorkflowStageRunsRequest generates requests for ListLegacyWorkflowStageRuns
func NewListLegacyWorkflowStageRunsRequest(server string, stageId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stage_id", runtime.ParamLocationPath, stageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacy-workflow-stages/%s/workflow-stage-runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLegacyWorkflowsRequest generates requests for ListLegacyWorkflows
func NewListLegacyWorkflowsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacy-workflows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLegacyWorkflowMetadataRequest calls the generic UpdateLegacyWorkflowMetadata builder with application/json body
func NewUpdateLegacyWorkflowMetadataRequest(server string, legacyWorkflowId string, body UpdateLegacyWorkflowMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLegacyWorkflowMetadataRequestWithBody(server, legacyWorkflowId, "application/json", bodyReader)
}

// NewUpdateLegacyWorkflowMetadataRequestWithBody generates requests for UpdateLegacyWorkflowMetadata with any type of body
func NewUpdateLegacyWorkflowMetadataRequestWithBody(server string, legacyWorkflowId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "legacy_workflow_id", runtime.ParamLocationPath, legacyWorkflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacy-workflows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListLegacyWorkflowStagesRequest generates requests for ListLegacyWorkflowStages
func NewListLegacyWorkflowStagesRequest(server string, legacyWorkflowId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "legacy_workflow_id", runtime.ParamLocationPath, legacyWorkflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacy-workflows/%s/workflow-stages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLocationSchemasRequest generates requests for ListLocationSchemas
func NewListLocationSchemasRequest(server string, params *ListLocationSchemasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/location-schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationSchemaRequest generates requests for GetLocationSchema
func NewGetLocationSchemaRequest(server string, schemaId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/location-schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLocationsRequest generates requests for ListLocations
func NewListLocationsRequest(server string, params *ListLocationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaFields", runtime.ParamLocationQuery, *params.SchemaFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AncestorStorageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ancestorStorageId", runtime.ParamLocationQuery, *params.AncestorStorageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Barcodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "barcodes", runtime.ParamLocationQuery, *params.Barcodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLocationRequest calls the generic CreateLocation builder with application/json body
func NewCreateLocationRequest(server string, body CreateLocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLocationRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLocationRequestWithBody generates requests for CreateLocation with any type of body
func NewCreateLocationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLocationRequest generates requests for GetLocation
func NewGetLocationRequest(server string, locationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "location_id", runtime.ParamLocationPath, locationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateLocationRequest calls the generic UpdateLocation builder with application/json body
func NewUpdateLocationRequest(server string, locationId string, body UpdateLocationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateLocationRequestWithBody(server, locationId, "application/json", bodyReader)
}

// NewUpdateLocationRequestWithBody generates requests for UpdateLocation with any type of body
func NewUpdateLocationRequestWithBody(server string, locationId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "location_id", runtime.ParamLocationPath, locationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveLocationsRequest calls the generic ArchiveLocations builder with application/json body
func NewArchiveLocationsRequest(server string, body ArchiveLocationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveLocationsRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveLocationsRequestWithBody generates requests for ArchiveLocations with any type of body
func NewArchiveLocationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkGetLocationsRequest generates requests for BulkGetLocations
func NewBulkGetLocationsRequest(server string, params *BulkGetLocationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations:bulk-get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LocationIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locationIds", runtime.ParamLocationQuery, *params.LocationIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Barcodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "barcodes", runtime.ParamLocationQuery, *params.Barcodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnarchiveLocationsRequest calls the generic UnarchiveLocations builder with application/json body
func NewUnarchiveLocationsRequest(server string, body UnarchiveLocationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveLocationsRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveLocationsRequestWithBody generates requests for UnarchiveLocations with any type of body
func NewUnarchiveLocationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListMixturesRequest generates requests for ListMixtures
func NewListMixturesRequest(server string, params *ListMixturesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mixtures")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FolderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "folderId", runtime.ParamLocationQuery, *params.FolderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MentionedIn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentionedIn", runtime.ParamLocationQuery, *params.MentionedIn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegistryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "registryId", runtime.ParamLocationQuery, *params.RegistryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaFields", runtime.ParamLocationQuery, *params.SchemaFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mentions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentions", runtime.ParamLocationQuery, *params.Mentions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntityRegistryIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entityRegistryIds.anyOf", runtime.ParamLocationQuery, *params.EntityRegistryIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IngredientComponentEntityIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ingredientComponentEntityIds", runtime.ParamLocationQuery, *params.IngredientComponentEntityIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IngredientComponentEntityIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ingredientComponentEntityIds.anyOf", runtime.ParamLocationQuery, *params.IngredientComponentEntityIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authorIds.anyOf", runtime.ParamLocationQuery, *params.AuthorIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMixtureRequest calls the generic CreateMixture builder with application/json body
func NewCreateMixtureRequest(server string, body CreateMixtureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMixtureRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateMixtureRequestWithBody generates requests for CreateMixture with any type of body
func NewCreateMixtureRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mixtures")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMixtureRequest generates requests for GetMixture
func NewGetMixtureRequest(server string, mixtureId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mixture_id", runtime.ParamLocationPath, mixtureId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mixtures/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMixtureRequest calls the generic UpdateMixture builder with application/json body
func NewUpdateMixtureRequest(server string, mixtureId string, body UpdateMixtureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMixtureRequestWithBody(server, mixtureId, "application/json", bodyReader)
}

// NewUpdateMixtureRequestWithBody generates requests for UpdateMixture with any type of body
func NewUpdateMixtureRequestWithBody(server string, mixtureId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mixture_id", runtime.ParamLocationPath, mixtureId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mixtures/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveMixturesRequest calls the generic ArchiveMixtures builder with application/json body
func NewArchiveMixturesRequest(server string, body ArchiveMixturesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveMixturesRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveMixturesRequestWithBody generates requests for ArchiveMixtures with any type of body
func NewArchiveMixturesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mixtures:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkCreateMixturesRequest calls the generic BulkCreateMixtures builder with application/json body
func NewBulkCreateMixturesRequest(server string, body BulkCreateMixturesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateMixturesRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateMixturesRequestWithBody generates requests for BulkCreateMixtures with any type of body
func NewBulkCreateMixturesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mixtures:bulk-create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkUpdateMixturesRequest calls the generic BulkUpdateMixtures builder with application/json body
func NewBulkUpdateMixturesRequest(server string, body BulkUpdateMixturesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateMixturesRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateMixturesRequestWithBody generates requests for BulkUpdateMixtures with any type of body
func NewBulkUpdateMixturesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mixtures:bulk-update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveMixturesRequest calls the generic UnarchiveMixtures builder with application/json body
func NewUnarchiveMixturesRequest(server string, body UnarchiveMixturesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveMixturesRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveMixturesRequestWithBody generates requests for UnarchiveMixtures with any type of body
func NewUnarchiveMixturesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/mixtures:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListMoleculesRequest generates requests for ListMolecules
func NewListMoleculesRequest(server string, params *ListMoleculesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/molecules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FolderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "folderId", runtime.ParamLocationQuery, *params.FolderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MentionedIn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mentionedIn", runtime.ParamLocationQuery, *params.MentionedIn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegistryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "registryId", runtime.ParamLocationQuery, *params.RegistryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaFields", runtime.ParamLocationQuery, *params.SchemaFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mentions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "mentions", runtime.ParamLocationQuery, *params.Mentions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntityRegistryIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entityRegistryIds.anyOf", runtime.ParamLocationQuery, *params.EntityRegistryIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authorIds.anyOf", runtime.ParamLocationQuery, *params.AuthorIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChemicalSubstructureMol != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chemicalSubstructure.mol", runtime.ParamLocationQuery, *params.ChemicalSubstructureMol); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ChemicalSubstructureSmiles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chemicalSubstructure.smiles", runtime.ParamLocationQuery, *params.ChemicalSubstructureSmiles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMoleculeRequest calls the generic CreateMolecule builder with application/json body
func NewCreateMoleculeRequest(server string, body CreateMoleculeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMoleculeRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateMoleculeRequestWithBody generates requests for CreateMolecule with any type of body
func NewCreateMoleculeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/molecules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMoleculeRequest generates requests for GetMolecule
func NewGetMoleculeRequest(server string, moleculeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "molecule_id", runtime.ParamLocationPath, moleculeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/molecules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMoleculeRequest calls the generic UpdateMolecule builder with application/json body
func NewUpdateMoleculeRequest(server string, moleculeId string, body UpdateMoleculeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMoleculeRequestWithBody(server, moleculeId, "application/json", bodyReader)
}

// NewUpdateMoleculeRequestWithBody generates requests for UpdateMolecule with any type of body
func NewUpdateMoleculeRequestWithBody(server string, moleculeId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "molecule_id", runtime.ParamLocationPath, moleculeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/molecules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveMoleculesRequest calls the generic ArchiveMolecules builder with application/json body
func NewArchiveMoleculesRequest(server string, body ArchiveMoleculesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveMoleculesRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveMoleculesRequestWithBody generates requests for ArchiveMolecules with any type of body
func NewArchiveMoleculesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/molecules:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkCreateMoleculesRequest calls the generic BulkCreateMolecules builder with application/json body
func NewBulkCreateMoleculesRequest(server string, body BulkCreateMoleculesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateMoleculesRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateMoleculesRequestWithBody generates requests for BulkCreateMolecules with any type of body
func NewBulkCreateMoleculesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/molecules:bulk-create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkUpdateMoleculesRequest calls the generic BulkUpdateMolecules builder with application/json body
func NewBulkUpdateMoleculesRequest(server string, body BulkUpdateMoleculesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateMoleculesRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateMoleculesRequestWithBody generates requests for BulkUpdateMolecules with any type of body
func NewBulkUpdateMoleculesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/molecules:bulk-update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveMoleculesRequest calls the generic UnarchiveMolecules builder with application/json body
func NewUnarchiveMoleculesRequest(server string, body UnarchiveMoleculesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveMoleculesRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveMoleculesRequestWithBody generates requests for UnarchiveMolecules with any type of body
func NewUnarchiveMoleculesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/molecules:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListMonomersRequest generates requests for ListMonomers
func NewListMonomersRequest(server string, params *ListMonomersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monomers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMonomerRequest calls the generic CreateMonomer builder with application/json body
func NewCreateMonomerRequest(server string, params *CreateMonomerParams, body CreateMonomerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMonomerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateMonomerRequestWithBody generates requests for CreateMonomer with any type of body
func NewCreateMonomerRequestWithBody(server string, params *CreateMonomerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monomers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateMonomerRequest calls the generic UpdateMonomer builder with application/json body
func NewUpdateMonomerRequest(server string, monomerId string, params *UpdateMonomerParams, body UpdateMonomerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMonomerRequestWithBody(server, monomerId, params, "application/json", bodyReader)
}

// NewUpdateMonomerRequestWithBody generates requests for UpdateMonomer with any type of body
func NewUpdateMonomerRequestWithBody(server string, monomerId string, params *UpdateMonomerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "monomer_id", runtime.ParamLocationPath, monomerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monomers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveMonomersRequest calls the generic ArchiveMonomers builder with application/json body
func NewArchiveMonomersRequest(server string, body ArchiveMonomersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveMonomersRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveMonomersRequestWithBody generates requests for ArchiveMonomers with any type of body
func NewArchiveMonomersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monomers:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveMonomersRequest calls the generic UnarchiveMonomers builder with application/json body
func NewUnarchiveMonomersRequest(server string, body UnarchiveMonomersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveMonomersRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveMonomersRequestWithBody generates requests for UnarchiveMonomers with any type of body
func NewUnarchiveMonomersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monomers:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListNucleotideAlignmentsRequest generates requests for ListNucleotideAlignments
func NewListNucleotideAlignmentsRequest(server string, params *ListNucleotideAlignmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nucleotide-alignments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SequenceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sequenceIds", runtime.ParamLocationQuery, *params.SequenceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteNucleotideAlignmentRequest generates requests for DeleteNucleotideAlignment
func NewDeleteNucleotideAlignmentRequest(server string, alignmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alignment_id", runtime.ParamLocationPath, alignmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nucleotide-alignments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNucleotideAlignmentRequest generates requests for GetNucleotideAlignment
func NewGetNucleotideAlignmentRequest(server string, alignmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "alignment_id", runtime.ParamLocationPath, alignmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nucleotide-alignments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateConsensusNucleotideAlignmentRequest calls the generic CreateConsensusNucleotideAlignment builder with application/json body
func NewCreateConsensusNucleotideAlignmentRequest(server string, body CreateConsensusNucleotideAlignmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateConsensusNucleotideAlignmentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateConsensusNucleotideAlignmentRequestWithBody generates requests for CreateConsensusNucleotideAlignment with any type of body
func NewCreateConsensusNucleotideAlignmentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nucleotide-alignments:create-consensus-alignment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTemplateNucleotideAlignmentRequest calls the generic CreateTemplateNucleotideAlignment builder with application/json body
func NewCreateTemplateNucleotideAlignmentRequest(server string, body CreateTemplateNucleotideAlignmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTemplateNucleotideAlignmentRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTemplateNucleotideAlignmentRequestWithBody generates requests for CreateTemplateNucleotideAlignment with any type of body
func NewCreateTemplateNucleotideAlignmentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nucleotide-alignments:create-template-alignment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOligosRequest generates requests for ListOligos
func NewListOligosRequest(server string, params *ListOligosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oligos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bases != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bases", runtime.ParamLocationQuery, *params.Bases); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FolderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "folderId", runtime.ParamLocationQuery, *params.FolderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MentionedIn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentionedIn", runtime.ParamLocationQuery, *params.MentionedIn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegistryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "registryId", runtime.ParamLocationQuery, *params.RegistryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaFields", runtime.ParamLocationQuery, *params.SchemaFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mentions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentions", runtime.ParamLocationQuery, *params.Mentions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntityRegistryIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entityRegistryIds.anyOf", runtime.ParamLocationQuery, *params.EntityRegistryIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOligoRequest calls the generic CreateOligo builder with application/json body
func NewCreateOligoRequest(server string, body CreateOligoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOligoRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOligoRequestWithBody generates requests for CreateOligo with any type of body
func NewCreateOligoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oligos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOligoRequest generates requests for GetOligo
func NewGetOligoRequest(server string, oligoId string, params *GetOligoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "oligo_id", runtime.ParamLocationPath, oligoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oligos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOligoRequest calls the generic UpdateOligo builder with application/json body
func NewUpdateOligoRequest(server string, oligoId string, body UpdateOligoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOligoRequestWithBody(server, oligoId, "application/json", bodyReader)
}

// NewUpdateOligoRequestWithBody generates requests for UpdateOligo with any type of body
func NewUpdateOligoRequestWithBody(server string, oligoId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "oligo_id", runtime.ParamLocationPath, oligoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oligos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveOligosRequest calls the generic ArchiveOligos builder with application/json body
func NewArchiveOligosRequest(server string, body ArchiveOligosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveOligosRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveOligosRequestWithBody generates requests for ArchiveOligos with any type of body
func NewArchiveOligosRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oligos:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkCreateOligosRequest calls the generic BulkCreateOligos builder with application/json body
func NewBulkCreateOligosRequest(server string, body BulkCreateOligosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateOligosRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateOligosRequestWithBody generates requests for BulkCreateOligos with any type of body
func NewBulkCreateOligosRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oligos:bulk-create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkGetOligosRequest generates requests for BulkGetOligos
func NewBulkGetOligosRequest(server string, params *BulkGetOligosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oligos:bulk-get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "oligoIds", runtime.ParamLocationQuery, params.OligoIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnarchiveOligosRequest calls the generic UnarchiveOligos builder with application/json body
func NewUnarchiveOligosRequest(server string, body UnarchiveOligosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveOligosRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveOligosRequestWithBody generates requests for UnarchiveOligos with any type of body
func NewUnarchiveOligosRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oligos:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListOrganizationsRequest generates requests for ListOrganizations
func NewListOrganizationsRequest(server string, params *ListOrganizationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasMembers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasMembers", runtime.ParamLocationQuery, *params.HasMembers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasAdmins != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasAdmins", runtime.ParamLocationQuery, *params.HasAdmins); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationRequest generates requests for GetOrganization
func NewGetOrganizationRequest(server string, organizationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, organizationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/organizations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPlateSchemasRequest generates requests for ListPlateSchemas
func NewListPlateSchemasRequest(server string, params *ListPlateSchemasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plate-schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlateSchemaRequest generates requests for GetPlateSchema
func NewGetPlateSchemaRequest(server string, schemaId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plate-schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPlatesRequest generates requests for ListPlates
func NewListPlatesRequest(server string, params *ListPlatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaFields", runtime.ParamLocationQuery, *params.SchemaFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AncestorStorageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ancestorStorageId", runtime.ParamLocationQuery, *params.AncestorStorageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StorageContentsId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storageContentsId", runtime.ParamLocationQuery, *params.StorageContentsId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StorageContentsIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "storageContentsIds", runtime.ParamLocationQuery, *params.StorageContentsIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Barcodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "barcodes", runtime.ParamLocationQuery, *params.Barcodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePlateRequest calls the generic CreatePlate builder with application/json body
func NewCreatePlateRequest(server string, params *CreatePlateParams, body CreatePlateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePlateRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePlateRequestWithBody generates requests for CreatePlate with any type of body
func NewCreatePlateRequestWithBody(server string, params *CreatePlateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlateRequest generates requests for GetPlate
func NewGetPlateRequest(server string, plateId string, params *GetPlateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plate_id", runtime.ParamLocationPath, plateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePlateRequest calls the generic UpdatePlate builder with application/json body
func NewUpdatePlateRequest(server string, plateId string, params *UpdatePlateParams, body UpdatePlateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePlateRequestWithBody(server, plateId, params, "application/json", bodyReader)
}

// NewUpdatePlateRequestWithBody generates requests for UpdatePlate with any type of body
func NewUpdatePlateRequestWithBody(server string, plateId string, params *UpdatePlateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plate_id", runtime.ParamLocationPath, plateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchivePlatesRequest calls the generic ArchivePlates builder with application/json body
func NewArchivePlatesRequest(server string, body ArchivePlatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchivePlatesRequestWithBody(server, "application/json", bodyReader)
}

// NewArchivePlatesRequestWithBody generates requests for ArchivePlates with any type of body
func NewArchivePlatesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plates:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkGetPlatesRequest generates requests for BulkGetPlates
func NewBulkGetPlatesRequest(server string, params *BulkGetPlatesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plates:bulk-get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PlateIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "plateIds", runtime.ParamLocationQuery, *params.PlateIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Barcodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "barcodes", runtime.ParamLocationQuery, *params.Barcodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnarchivePlatesRequest calls the generic UnarchivePlates builder with application/json body
func NewUnarchivePlatesRequest(server string, body UnarchivePlatesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchivePlatesRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchivePlatesRequestWithBody generates requests for UnarchivePlates with any type of body
func NewUnarchivePlatesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plates:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListProjectsRequest generates requests for ListProjects
func NewListProjectsRequest(server string, params *ListProjectsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProjectRequest generates requests for GetProject
func NewGetProjectRequest(server string, projectId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "project_id", runtime.ParamLocationPath, projectId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveProjectsRequest calls the generic ArchiveProjects builder with application/json body
func NewArchiveProjectsRequest(server string, body ArchiveProjectsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveProjectsRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveProjectsRequestWithBody generates requests for ArchiveProjects with any type of body
func NewArchiveProjectsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveProjectsRequest calls the generic UnarchiveProjects builder with application/json body
func NewUnarchiveProjectsRequest(server string, body UnarchiveProjectsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveProjectsRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveProjectsRequestWithBody generates requests for UnarchiveProjects with any type of body
func NewUnarchiveProjectsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/projects:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListRegistriesRequest generates requests for ListRegistries
func NewListRegistriesRequest(server string, params *ListRegistriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryRequest generates requests for GetRegistry
func NewGetRegistryRequest(server string, registryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, registryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBatchSchemasByRegistryRequest generates requests for ListBatchSchemasByRegistry
func NewListBatchSchemasByRegistryRequest(server string, registryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, registryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/batch-schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBoxSchemasByRegistryRequest generates requests for ListBoxSchemasByRegistry
func NewListBoxSchemasByRegistryRequest(server string, registryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, registryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/box-schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListContainerSchemasByRegistryRequest generates requests for ListContainerSchemasByRegistry
func NewListContainerSchemasByRegistryRequest(server string, registryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, registryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/container-schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListDropdownsByRegistryRequest generates requests for ListDropdownsByRegistry
func NewListDropdownsByRegistryRequest(server string, registryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, registryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/dropdowns", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEntitySchemasByRegistryRequest generates requests for ListEntitySchemasByRegistry
func NewListEntitySchemasByRegistryRequest(server string, registryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, registryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/entity-schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPrintersRequest generates requests for ListPrinters
func NewListPrintersRequest(server string, registryId string, params *ListPrintersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, registryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/label-printers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLabelTemplatesRequest generates requests for ListLabelTemplates
func NewListLabelTemplatesRequest(server string, registryId string, params *ListLabelTemplatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, registryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/label-templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListLocationSchemasByRegistryRequest generates requests for ListLocationSchemasByRegistry
func NewListLocationSchemasByRegistryRequest(server string, registryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, registryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/location-schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPlateSchemasByRegistryRequest generates requests for ListPlateSchemasByRegistry
func NewListPlateSchemasByRegistryRequest(server string, registryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, registryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/plate-schemas", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkGetRegisteredEntitiesRequest generates requests for BulkGetRegisteredEntities
func NewBulkGetRegisteredEntitiesRequest(server string, registryId string, params *BulkGetRegisteredEntitiesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, registryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/registered-entities:bulk-get", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entityRegistryIds", runtime.ParamLocationQuery, params.EntityRegistryIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterEntitiesRequest calls the generic RegisterEntities builder with application/json body
func NewRegisterEntitiesRequest(server string, registryId string, body RegisterEntitiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterEntitiesRequestWithBody(server, registryId, "application/json", bodyReader)
}

// NewRegisterEntitiesRequestWithBody generates requests for RegisterEntities with any type of body
func NewRegisterEntitiesRequestWithBody(server string, registryId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, registryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s:bulk-register-entities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnregisterEntitiesRequest calls the generic UnregisterEntities builder with application/json body
func NewUnregisterEntitiesRequest(server string, registryId string, body UnregisterEntitiesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnregisterEntitiesRequestWithBody(server, registryId, "application/json", bodyReader)
}

// NewUnregisterEntitiesRequestWithBody generates requests for UnregisterEntities with any type of body
func NewUnregisterEntitiesRequestWithBody(server string, registryId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, registryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s:unregister-entities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewValidateBarcodesRequest calls the generic ValidateBarcodes builder with application/json body
func NewValidateBarcodesRequest(server string, registryId string, body ValidateBarcodesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewValidateBarcodesRequestWithBody(server, registryId, "application/json", bodyReader)
}

// NewValidateBarcodesRequestWithBody generates requests for ValidateBarcodes with any type of body
func NewValidateBarcodesRequestWithBody(server string, registryId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, registryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s:validate-barcodes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListRequestFulfillmentsRequest generates requests for ListRequestFulfillments
func NewListRequestFulfillmentsRequest(server string, params *ListRequestFulfillmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/request-fulfillments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entryId", runtime.ParamLocationQuery, params.EntryId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRequestFulfillmentRequest generates requests for GetRequestFulfillment
func NewGetRequestFulfillmentRequest(server string, requestFulfillmentId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request_fulfillment_id", runtime.ParamLocationPath, requestFulfillmentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/request-fulfillments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRequestSchemasRequest generates requests for ListRequestSchemas
func NewListRequestSchemasRequest(server string, params *ListRequestSchemasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/request-schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRequestSchemaRequest generates requests for GetRequestSchema
func NewGetRequestSchemaRequest(server string, schemaId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/request-schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRequestTaskSchemasRequest generates requests for ListRequestTaskSchemas
func NewListRequestTaskSchemasRequest(server string, params *ListRequestTaskSchemasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/request-task-schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRequestTaskSchemaRequest generates requests for GetRequestTaskSchema
func NewGetRequestTaskSchemaRequest(server string, schemaId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/request-task-schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRequestsRequest generates requests for ListRequests
func NewListRequestsRequest(server string, params *ListRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, params.SchemaId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.RequestStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestStatus", runtime.ParamLocationQuery, *params.RequestStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCreatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minCreatedTime", runtime.ParamLocationQuery, *params.MinCreatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxCreatedTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxCreatedTime", runtime.ParamLocationQuery, *params.MaxCreatedTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRequestRequest calls the generic CreateRequest builder with application/json body
func NewCreateRequestRequest(server string, body CreateRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRequestRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRequestRequestWithBody generates requests for CreateRequest with any type of body
func NewCreateRequestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRequestRequest generates requests for GetRequest
func NewGetRequestRequest(server string, requestId string, params *GetRequestParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request_id", runtime.ParamLocationPath, requestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchRequestRequest calls the generic PatchRequest builder with application/json body
func NewPatchRequestRequest(server string, requestId string, body PatchRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchRequestRequestWithBody(server, requestId, "application/json", bodyReader)
}

// NewPatchRequestRequestWithBody generates requests for PatchRequest with any type of body
func NewPatchRequestRequestWithBody(server string, requestId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request_id", runtime.ParamLocationPath, requestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/requests/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRequestResponseRequest generates requests for GetRequestResponse
func NewGetRequestResponseRequest(server string, requestId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request_id", runtime.ParamLocationPath, requestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/requests/%s/response", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkCreateRequestTasksRequest calls the generic BulkCreateRequestTasks builder with application/json body
func NewBulkCreateRequestTasksRequest(server string, requestId string, body BulkCreateRequestTasksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateRequestTasksRequestWithBody(server, requestId, "application/json", bodyReader)
}

// NewBulkCreateRequestTasksRequestWithBody generates requests for BulkCreateRequestTasks with any type of body
func NewBulkCreateRequestTasksRequestWithBody(server string, requestId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request_id", runtime.ParamLocationPath, requestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/requests/%s/tasks:bulk-create", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkUpdateRequestTasksRequest calls the generic BulkUpdateRequestTasks builder with application/json body
func NewBulkUpdateRequestTasksRequest(server string, requestId string, body BulkUpdateRequestTasksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateRequestTasksRequestWithBody(server, requestId, "application/json", bodyReader)
}

// NewBulkUpdateRequestTasksRequestWithBody generates requests for BulkUpdateRequestTasks with any type of body
func NewBulkUpdateRequestTasksRequestWithBody(server string, requestId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request_id", runtime.ParamLocationPath, requestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/requests/%s/tasks:bulk-update", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExecuteRequestsSampleGroupsRequest calls the generic ExecuteRequestsSampleGroups builder with application/json body
func NewExecuteRequestsSampleGroupsRequest(server string, requestId string, body ExecuteRequestsSampleGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExecuteRequestsSampleGroupsRequestWithBody(server, requestId, "application/json", bodyReader)
}

// NewExecuteRequestsSampleGroupsRequestWithBody generates requests for ExecuteRequestsSampleGroups with any type of body
func NewExecuteRequestsSampleGroupsRequestWithBody(server string, requestId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "request_id", runtime.ParamLocationPath, requestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/requests/%s:execute-sample-groups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkGetRequestsRequest generates requests for BulkGetRequests
func NewBulkGetRequestsRequest(server string, params *BulkGetRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/requests:bulk-get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RequestIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestIds", runtime.ParamLocationQuery, *params.RequestIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisplayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "displayIds", runtime.ParamLocationQuery, *params.DisplayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAssayResultsTransactionRequest generates requests for CreateAssayResultsTransaction
func NewCreateAssayResultsTransactionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/result-transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAssayResultsInTransactionRequest calls the generic CreateAssayResultsInTransaction builder with application/json body
func NewCreateAssayResultsInTransactionRequest(server string, transactionId openapi_types.UUID, body CreateAssayResultsInTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAssayResultsInTransactionRequestWithBody(server, transactionId, "application/json", bodyReader)
}

// NewCreateAssayResultsInTransactionRequestWithBody generates requests for CreateAssayResultsInTransaction with any type of body
func NewCreateAssayResultsInTransactionRequestWithBody(server string, transactionId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/result-transactions/%s/results", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAbortAssayResultsTransactionRequest generates requests for AbortAssayResultsTransaction
func NewAbortAssayResultsTransactionRequest(server string, transactionId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/result-transactions/%s:abort", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommitAssayResultsTransactionRequest generates requests for CommitAssayResultsTransaction
func NewCommitAssayResultsTransactionRequest(server string, transactionId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/result-transactions/%s:commit", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListRNAOligosRequest generates requests for ListRNAOligos
func NewListRNAOligosRequest(server string, params *ListRNAOligosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-oligos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bases != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bases", runtime.ParamLocationQuery, *params.Bases); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FolderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "folderId", runtime.ParamLocationQuery, *params.FolderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MentionedIn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentionedIn", runtime.ParamLocationQuery, *params.MentionedIn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegistryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "registryId", runtime.ParamLocationQuery, *params.RegistryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaFields", runtime.ParamLocationQuery, *params.SchemaFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mentions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentions", runtime.ParamLocationQuery, *params.Mentions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntityRegistryIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entityRegistryIds.anyOf", runtime.ParamLocationQuery, *params.EntityRegistryIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authorIds.anyOf", runtime.ParamLocationQuery, *params.AuthorIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomNotationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customNotationId", runtime.ParamLocationQuery, *params.CustomNotationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRNAOligoRequest calls the generic CreateRNAOligo builder with application/json body
func NewCreateRNAOligoRequest(server string, body CreateRNAOligoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRNAOligoRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRNAOligoRequestWithBody generates requests for CreateRNAOligo with any type of body
func NewCreateRNAOligoRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-oligos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRNAOligoRequest generates requests for GetRNAOligo
func NewGetRNAOligoRequest(server string, oligoId string, params *GetRNAOligoParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "oligo_id", runtime.ParamLocationPath, oligoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-oligos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomNotationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customNotationId", runtime.ParamLocationQuery, *params.CustomNotationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRNAOligoRequest calls the generic UpdateRNAOligo builder with application/json body
func NewUpdateRNAOligoRequest(server string, oligoId string, body UpdateRNAOligoJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRNAOligoRequestWithBody(server, oligoId, "application/json", bodyReader)
}

// NewUpdateRNAOligoRequestWithBody generates requests for UpdateRNAOligo with any type of body
func NewUpdateRNAOligoRequestWithBody(server string, oligoId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "oligo_id", runtime.ParamLocationPath, oligoId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-oligos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveRNAOligosRequest calls the generic ArchiveRNAOligos builder with application/json body
func NewArchiveRNAOligosRequest(server string, body ArchiveRNAOligosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveRNAOligosRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveRNAOligosRequestWithBody generates requests for ArchiveRNAOligos with any type of body
func NewArchiveRNAOligosRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-oligos:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkCreateRNAOligosRequest calls the generic BulkCreateRNAOligos builder with application/json body
func NewBulkCreateRNAOligosRequest(server string, body BulkCreateRNAOligosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateRNAOligosRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateRNAOligosRequestWithBody generates requests for BulkCreateRNAOligos with any type of body
func NewBulkCreateRNAOligosRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-oligos:bulk-create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkUpdateRNAOligosRequest calls the generic BulkUpdateRNAOligos builder with application/json body
func NewBulkUpdateRNAOligosRequest(server string, body BulkUpdateRNAOligosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateRNAOligosRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateRNAOligosRequestWithBody generates requests for BulkUpdateRNAOligos with any type of body
func NewBulkUpdateRNAOligosRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-oligos:bulk-update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveRNAOligosRequest calls the generic UnarchiveRNAOligos builder with application/json body
func NewUnarchiveRNAOligosRequest(server string, body UnarchiveRNAOligosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveRNAOligosRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveRNAOligosRequestWithBody generates requests for UnarchiveRNAOligos with any type of body
func NewUnarchiveRNAOligosRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-oligos:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListRNASequencesRequest generates requests for ListRNASequences
func NewListRNASequencesRequest(server string, params *ListRNASequencesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-sequences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bases != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bases", runtime.ParamLocationQuery, *params.Bases); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FolderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "folderId", runtime.ParamLocationQuery, *params.FolderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MentionedIn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentionedIn", runtime.ParamLocationQuery, *params.MentionedIn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RegistryId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "registryId", runtime.ParamLocationQuery, *params.RegistryId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaFields", runtime.ParamLocationQuery, *params.SchemaFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Mentions != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentions", runtime.ParamLocationQuery, *params.Mentions); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EntityRegistryIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entityRegistryIds.anyOf", runtime.ParamLocationQuery, *params.EntityRegistryIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authorIds.anyOf", runtime.ParamLocationQuery, *params.AuthorIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomNotationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customNotationId", runtime.ParamLocationQuery, *params.CustomNotationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRNASequenceRequest calls the generic CreateRNASequence builder with application/json body
func NewCreateRNASequenceRequest(server string, body CreateRNASequenceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRNASequenceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRNASequenceRequestWithBody generates requests for CreateRNASequence with any type of body
func NewCreateRNASequenceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-sequences")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRNASequenceRequest generates requests for GetRNASequence
func NewGetRNASequenceRequest(server string, rnaSequenceId string, params *GetRNASequenceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "rna_sequence_id", runtime.ParamLocationPath, rnaSequenceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-sequences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomNotationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customNotationId", runtime.ParamLocationQuery, *params.CustomNotationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRNASequenceRequest calls the generic UpdateRNASequence builder with application/json body
func NewUpdateRNASequenceRequest(server string, rnaSequenceId string, body UpdateRNASequenceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRNASequenceRequestWithBody(server, rnaSequenceId, "application/json", bodyReader)
}

// NewUpdateRNASequenceRequestWithBody generates requests for UpdateRNASequence with any type of body
func NewUpdateRNASequenceRequestWithBody(server string, rnaSequenceId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "rna_sequence_id", runtime.ParamLocationPath, rnaSequenceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-sequences/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveRNASequencesRequest calls the generic ArchiveRNASequences builder with application/json body
func NewArchiveRNASequencesRequest(server string, body ArchiveRNASequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveRNASequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveRNASequencesRequestWithBody generates requests for ArchiveRNASequences with any type of body
func NewArchiveRNASequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-sequences:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAutoAnnotateRnaSequencesRequest calls the generic AutoAnnotateRnaSequences builder with application/json body
func NewAutoAnnotateRnaSequencesRequest(server string, body AutoAnnotateRnaSequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAutoAnnotateRnaSequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewAutoAnnotateRnaSequencesRequestWithBody generates requests for AutoAnnotateRnaSequences with any type of body
func NewAutoAnnotateRnaSequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-sequences:auto-annotate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAutofillRNASequencePartsRequest calls the generic AutofillRNASequenceParts builder with application/json body
func NewAutofillRNASequencePartsRequest(server string, body AutofillRNASequencePartsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAutofillRNASequencePartsRequestWithBody(server, "application/json", bodyReader)
}

// NewAutofillRNASequencePartsRequestWithBody generates requests for AutofillRNASequenceParts with any type of body
func NewAutofillRNASequencePartsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-sequences:autofill-parts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAutofillRNASequenceTranslationsRequest calls the generic AutofillRNASequenceTranslations builder with application/json body
func NewAutofillRNASequenceTranslationsRequest(server string, body AutofillRNASequenceTranslationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAutofillRNASequenceTranslationsRequestWithBody(server, "application/json", bodyReader)
}

// NewAutofillRNASequenceTranslationsRequestWithBody generates requests for AutofillRNASequenceTranslations with any type of body
func NewAutofillRNASequenceTranslationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-sequences:autofill-translations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkCreateRNASequencesRequest calls the generic BulkCreateRNASequences builder with application/json body
func NewBulkCreateRNASequencesRequest(server string, body BulkCreateRNASequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateRNASequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateRNASequencesRequestWithBody generates requests for BulkCreateRNASequences with any type of body
func NewBulkCreateRNASequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-sequences:bulk-create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkGetRNASequencesRequest generates requests for BulkGetRNASequences
func NewBulkGetRNASequencesRequest(server string, params *BulkGetRNASequencesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-sequences:bulk-get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rnaSequenceIds", runtime.ParamLocationQuery, params.RnaSequenceIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Returning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "returning", runtime.ParamLocationQuery, *params.Returning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkUpdateRNASequencesRequest calls the generic BulkUpdateRNASequences builder with application/json body
func NewBulkUpdateRNASequencesRequest(server string, body BulkUpdateRNASequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateRNASequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateRNASequencesRequestWithBody generates requests for BulkUpdateRNASequences with any type of body
func NewBulkUpdateRNASequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-sequences:bulk-update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMatchBasesRnaSequencesRequest calls the generic MatchBasesRnaSequences builder with application/json body
func NewMatchBasesRnaSequencesRequest(server string, body MatchBasesRnaSequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMatchBasesRnaSequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewMatchBasesRnaSequencesRequestWithBody generates requests for MatchBasesRnaSequences with any type of body
func NewMatchBasesRnaSequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-sequences:match-bases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchRnaSequencesRequest calls the generic SearchRnaSequences builder with application/json body
func NewSearchRnaSequencesRequest(server string, body SearchRnaSequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchRnaSequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewSearchRnaSequencesRequestWithBody generates requests for SearchRnaSequences with any type of body
func NewSearchRnaSequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-sequences:search-bases")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveRNASequencesRequest calls the generic UnarchiveRNASequences builder with application/json body
func NewUnarchiveRNASequencesRequest(server string, body UnarchiveRNASequencesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveRNASequencesRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveRNASequencesRequestWithBody generates requests for UnarchiveRNASequences with any type of body
func NewUnarchiveRNASequencesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rna-sequences:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTaskRequest generates requests for GetTask
func NewGetTaskRequest(server string, taskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "task_id", runtime.ParamLocationPath, taskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListTeamsRequest generates requests for ListTeams
func NewListTeamsRequest(server string, params *ListTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MentionedIn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentionedIn", runtime.ParamLocationQuery, *params.MentionedIn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrganizationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "organizationId", runtime.ParamLocationQuery, *params.OrganizationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasMembers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasMembers", runtime.ParamLocationQuery, *params.HasMembers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasAdmins != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasAdmins", runtime.ParamLocationQuery, *params.HasAdmins); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamRequest generates requests for GetTeam
func NewGetTeamRequest(server string, teamId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "team_id", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateTokenRequestWithFormdataBody calls the generic GenerateToken builder with application/x-www-form-urlencoded body
func NewGenerateTokenRequestWithFormdataBody(server string, body GenerateTokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewGenerateTokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewGenerateTokenRequestWithBody generates requests for GenerateToken with any type of body
func NewGenerateTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTransferIntoContainersRequest calls the generic TransferIntoContainers builder with application/json body
func NewTransferIntoContainersRequest(server string, body TransferIntoContainersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTransferIntoContainersRequestWithBody(server, "application/json", bodyReader)
}

// NewTransferIntoContainersRequestWithBody generates requests for TransferIntoContainers with any type of body
func NewTransferIntoContainersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transfers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListUsersRequest generates requests for ListUsers
func NewListUsersRequest(server string, params *ListUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf", runtime.ParamLocationQuery, *params.NamesAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NamesAnyOfCaseSensitive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "names.anyOf.caseSensitive", runtime.ParamLocationQuery, *params.NamesAnyOfCaseSensitive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MemberOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "memberOf", runtime.ParamLocationQuery, *params.MemberOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdminOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "adminOf", runtime.ParamLocationQuery, *params.AdminOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Handles != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "handles", runtime.ParamLocationQuery, *params.Handles); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EmailAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email.anyOf", runtime.ParamLocationQuery, *params.EmailAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PasswordLastChangedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "passwordLastChangedAt", runtime.ParamLocationQuery, *params.PasswordLastChangedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest calls the generic UpdateUser builder with application/json body
func NewUpdateUserRequest(server string, userId string, body UpdateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserRequestWithBody generates requests for UpdateUser with any type of body
func NewUpdateUserRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserActivityRequest generates requests for GetUserActivity
func NewGetUserActivityRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_id", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/activity", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkCreateUsersRequest calls the generic BulkCreateUsers builder with application/json body
func NewBulkCreateUsersRequest(server string, body BulkCreateUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateUsersRequestWithBody generates requests for BulkCreateUsers with any type of body
func NewBulkCreateUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users:bulk-create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkUpdateUsersRequest calls the generic BulkUpdateUsers builder with application/json body
func NewBulkUpdateUsersRequest(server string, body BulkUpdateUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateUsersRequestWithBody generates requests for BulkUpdateUsers with any type of body
func NewBulkUpdateUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users:bulk-update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateWarehouseCredentialsRequest calls the generic CreateWarehouseCredentials builder with application/json body
func NewCreateWarehouseCredentialsRequest(server string, body CreateWarehouseCredentialsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWarehouseCredentialsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWarehouseCredentialsRequestWithBody generates requests for CreateWarehouseCredentials with any type of body
func NewCreateWarehouseCredentialsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/warehouse-credentials")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWorkflowOutputsRequest generates requests for ListWorkflowOutputs
func NewListWorkflowOutputsRequest(server string, params *ListWorkflowOutputsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowTaskGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflowTaskGroupIds", runtime.ParamLocationQuery, *params.WorkflowTaskGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowTaskIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflowTaskIds", runtime.ParamLocationQuery, *params.WorkflowTaskIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WatcherIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "watcherIds", runtime.ParamLocationQuery, *params.WatcherIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponsibleTeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "responsibleTeamIds", runtime.ParamLocationQuery, *params.ResponsibleTeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreationOriginIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creationOriginIds", runtime.ParamLocationQuery, *params.CreationOriginIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedItemIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkedItemIds.anyOf", runtime.ParamLocationQuery, *params.LinkedItemIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedItemIdsAllOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkedItemIds.allOf", runtime.ParamLocationQuery, *params.LinkedItemIdsAllOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedItemIdsNoneOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkedItemIds.noneOf", runtime.ParamLocationQuery, *params.LinkedItemIdsNoneOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaFields", runtime.ParamLocationQuery, *params.SchemaFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisplayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "displayIds", runtime.ParamLocationQuery, *params.DisplayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWorkflowOutputRequest calls the generic CreateWorkflowOutput builder with application/json body
func NewCreateWorkflowOutputRequest(server string, body CreateWorkflowOutputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkflowOutputRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWorkflowOutputRequestWithBody generates requests for CreateWorkflowOutput with any type of body
func NewCreateWorkflowOutputRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkflowOutputRequest generates requests for GetWorkflowOutput
func NewGetWorkflowOutputRequest(server string, workflowOutputId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_output_id", runtime.ParamLocationPath, workflowOutputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWorkflowOutputRequest calls the generic UpdateWorkflowOutput builder with application/json body
func NewUpdateWorkflowOutputRequest(server string, workflowOutputId string, body UpdateWorkflowOutputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWorkflowOutputRequestWithBody(server, workflowOutputId, "application/json", bodyReader)
}

// NewUpdateWorkflowOutputRequestWithBody generates requests for UpdateWorkflowOutput with any type of body
func NewUpdateWorkflowOutputRequestWithBody(server string, workflowOutputId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_output_id", runtime.ParamLocationPath, workflowOutputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveWorkflowOutputsRequest calls the generic ArchiveWorkflowOutputs builder with application/json body
func NewArchiveWorkflowOutputsRequest(server string, body ArchiveWorkflowOutputsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveWorkflowOutputsRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveWorkflowOutputsRequestWithBody generates requests for ArchiveWorkflowOutputs with any type of body
func NewArchiveWorkflowOutputsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-outputs:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkCreateWorkflowOutputsRequest calls the generic BulkCreateWorkflowOutputs builder with application/json body
func NewBulkCreateWorkflowOutputsRequest(server string, body BulkCreateWorkflowOutputsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateWorkflowOutputsRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateWorkflowOutputsRequestWithBody generates requests for BulkCreateWorkflowOutputs with any type of body
func NewBulkCreateWorkflowOutputsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-outputs:bulk-create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkUpdateWorkflowOutputsRequest calls the generic BulkUpdateWorkflowOutputs builder with application/json body
func NewBulkUpdateWorkflowOutputsRequest(server string, body BulkUpdateWorkflowOutputsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateWorkflowOutputsRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateWorkflowOutputsRequestWithBody generates requests for BulkUpdateWorkflowOutputs with any type of body
func NewBulkUpdateWorkflowOutputsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-outputs:bulk-update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveWorkflowOutputsRequest calls the generic UnarchiveWorkflowOutputs builder with application/json body
func NewUnarchiveWorkflowOutputsRequest(server string, body UnarchiveWorkflowOutputsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveWorkflowOutputsRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveWorkflowOutputsRequestWithBody generates requests for UnarchiveWorkflowOutputs with any type of body
func NewUnarchiveWorkflowOutputsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-outputs:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListStageRunInputSamplesRequest generates requests for ListStageRunInputSamples
func NewListStageRunInputSamplesRequest(server string, stageRunId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stage_run_id", runtime.ParamLocationPath, stageRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-stage-runs/%s/input-samples", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListStageRunOutputSamplesRequest generates requests for ListStageRunOutputSamples
func NewListStageRunOutputSamplesRequest(server string, stageRunId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stage_run_id", runtime.ParamLocationPath, stageRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-stage-runs/%s/output-samples", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListStageRunRegisteredSamplesRequest generates requests for ListStageRunRegisteredSamples
func NewListStageRunRegisteredSamplesRequest(server string, stageRunId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stage_run_id", runtime.ParamLocationPath, stageRunId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-stage-runs/%s/registered-samples", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkflowStageRunsRequest generates requests for ListWorkflowStageRuns
func NewListWorkflowStageRunsRequest(server string, stageId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "stage_id", runtime.ParamLocationPath, stageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-stages/%s/workflow-stage-runs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkflowTaskGroupsRequest generates requests for ListWorkflowTaskGroups
func NewListWorkflowTaskGroupsRequest(server string, params *ListWorkflowTaskGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-task-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FolderId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "folderId", runtime.ParamLocationQuery, *params.FolderId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MentionedIn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mentionedIn", runtime.ParamLocationQuery, *params.MentionedIn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WatcherIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "watcherIds", runtime.ParamLocationQuery, *params.WatcherIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "executionTypes", runtime.ParamLocationQuery, *params.ExecutionTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponsibleTeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "responsibleTeamIds", runtime.ParamLocationQuery, *params.ResponsibleTeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statusIds.anyOf", runtime.ParamLocationQuery, *params.StatusIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusIdsNoneOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statusIds.noneOf", runtime.ParamLocationQuery, *params.StatusIdsNoneOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusIdsOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statusIds.only", runtime.ParamLocationQuery, *params.StatusIdsOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisplayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "displayIds", runtime.ParamLocationQuery, *params.DisplayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWorkflowTaskGroupRequest calls the generic CreateWorkflowTaskGroup builder with application/json body
func NewCreateWorkflowTaskGroupRequest(server string, body CreateWorkflowTaskGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkflowTaskGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWorkflowTaskGroupRequestWithBody generates requests for CreateWorkflowTaskGroup with any type of body
func NewCreateWorkflowTaskGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-task-groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkflowTaskGroupRequest generates requests for GetWorkflowTaskGroup
func NewGetWorkflowTaskGroupRequest(server string, workflowTaskGroupId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_task_group_id", runtime.ParamLocationPath, workflowTaskGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-task-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWorkflowTaskGroupRequest calls the generic UpdateWorkflowTaskGroup builder with application/json body
func NewUpdateWorkflowTaskGroupRequest(server string, workflowTaskGroupId string, body UpdateWorkflowTaskGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWorkflowTaskGroupRequestWithBody(server, workflowTaskGroupId, "application/json", bodyReader)
}

// NewUpdateWorkflowTaskGroupRequestWithBody generates requests for UpdateWorkflowTaskGroup with any type of body
func NewUpdateWorkflowTaskGroupRequestWithBody(server string, workflowTaskGroupId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_task_group_id", runtime.ParamLocationPath, workflowTaskGroupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-task-groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewArchiveWorkflowTaskGroupsRequest calls the generic ArchiveWorkflowTaskGroups builder with application/json body
func NewArchiveWorkflowTaskGroupsRequest(server string, body ArchiveWorkflowTaskGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveWorkflowTaskGroupsRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveWorkflowTaskGroupsRequestWithBody generates requests for ArchiveWorkflowTaskGroups with any type of body
func NewArchiveWorkflowTaskGroupsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-task-groups:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveWorkflowTaskGroupsRequest calls the generic UnarchiveWorkflowTaskGroups builder with application/json body
func NewUnarchiveWorkflowTaskGroupsRequest(server string, body UnarchiveWorkflowTaskGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveWorkflowTaskGroupsRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveWorkflowTaskGroupsRequestWithBody generates requests for UnarchiveWorkflowTaskGroups with any type of body
func NewUnarchiveWorkflowTaskGroupsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-task-groups:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWorkflowTaskSchemasRequest generates requests for ListWorkflowTaskSchemas
func NewListWorkflowTaskSchemasRequest(server string, params *ListWorkflowTaskSchemasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-task-schemas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWorkflowTaskSchemaRequest generates requests for GetWorkflowTaskSchema
func NewGetWorkflowTaskSchemaRequest(server string, schemaId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, schemaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-task-schemas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListWorkflowTasksRequest generates requests for ListWorkflowTasks
func NewListWorkflowTasksRequest(server string, params *ListWorkflowTasksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WorkflowTaskGroupIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "workflowTaskGroupIds", runtime.ParamLocationQuery, *params.WorkflowTaskGroupIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaId", runtime.ParamLocationQuery, *params.SchemaId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StatusIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "statusIds", runtime.ParamLocationQuery, *params.StatusIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssigneeIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assigneeIds", runtime.ParamLocationQuery, *params.AssigneeIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WatcherIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "watcherIds", runtime.ParamLocationQuery, *params.WatcherIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ResponsibleTeamIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "responsibleTeamIds", runtime.ParamLocationQuery, *params.ResponsibleTeamIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionOriginIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "executionOriginIds", runtime.ParamLocationQuery, *params.ExecutionOriginIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExecutionTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "executionTypes", runtime.ParamLocationQuery, *params.ExecutionTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedItemIdsAnyOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkedItemIds.anyOf", runtime.ParamLocationQuery, *params.LinkedItemIdsAnyOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedItemIdsAllOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkedItemIds.allOf", runtime.ParamLocationQuery, *params.LinkedItemIdsAllOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedItemIdsNoneOf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linkedItemIds.noneOf", runtime.ParamLocationQuery, *params.LinkedItemIdsNoneOf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchemaFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schemaFields", runtime.ParamLocationQuery, *params.SchemaFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NameIncludes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nameIncludes", runtime.ParamLocationQuery, *params.NameIncludes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatorIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "creatorIds", runtime.ParamLocationQuery, *params.CreatorIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledOn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduledOn", runtime.ParamLocationQuery, *params.ScheduledOn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledOnLt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduledOn.lt", runtime.ParamLocationQuery, *params.ScheduledOnLt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledOnLte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduledOn.lte", runtime.ParamLocationQuery, *params.ScheduledOnLte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledOnGte != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduledOn.gte", runtime.ParamLocationQuery, *params.ScheduledOnGte); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledOnGt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduledOn.gt", runtime.ParamLocationQuery, *params.ScheduledOnGt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ModifiedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modifiedAt", runtime.ParamLocationQuery, *params.ModifiedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "nextToken", runtime.ParamLocationQuery, *params.NextToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisplayIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "displayIds", runtime.ParamLocationQuery, *params.DisplayIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ArchiveReason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "archiveReason", runtime.ParamLocationQuery, *params.ArchiveReason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWorkflowTaskRequest calls the generic CreateWorkflowTask builder with application/json body
func NewCreateWorkflowTaskRequest(server string, body CreateWorkflowTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWorkflowTaskRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWorkflowTaskRequestWithBody generates requests for CreateWorkflowTask with any type of body
func NewCreateWorkflowTaskRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-tasks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkflowTaskRequest generates requests for GetWorkflowTask
func NewGetWorkflowTaskRequest(server string, workflowTaskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_task_id", runtime.ParamLocationPath, workflowTaskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWorkflowTaskRequest calls the generic UpdateWorkflowTask builder with application/json body
func NewUpdateWorkflowTaskRequest(server string, workflowTaskId string, body UpdateWorkflowTaskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWorkflowTaskRequestWithBody(server, workflowTaskId, "application/json", bodyReader)
}

// NewUpdateWorkflowTaskRequestWithBody generates requests for UpdateWorkflowTask with any type of body
func NewUpdateWorkflowTaskRequestWithBody(server string, workflowTaskId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_task_id", runtime.ParamLocationPath, workflowTaskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-tasks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCopyWorkflowTaskRequest generates requests for CopyWorkflowTask
func NewCopyWorkflowTaskRequest(server string, workflowTaskId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_task_id", runtime.ParamLocationPath, workflowTaskId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-tasks/%s:copy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewArchiveWorkflowTasksRequest calls the generic ArchiveWorkflowTasks builder with application/json body
func NewArchiveWorkflowTasksRequest(server string, body ArchiveWorkflowTasksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveWorkflowTasksRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveWorkflowTasksRequestWithBody generates requests for ArchiveWorkflowTasks with any type of body
func NewArchiveWorkflowTasksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-tasks:archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkCopyWorkflowTasksRequest calls the generic BulkCopyWorkflowTasks builder with application/json body
func NewBulkCopyWorkflowTasksRequest(server string, body BulkCopyWorkflowTasksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCopyWorkflowTasksRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCopyWorkflowTasksRequestWithBody generates requests for BulkCopyWorkflowTasks with any type of body
func NewBulkCopyWorkflowTasksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-tasks:bulk-copy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkCreateWorkflowTasksRequest calls the generic BulkCreateWorkflowTasks builder with application/json body
func NewBulkCreateWorkflowTasksRequest(server string, body BulkCreateWorkflowTasksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkCreateWorkflowTasksRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkCreateWorkflowTasksRequestWithBody generates requests for BulkCreateWorkflowTasks with any type of body
func NewBulkCreateWorkflowTasksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-tasks:bulk-create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBulkUpdateWorkflowTasksRequest calls the generic BulkUpdateWorkflowTasks builder with application/json body
func NewBulkUpdateWorkflowTasksRequest(server string, body BulkUpdateWorkflowTasksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateWorkflowTasksRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateWorkflowTasksRequestWithBody generates requests for BulkUpdateWorkflowTasks with any type of body
func NewBulkUpdateWorkflowTasksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-tasks:bulk-update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUnarchiveWorkflowTasksRequest calls the generic UnarchiveWorkflowTasks builder with application/json body
func NewUnarchiveWorkflowTasksRequest(server string, body UnarchiveWorkflowTasksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnarchiveWorkflowTasksRequestWithBody(server, "application/json", bodyReader)
}

// NewUnarchiveWorkflowTasksRequestWithBody generates requests for UnarchiveWorkflowTasks with any type of body
func NewUnarchiveWorkflowTasksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflow-tasks:unarchive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWorkflowsRequest generates requests for ListWorkflows
func NewListWorkflowsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWorkflowMetadataRequest calls the generic UpdateWorkflowMetadata builder with application/json body
func NewUpdateWorkflowMetadataRequest(server string, workflowId string, body UpdateWorkflowMetadataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWorkflowMetadataRequestWithBody(server, workflowId, "application/json", bodyReader)
}

// NewUpdateWorkflowMetadataRequestWithBody generates requests for UpdateWorkflowMetadata with any type of body
func NewUpdateWorkflowMetadataRequestWithBody(server string, workflowId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListWorkflowStagesRequest generates requests for ListWorkflowStages
func NewListWorkflowStagesRequest(server string, workflowId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, workflowId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/workflows/%s/workflow-stages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListAASequencesWithResponse request
	ListAASequencesWithResponse(ctx context.Context, params *ListAASequencesParams, reqEditors ...RequestEditorFn) (*ListAASequencesResponse, error)

	// CreateAASequenceWithBodyWithResponse request with any body
	CreateAASequenceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAASequenceResponse, error)

	CreateAASequenceWithResponse(ctx context.Context, body CreateAASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAASequenceResponse, error)

	// GetAASequenceWithResponse request
	GetAASequenceWithResponse(ctx context.Context, aaSequenceId string, params *GetAASequenceParams, reqEditors ...RequestEditorFn) (*GetAASequenceResponse, error)

	// UpdateAASequenceWithBodyWithResponse request with any body
	UpdateAASequenceWithBodyWithResponse(ctx context.Context, aaSequenceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAASequenceResponse, error)

	UpdateAASequenceWithResponse(ctx context.Context, aaSequenceId string, body UpdateAASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAASequenceResponse, error)

	// ArchiveAASequencesWithBodyWithResponse request with any body
	ArchiveAASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveAASequencesResponse, error)

	ArchiveAASequencesWithResponse(ctx context.Context, body ArchiveAASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveAASequencesResponse, error)

	// AutoAnnotateAaSequencesWithBodyWithResponse request with any body
	AutoAnnotateAaSequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AutoAnnotateAaSequencesResponse, error)

	AutoAnnotateAaSequencesWithResponse(ctx context.Context, body AutoAnnotateAaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*AutoAnnotateAaSequencesResponse, error)

	// BulkCreateAASequencesWithBodyWithResponse request with any body
	BulkCreateAASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateAASequencesResponse, error)

	BulkCreateAASequencesWithResponse(ctx context.Context, body BulkCreateAASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateAASequencesResponse, error)

	// BulkGetAASequencesWithResponse request
	BulkGetAASequencesWithResponse(ctx context.Context, params *BulkGetAASequencesParams, reqEditors ...RequestEditorFn) (*BulkGetAASequencesResponse, error)

	// BulkUpdateAASequencesWithBodyWithResponse request with any body
	BulkUpdateAASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateAASequencesResponse, error)

	BulkUpdateAASequencesWithResponse(ctx context.Context, body BulkUpdateAASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateAASequencesResponse, error)

	// UnarchiveAASequencesWithBodyWithResponse request with any body
	UnarchiveAASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveAASequencesResponse, error)

	UnarchiveAASequencesWithResponse(ctx context.Context, body UnarchiveAASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveAASequencesResponse, error)

	// CreateAppCanvasWithBodyWithResponse request with any body
	CreateAppCanvasWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppCanvasResponse, error)

	CreateAppCanvasWithResponse(ctx context.Context, body CreateAppCanvasJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppCanvasResponse, error)

	// GetAppCanvasWithResponse request
	GetAppCanvasWithResponse(ctx context.Context, canvasId string, params *GetAppCanvasParams, reqEditors ...RequestEditorFn) (*GetAppCanvasResponse, error)

	// UpdateAppCanvasWithBodyWithResponse request with any body
	UpdateAppCanvasWithBodyWithResponse(ctx context.Context, canvasId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppCanvasResponse, error)

	UpdateAppCanvasWithResponse(ctx context.Context, canvasId string, body UpdateAppCanvasJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppCanvasResponse, error)

	// ArchiveAppCanvasesWithBodyWithResponse request with any body
	ArchiveAppCanvasesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveAppCanvasesResponse, error)

	ArchiveAppCanvasesWithResponse(ctx context.Context, body ArchiveAppCanvasesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveAppCanvasesResponse, error)

	// UnarchiveAppCanvasesWithBodyWithResponse request with any body
	UnarchiveAppCanvasesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveAppCanvasesResponse, error)

	UnarchiveAppCanvasesWithResponse(ctx context.Context, body UnarchiveAppCanvasesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveAppCanvasesResponse, error)

	// ListAppConfigurationItemsWithResponse request
	ListAppConfigurationItemsWithResponse(ctx context.Context, params *ListAppConfigurationItemsParams, reqEditors ...RequestEditorFn) (*ListAppConfigurationItemsResponse, error)

	// CreateAppConfigurationItemWithBodyWithResponse request with any body
	CreateAppConfigurationItemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppConfigurationItemResponse, error)

	CreateAppConfigurationItemWithResponse(ctx context.Context, body CreateAppConfigurationItemJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppConfigurationItemResponse, error)

	// GetAppConfigurationItemByIdWithResponse request
	GetAppConfigurationItemByIdWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*GetAppConfigurationItemByIdResponse, error)

	// UpdateAppConfigurationItemWithBodyWithResponse request with any body
	UpdateAppConfigurationItemWithBodyWithResponse(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppConfigurationItemResponse, error)

	UpdateAppConfigurationItemWithResponse(ctx context.Context, itemId string, body UpdateAppConfigurationItemJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppConfigurationItemResponse, error)

	// BulkCreateAppConfigurationItemsWithBodyWithResponse request with any body
	BulkCreateAppConfigurationItemsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateAppConfigurationItemsResponse, error)

	BulkCreateAppConfigurationItemsWithResponse(ctx context.Context, body BulkCreateAppConfigurationItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateAppConfigurationItemsResponse, error)

	// BulkUpdateAppConfigurationItemsWithBodyWithResponse request with any body
	BulkUpdateAppConfigurationItemsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateAppConfigurationItemsResponse, error)

	BulkUpdateAppConfigurationItemsWithResponse(ctx context.Context, body BulkUpdateAppConfigurationItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateAppConfigurationItemsResponse, error)

	// CreateAppSessionWithBodyWithResponse request with any body
	CreateAppSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppSessionResponse, error)

	CreateAppSessionWithResponse(ctx context.Context, body CreateAppSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppSessionResponse, error)

	// GetAppSessionByIdWithResponse request
	GetAppSessionByIdWithResponse(ctx context.Context, id string, params *GetAppSessionByIdParams, reqEditors ...RequestEditorFn) (*GetAppSessionByIdResponse, error)

	// UpdateAppSessionWithBodyWithResponse request with any body
	UpdateAppSessionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppSessionResponse, error)

	UpdateAppSessionWithResponse(ctx context.Context, id string, body UpdateAppSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppSessionResponse, error)

	// ListBenchlingAppsWithResponse request
	ListBenchlingAppsWithResponse(ctx context.Context, params *ListBenchlingAppsParams, reqEditors ...RequestEditorFn) (*ListBenchlingAppsResponse, error)

	// CreateBenchlingAppWithBodyWithResponse request with any body
	CreateBenchlingAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBenchlingAppResponse, error)

	CreateBenchlingAppWithResponse(ctx context.Context, body CreateBenchlingAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBenchlingAppResponse, error)

	// GetBenchlingAppByIDWithResponse request
	GetBenchlingAppByIDWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetBenchlingAppByIDResponse, error)

	// PatchBenchlingAppWithBodyWithResponse request with any body
	PatchBenchlingAppWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchBenchlingAppResponse, error)

	PatchBenchlingAppWithResponse(ctx context.Context, appId string, body PatchBenchlingAppJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchBenchlingAppResponse, error)

	// ArchiveBenchlingAppsWithBodyWithResponse request with any body
	ArchiveBenchlingAppsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveBenchlingAppsResponse, error)

	ArchiveBenchlingAppsWithResponse(ctx context.Context, body ArchiveBenchlingAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveBenchlingAppsResponse, error)

	// UnarchiveBenchlingAppsWithBodyWithResponse request with any body
	UnarchiveBenchlingAppsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveBenchlingAppsResponse, error)

	UnarchiveBenchlingAppsWithResponse(ctx context.Context, body UnarchiveBenchlingAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveBenchlingAppsResponse, error)

	// ListAssayResultSchemasWithResponse request
	ListAssayResultSchemasWithResponse(ctx context.Context, params *ListAssayResultSchemasParams, reqEditors ...RequestEditorFn) (*ListAssayResultSchemasResponse, error)

	// GetResultSchemaWithResponse request
	GetResultSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetResultSchemaResponse, error)

	// ListAssayResultsWithResponse request
	ListAssayResultsWithResponse(ctx context.Context, params *ListAssayResultsParams, reqEditors ...RequestEditorFn) (*ListAssayResultsResponse, error)

	// CreateAssayResultsWithBodyWithResponse request with any body
	CreateAssayResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAssayResultsResponse, error)

	CreateAssayResultsWithResponse(ctx context.Context, body CreateAssayResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAssayResultsResponse, error)

	// GetAssayResultWithResponse request
	GetAssayResultWithResponse(ctx context.Context, assayResultId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAssayResultResponse, error)

	// ArchiveAssayResultsWithBodyWithResponse request with any body
	ArchiveAssayResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveAssayResultsResponse, error)

	ArchiveAssayResultsWithResponse(ctx context.Context, body ArchiveAssayResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveAssayResultsResponse, error)

	// BulkCreateAssayResultsWithBodyWithResponse request with any body
	BulkCreateAssayResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateAssayResultsResponse, error)

	BulkCreateAssayResultsWithResponse(ctx context.Context, body BulkCreateAssayResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateAssayResultsResponse, error)

	// BulkGetAssayResultsWithResponse request
	BulkGetAssayResultsWithResponse(ctx context.Context, params *BulkGetAssayResultsParams, reqEditors ...RequestEditorFn) (*BulkGetAssayResultsResponse, error)

	// UnarchiveAssayResultsWithBodyWithResponse request with any body
	UnarchiveAssayResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveAssayResultsResponse, error)

	UnarchiveAssayResultsWithResponse(ctx context.Context, body UnarchiveAssayResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveAssayResultsResponse, error)

	// ListAssayRunSchemasWithResponse request
	ListAssayRunSchemasWithResponse(ctx context.Context, params *ListAssayRunSchemasParams, reqEditors ...RequestEditorFn) (*ListAssayRunSchemasResponse, error)

	// GetRunSchemaWithResponse request
	GetRunSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetRunSchemaResponse, error)

	// ListAssayRunsWithResponse request
	ListAssayRunsWithResponse(ctx context.Context, params *ListAssayRunsParams, reqEditors ...RequestEditorFn) (*ListAssayRunsResponse, error)

	// CreateAssayRunsWithBodyWithResponse request with any body
	CreateAssayRunsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAssayRunsResponse, error)

	CreateAssayRunsWithResponse(ctx context.Context, body CreateAssayRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAssayRunsResponse, error)

	// GetAssayRunWithResponse request
	GetAssayRunWithResponse(ctx context.Context, assayRunId string, reqEditors ...RequestEditorFn) (*GetAssayRunResponse, error)

	// UpdateAssayRunWithBodyWithResponse request with any body
	UpdateAssayRunWithBodyWithResponse(ctx context.Context, assayRunId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssayRunResponse, error)

	UpdateAssayRunWithResponse(ctx context.Context, assayRunId string, body UpdateAssayRunJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssayRunResponse, error)

	// ListAutomationInputGeneratorsWithResponse request
	ListAutomationInputGeneratorsWithResponse(ctx context.Context, assayRunId string, params *ListAutomationInputGeneratorsParams, reqEditors ...RequestEditorFn) (*ListAutomationInputGeneratorsResponse, error)

	// ListAutomationOutputProcessorsDeprecatedWithResponse request
	ListAutomationOutputProcessorsDeprecatedWithResponse(ctx context.Context, assayRunId string, params *ListAutomationOutputProcessorsDeprecatedParams, reqEditors ...RequestEditorFn) (*ListAutomationOutputProcessorsDeprecatedResponse, error)

	// ArchiveAssayRunsWithBodyWithResponse request with any body
	ArchiveAssayRunsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveAssayRunsResponse, error)

	ArchiveAssayRunsWithResponse(ctx context.Context, body ArchiveAssayRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveAssayRunsResponse, error)

	// BulkGetAssayRunsWithResponse request
	BulkGetAssayRunsWithResponse(ctx context.Context, params *BulkGetAssayRunsParams, reqEditors ...RequestEditorFn) (*BulkGetAssayRunsResponse, error)

	// UnarchiveAssayRunsWithBodyWithResponse request with any body
	UnarchiveAssayRunsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveAssayRunsResponse, error)

	UnarchiveAssayRunsWithResponse(ctx context.Context, body UnarchiveAssayRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveAssayRunsResponse, error)

	// GetLabAutomationTransformWithResponse request
	GetLabAutomationTransformWithResponse(ctx context.Context, transformId string, reqEditors ...RequestEditorFn) (*GetLabAutomationTransformResponse, error)

	// UpdateLabAutomationTransformWithBodyWithResponse request with any body
	UpdateLabAutomationTransformWithBodyWithResponse(ctx context.Context, transformId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLabAutomationTransformResponse, error)

	UpdateLabAutomationTransformWithResponse(ctx context.Context, transformId string, body UpdateLabAutomationTransformJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLabAutomationTransformResponse, error)

	// GetAutomationInputGeneratorWithResponse request
	GetAutomationInputGeneratorWithResponse(ctx context.Context, inputGeneratorId string, reqEditors ...RequestEditorFn) (*GetAutomationInputGeneratorResponse, error)

	// UpdateAutomationInputGeneratorWithBodyWithResponse request with any body
	UpdateAutomationInputGeneratorWithBodyWithResponse(ctx context.Context, inputGeneratorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAutomationInputGeneratorResponse, error)

	UpdateAutomationInputGeneratorWithResponse(ctx context.Context, inputGeneratorId string, body UpdateAutomationInputGeneratorJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAutomationInputGeneratorResponse, error)

	// GenerateInputWithAutomationInputGeneratorWithResponse request
	GenerateInputWithAutomationInputGeneratorWithResponse(ctx context.Context, inputGeneratorId string, reqEditors ...RequestEditorFn) (*GenerateInputWithAutomationInputGeneratorResponse, error)

	// ListAutomationOutputProcessorsWithResponse request
	ListAutomationOutputProcessorsWithResponse(ctx context.Context, params *ListAutomationOutputProcessorsParams, reqEditors ...RequestEditorFn) (*ListAutomationOutputProcessorsResponse, error)

	// CreateAutomationOutputProcessorWithBodyWithResponse request with any body
	CreateAutomationOutputProcessorWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAutomationOutputProcessorResponse, error)

	CreateAutomationOutputProcessorWithResponse(ctx context.Context, body CreateAutomationOutputProcessorJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAutomationOutputProcessorResponse, error)

	// GetAutomationOutputProcessorWithResponse request
	GetAutomationOutputProcessorWithResponse(ctx context.Context, outputProcessorId string, reqEditors ...RequestEditorFn) (*GetAutomationOutputProcessorResponse, error)

	// UpdateAutomationOutputProcessorWithBodyWithResponse request with any body
	UpdateAutomationOutputProcessorWithBodyWithResponse(ctx context.Context, outputProcessorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAutomationOutputProcessorResponse, error)

	UpdateAutomationOutputProcessorWithResponse(ctx context.Context, outputProcessorId string, body UpdateAutomationOutputProcessorJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAutomationOutputProcessorResponse, error)

	// ProcessOutputWithAutomationOutputProcessorWithResponse request
	ProcessOutputWithAutomationOutputProcessorWithResponse(ctx context.Context, outputProcessorId string, reqEditors ...RequestEditorFn) (*ProcessOutputWithAutomationOutputProcessorResponse, error)

	// ArchiveAutomationOutputProcessorsWithBodyWithResponse request with any body
	ArchiveAutomationOutputProcessorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveAutomationOutputProcessorsResponse, error)

	ArchiveAutomationOutputProcessorsWithResponse(ctx context.Context, body ArchiveAutomationOutputProcessorsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveAutomationOutputProcessorsResponse, error)

	// UnarchiveAutomationOutputProcessorsWithBodyWithResponse request with any body
	UnarchiveAutomationOutputProcessorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveAutomationOutputProcessorsResponse, error)

	UnarchiveAutomationOutputProcessorsWithResponse(ctx context.Context, body UnarchiveAutomationOutputProcessorsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveAutomationOutputProcessorsResponse, error)

	// ListBatchSchemasWithResponse request
	ListBatchSchemasWithResponse(ctx context.Context, params *ListBatchSchemasParams, reqEditors ...RequestEditorFn) (*ListBatchSchemasResponse, error)

	// GetBatchSchemaWithResponse request
	GetBatchSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetBatchSchemaResponse, error)

	// ListBatchesWithResponse request
	ListBatchesWithResponse(ctx context.Context, params *ListBatchesParams, reqEditors ...RequestEditorFn) (*ListBatchesResponse, error)

	// CreateBatchWithBodyWithResponse request with any body
	CreateBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBatchResponse, error)

	CreateBatchWithResponse(ctx context.Context, body CreateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBatchResponse, error)

	// GetBatchWithResponse request
	GetBatchWithResponse(ctx context.Context, batchId string, reqEditors ...RequestEditorFn) (*GetBatchResponse, error)

	// UpdateBatchWithBodyWithResponse request with any body
	UpdateBatchWithBodyWithResponse(ctx context.Context, batchId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBatchResponse, error)

	UpdateBatchWithResponse(ctx context.Context, batchId string, body UpdateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBatchResponse, error)

	// ArchiveBatchesWithBodyWithResponse request with any body
	ArchiveBatchesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveBatchesResponse, error)

	ArchiveBatchesWithResponse(ctx context.Context, body ArchiveBatchesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveBatchesResponse, error)

	// BulkGetBatchesWithResponse request
	BulkGetBatchesWithResponse(ctx context.Context, params *BulkGetBatchesParams, reqEditors ...RequestEditorFn) (*BulkGetBatchesResponse, error)

	// UnarchiveBatchesWithBodyWithResponse request with any body
	UnarchiveBatchesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveBatchesResponse, error)

	UnarchiveBatchesWithResponse(ctx context.Context, body UnarchiveBatchesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveBatchesResponse, error)

	// CreateBlobWithBodyWithResponse request with any body
	CreateBlobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBlobResponse, error)

	CreateBlobWithResponse(ctx context.Context, body CreateBlobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBlobResponse, error)

	// GetBlobWithResponse request
	GetBlobWithResponse(ctx context.Context, blobId string, params *GetBlobParams, reqEditors ...RequestEditorFn) (*GetBlobResponse, error)

	// GetBlobFileWithResponse request
	GetBlobFileWithResponse(ctx context.Context, blobId string, reqEditors ...RequestEditorFn) (*GetBlobFileResponse, error)

	// GetBlobUrlWithResponse request
	GetBlobUrlWithResponse(ctx context.Context, blobId string, reqEditors ...RequestEditorFn) (*GetBlobUrlResponse, error)

	// CreateBlobPartWithBodyWithResponse request with any body
	CreateBlobPartWithBodyWithResponse(ctx context.Context, blobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBlobPartResponse, error)

	CreateBlobPartWithResponse(ctx context.Context, blobId string, body CreateBlobPartJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBlobPartResponse, error)

	// AbortMultipartBlobWithResponse request
	AbortMultipartBlobWithResponse(ctx context.Context, blobId string, reqEditors ...RequestEditorFn) (*AbortMultipartBlobResponse, error)

	// CompleteMultipartBlobWithBodyWithResponse request with any body
	CompleteMultipartBlobWithBodyWithResponse(ctx context.Context, blobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteMultipartBlobResponse, error)

	CompleteMultipartBlobWithResponse(ctx context.Context, blobId string, body CompleteMultipartBlobJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteMultipartBlobResponse, error)

	// BulkGetBlobsWithResponse request
	BulkGetBlobsWithResponse(ctx context.Context, params *BulkGetBlobsParams, reqEditors ...RequestEditorFn) (*BulkGetBlobsResponse, error)

	// CreateMultipartBlobWithBodyWithResponse request with any body
	CreateMultipartBlobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMultipartBlobResponse, error)

	CreateMultipartBlobWithResponse(ctx context.Context, body CreateMultipartBlobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMultipartBlobResponse, error)

	// ListBoxSchemasWithResponse request
	ListBoxSchemasWithResponse(ctx context.Context, params *ListBoxSchemasParams, reqEditors ...RequestEditorFn) (*ListBoxSchemasResponse, error)

	// GetBoxSchemaWithResponse request
	GetBoxSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetBoxSchemaResponse, error)

	// ListBoxesWithResponse request
	ListBoxesWithResponse(ctx context.Context, params *ListBoxesParams, reqEditors ...RequestEditorFn) (*ListBoxesResponse, error)

	// CreateBoxWithBodyWithResponse request with any body
	CreateBoxWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBoxResponse, error)

	CreateBoxWithResponse(ctx context.Context, body CreateBoxJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBoxResponse, error)

	// GetBoxWithResponse request
	GetBoxWithResponse(ctx context.Context, boxId string, reqEditors ...RequestEditorFn) (*GetBoxResponse, error)

	// UpdateBoxWithBodyWithResponse request with any body
	UpdateBoxWithBodyWithResponse(ctx context.Context, boxId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBoxResponse, error)

	UpdateBoxWithResponse(ctx context.Context, boxId string, body UpdateBoxJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBoxResponse, error)

	// ListBoxContentsWithResponse request
	ListBoxContentsWithResponse(ctx context.Context, boxId string, params *ListBoxContentsParams, reqEditors ...RequestEditorFn) (*ListBoxContentsResponse, error)

	// ArchiveBoxesWithBodyWithResponse request with any body
	ArchiveBoxesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveBoxesResponse, error)

	ArchiveBoxesWithResponse(ctx context.Context, body ArchiveBoxesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveBoxesResponse, error)

	// BulkGetBoxesWithResponse request
	BulkGetBoxesWithResponse(ctx context.Context, params *BulkGetBoxesParams, reqEditors ...RequestEditorFn) (*BulkGetBoxesResponse, error)

	// UnarchiveBoxesWithBodyWithResponse request with any body
	UnarchiveBoxesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveBoxesResponse, error)

	UnarchiveBoxesWithResponse(ctx context.Context, body UnarchiveBoxesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveBoxesResponse, error)

	// ListContainerSchemasWithResponse request
	ListContainerSchemasWithResponse(ctx context.Context, params *ListContainerSchemasParams, reqEditors ...RequestEditorFn) (*ListContainerSchemasResponse, error)

	// GetContainerSchemaWithResponse request
	GetContainerSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetContainerSchemaResponse, error)

	// ListContainersWithResponse request
	ListContainersWithResponse(ctx context.Context, params *ListContainersParams, reqEditors ...RequestEditorFn) (*ListContainersResponse, error)

	// CreateContainerWithBodyWithResponse request with any body
	CreateContainerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateContainerResponse, error)

	CreateContainerWithResponse(ctx context.Context, body CreateContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateContainerResponse, error)

	// GetContainerWithResponse request
	GetContainerWithResponse(ctx context.Context, containerId string, params *GetContainerParams, reqEditors ...RequestEditorFn) (*GetContainerResponse, error)

	// UpdateContainerWithBodyWithResponse request with any body
	UpdateContainerWithBodyWithResponse(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateContainerResponse, error)

	UpdateContainerWithResponse(ctx context.Context, containerId string, body UpdateContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateContainerResponse, error)

	// ListContainerContentsWithResponse request
	ListContainerContentsWithResponse(ctx context.Context, containerId string, reqEditors ...RequestEditorFn) (*ListContainerContentsResponse, error)

	// DeleteContainerContentWithResponse request
	DeleteContainerContentWithResponse(ctx context.Context, containerId string, containableId string, reqEditors ...RequestEditorFn) (*DeleteContainerContentResponse, error)

	// GetContainerContentWithResponse request
	GetContainerContentWithResponse(ctx context.Context, containerId string, containableId string, reqEditors ...RequestEditorFn) (*GetContainerContentResponse, error)

	// UpdateContainerContentWithBodyWithResponse request with any body
	UpdateContainerContentWithBodyWithResponse(ctx context.Context, containerId string, containableId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateContainerContentResponse, error)

	UpdateContainerContentWithResponse(ctx context.Context, containerId string, containableId string, body UpdateContainerContentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateContainerContentResponse, error)

	// TransferIntoContainerWithBodyWithResponse request with any body
	TransferIntoContainerWithBodyWithResponse(ctx context.Context, destinationContainerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferIntoContainerResponse, error)

	TransferIntoContainerWithResponse(ctx context.Context, destinationContainerId string, body TransferIntoContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*TransferIntoContainerResponse, error)

	// ArchiveContainersWithBodyWithResponse request with any body
	ArchiveContainersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveContainersResponse, error)

	ArchiveContainersWithResponse(ctx context.Context, body ArchiveContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveContainersResponse, error)

	// BulkCreateContainersWithBodyWithResponse request with any body
	BulkCreateContainersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateContainersResponse, error)

	BulkCreateContainersWithResponse(ctx context.Context, body BulkCreateContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateContainersResponse, error)

	// BulkGetContainersWithResponse request
	BulkGetContainersWithResponse(ctx context.Context, params *BulkGetContainersParams, reqEditors ...RequestEditorFn) (*BulkGetContainersResponse, error)

	// BulkUpdateContainersWithBodyWithResponse request with any body
	BulkUpdateContainersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateContainersResponse, error)

	BulkUpdateContainersWithResponse(ctx context.Context, body BulkUpdateContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateContainersResponse, error)

	// CheckinContainersWithBodyWithResponse request with any body
	CheckinContainersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckinContainersResponse, error)

	CheckinContainersWithResponse(ctx context.Context, body CheckinContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckinContainersResponse, error)

	// CheckoutContainersWithBodyWithResponse request with any body
	CheckoutContainersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckoutContainersResponse, error)

	CheckoutContainersWithResponse(ctx context.Context, body CheckoutContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckoutContainersResponse, error)

	// PrintLabelsWithBodyWithResponse request with any body
	PrintLabelsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrintLabelsResponse, error)

	PrintLabelsWithResponse(ctx context.Context, body PrintLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*PrintLabelsResponse, error)

	// ReserveContainersWithBodyWithResponse request with any body
	ReserveContainersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReserveContainersResponse, error)

	ReserveContainersWithResponse(ctx context.Context, body ReserveContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*ReserveContainersResponse, error)

	// UnarchiveContainersWithBodyWithResponse request with any body
	UnarchiveContainersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveContainersResponse, error)

	UnarchiveContainersWithResponse(ctx context.Context, body UnarchiveContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveContainersResponse, error)

	// ListCustomEntitiesWithResponse request
	ListCustomEntitiesWithResponse(ctx context.Context, params *ListCustomEntitiesParams, reqEditors ...RequestEditorFn) (*ListCustomEntitiesResponse, error)

	// CreateCustomEntityWithBodyWithResponse request with any body
	CreateCustomEntityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomEntityResponse, error)

	CreateCustomEntityWithResponse(ctx context.Context, body CreateCustomEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomEntityResponse, error)

	// GetCustomEntityWithResponse request
	GetCustomEntityWithResponse(ctx context.Context, customEntityId string, params *GetCustomEntityParams, reqEditors ...RequestEditorFn) (*GetCustomEntityResponse, error)

	// UpdateCustomEntityWithBodyWithResponse request with any body
	UpdateCustomEntityWithBodyWithResponse(ctx context.Context, customEntityId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomEntityResponse, error)

	UpdateCustomEntityWithResponse(ctx context.Context, customEntityId string, body UpdateCustomEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomEntityResponse, error)

	// ArchiveCustomEntitiesWithBodyWithResponse request with any body
	ArchiveCustomEntitiesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveCustomEntitiesResponse, error)

	ArchiveCustomEntitiesWithResponse(ctx context.Context, body ArchiveCustomEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveCustomEntitiesResponse, error)

	// BulkCreateCustomEntitiesWithBodyWithResponse request with any body
	BulkCreateCustomEntitiesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateCustomEntitiesResponse, error)

	BulkCreateCustomEntitiesWithResponse(ctx context.Context, body BulkCreateCustomEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateCustomEntitiesResponse, error)

	// BulkGetCustomEntitiesWithResponse request
	BulkGetCustomEntitiesWithResponse(ctx context.Context, params *BulkGetCustomEntitiesParams, reqEditors ...RequestEditorFn) (*BulkGetCustomEntitiesResponse, error)

	// BulkUpdateCustomEntitiesWithBodyWithResponse request with any body
	BulkUpdateCustomEntitiesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateCustomEntitiesResponse, error)

	BulkUpdateCustomEntitiesWithResponse(ctx context.Context, body BulkUpdateCustomEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateCustomEntitiesResponse, error)

	// UnarchiveCustomEntitiesWithBodyWithResponse request with any body
	UnarchiveCustomEntitiesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveCustomEntitiesResponse, error)

	UnarchiveCustomEntitiesWithResponse(ctx context.Context, body UnarchiveCustomEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveCustomEntitiesResponse, error)

	// ListCustomNotationsWithResponse request
	ListCustomNotationsWithResponse(ctx context.Context, params *ListCustomNotationsParams, reqEditors ...RequestEditorFn) (*ListCustomNotationsResponse, error)

	// ListDNAAlignmentsWithResponse request
	ListDNAAlignmentsWithResponse(ctx context.Context, params *ListDNAAlignmentsParams, reqEditors ...RequestEditorFn) (*ListDNAAlignmentsResponse, error)

	// DeleteDNAAlignmentWithResponse request
	DeleteDNAAlignmentWithResponse(ctx context.Context, dnaAlignmentId string, reqEditors ...RequestEditorFn) (*DeleteDNAAlignmentResponse, error)

	// GetDNAAlignmentWithResponse request
	GetDNAAlignmentWithResponse(ctx context.Context, dnaAlignmentId string, reqEditors ...RequestEditorFn) (*GetDNAAlignmentResponse, error)

	// CreateDnaConsensusAlignmentWithBodyWithResponse request with any body
	CreateDnaConsensusAlignmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDnaConsensusAlignmentResponse, error)

	CreateDnaConsensusAlignmentWithResponse(ctx context.Context, body CreateDnaConsensusAlignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDnaConsensusAlignmentResponse, error)

	// CreateDnaTemplateAlignmentWithBodyWithResponse request with any body
	CreateDnaTemplateAlignmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDnaTemplateAlignmentResponse, error)

	CreateDnaTemplateAlignmentWithResponse(ctx context.Context, body CreateDnaTemplateAlignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDnaTemplateAlignmentResponse, error)

	// ListDNAOligosWithResponse request
	ListDNAOligosWithResponse(ctx context.Context, params *ListDNAOligosParams, reqEditors ...RequestEditorFn) (*ListDNAOligosResponse, error)

	// CreateDNAOligoWithBodyWithResponse request with any body
	CreateDNAOligoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDNAOligoResponse, error)

	CreateDNAOligoWithResponse(ctx context.Context, body CreateDNAOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDNAOligoResponse, error)

	// GetDNAOligoWithResponse request
	GetDNAOligoWithResponse(ctx context.Context, oligoId string, params *GetDNAOligoParams, reqEditors ...RequestEditorFn) (*GetDNAOligoResponse, error)

	// UpdateDNAOligoWithBodyWithResponse request with any body
	UpdateDNAOligoWithBodyWithResponse(ctx context.Context, oligoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDNAOligoResponse, error)

	UpdateDNAOligoWithResponse(ctx context.Context, oligoId string, body UpdateDNAOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDNAOligoResponse, error)

	// ArchiveDNAOligosWithBodyWithResponse request with any body
	ArchiveDNAOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveDNAOligosResponse, error)

	ArchiveDNAOligosWithResponse(ctx context.Context, body ArchiveDNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveDNAOligosResponse, error)

	// BulkCreateDNAOligosWithBodyWithResponse request with any body
	BulkCreateDNAOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateDNAOligosResponse, error)

	BulkCreateDNAOligosWithResponse(ctx context.Context, body BulkCreateDNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateDNAOligosResponse, error)

	// BulkUpdateDNAOligosWithBodyWithResponse request with any body
	BulkUpdateDNAOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateDNAOligosResponse, error)

	BulkUpdateDNAOligosWithResponse(ctx context.Context, body BulkUpdateDNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateDNAOligosResponse, error)

	// UnarchiveDNAOligosWithBodyWithResponse request with any body
	UnarchiveDNAOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveDNAOligosResponse, error)

	UnarchiveDNAOligosWithResponse(ctx context.Context, body UnarchiveDNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveDNAOligosResponse, error)

	// ListDNASequencesWithResponse request
	ListDNASequencesWithResponse(ctx context.Context, params *ListDNASequencesParams, reqEditors ...RequestEditorFn) (*ListDNASequencesResponse, error)

	// CreateDNASequenceWithBodyWithResponse request with any body
	CreateDNASequenceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDNASequenceResponse, error)

	CreateDNASequenceWithResponse(ctx context.Context, body CreateDNASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDNASequenceResponse, error)

	// GetDNASequenceWithResponse request
	GetDNASequenceWithResponse(ctx context.Context, dnaSequenceId string, params *GetDNASequenceParams, reqEditors ...RequestEditorFn) (*GetDNASequenceResponse, error)

	// UpdateDNASequenceWithBodyWithResponse request with any body
	UpdateDNASequenceWithBodyWithResponse(ctx context.Context, dnaSequenceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDNASequenceResponse, error)

	UpdateDNASequenceWithResponse(ctx context.Context, dnaSequenceId string, body UpdateDNASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDNASequenceResponse, error)

	// ArchiveDNASequencesWithBodyWithResponse request with any body
	ArchiveDNASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveDNASequencesResponse, error)

	ArchiveDNASequencesWithResponse(ctx context.Context, body ArchiveDNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveDNASequencesResponse, error)

	// AutoAnnotateDnaSequencesWithBodyWithResponse request with any body
	AutoAnnotateDnaSequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AutoAnnotateDnaSequencesResponse, error)

	AutoAnnotateDnaSequencesWithResponse(ctx context.Context, body AutoAnnotateDnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*AutoAnnotateDnaSequencesResponse, error)

	// AutofillDNASequencePartsWithBodyWithResponse request with any body
	AutofillDNASequencePartsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AutofillDNASequencePartsResponse, error)

	AutofillDNASequencePartsWithResponse(ctx context.Context, body AutofillDNASequencePartsJSONRequestBody, reqEditors ...RequestEditorFn) (*AutofillDNASequencePartsResponse, error)

	// AutofillDNASequenceTranslationsWithBodyWithResponse request with any body
	AutofillDNASequenceTranslationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AutofillDNASequenceTranslationsResponse, error)

	AutofillDNASequenceTranslationsWithResponse(ctx context.Context, body AutofillDNASequenceTranslationsJSONRequestBody, reqEditors ...RequestEditorFn) (*AutofillDNASequenceTranslationsResponse, error)

	// BulkCreateDNASequencesWithBodyWithResponse request with any body
	BulkCreateDNASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateDNASequencesResponse, error)

	BulkCreateDNASequencesWithResponse(ctx context.Context, body BulkCreateDNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateDNASequencesResponse, error)

	// BulkGetDNASequencesWithResponse request
	BulkGetDNASequencesWithResponse(ctx context.Context, params *BulkGetDNASequencesParams, reqEditors ...RequestEditorFn) (*BulkGetDNASequencesResponse, error)

	// BulkUpdateDNASequencesWithBodyWithResponse request with any body
	BulkUpdateDNASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateDNASequencesResponse, error)

	BulkUpdateDNASequencesWithResponse(ctx context.Context, body BulkUpdateDNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateDNASequencesResponse, error)

	// MatchBasesDnaSequencesWithBodyWithResponse request with any body
	MatchBasesDnaSequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MatchBasesDnaSequencesResponse, error)

	MatchBasesDnaSequencesWithResponse(ctx context.Context, body MatchBasesDnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*MatchBasesDnaSequencesResponse, error)

	// SearchDnaSequencesWithBodyWithResponse request with any body
	SearchDnaSequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDnaSequencesResponse, error)

	SearchDnaSequencesWithResponse(ctx context.Context, body SearchDnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDnaSequencesResponse, error)

	// UnarchiveDNASequencesWithBodyWithResponse request with any body
	UnarchiveDNASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveDNASequencesResponse, error)

	UnarchiveDNASequencesWithResponse(ctx context.Context, body UnarchiveDNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveDNASequencesResponse, error)

	// ListDropdownsWithResponse request
	ListDropdownsWithResponse(ctx context.Context, params *ListDropdownsParams, reqEditors ...RequestEditorFn) (*ListDropdownsResponse, error)

	// CreateDropdownWithBodyWithResponse request with any body
	CreateDropdownWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDropdownResponse, error)

	CreateDropdownWithResponse(ctx context.Context, body CreateDropdownJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDropdownResponse, error)

	// GetDropdownWithResponse request
	GetDropdownWithResponse(ctx context.Context, dropdownId string, reqEditors ...RequestEditorFn) (*GetDropdownResponse, error)

	// UpdateDropdownWithBodyWithResponse request with any body
	UpdateDropdownWithBodyWithResponse(ctx context.Context, dropdownId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDropdownResponse, error)

	UpdateDropdownWithResponse(ctx context.Context, dropdownId string, body UpdateDropdownJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDropdownResponse, error)

	// ArchiveDropdownOptionsWithBodyWithResponse request with any body
	ArchiveDropdownOptionsWithBodyWithResponse(ctx context.Context, dropdownId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveDropdownOptionsResponse, error)

	ArchiveDropdownOptionsWithResponse(ctx context.Context, dropdownId string, body ArchiveDropdownOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveDropdownOptionsResponse, error)

	// UnarchiveDropdownOptionsWithBodyWithResponse request with any body
	UnarchiveDropdownOptionsWithBodyWithResponse(ctx context.Context, dropdownId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveDropdownOptionsResponse, error)

	UnarchiveDropdownOptionsWithResponse(ctx context.Context, dropdownId string, body UnarchiveDropdownOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveDropdownOptionsResponse, error)

	// GetEnitityBatchesWithResponse request
	GetEnitityBatchesWithResponse(ctx context.Context, entityId string, reqEditors ...RequestEditorFn) (*GetEnitityBatchesResponse, error)

	// ListEntitySchemasWithResponse request
	ListEntitySchemasWithResponse(ctx context.Context, params *ListEntitySchemasParams, reqEditors ...RequestEditorFn) (*ListEntitySchemasResponse, error)

	// GetEntitySchemaWithResponse request
	GetEntitySchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetEntitySchemaResponse, error)

	// ListEntriesWithResponse request
	ListEntriesWithResponse(ctx context.Context, params *ListEntriesParams, reqEditors ...RequestEditorFn) (*ListEntriesResponse, error)

	// CreateEntryWithBodyWithResponse request with any body
	CreateEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEntryResponse, error)

	CreateEntryWithResponse(ctx context.Context, body CreateEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEntryResponse, error)

	// GetEntryWithResponse request
	GetEntryWithResponse(ctx context.Context, entryId string, params *GetEntryParams, reqEditors ...RequestEditorFn) (*GetEntryResponse, error)

	// UpdateEntryWithBodyWithResponse request with any body
	UpdateEntryWithBodyWithResponse(ctx context.Context, entryId string, params *UpdateEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEntryResponse, error)

	UpdateEntryWithResponse(ctx context.Context, entryId string, params *UpdateEntryParams, body UpdateEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEntryResponse, error)

	// GetExternalFileMetadataWithResponse request
	GetExternalFileMetadataWithResponse(ctx context.Context, entryId string, externalFileId string, reqEditors ...RequestEditorFn) (*GetExternalFileMetadataResponse, error)

	// ArchiveEntriesWithBodyWithResponse request with any body
	ArchiveEntriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveEntriesResponse, error)

	ArchiveEntriesWithResponse(ctx context.Context, body ArchiveEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveEntriesResponse, error)

	// BulkGetEntriesWithResponse request
	BulkGetEntriesWithResponse(ctx context.Context, params *BulkGetEntriesParams, reqEditors ...RequestEditorFn) (*BulkGetEntriesResponse, error)

	// UnarchiveEntriesWithBodyWithResponse request with any body
	UnarchiveEntriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveEntriesResponse, error)

	UnarchiveEntriesWithResponse(ctx context.Context, body UnarchiveEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveEntriesResponse, error)

	// ListEntrySchemasWithResponse request
	ListEntrySchemasWithResponse(ctx context.Context, params *ListEntrySchemasParams, reqEditors ...RequestEditorFn) (*ListEntrySchemasResponse, error)

	// GetEntrySchemaWithResponse request
	GetEntrySchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetEntrySchemaResponse, error)

	// ListEntryTemplatesWithResponse request
	ListEntryTemplatesWithResponse(ctx context.Context, params *ListEntryTemplatesParams, reqEditors ...RequestEditorFn) (*ListEntryTemplatesResponse, error)

	// GetEntryTemplateWithResponse request
	GetEntryTemplateWithResponse(ctx context.Context, entryTemplateId string, params *GetEntryTemplateParams, reqEditors ...RequestEditorFn) (*GetEntryTemplateResponse, error)

	// ListEventsWithResponse request
	ListEventsWithResponse(ctx context.Context, params *ListEventsParams, reqEditors ...RequestEditorFn) (*ListEventsResponse, error)

	// ExportItemWithBodyWithResponse request with any body
	ExportItemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportItemResponse, error)

	ExportItemWithResponse(ctx context.Context, body ExportItemJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportItemResponse, error)

	// ListFeatureLibrariesWithResponse request
	ListFeatureLibrariesWithResponse(ctx context.Context, params *ListFeatureLibrariesParams, reqEditors ...RequestEditorFn) (*ListFeatureLibrariesResponse, error)

	// CreateFeatureLibraryWithBodyWithResponse request with any body
	CreateFeatureLibraryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFeatureLibraryResponse, error)

	CreateFeatureLibraryWithResponse(ctx context.Context, body CreateFeatureLibraryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFeatureLibraryResponse, error)

	// GetFeatureLibraryWithResponse request
	GetFeatureLibraryWithResponse(ctx context.Context, featureLibraryId string, params *GetFeatureLibraryParams, reqEditors ...RequestEditorFn) (*GetFeatureLibraryResponse, error)

	// UpdateFeatureLibraryWithBodyWithResponse request with any body
	UpdateFeatureLibraryWithBodyWithResponse(ctx context.Context, featureLibraryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFeatureLibraryResponse, error)

	UpdateFeatureLibraryWithResponse(ctx context.Context, featureLibraryId string, body UpdateFeatureLibraryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFeatureLibraryResponse, error)

	// ListFeaturesWithResponse request
	ListFeaturesWithResponse(ctx context.Context, params *ListFeaturesParams, reqEditors ...RequestEditorFn) (*ListFeaturesResponse, error)

	// CreateFeatureWithBodyWithResponse request with any body
	CreateFeatureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFeatureResponse, error)

	CreateFeatureWithResponse(ctx context.Context, body CreateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFeatureResponse, error)

	// GetFeatureWithResponse request
	GetFeatureWithResponse(ctx context.Context, featureId string, params *GetFeatureParams, reqEditors ...RequestEditorFn) (*GetFeatureResponse, error)

	// UpdateFeatureWithBodyWithResponse request with any body
	UpdateFeatureWithBodyWithResponse(ctx context.Context, featureId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFeatureResponse, error)

	UpdateFeatureWithResponse(ctx context.Context, featureId string, body UpdateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFeatureResponse, error)

	// BulkCreateFeaturesWithBodyWithResponse request with any body
	BulkCreateFeaturesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateFeaturesResponse, error)

	BulkCreateFeaturesWithResponse(ctx context.Context, body BulkCreateFeaturesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateFeaturesResponse, error)

	// ListFoldersWithResponse request
	ListFoldersWithResponse(ctx context.Context, params *ListFoldersParams, reqEditors ...RequestEditorFn) (*ListFoldersResponse, error)

	// CreateFolderWithBodyWithResponse request with any body
	CreateFolderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error)

	CreateFolderWithResponse(ctx context.Context, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error)

	// GetFolderWithResponse request
	GetFolderWithResponse(ctx context.Context, folderId string, reqEditors ...RequestEditorFn) (*GetFolderResponse, error)

	// ArchiveFoldersWithBodyWithResponse request with any body
	ArchiveFoldersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveFoldersResponse, error)

	ArchiveFoldersWithResponse(ctx context.Context, body ArchiveFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveFoldersResponse, error)

	// UnarchiveFoldersWithBodyWithResponse request with any body
	UnarchiveFoldersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveFoldersResponse, error)

	UnarchiveFoldersWithResponse(ctx context.Context, body UnarchiveFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveFoldersResponse, error)

	// ListLegacyWorkflowStageRunInputSamplesWithResponse request
	ListLegacyWorkflowStageRunInputSamplesWithResponse(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*ListLegacyWorkflowStageRunInputSamplesResponse, error)

	// ListLegacyWorkflowStageRunOutputSamplesWithResponse request
	ListLegacyWorkflowStageRunOutputSamplesWithResponse(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*ListLegacyWorkflowStageRunOutputSamplesResponse, error)

	// ListLegacyWorkflowStageRunRegisteredSamplesWithResponse request
	ListLegacyWorkflowStageRunRegisteredSamplesWithResponse(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*ListLegacyWorkflowStageRunRegisteredSamplesResponse, error)

	// ListLegacyWorkflowStageRunsWithResponse request
	ListLegacyWorkflowStageRunsWithResponse(ctx context.Context, stageId string, reqEditors ...RequestEditorFn) (*ListLegacyWorkflowStageRunsResponse, error)

	// ListLegacyWorkflowsWithResponse request
	ListLegacyWorkflowsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLegacyWorkflowsResponse, error)

	// UpdateLegacyWorkflowMetadataWithBodyWithResponse request with any body
	UpdateLegacyWorkflowMetadataWithBodyWithResponse(ctx context.Context, legacyWorkflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLegacyWorkflowMetadataResponse, error)

	UpdateLegacyWorkflowMetadataWithResponse(ctx context.Context, legacyWorkflowId string, body UpdateLegacyWorkflowMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLegacyWorkflowMetadataResponse, error)

	// ListLegacyWorkflowStagesWithResponse request
	ListLegacyWorkflowStagesWithResponse(ctx context.Context, legacyWorkflowId string, reqEditors ...RequestEditorFn) (*ListLegacyWorkflowStagesResponse, error)

	// ListLocationSchemasWithResponse request
	ListLocationSchemasWithResponse(ctx context.Context, params *ListLocationSchemasParams, reqEditors ...RequestEditorFn) (*ListLocationSchemasResponse, error)

	// GetLocationSchemaWithResponse request
	GetLocationSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetLocationSchemaResponse, error)

	// ListLocationsWithResponse request
	ListLocationsWithResponse(ctx context.Context, params *ListLocationsParams, reqEditors ...RequestEditorFn) (*ListLocationsResponse, error)

	// CreateLocationWithBodyWithResponse request with any body
	CreateLocationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLocationResponse, error)

	CreateLocationWithResponse(ctx context.Context, body CreateLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLocationResponse, error)

	// GetLocationWithResponse request
	GetLocationWithResponse(ctx context.Context, locationId string, reqEditors ...RequestEditorFn) (*GetLocationResponse, error)

	// UpdateLocationWithBodyWithResponse request with any body
	UpdateLocationWithBodyWithResponse(ctx context.Context, locationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLocationResponse, error)

	UpdateLocationWithResponse(ctx context.Context, locationId string, body UpdateLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLocationResponse, error)

	// ArchiveLocationsWithBodyWithResponse request with any body
	ArchiveLocationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveLocationsResponse, error)

	ArchiveLocationsWithResponse(ctx context.Context, body ArchiveLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveLocationsResponse, error)

	// BulkGetLocationsWithResponse request
	BulkGetLocationsWithResponse(ctx context.Context, params *BulkGetLocationsParams, reqEditors ...RequestEditorFn) (*BulkGetLocationsResponse, error)

	// UnarchiveLocationsWithBodyWithResponse request with any body
	UnarchiveLocationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveLocationsResponse, error)

	UnarchiveLocationsWithResponse(ctx context.Context, body UnarchiveLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveLocationsResponse, error)

	// ListMixturesWithResponse request
	ListMixturesWithResponse(ctx context.Context, params *ListMixturesParams, reqEditors ...RequestEditorFn) (*ListMixturesResponse, error)

	// CreateMixtureWithBodyWithResponse request with any body
	CreateMixtureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMixtureResponse, error)

	CreateMixtureWithResponse(ctx context.Context, body CreateMixtureJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMixtureResponse, error)

	// GetMixtureWithResponse request
	GetMixtureWithResponse(ctx context.Context, mixtureId string, reqEditors ...RequestEditorFn) (*GetMixtureResponse, error)

	// UpdateMixtureWithBodyWithResponse request with any body
	UpdateMixtureWithBodyWithResponse(ctx context.Context, mixtureId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMixtureResponse, error)

	UpdateMixtureWithResponse(ctx context.Context, mixtureId string, body UpdateMixtureJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMixtureResponse, error)

	// ArchiveMixturesWithBodyWithResponse request with any body
	ArchiveMixturesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveMixturesResponse, error)

	ArchiveMixturesWithResponse(ctx context.Context, body ArchiveMixturesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveMixturesResponse, error)

	// BulkCreateMixturesWithBodyWithResponse request with any body
	BulkCreateMixturesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateMixturesResponse, error)

	BulkCreateMixturesWithResponse(ctx context.Context, body BulkCreateMixturesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateMixturesResponse, error)

	// BulkUpdateMixturesWithBodyWithResponse request with any body
	BulkUpdateMixturesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateMixturesResponse, error)

	BulkUpdateMixturesWithResponse(ctx context.Context, body BulkUpdateMixturesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateMixturesResponse, error)

	// UnarchiveMixturesWithBodyWithResponse request with any body
	UnarchiveMixturesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveMixturesResponse, error)

	UnarchiveMixturesWithResponse(ctx context.Context, body UnarchiveMixturesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveMixturesResponse, error)

	// ListMoleculesWithResponse request
	ListMoleculesWithResponse(ctx context.Context, params *ListMoleculesParams, reqEditors ...RequestEditorFn) (*ListMoleculesResponse, error)

	// CreateMoleculeWithBodyWithResponse request with any body
	CreateMoleculeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMoleculeResponse, error)

	CreateMoleculeWithResponse(ctx context.Context, body CreateMoleculeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMoleculeResponse, error)

	// GetMoleculeWithResponse request
	GetMoleculeWithResponse(ctx context.Context, moleculeId string, reqEditors ...RequestEditorFn) (*GetMoleculeResponse, error)

	// UpdateMoleculeWithBodyWithResponse request with any body
	UpdateMoleculeWithBodyWithResponse(ctx context.Context, moleculeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMoleculeResponse, error)

	UpdateMoleculeWithResponse(ctx context.Context, moleculeId string, body UpdateMoleculeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMoleculeResponse, error)

	// ArchiveMoleculesWithBodyWithResponse request with any body
	ArchiveMoleculesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveMoleculesResponse, error)

	ArchiveMoleculesWithResponse(ctx context.Context, body ArchiveMoleculesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveMoleculesResponse, error)

	// BulkCreateMoleculesWithBodyWithResponse request with any body
	BulkCreateMoleculesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateMoleculesResponse, error)

	BulkCreateMoleculesWithResponse(ctx context.Context, body BulkCreateMoleculesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateMoleculesResponse, error)

	// BulkUpdateMoleculesWithBodyWithResponse request with any body
	BulkUpdateMoleculesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateMoleculesResponse, error)

	BulkUpdateMoleculesWithResponse(ctx context.Context, body BulkUpdateMoleculesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateMoleculesResponse, error)

	// UnarchiveMoleculesWithBodyWithResponse request with any body
	UnarchiveMoleculesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveMoleculesResponse, error)

	UnarchiveMoleculesWithResponse(ctx context.Context, body UnarchiveMoleculesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveMoleculesResponse, error)

	// ListMonomersWithResponse request
	ListMonomersWithResponse(ctx context.Context, params *ListMonomersParams, reqEditors ...RequestEditorFn) (*ListMonomersResponse, error)

	// CreateMonomerWithBodyWithResponse request with any body
	CreateMonomerWithBodyWithResponse(ctx context.Context, params *CreateMonomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMonomerResponse, error)

	CreateMonomerWithResponse(ctx context.Context, params *CreateMonomerParams, body CreateMonomerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMonomerResponse, error)

	// UpdateMonomerWithBodyWithResponse request with any body
	UpdateMonomerWithBodyWithResponse(ctx context.Context, monomerId string, params *UpdateMonomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMonomerResponse, error)

	UpdateMonomerWithResponse(ctx context.Context, monomerId string, params *UpdateMonomerParams, body UpdateMonomerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMonomerResponse, error)

	// ArchiveMonomersWithBodyWithResponse request with any body
	ArchiveMonomersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveMonomersResponse, error)

	ArchiveMonomersWithResponse(ctx context.Context, body ArchiveMonomersJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveMonomersResponse, error)

	// UnarchiveMonomersWithBodyWithResponse request with any body
	UnarchiveMonomersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveMonomersResponse, error)

	UnarchiveMonomersWithResponse(ctx context.Context, body UnarchiveMonomersJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveMonomersResponse, error)

	// ListNucleotideAlignmentsWithResponse request
	ListNucleotideAlignmentsWithResponse(ctx context.Context, params *ListNucleotideAlignmentsParams, reqEditors ...RequestEditorFn) (*ListNucleotideAlignmentsResponse, error)

	// DeleteNucleotideAlignmentWithResponse request
	DeleteNucleotideAlignmentWithResponse(ctx context.Context, alignmentId string, reqEditors ...RequestEditorFn) (*DeleteNucleotideAlignmentResponse, error)

	// GetNucleotideAlignmentWithResponse request
	GetNucleotideAlignmentWithResponse(ctx context.Context, alignmentId string, reqEditors ...RequestEditorFn) (*GetNucleotideAlignmentResponse, error)

	// CreateConsensusNucleotideAlignmentWithBodyWithResponse request with any body
	CreateConsensusNucleotideAlignmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConsensusNucleotideAlignmentResponse, error)

	CreateConsensusNucleotideAlignmentWithResponse(ctx context.Context, body CreateConsensusNucleotideAlignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConsensusNucleotideAlignmentResponse, error)

	// CreateTemplateNucleotideAlignmentWithBodyWithResponse request with any body
	CreateTemplateNucleotideAlignmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTemplateNucleotideAlignmentResponse, error)

	CreateTemplateNucleotideAlignmentWithResponse(ctx context.Context, body CreateTemplateNucleotideAlignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTemplateNucleotideAlignmentResponse, error)

	// ListOligosWithResponse request
	ListOligosWithResponse(ctx context.Context, params *ListOligosParams, reqEditors ...RequestEditorFn) (*ListOligosResponse, error)

	// CreateOligoWithBodyWithResponse request with any body
	CreateOligoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOligoResponse, error)

	CreateOligoWithResponse(ctx context.Context, body CreateOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOligoResponse, error)

	// GetOligoWithResponse request
	GetOligoWithResponse(ctx context.Context, oligoId string, params *GetOligoParams, reqEditors ...RequestEditorFn) (*GetOligoResponse, error)

	// UpdateOligoWithBodyWithResponse request with any body
	UpdateOligoWithBodyWithResponse(ctx context.Context, oligoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOligoResponse, error)

	UpdateOligoWithResponse(ctx context.Context, oligoId string, body UpdateOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOligoResponse, error)

	// ArchiveOligosWithBodyWithResponse request with any body
	ArchiveOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveOligosResponse, error)

	ArchiveOligosWithResponse(ctx context.Context, body ArchiveOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveOligosResponse, error)

	// BulkCreateOligosWithBodyWithResponse request with any body
	BulkCreateOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateOligosResponse, error)

	BulkCreateOligosWithResponse(ctx context.Context, body BulkCreateOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateOligosResponse, error)

	// BulkGetOligosWithResponse request
	BulkGetOligosWithResponse(ctx context.Context, params *BulkGetOligosParams, reqEditors ...RequestEditorFn) (*BulkGetOligosResponse, error)

	// UnarchiveOligosWithBodyWithResponse request with any body
	UnarchiveOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveOligosResponse, error)

	UnarchiveOligosWithResponse(ctx context.Context, body UnarchiveOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveOligosResponse, error)

	// ListOrganizationsWithResponse request
	ListOrganizationsWithResponse(ctx context.Context, params *ListOrganizationsParams, reqEditors ...RequestEditorFn) (*ListOrganizationsResponse, error)

	// GetOrganizationWithResponse request
	GetOrganizationWithResponse(ctx context.Context, organizationId string, reqEditors ...RequestEditorFn) (*GetOrganizationResponse, error)

	// ListPlateSchemasWithResponse request
	ListPlateSchemasWithResponse(ctx context.Context, params *ListPlateSchemasParams, reqEditors ...RequestEditorFn) (*ListPlateSchemasResponse, error)

	// GetPlateSchemaWithResponse request
	GetPlateSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetPlateSchemaResponse, error)

	// ListPlatesWithResponse request
	ListPlatesWithResponse(ctx context.Context, params *ListPlatesParams, reqEditors ...RequestEditorFn) (*ListPlatesResponse, error)

	// CreatePlateWithBodyWithResponse request with any body
	CreatePlateWithBodyWithResponse(ctx context.Context, params *CreatePlateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlateResponse, error)

	CreatePlateWithResponse(ctx context.Context, params *CreatePlateParams, body CreatePlateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlateResponse, error)

	// GetPlateWithResponse request
	GetPlateWithResponse(ctx context.Context, plateId string, params *GetPlateParams, reqEditors ...RequestEditorFn) (*GetPlateResponse, error)

	// UpdatePlateWithBodyWithResponse request with any body
	UpdatePlateWithBodyWithResponse(ctx context.Context, plateId string, params *UpdatePlateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlateResponse, error)

	UpdatePlateWithResponse(ctx context.Context, plateId string, params *UpdatePlateParams, body UpdatePlateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlateResponse, error)

	// ArchivePlatesWithBodyWithResponse request with any body
	ArchivePlatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchivePlatesResponse, error)

	ArchivePlatesWithResponse(ctx context.Context, body ArchivePlatesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchivePlatesResponse, error)

	// BulkGetPlatesWithResponse request
	BulkGetPlatesWithResponse(ctx context.Context, params *BulkGetPlatesParams, reqEditors ...RequestEditorFn) (*BulkGetPlatesResponse, error)

	// UnarchivePlatesWithBodyWithResponse request with any body
	UnarchivePlatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchivePlatesResponse, error)

	UnarchivePlatesWithResponse(ctx context.Context, body UnarchivePlatesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchivePlatesResponse, error)

	// ListProjectsWithResponse request
	ListProjectsWithResponse(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error)

	// GetProjectWithResponse request
	GetProjectWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*GetProjectResponse, error)

	// ArchiveProjectsWithBodyWithResponse request with any body
	ArchiveProjectsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveProjectsResponse, error)

	ArchiveProjectsWithResponse(ctx context.Context, body ArchiveProjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveProjectsResponse, error)

	// UnarchiveProjectsWithBodyWithResponse request with any body
	UnarchiveProjectsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveProjectsResponse, error)

	UnarchiveProjectsWithResponse(ctx context.Context, body UnarchiveProjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveProjectsResponse, error)

	// ListRegistriesWithResponse request
	ListRegistriesWithResponse(ctx context.Context, params *ListRegistriesParams, reqEditors ...RequestEditorFn) (*ListRegistriesResponse, error)

	// GetRegistryWithResponse request
	GetRegistryWithResponse(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*GetRegistryResponse, error)

	// ListBatchSchemasByRegistryWithResponse request
	ListBatchSchemasByRegistryWithResponse(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*ListBatchSchemasByRegistryResponse, error)

	// ListBoxSchemasByRegistryWithResponse request
	ListBoxSchemasByRegistryWithResponse(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*ListBoxSchemasByRegistryResponse, error)

	// ListContainerSchemasByRegistryWithResponse request
	ListContainerSchemasByRegistryWithResponse(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*ListContainerSchemasByRegistryResponse, error)

	// ListDropdownsByRegistryWithResponse request
	ListDropdownsByRegistryWithResponse(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*ListDropdownsByRegistryResponse, error)

	// ListEntitySchemasByRegistryWithResponse request
	ListEntitySchemasByRegistryWithResponse(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*ListEntitySchemasByRegistryResponse, error)

	// ListPrintersWithResponse request
	ListPrintersWithResponse(ctx context.Context, registryId string, params *ListPrintersParams, reqEditors ...RequestEditorFn) (*ListPrintersResponse, error)

	// ListLabelTemplatesWithResponse request
	ListLabelTemplatesWithResponse(ctx context.Context, registryId string, params *ListLabelTemplatesParams, reqEditors ...RequestEditorFn) (*ListLabelTemplatesResponse, error)

	// ListLocationSchemasByRegistryWithResponse request
	ListLocationSchemasByRegistryWithResponse(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*ListLocationSchemasByRegistryResponse, error)

	// ListPlateSchemasByRegistryWithResponse request
	ListPlateSchemasByRegistryWithResponse(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*ListPlateSchemasByRegistryResponse, error)

	// BulkGetRegisteredEntitiesWithResponse request
	BulkGetRegisteredEntitiesWithResponse(ctx context.Context, registryId string, params *BulkGetRegisteredEntitiesParams, reqEditors ...RequestEditorFn) (*BulkGetRegisteredEntitiesResponse, error)

	// RegisterEntitiesWithBodyWithResponse request with any body
	RegisterEntitiesWithBodyWithResponse(ctx context.Context, registryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterEntitiesResponse, error)

	RegisterEntitiesWithResponse(ctx context.Context, registryId string, body RegisterEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterEntitiesResponse, error)

	// UnregisterEntitiesWithBodyWithResponse request with any body
	UnregisterEntitiesWithBodyWithResponse(ctx context.Context, registryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnregisterEntitiesResponse, error)

	UnregisterEntitiesWithResponse(ctx context.Context, registryId string, body UnregisterEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnregisterEntitiesResponse, error)

	// ValidateBarcodesWithBodyWithResponse request with any body
	ValidateBarcodesWithBodyWithResponse(ctx context.Context, registryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateBarcodesResponse, error)

	ValidateBarcodesWithResponse(ctx context.Context, registryId string, body ValidateBarcodesJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateBarcodesResponse, error)

	// ListRequestFulfillmentsWithResponse request
	ListRequestFulfillmentsWithResponse(ctx context.Context, params *ListRequestFulfillmentsParams, reqEditors ...RequestEditorFn) (*ListRequestFulfillmentsResponse, error)

	// GetRequestFulfillmentWithResponse request
	GetRequestFulfillmentWithResponse(ctx context.Context, requestFulfillmentId string, reqEditors ...RequestEditorFn) (*GetRequestFulfillmentResponse, error)

	// ListRequestSchemasWithResponse request
	ListRequestSchemasWithResponse(ctx context.Context, params *ListRequestSchemasParams, reqEditors ...RequestEditorFn) (*ListRequestSchemasResponse, error)

	// GetRequestSchemaWithResponse request
	GetRequestSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetRequestSchemaResponse, error)

	// ListRequestTaskSchemasWithResponse request
	ListRequestTaskSchemasWithResponse(ctx context.Context, params *ListRequestTaskSchemasParams, reqEditors ...RequestEditorFn) (*ListRequestTaskSchemasResponse, error)

	// GetRequestTaskSchemaWithResponse request
	GetRequestTaskSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetRequestTaskSchemaResponse, error)

	// ListRequestsWithResponse request
	ListRequestsWithResponse(ctx context.Context, params *ListRequestsParams, reqEditors ...RequestEditorFn) (*ListRequestsResponse, error)

	// CreateRequestWithBodyWithResponse request with any body
	CreateRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRequestResponse, error)

	CreateRequestWithResponse(ctx context.Context, body CreateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRequestResponse, error)

	// GetRequestWithResponse request
	GetRequestWithResponse(ctx context.Context, requestId string, params *GetRequestParams, reqEditors ...RequestEditorFn) (*GetRequestResponse, error)

	// PatchRequestWithBodyWithResponse request with any body
	PatchRequestWithBodyWithResponse(ctx context.Context, requestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchRequestResponse, error)

	PatchRequestWithResponse(ctx context.Context, requestId string, body PatchRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchRequestResponse, error)

	// GetRequestResponseWithResponse request
	GetRequestResponseWithResponse(ctx context.Context, requestId string, reqEditors ...RequestEditorFn) (*GetRequestResponseResponse, error)

	// BulkCreateRequestTasksWithBodyWithResponse request with any body
	BulkCreateRequestTasksWithBodyWithResponse(ctx context.Context, requestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateRequestTasksResponse, error)

	BulkCreateRequestTasksWithResponse(ctx context.Context, requestId string, body BulkCreateRequestTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateRequestTasksResponse, error)

	// BulkUpdateRequestTasksWithBodyWithResponse request with any body
	BulkUpdateRequestTasksWithBodyWithResponse(ctx context.Context, requestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateRequestTasksResponse, error)

	BulkUpdateRequestTasksWithResponse(ctx context.Context, requestId string, body BulkUpdateRequestTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateRequestTasksResponse, error)

	// ExecuteRequestsSampleGroupsWithBodyWithResponse request with any body
	ExecuteRequestsSampleGroupsWithBodyWithResponse(ctx context.Context, requestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteRequestsSampleGroupsResponse, error)

	ExecuteRequestsSampleGroupsWithResponse(ctx context.Context, requestId string, body ExecuteRequestsSampleGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteRequestsSampleGroupsResponse, error)

	// BulkGetRequestsWithResponse request
	BulkGetRequestsWithResponse(ctx context.Context, params *BulkGetRequestsParams, reqEditors ...RequestEditorFn) (*BulkGetRequestsResponse, error)

	// CreateAssayResultsTransactionWithResponse request
	CreateAssayResultsTransactionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateAssayResultsTransactionResponse, error)

	// CreateAssayResultsInTransactionWithBodyWithResponse request with any body
	CreateAssayResultsInTransactionWithBodyWithResponse(ctx context.Context, transactionId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAssayResultsInTransactionResponse, error)

	CreateAssayResultsInTransactionWithResponse(ctx context.Context, transactionId openapi_types.UUID, body CreateAssayResultsInTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAssayResultsInTransactionResponse, error)

	// AbortAssayResultsTransactionWithResponse request
	AbortAssayResultsTransactionWithResponse(ctx context.Context, transactionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*AbortAssayResultsTransactionResponse, error)

	// CommitAssayResultsTransactionWithResponse request
	CommitAssayResultsTransactionWithResponse(ctx context.Context, transactionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*CommitAssayResultsTransactionResponse, error)

	// ListRNAOligosWithResponse request
	ListRNAOligosWithResponse(ctx context.Context, params *ListRNAOligosParams, reqEditors ...RequestEditorFn) (*ListRNAOligosResponse, error)

	// CreateRNAOligoWithBodyWithResponse request with any body
	CreateRNAOligoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRNAOligoResponse, error)

	CreateRNAOligoWithResponse(ctx context.Context, body CreateRNAOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRNAOligoResponse, error)

	// GetRNAOligoWithResponse request
	GetRNAOligoWithResponse(ctx context.Context, oligoId string, params *GetRNAOligoParams, reqEditors ...RequestEditorFn) (*GetRNAOligoResponse, error)

	// UpdateRNAOligoWithBodyWithResponse request with any body
	UpdateRNAOligoWithBodyWithResponse(ctx context.Context, oligoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRNAOligoResponse, error)

	UpdateRNAOligoWithResponse(ctx context.Context, oligoId string, body UpdateRNAOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRNAOligoResponse, error)

	// ArchiveRNAOligosWithBodyWithResponse request with any body
	ArchiveRNAOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveRNAOligosResponse, error)

	ArchiveRNAOligosWithResponse(ctx context.Context, body ArchiveRNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveRNAOligosResponse, error)

	// BulkCreateRNAOligosWithBodyWithResponse request with any body
	BulkCreateRNAOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateRNAOligosResponse, error)

	BulkCreateRNAOligosWithResponse(ctx context.Context, body BulkCreateRNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateRNAOligosResponse, error)

	// BulkUpdateRNAOligosWithBodyWithResponse request with any body
	BulkUpdateRNAOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateRNAOligosResponse, error)

	BulkUpdateRNAOligosWithResponse(ctx context.Context, body BulkUpdateRNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateRNAOligosResponse, error)

	// UnarchiveRNAOligosWithBodyWithResponse request with any body
	UnarchiveRNAOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveRNAOligosResponse, error)

	UnarchiveRNAOligosWithResponse(ctx context.Context, body UnarchiveRNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveRNAOligosResponse, error)

	// ListRNASequencesWithResponse request
	ListRNASequencesWithResponse(ctx context.Context, params *ListRNASequencesParams, reqEditors ...RequestEditorFn) (*ListRNASequencesResponse, error)

	// CreateRNASequenceWithBodyWithResponse request with any body
	CreateRNASequenceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRNASequenceResponse, error)

	CreateRNASequenceWithResponse(ctx context.Context, body CreateRNASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRNASequenceResponse, error)

	// GetRNASequenceWithResponse request
	GetRNASequenceWithResponse(ctx context.Context, rnaSequenceId string, params *GetRNASequenceParams, reqEditors ...RequestEditorFn) (*GetRNASequenceResponse, error)

	// UpdateRNASequenceWithBodyWithResponse request with any body
	UpdateRNASequenceWithBodyWithResponse(ctx context.Context, rnaSequenceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRNASequenceResponse, error)

	UpdateRNASequenceWithResponse(ctx context.Context, rnaSequenceId string, body UpdateRNASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRNASequenceResponse, error)

	// ArchiveRNASequencesWithBodyWithResponse request with any body
	ArchiveRNASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveRNASequencesResponse, error)

	ArchiveRNASequencesWithResponse(ctx context.Context, body ArchiveRNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveRNASequencesResponse, error)

	// AutoAnnotateRnaSequencesWithBodyWithResponse request with any body
	AutoAnnotateRnaSequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AutoAnnotateRnaSequencesResponse, error)

	AutoAnnotateRnaSequencesWithResponse(ctx context.Context, body AutoAnnotateRnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*AutoAnnotateRnaSequencesResponse, error)

	// AutofillRNASequencePartsWithBodyWithResponse request with any body
	AutofillRNASequencePartsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AutofillRNASequencePartsResponse, error)

	AutofillRNASequencePartsWithResponse(ctx context.Context, body AutofillRNASequencePartsJSONRequestBody, reqEditors ...RequestEditorFn) (*AutofillRNASequencePartsResponse, error)

	// AutofillRNASequenceTranslationsWithBodyWithResponse request with any body
	AutofillRNASequenceTranslationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AutofillRNASequenceTranslationsResponse, error)

	AutofillRNASequenceTranslationsWithResponse(ctx context.Context, body AutofillRNASequenceTranslationsJSONRequestBody, reqEditors ...RequestEditorFn) (*AutofillRNASequenceTranslationsResponse, error)

	// BulkCreateRNASequencesWithBodyWithResponse request with any body
	BulkCreateRNASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateRNASequencesResponse, error)

	BulkCreateRNASequencesWithResponse(ctx context.Context, body BulkCreateRNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateRNASequencesResponse, error)

	// BulkGetRNASequencesWithResponse request
	BulkGetRNASequencesWithResponse(ctx context.Context, params *BulkGetRNASequencesParams, reqEditors ...RequestEditorFn) (*BulkGetRNASequencesResponse, error)

	// BulkUpdateRNASequencesWithBodyWithResponse request with any body
	BulkUpdateRNASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateRNASequencesResponse, error)

	BulkUpdateRNASequencesWithResponse(ctx context.Context, body BulkUpdateRNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateRNASequencesResponse, error)

	// MatchBasesRnaSequencesWithBodyWithResponse request with any body
	MatchBasesRnaSequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MatchBasesRnaSequencesResponse, error)

	MatchBasesRnaSequencesWithResponse(ctx context.Context, body MatchBasesRnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*MatchBasesRnaSequencesResponse, error)

	// SearchRnaSequencesWithBodyWithResponse request with any body
	SearchRnaSequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRnaSequencesResponse, error)

	SearchRnaSequencesWithResponse(ctx context.Context, body SearchRnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRnaSequencesResponse, error)

	// UnarchiveRNASequencesWithBodyWithResponse request with any body
	UnarchiveRNASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveRNASequencesResponse, error)

	UnarchiveRNASequencesWithResponse(ctx context.Context, body UnarchiveRNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveRNASequencesResponse, error)

	// GetTaskWithResponse request
	GetTaskWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetTaskResponse, error)

	// ListTeamsWithResponse request
	ListTeamsWithResponse(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*ListTeamsResponse, error)

	// GetTeamWithResponse request
	GetTeamWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*GetTeamResponse, error)

	// GenerateTokenWithBodyWithResponse request with any body
	GenerateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTokenResponse, error)

	GenerateTokenWithFormdataBodyWithResponse(ctx context.Context, body GenerateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*GenerateTokenResponse, error)

	// TransferIntoContainersWithBodyWithResponse request with any body
	TransferIntoContainersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferIntoContainersResponse, error)

	TransferIntoContainersWithResponse(ctx context.Context, body TransferIntoContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*TransferIntoContainersResponse, error)

	// ListUsersWithResponse request
	ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// UpdateUserWithBodyWithResponse request with any body
	UpdateUserWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	UpdateUserWithResponse(ctx context.Context, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// GetUserActivityWithResponse request
	GetUserActivityWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserActivityResponse, error)

	// BulkCreateUsersWithBodyWithResponse request with any body
	BulkCreateUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateUsersResponse, error)

	BulkCreateUsersWithResponse(ctx context.Context, body BulkCreateUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateUsersResponse, error)

	// BulkUpdateUsersWithBodyWithResponse request with any body
	BulkUpdateUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateUsersResponse, error)

	BulkUpdateUsersWithResponse(ctx context.Context, body BulkUpdateUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateUsersResponse, error)

	// CreateWarehouseCredentialsWithBodyWithResponse request with any body
	CreateWarehouseCredentialsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWarehouseCredentialsResponse, error)

	CreateWarehouseCredentialsWithResponse(ctx context.Context, body CreateWarehouseCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWarehouseCredentialsResponse, error)

	// ListWorkflowOutputsWithResponse request
	ListWorkflowOutputsWithResponse(ctx context.Context, params *ListWorkflowOutputsParams, reqEditors ...RequestEditorFn) (*ListWorkflowOutputsResponse, error)

	// CreateWorkflowOutputWithBodyWithResponse request with any body
	CreateWorkflowOutputWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkflowOutputResponse, error)

	CreateWorkflowOutputWithResponse(ctx context.Context, body CreateWorkflowOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkflowOutputResponse, error)

	// GetWorkflowOutputWithResponse request
	GetWorkflowOutputWithResponse(ctx context.Context, workflowOutputId string, reqEditors ...RequestEditorFn) (*GetWorkflowOutputResponse, error)

	// UpdateWorkflowOutputWithBodyWithResponse request with any body
	UpdateWorkflowOutputWithBodyWithResponse(ctx context.Context, workflowOutputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkflowOutputResponse, error)

	UpdateWorkflowOutputWithResponse(ctx context.Context, workflowOutputId string, body UpdateWorkflowOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkflowOutputResponse, error)

	// ArchiveWorkflowOutputsWithBodyWithResponse request with any body
	ArchiveWorkflowOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveWorkflowOutputsResponse, error)

	ArchiveWorkflowOutputsWithResponse(ctx context.Context, body ArchiveWorkflowOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveWorkflowOutputsResponse, error)

	// BulkCreateWorkflowOutputsWithBodyWithResponse request with any body
	BulkCreateWorkflowOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateWorkflowOutputsResponse, error)

	BulkCreateWorkflowOutputsWithResponse(ctx context.Context, body BulkCreateWorkflowOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateWorkflowOutputsResponse, error)

	// BulkUpdateWorkflowOutputsWithBodyWithResponse request with any body
	BulkUpdateWorkflowOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateWorkflowOutputsResponse, error)

	BulkUpdateWorkflowOutputsWithResponse(ctx context.Context, body BulkUpdateWorkflowOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateWorkflowOutputsResponse, error)

	// UnarchiveWorkflowOutputsWithBodyWithResponse request with any body
	UnarchiveWorkflowOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveWorkflowOutputsResponse, error)

	UnarchiveWorkflowOutputsWithResponse(ctx context.Context, body UnarchiveWorkflowOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveWorkflowOutputsResponse, error)

	// ListStageRunInputSamplesWithResponse request
	ListStageRunInputSamplesWithResponse(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*ListStageRunInputSamplesResponse, error)

	// ListStageRunOutputSamplesWithResponse request
	ListStageRunOutputSamplesWithResponse(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*ListStageRunOutputSamplesResponse, error)

	// ListStageRunRegisteredSamplesWithResponse request
	ListStageRunRegisteredSamplesWithResponse(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*ListStageRunRegisteredSamplesResponse, error)

	// ListWorkflowStageRunsWithResponse request
	ListWorkflowStageRunsWithResponse(ctx context.Context, stageId string, reqEditors ...RequestEditorFn) (*ListWorkflowStageRunsResponse, error)

	// ListWorkflowTaskGroupsWithResponse request
	ListWorkflowTaskGroupsWithResponse(ctx context.Context, params *ListWorkflowTaskGroupsParams, reqEditors ...RequestEditorFn) (*ListWorkflowTaskGroupsResponse, error)

	// CreateWorkflowTaskGroupWithBodyWithResponse request with any body
	CreateWorkflowTaskGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkflowTaskGroupResponse, error)

	CreateWorkflowTaskGroupWithResponse(ctx context.Context, body CreateWorkflowTaskGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkflowTaskGroupResponse, error)

	// GetWorkflowTaskGroupWithResponse request
	GetWorkflowTaskGroupWithResponse(ctx context.Context, workflowTaskGroupId string, reqEditors ...RequestEditorFn) (*GetWorkflowTaskGroupResponse, error)

	// UpdateWorkflowTaskGroupWithBodyWithResponse request with any body
	UpdateWorkflowTaskGroupWithBodyWithResponse(ctx context.Context, workflowTaskGroupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkflowTaskGroupResponse, error)

	UpdateWorkflowTaskGroupWithResponse(ctx context.Context, workflowTaskGroupId string, body UpdateWorkflowTaskGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkflowTaskGroupResponse, error)

	// ArchiveWorkflowTaskGroupsWithBodyWithResponse request with any body
	ArchiveWorkflowTaskGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveWorkflowTaskGroupsResponse, error)

	ArchiveWorkflowTaskGroupsWithResponse(ctx context.Context, body ArchiveWorkflowTaskGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveWorkflowTaskGroupsResponse, error)

	// UnarchiveWorkflowTaskGroupsWithBodyWithResponse request with any body
	UnarchiveWorkflowTaskGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveWorkflowTaskGroupsResponse, error)

	UnarchiveWorkflowTaskGroupsWithResponse(ctx context.Context, body UnarchiveWorkflowTaskGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveWorkflowTaskGroupsResponse, error)

	// ListWorkflowTaskSchemasWithResponse request
	ListWorkflowTaskSchemasWithResponse(ctx context.Context, params *ListWorkflowTaskSchemasParams, reqEditors ...RequestEditorFn) (*ListWorkflowTaskSchemasResponse, error)

	// GetWorkflowTaskSchemaWithResponse request
	GetWorkflowTaskSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetWorkflowTaskSchemaResponse, error)

	// ListWorkflowTasksWithResponse request
	ListWorkflowTasksWithResponse(ctx context.Context, params *ListWorkflowTasksParams, reqEditors ...RequestEditorFn) (*ListWorkflowTasksResponse, error)

	// CreateWorkflowTaskWithBodyWithResponse request with any body
	CreateWorkflowTaskWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkflowTaskResponse, error)

	CreateWorkflowTaskWithResponse(ctx context.Context, body CreateWorkflowTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkflowTaskResponse, error)

	// GetWorkflowTaskWithResponse request
	GetWorkflowTaskWithResponse(ctx context.Context, workflowTaskId string, reqEditors ...RequestEditorFn) (*GetWorkflowTaskResponse, error)

	// UpdateWorkflowTaskWithBodyWithResponse request with any body
	UpdateWorkflowTaskWithBodyWithResponse(ctx context.Context, workflowTaskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkflowTaskResponse, error)

	UpdateWorkflowTaskWithResponse(ctx context.Context, workflowTaskId string, body UpdateWorkflowTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkflowTaskResponse, error)

	// CopyWorkflowTaskWithResponse request
	CopyWorkflowTaskWithResponse(ctx context.Context, workflowTaskId string, reqEditors ...RequestEditorFn) (*CopyWorkflowTaskResponse, error)

	// ArchiveWorkflowTasksWithBodyWithResponse request with any body
	ArchiveWorkflowTasksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveWorkflowTasksResponse, error)

	ArchiveWorkflowTasksWithResponse(ctx context.Context, body ArchiveWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveWorkflowTasksResponse, error)

	// BulkCopyWorkflowTasksWithBodyWithResponse request with any body
	BulkCopyWorkflowTasksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCopyWorkflowTasksResponse, error)

	BulkCopyWorkflowTasksWithResponse(ctx context.Context, body BulkCopyWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCopyWorkflowTasksResponse, error)

	// BulkCreateWorkflowTasksWithBodyWithResponse request with any body
	BulkCreateWorkflowTasksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateWorkflowTasksResponse, error)

	BulkCreateWorkflowTasksWithResponse(ctx context.Context, body BulkCreateWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateWorkflowTasksResponse, error)

	// BulkUpdateWorkflowTasksWithBodyWithResponse request with any body
	BulkUpdateWorkflowTasksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateWorkflowTasksResponse, error)

	BulkUpdateWorkflowTasksWithResponse(ctx context.Context, body BulkUpdateWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateWorkflowTasksResponse, error)

	// UnarchiveWorkflowTasksWithBodyWithResponse request with any body
	UnarchiveWorkflowTasksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveWorkflowTasksResponse, error)

	UnarchiveWorkflowTasksWithResponse(ctx context.Context, body UnarchiveWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveWorkflowTasksResponse, error)

	// ListWorkflowsWithResponse request
	ListWorkflowsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkflowsResponse, error)

	// UpdateWorkflowMetadataWithBodyWithResponse request with any body
	UpdateWorkflowMetadataWithBodyWithResponse(ctx context.Context, workflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkflowMetadataResponse, error)

	UpdateWorkflowMetadataWithResponse(ctx context.Context, workflowId string, body UpdateWorkflowMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkflowMetadataResponse, error)

	// ListWorkflowStagesWithResponse request
	ListWorkflowStagesWithResponse(ctx context.Context, workflowId string, reqEditors ...RequestEditorFn) (*ListWorkflowStagesResponse, error)
}

type ListAASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AaSequencesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListAASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAASequenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AaSequence
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateAASequenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAASequenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAASequenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AaSequence
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetAASequenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAASequenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAASequenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AaSequence
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UpdateAASequenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAASequenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveAASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AaSequencesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveAASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveAASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AutoAnnotateAaSequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r AutoAnnotateAaSequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AutoAnnotateAaSequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateAASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCreateAASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateAASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkGetAASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AaSequencesBulkGet
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkGetAASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkGetAASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateAASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkUpdateAASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateAASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveAASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AaSequencesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveAASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveAASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAppCanvasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AppCanvas
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
}

// Status returns HTTPResponse.Status
func (r CreateAppCanvasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppCanvasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppCanvasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppCanvas
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetAppCanvasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppCanvasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppCanvasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppCanvas
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdateAppCanvasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppCanvasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveAppCanvasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppCanvasesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveAppCanvasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveAppCanvasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveAppCanvasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppCanvasesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveAppCanvasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveAppCanvasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAppConfigurationItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppConfigurationPaginatedList
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r ListAppConfigurationItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAppConfigurationItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAppConfigurationItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AppConfigItem
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateAppConfigurationItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppConfigurationItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppConfigurationItemByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppConfigItem
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetAppConfigurationItemByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppConfigurationItemByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppConfigurationItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppConfigItem
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdateAppConfigurationItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppConfigurationItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateAppConfigurationItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCreateAppConfigurationItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateAppConfigurationItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateAppConfigurationItemsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkUpdateAppConfigurationItemsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateAppConfigurationItemsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAppSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AppSession
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
}

// Status returns HTTPResponse.Status
func (r CreateAppSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppSessionByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppSession
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetAppSessionByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppSessionByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AppSession
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdateAppSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBenchlingAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BenchlingAppsPaginatedList
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
}

// Status returns HTTPResponse.Status
func (r ListBenchlingAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBenchlingAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBenchlingAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BenchlingApp
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
	JSON409      *ConflictError
}

// Status returns HTTPResponse.Status
func (r CreateBenchlingAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBenchlingAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBenchlingAppByIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BenchlingApp
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetBenchlingAppByIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBenchlingAppByIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchBenchlingAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BenchlingApp
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r PatchBenchlingAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchBenchlingAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveBenchlingAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BenchlingAppsArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveBenchlingAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveBenchlingAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveBenchlingAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BenchlingAppsArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveBenchlingAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveBenchlingAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssayResultSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayResultSchemasPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListAssayResultSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssayResultSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResultSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayResultSchema
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetResultSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResultSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssayResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayResultsPaginatedList
}

// Status returns HTTPResponse.Status
func (r ListAssayResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssayResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAssayResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayResultsCreateResponse
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateAssayResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAssayResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssayResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayResult
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetAssayResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssayResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveAssayResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayResultIdsResponse
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveAssayResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveAssayResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateAssayResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCreateAssayResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateAssayResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkGetAssayResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayResultsBulkGet
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkGetAssayResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkGetAssayResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveAssayResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayResultIdsResponse
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveAssayResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveAssayResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssayRunSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayRunSchemasPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListAssayRunSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssayRunSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRunSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayRunSchema
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetRunSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRunSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssayRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayRunsPaginatedList
}

// Status returns HTTPResponse.Status
func (r ListAssayRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssayRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAssayRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayRunsBulkCreateResponse
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateAssayRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAssayRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssayRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayRun
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetAssayRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssayRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAssayRunResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayRun
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UpdateAssayRunResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAssayRunResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAutomationInputGeneratorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationFileInputsPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListAutomationInputGeneratorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAutomationInputGeneratorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAutomationOutputProcessorsDeprecatedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeprecatedAutomationOutputProcessorsPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListAutomationOutputProcessorsDeprecatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAutomationOutputProcessorsDeprecatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveAssayRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayRunsArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveAssayRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveAssayRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkGetAssayRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayRunsBulkGet
}

// Status returns HTTPResponse.Status
func (r BulkGetAssayRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkGetAssayRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveAssayRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayRunsArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveAssayRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveAssayRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLabAutomationTransformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LabAutomationTransform
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetLabAutomationTransformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLabAutomationTransformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLabAutomationTransformResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LabAutomationTransform
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UpdateLabAutomationTransformResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLabAutomationTransformResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutomationInputGeneratorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationInputGenerator
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetAutomationInputGeneratorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutomationInputGeneratorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAutomationInputGeneratorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationInputGenerator
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UpdateAutomationInputGeneratorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAutomationInputGeneratorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateInputWithAutomationInputGeneratorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GenerateInputWithAutomationInputGeneratorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateInputWithAutomationInputGeneratorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAutomationOutputProcessorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationOutputProcessorsPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListAutomationOutputProcessorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAutomationOutputProcessorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAutomationOutputProcessorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AutomationOutputProcessor
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateAutomationOutputProcessorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAutomationOutputProcessorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutomationOutputProcessorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationOutputProcessor
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetAutomationOutputProcessorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutomationOutputProcessorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAutomationOutputProcessorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationOutputProcessor
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UpdateAutomationOutputProcessorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAutomationOutputProcessorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProcessOutputWithAutomationOutputProcessorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ProcessOutputWithAutomationOutputProcessorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessOutputWithAutomationOutputProcessorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveAutomationOutputProcessorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationOutputProcessorArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveAutomationOutputProcessorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveAutomationOutputProcessorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveAutomationOutputProcessorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AutomationOutputProcessorArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveAutomationOutputProcessorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveAutomationOutputProcessorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BatchSchemasPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListBatchSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBatchSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BatchSchema
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetBatchSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBatchSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BatchesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListBatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Batch
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Batch
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Batch
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UpdateBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveBatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BatchesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveBatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveBatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkGetBatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BatchesBulkGet
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkGetBatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkGetBatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveBatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BatchesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveBatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveBatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBlobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Blob
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateBlobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBlobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Blob
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetBlobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlobFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetBlobFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlobFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlobUrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlobUrl
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetBlobUrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlobUrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBlobPartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlobPart
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateBlobPartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBlobPartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AbortMultipartBlobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyObject
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r AbortMultipartBlobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AbortMultipartBlobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CompleteMultipartBlobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Blob
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CompleteMultipartBlobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompleteMultipartBlobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkGetBlobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BlobsBulkGet
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkGetBlobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkGetBlobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMultipartBlobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Blob
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateMultipartBlobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMultipartBlobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBoxSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BoxSchemasPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListBoxSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBoxSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBoxSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BoxSchema
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetBoxSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBoxSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBoxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BoxesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListBoxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBoxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBoxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Box
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateBoxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBoxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBoxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Box
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetBoxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBoxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateBoxResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Box
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdateBoxResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateBoxResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBoxContentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BoxContentsPaginatedList
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r ListBoxContentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBoxContentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveBoxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BoxesArchivalChange
	JSON403      *ForbiddenRestrictedSampleError
}

// Status returns HTTPResponse.Status
func (r ArchiveBoxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveBoxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkGetBoxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BoxesBulkGet
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkGetBoxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkGetBoxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveBoxesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BoxesArchivalChange
}

// Status returns HTTPResponse.Status
func (r UnarchiveBoxesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveBoxesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListContainerSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContainerSchemasPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListContainerSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListContainerSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContainerSchema
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetContainerSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListContainersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContainersPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListContainersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListContainersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateContainerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Container
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateContainerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateContainerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Container
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetContainerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateContainerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Container
	JSON400      *BadRequestError
	JSON403      *ForbiddenRestrictedSampleError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdateContainerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateContainerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListContainerContentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContainerContentsList
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r ListContainerContentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListContainerContentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteContainerContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON403      *ForbiddenRestrictedSampleError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r DeleteContainerContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteContainerContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContainerContent
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetContainerContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateContainerContentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContainerContent
	JSON400      *BadRequestError
	JSON403      *ForbiddenRestrictedSampleError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdateContainerContentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateContainerContentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferIntoContainerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyObject
	JSON400      *BadRequestError
	JSON403      *ForbiddenRestrictedSampleError
}

// Status returns HTTPResponse.Status
func (r TransferIntoContainerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferIntoContainerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveContainersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContainersArchivalChange
	JSON400      *BadRequestError
	JSON403      *ForbiddenRestrictedSampleError
}

// Status returns HTTPResponse.Status
func (r ArchiveContainersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveContainersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateContainersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCreateContainersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateContainersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkGetContainersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContainersList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkGetContainersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkGetContainersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateContainersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkUpdateContainersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateContainersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckinContainersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyObject
	JSON400      *BadRequestError
	JSON403      *ForbiddenRestrictedSampleError
}

// Status returns HTTPResponse.Status
func (r CheckinContainersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckinContainersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckoutContainersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyObject
	JSON400      *BadRequestError
	JSON403      *ForbiddenRestrictedSampleError
}

// Status returns HTTPResponse.Status
func (r CheckoutContainersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckoutContainersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PrintLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyObject
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r PrintLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PrintLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReserveContainersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyObject
	JSON400      *BadRequestError
	JSON403      *ForbiddenRestrictedSampleError
}

// Status returns HTTPResponse.Status
func (r ReserveContainersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReserveContainersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveContainersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContainersArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveContainersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveContainersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomEntitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomEntitiesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListCustomEntitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomEntitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CustomEntity
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateCustomEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomEntity
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetCustomEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomEntityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomEntity
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UpdateCustomEntityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomEntityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveCustomEntitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomEntitiesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveCustomEntitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveCustomEntitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateCustomEntitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCreateCustomEntitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateCustomEntitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkGetCustomEntitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomEntitiesList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkGetCustomEntitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkGetCustomEntitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateCustomEntitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkUpdateCustomEntitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateCustomEntitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveCustomEntitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomEntitiesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveCustomEntitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveCustomEntitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomNotationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomNotationsPaginatedList
}

// Status returns HTTPResponse.Status
func (r ListCustomNotationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomNotationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDNAAlignmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaAlignmentsPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListDNAAlignmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDNAAlignmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDNAAlignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyObject
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r DeleteDNAAlignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDNAAlignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDNAAlignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaAlignment
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetDNAAlignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDNAAlignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDnaConsensusAlignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
}

// Status returns HTTPResponse.Status
func (r CreateDnaConsensusAlignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDnaConsensusAlignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDnaTemplateAlignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
}

// Status returns HTTPResponse.Status
func (r CreateDnaTemplateAlignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDnaTemplateAlignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDNAOligosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaOligosPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListDNAOligosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDNAOligosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDNAOligoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DnaOligo
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateDNAOligoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDNAOligoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDNAOligoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaOligo
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetDNAOligoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDNAOligoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDNAOligoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaOligo
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UpdateDNAOligoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDNAOligoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveDNAOligosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaOligosArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveDNAOligosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveDNAOligosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateDNAOligosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCreateDNAOligosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateDNAOligosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateDNAOligosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkUpdateDNAOligosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateDNAOligosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveDNAOligosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaOligosArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveDNAOligosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveDNAOligosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDNASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaSequencesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListDNASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDNASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDNASequenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DnaSequence
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateDNASequenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDNASequenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDNASequenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaSequence
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetDNASequenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDNASequenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDNASequenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaSequence
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UpdateDNASequenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDNASequenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveDNASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaSequencesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveDNASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveDNASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AutoAnnotateDnaSequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r AutoAnnotateDnaSequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AutoAnnotateDnaSequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AutofillDNASequencePartsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r AutofillDNASequencePartsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AutofillDNASequencePartsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AutofillDNASequenceTranslationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r AutofillDNASequenceTranslationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AutofillDNASequenceTranslationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateDNASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCreateDNASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateDNASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkGetDNASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaSequencesBulkGet
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkGetDNASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkGetDNASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateDNASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkUpdateDNASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateDNASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MatchBasesDnaSequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaSequencesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r MatchBasesDnaSequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MatchBasesDnaSequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDnaSequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaSequencesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r SearchDnaSequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDnaSequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveDNASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaSequencesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveDNASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveDNASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDropdownsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DropdownSummariesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListDropdownsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDropdownsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDropdownResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dropdown
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateDropdownResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDropdownResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDropdownResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dropdown
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetDropdownResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDropdownResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDropdownResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Dropdown
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdateDropdownResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDropdownResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveDropdownOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DropdownOptionsArchivalChange
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r ArchiveDropdownOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveDropdownOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveDropdownOptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DropdownOptionsArchivalChange
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UnarchiveDropdownOptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveDropdownOptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnitityBatchesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BatchesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetEnitityBatchesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnitityBatchesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEntitySchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntitySchemasPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListEntitySchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEntitySchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntitySchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntitySchema
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetEntitySchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntitySchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntriesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Entry
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntryById
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Entry
}

// Status returns HTTPResponse.Status
func (r UpdateEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExternalFileMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntryExternalFileById
}

// Status returns HTTPResponse.Status
func (r GetExternalFileMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExternalFileMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntriesArchivalChange
}

// Status returns HTTPResponse.Status
func (r ArchiveEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkGetEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Entries
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkGetEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkGetEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntriesArchivalChange
}

// Status returns HTTPResponse.Status
func (r UnarchiveEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEntrySchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntrySchemasPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListEntrySchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEntrySchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntrySchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntrySchemaDetailed
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetEntrySchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntrySchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEntryTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntryTemplatesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListEntryTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEntryTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEntryTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntryTemplate
}

// Status returns HTTPResponse.Status
func (r GetEntryTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEntryTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EventsPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportItemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ExportItemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportItemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFeatureLibrariesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FeatureLibrariesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListFeatureLibrariesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFeatureLibrariesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFeatureLibraryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *FeatureLibrary
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateFeatureLibraryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFeatureLibraryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeatureLibraryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FeatureLibrary
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetFeatureLibraryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeatureLibraryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFeatureLibraryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FeatureLibrary
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdateFeatureLibraryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFeatureLibraryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFeaturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FeaturesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListFeaturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFeaturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFeatureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Feature
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateFeatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFeatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFeatureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Feature
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetFeatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFeatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFeatureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Feature
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdateFeatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFeatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateFeaturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCreateFeaturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateFeaturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FoldersPaginatedList
}

// Status returns HTTPResponse.Status
func (r ListFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Folder
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Folder
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FoldersArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FoldersArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLegacyWorkflowStageRunInputSamplesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LegacyWorkflowSampleList
}

// Status returns HTTPResponse.Status
func (r ListLegacyWorkflowStageRunInputSamplesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLegacyWorkflowStageRunInputSamplesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLegacyWorkflowStageRunOutputSamplesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LegacyWorkflowSampleList
}

// Status returns HTTPResponse.Status
func (r ListLegacyWorkflowStageRunOutputSamplesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLegacyWorkflowStageRunOutputSamplesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLegacyWorkflowStageRunRegisteredSamplesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LegacyWorkflowSampleList
}

// Status returns HTTPResponse.Status
func (r ListLegacyWorkflowStageRunRegisteredSamplesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLegacyWorkflowStageRunRegisteredSamplesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLegacyWorkflowStageRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LegacyWorkflowStageRunList
}

// Status returns HTTPResponse.Status
func (r ListLegacyWorkflowStageRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLegacyWorkflowStageRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLegacyWorkflowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LegacyWorkflowList
}

// Status returns HTTPResponse.Status
func (r ListLegacyWorkflowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLegacyWorkflowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLegacyWorkflowMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LegacyWorkflow
}

// Status returns HTTPResponse.Status
func (r UpdateLegacyWorkflowMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLegacyWorkflowMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLegacyWorkflowStagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LegacyWorkflowStageList
}

// Status returns HTTPResponse.Status
func (r ListLegacyWorkflowStagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLegacyWorkflowStagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLocationSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LocationSchemasPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListLocationSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLocationSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LocationSchema
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetLocationSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LocationsPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Location
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Location
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateLocationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Location
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdateLocationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateLocationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LocationsArchivalChange
	JSON400      *BadRequestError
	JSON403      *ForbiddenRestrictedSampleError
}

// Status returns HTTPResponse.Status
func (r ArchiveLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkGetLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LocationsBulkGet
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r BulkGetLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkGetLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LocationsArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMixturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MixturesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListMixturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMixturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMixtureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Mixture
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateMixtureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMixtureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMixtureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Mixture
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetMixtureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMixtureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMixtureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Mixture
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UpdateMixtureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMixtureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveMixturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MixturesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveMixturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveMixturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateMixturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCreateMixturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateMixturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateMixturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkUpdateMixturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateMixturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveMixturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MixturesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveMixturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveMixturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMoleculesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MoleculesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListMoleculesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMoleculesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMoleculeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Molecule
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateMoleculeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMoleculeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMoleculeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Molecule
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetMoleculeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMoleculeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMoleculeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Molecule
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UpdateMoleculeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMoleculeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveMoleculesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MoleculesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveMoleculesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveMoleculesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateMoleculesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCreateMoleculesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateMoleculesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateMoleculesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkUpdateMoleculesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateMoleculesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveMoleculesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MoleculesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveMoleculesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveMoleculesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMonomersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MonomersPaginatedList
}

// Status returns HTTPResponse.Status
func (r ListMonomersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMonomersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMonomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Monomer
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
}

// Status returns HTTPResponse.Status
func (r CreateMonomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMonomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMonomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Monomer
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdateMonomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMonomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveMonomersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MonomersArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveMonomersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveMonomersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveMonomersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MonomersArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveMonomersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveMonomersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNucleotideAlignmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NucleotideAlignmentsPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListNucleotideAlignmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNucleotideAlignmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNucleotideAlignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyObject
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r DeleteNucleotideAlignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNucleotideAlignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNucleotideAlignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NucleotideAlignment
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetNucleotideAlignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNucleotideAlignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateConsensusNucleotideAlignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
}

// Status returns HTTPResponse.Status
func (r CreateConsensusNucleotideAlignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConsensusNucleotideAlignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTemplateNucleotideAlignmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
}

// Status returns HTTPResponse.Status
func (r CreateTemplateNucleotideAlignmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTemplateNucleotideAlignmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOligosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OligosPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListOligosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOligosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOligoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DnaOligo
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateOligoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOligoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOligoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaOligo
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetOligoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOligoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOligoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DnaOligo
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UpdateOligoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOligoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveOligosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OligosArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveOligosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveOligosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateOligosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCreateOligosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateOligosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkGetOligosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OligosBulkGet
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkGetOligosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkGetOligosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveOligosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OligosArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveOligosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveOligosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOrganizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrganizationsPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListOrganizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOrganizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Organization
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlateSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlateSchemasPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListPlateSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlateSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlateSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlateSchema
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetPlateSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlateSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListPlatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePlateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Plate
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreatePlateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePlateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plate
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetPlateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePlateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Plate
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdatePlateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePlateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchivePlatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatesArchivalChange
	JSON400      *BadRequestError
	JSON403      *ForbiddenRestrictedSampleError
}

// Status returns HTTPResponse.Status
func (r ArchivePlatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchivePlatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkGetPlatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatesBulkGet
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r BulkGetPlatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkGetPlatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchivePlatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlatesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchivePlatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchivePlatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectsPaginatedList
}

// Status returns HTTPResponse.Status
func (r ListProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Project
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetProjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectsArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveProjectsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectsArchivalChange
}

// Status returns HTTPResponse.Status
func (r UnarchiveProjectsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveProjectsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRegistriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegistriesList
}

// Status returns HTTPResponse.Status
func (r ListRegistriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRegistriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Registry
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBatchSchemasByRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BatchSchemasList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListBatchSchemasByRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBatchSchemasByRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBoxSchemasByRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BoxSchemasList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListBoxSchemasByRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBoxSchemasByRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListContainerSchemasByRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContainerSchemasList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListContainerSchemasByRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListContainerSchemasByRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDropdownsByRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DropdownsRegistryList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListDropdownsByRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDropdownsByRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEntitySchemasByRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeprecatedEntitySchemasList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListEntitySchemasByRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEntitySchemasByRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPrintersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PrintersList
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r ListPrintersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPrintersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLabelTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LabelTemplatesList
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r ListLabelTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLabelTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListLocationSchemasByRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LocationSchemasList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListLocationSchemasByRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListLocationSchemasByRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlateSchemasByRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PlateSchemasList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListPlateSchemasByRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlateSchemasByRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkGetRegisteredEntitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegisteredEntitiesList
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r BulkGetRegisteredEntitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkGetRegisteredEntitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterEntitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r RegisterEntitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterEntitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnregisterEntitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EmptyObject
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnregisterEntitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnregisterEntitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ValidateBarcodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BarcodeValidationResults
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r ValidateBarcodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ValidateBarcodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRequestFulfillmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestFulfillmentsPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListRequestFulfillmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRequestFulfillmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRequestFulfillmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestFulfillment
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetRequestFulfillmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRequestFulfillmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRequestSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestSchemasPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListRequestSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRequestSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRequestSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestSchema
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetRequestSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRequestSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRequestTaskSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestTaskSchemasPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListRequestTaskSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRequestTaskSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRequestTaskSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestTaskSchema
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetRequestTaskSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRequestTaskSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestsPaginatedList
}

// Status returns HTTPResponse.Status
func (r ListRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Request
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Request
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Request
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r PatchRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRequestResponseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestResponse
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetRequestResponseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRequestResponseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateRequestTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestTasksBulkCreateResponse
	JSON400      *BadRequestErrorBulk
}

// Status returns HTTPResponse.Status
func (r BulkCreateRequestTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateRequestTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateRequestTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestTasksBulkUpdateResponse
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r BulkUpdateRequestTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateRequestTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecuteRequestsSampleGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExecuteSampleGroups
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r ExecuteRequestsSampleGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecuteRequestsSampleGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkGetRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestsBulkGet
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkGetRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkGetRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAssayResultsTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayResultTransactionCreateResponse
}

// Status returns HTTPResponse.Status
func (r CreateAssayResultsTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAssayResultsTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAssayResultsInTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayResultsCreateResponse
}

// Status returns HTTPResponse.Status
func (r CreateAssayResultsInTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAssayResultsInTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AbortAssayResultsTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayResultTransactionCreateResponse
}

// Status returns HTTPResponse.Status
func (r AbortAssayResultsTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AbortAssayResultsTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitAssayResultsTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AssayResultTransactionCreateResponse
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CommitAssayResultsTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitAssayResultsTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRNAOligosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RnaOligosPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListRNAOligosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRNAOligosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRNAOligoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RnaOligo
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateRNAOligoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRNAOligoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRNAOligoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RnaOligo
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetRNAOligoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRNAOligoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRNAOligoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RnaOligo
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UpdateRNAOligoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRNAOligoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveRNAOligosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RnaOligosArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveRNAOligosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveRNAOligosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateRNAOligosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCreateRNAOligosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateRNAOligosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateRNAOligosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkUpdateRNAOligosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateRNAOligosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveRNAOligosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RnaOligosArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveRNAOligosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveRNAOligosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListRNASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RnaSequencesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListRNASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListRNASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRNASequenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RnaSequence
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateRNASequenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRNASequenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRNASequenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RnaSequence
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r GetRNASequenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRNASequenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRNASequenceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RnaSequence
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UpdateRNASequenceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRNASequenceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveRNASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RnaSequencesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveRNASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveRNASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AutoAnnotateRnaSequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r AutoAnnotateRnaSequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AutoAnnotateRnaSequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AutofillRNASequencePartsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r AutofillRNASequencePartsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AutofillRNASequencePartsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AutofillRNASequenceTranslationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r AutofillRNASequenceTranslationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AutofillRNASequenceTranslationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateRNASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCreateRNASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateRNASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkGetRNASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RnaSequencesBulkGet
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkGetRNASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkGetRNASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateRNASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkUpdateRNASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateRNASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MatchBasesRnaSequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RnaSequencesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r MatchBasesRnaSequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MatchBasesRnaSequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchRnaSequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RnaSequencesPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r SearchRnaSequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchRnaSequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveRNASequencesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RnaSequencesArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveRNASequencesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveRNASequencesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
	JSON404 *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamsPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Team
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetTeamResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TokenResponse
	JSON400      *OAuthBadRequestError
	JSON401      *OAuthUnauthorizedError
}

// Status returns HTTPResponse.Status
func (r GenerateTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferIntoContainersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r TransferIntoContainersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferIntoContainersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON400      *BadRequestError
	JSON403      *ForbiddenError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserActivityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserActivity
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetUserActivityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserActivityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCreateUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkUpdateUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWarehouseCredentialsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WarehouseCredentials
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateWarehouseCredentialsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWarehouseCredentialsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkflowOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowOutputsPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListWorkflowOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkflowOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkflowOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WorkflowOutput
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateWorkflowOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkflowOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkflowOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowOutput
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetWorkflowOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkflowOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWorkflowOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowOutput
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdateWorkflowOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkflowOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveWorkflowOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowOutputsArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveWorkflowOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveWorkflowOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateWorkflowOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCreateWorkflowOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateWorkflowOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateWorkflowOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkUpdateWorkflowOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateWorkflowOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveWorkflowOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowOutputsArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveWorkflowOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveWorkflowOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStageRunInputSamplesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowSampleList
}

// Status returns HTTPResponse.Status
func (r ListStageRunInputSamplesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStageRunInputSamplesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStageRunOutputSamplesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowSampleList
}

// Status returns HTTPResponse.Status
func (r ListStageRunOutputSamplesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStageRunOutputSamplesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStageRunRegisteredSamplesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowSampleList
}

// Status returns HTTPResponse.Status
func (r ListStageRunRegisteredSamplesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStageRunRegisteredSamplesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkflowStageRunsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowStageRunList
}

// Status returns HTTPResponse.Status
func (r ListWorkflowStageRunsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkflowStageRunsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkflowTaskGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowTaskGroupsPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListWorkflowTaskGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkflowTaskGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkflowTaskGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WorkflowTaskGroup
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateWorkflowTaskGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkflowTaskGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkflowTaskGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowTaskGroup
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetWorkflowTaskGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkflowTaskGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWorkflowTaskGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowTaskGroup
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdateWorkflowTaskGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkflowTaskGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveWorkflowTaskGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowTaskGroupsArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveWorkflowTaskGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveWorkflowTaskGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveWorkflowTaskGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowTaskGroupsArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveWorkflowTaskGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveWorkflowTaskGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkflowTaskSchemasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowTaskSchemasPaginatedList
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r ListWorkflowTaskSchemasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkflowTaskSchemasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkflowTaskSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowTaskSchema
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetWorkflowTaskSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkflowTaskSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkflowTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowTasksPaginatedList
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ListWorkflowTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkflowTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWorkflowTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WorkflowTask
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r CreateWorkflowTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWorkflowTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkflowTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowTask
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r GetWorkflowTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkflowTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWorkflowTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowTask
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdateWorkflowTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkflowTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CopyWorkflowTaskResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WorkflowTask
	JSON400      *BadRequestError
	JSON404      *NotFoundError
}

// Status returns HTTPResponse.Status
func (r CopyWorkflowTaskResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CopyWorkflowTaskResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ArchiveWorkflowTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowTasksArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r ArchiveWorkflowTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveWorkflowTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCopyWorkflowTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCopyWorkflowTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCopyWorkflowTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkCreateWorkflowTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkCreateWorkflowTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkCreateWorkflowTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateWorkflowTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *AsyncTaskLink
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r BulkUpdateWorkflowTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateWorkflowTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnarchiveWorkflowTasksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowTasksArchivalChange
	JSON400      *BadRequestError
}

// Status returns HTTPResponse.Status
func (r UnarchiveWorkflowTasksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnarchiveWorkflowTasksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkflowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowList
}

// Status returns HTTPResponse.Status
func (r ListWorkflowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkflowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWorkflowMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LegacyWorkflow
}

// Status returns HTTPResponse.Status
func (r UpdateWorkflowMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWorkflowMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListWorkflowStagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkflowStageList
}

// Status returns HTTPResponse.Status
func (r ListWorkflowStagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListWorkflowStagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListAASequencesWithResponse request returning *ListAASequencesResponse
func (c *ClientWithResponses) ListAASequencesWithResponse(ctx context.Context, params *ListAASequencesParams, reqEditors ...RequestEditorFn) (*ListAASequencesResponse, error) {
	rsp, err := c.ListAASequences(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAASequencesResponse(rsp)
}

// CreateAASequenceWithBodyWithResponse request with arbitrary body returning *CreateAASequenceResponse
func (c *ClientWithResponses) CreateAASequenceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAASequenceResponse, error) {
	rsp, err := c.CreateAASequenceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAASequenceResponse(rsp)
}

func (c *ClientWithResponses) CreateAASequenceWithResponse(ctx context.Context, body CreateAASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAASequenceResponse, error) {
	rsp, err := c.CreateAASequence(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAASequenceResponse(rsp)
}

// GetAASequenceWithResponse request returning *GetAASequenceResponse
func (c *ClientWithResponses) GetAASequenceWithResponse(ctx context.Context, aaSequenceId string, params *GetAASequenceParams, reqEditors ...RequestEditorFn) (*GetAASequenceResponse, error) {
	rsp, err := c.GetAASequence(ctx, aaSequenceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAASequenceResponse(rsp)
}

// UpdateAASequenceWithBodyWithResponse request with arbitrary body returning *UpdateAASequenceResponse
func (c *ClientWithResponses) UpdateAASequenceWithBodyWithResponse(ctx context.Context, aaSequenceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAASequenceResponse, error) {
	rsp, err := c.UpdateAASequenceWithBody(ctx, aaSequenceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAASequenceResponse(rsp)
}

func (c *ClientWithResponses) UpdateAASequenceWithResponse(ctx context.Context, aaSequenceId string, body UpdateAASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAASequenceResponse, error) {
	rsp, err := c.UpdateAASequence(ctx, aaSequenceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAASequenceResponse(rsp)
}

// ArchiveAASequencesWithBodyWithResponse request with arbitrary body returning *ArchiveAASequencesResponse
func (c *ClientWithResponses) ArchiveAASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveAASequencesResponse, error) {
	rsp, err := c.ArchiveAASequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveAASequencesResponse(rsp)
}

func (c *ClientWithResponses) ArchiveAASequencesWithResponse(ctx context.Context, body ArchiveAASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveAASequencesResponse, error) {
	rsp, err := c.ArchiveAASequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveAASequencesResponse(rsp)
}

// AutoAnnotateAaSequencesWithBodyWithResponse request with arbitrary body returning *AutoAnnotateAaSequencesResponse
func (c *ClientWithResponses) AutoAnnotateAaSequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AutoAnnotateAaSequencesResponse, error) {
	rsp, err := c.AutoAnnotateAaSequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutoAnnotateAaSequencesResponse(rsp)
}

func (c *ClientWithResponses) AutoAnnotateAaSequencesWithResponse(ctx context.Context, body AutoAnnotateAaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*AutoAnnotateAaSequencesResponse, error) {
	rsp, err := c.AutoAnnotateAaSequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutoAnnotateAaSequencesResponse(rsp)
}

// BulkCreateAASequencesWithBodyWithResponse request with arbitrary body returning *BulkCreateAASequencesResponse
func (c *ClientWithResponses) BulkCreateAASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateAASequencesResponse, error) {
	rsp, err := c.BulkCreateAASequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateAASequencesResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateAASequencesWithResponse(ctx context.Context, body BulkCreateAASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateAASequencesResponse, error) {
	rsp, err := c.BulkCreateAASequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateAASequencesResponse(rsp)
}

// BulkGetAASequencesWithResponse request returning *BulkGetAASequencesResponse
func (c *ClientWithResponses) BulkGetAASequencesWithResponse(ctx context.Context, params *BulkGetAASequencesParams, reqEditors ...RequestEditorFn) (*BulkGetAASequencesResponse, error) {
	rsp, err := c.BulkGetAASequences(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkGetAASequencesResponse(rsp)
}

// BulkUpdateAASequencesWithBodyWithResponse request with arbitrary body returning *BulkUpdateAASequencesResponse
func (c *ClientWithResponses) BulkUpdateAASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateAASequencesResponse, error) {
	rsp, err := c.BulkUpdateAASequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateAASequencesResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateAASequencesWithResponse(ctx context.Context, body BulkUpdateAASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateAASequencesResponse, error) {
	rsp, err := c.BulkUpdateAASequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateAASequencesResponse(rsp)
}

// UnarchiveAASequencesWithBodyWithResponse request with arbitrary body returning *UnarchiveAASequencesResponse
func (c *ClientWithResponses) UnarchiveAASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveAASequencesResponse, error) {
	rsp, err := c.UnarchiveAASequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveAASequencesResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveAASequencesWithResponse(ctx context.Context, body UnarchiveAASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveAASequencesResponse, error) {
	rsp, err := c.UnarchiveAASequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveAASequencesResponse(rsp)
}

// CreateAppCanvasWithBodyWithResponse request with arbitrary body returning *CreateAppCanvasResponse
func (c *ClientWithResponses) CreateAppCanvasWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppCanvasResponse, error) {
	rsp, err := c.CreateAppCanvasWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppCanvasResponse(rsp)
}

func (c *ClientWithResponses) CreateAppCanvasWithResponse(ctx context.Context, body CreateAppCanvasJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppCanvasResponse, error) {
	rsp, err := c.CreateAppCanvas(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppCanvasResponse(rsp)
}

// GetAppCanvasWithResponse request returning *GetAppCanvasResponse
func (c *ClientWithResponses) GetAppCanvasWithResponse(ctx context.Context, canvasId string, params *GetAppCanvasParams, reqEditors ...RequestEditorFn) (*GetAppCanvasResponse, error) {
	rsp, err := c.GetAppCanvas(ctx, canvasId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppCanvasResponse(rsp)
}

// UpdateAppCanvasWithBodyWithResponse request with arbitrary body returning *UpdateAppCanvasResponse
func (c *ClientWithResponses) UpdateAppCanvasWithBodyWithResponse(ctx context.Context, canvasId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppCanvasResponse, error) {
	rsp, err := c.UpdateAppCanvasWithBody(ctx, canvasId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppCanvasResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppCanvasWithResponse(ctx context.Context, canvasId string, body UpdateAppCanvasJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppCanvasResponse, error) {
	rsp, err := c.UpdateAppCanvas(ctx, canvasId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppCanvasResponse(rsp)
}

// ArchiveAppCanvasesWithBodyWithResponse request with arbitrary body returning *ArchiveAppCanvasesResponse
func (c *ClientWithResponses) ArchiveAppCanvasesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveAppCanvasesResponse, error) {
	rsp, err := c.ArchiveAppCanvasesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveAppCanvasesResponse(rsp)
}

func (c *ClientWithResponses) ArchiveAppCanvasesWithResponse(ctx context.Context, body ArchiveAppCanvasesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveAppCanvasesResponse, error) {
	rsp, err := c.ArchiveAppCanvases(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveAppCanvasesResponse(rsp)
}

// UnarchiveAppCanvasesWithBodyWithResponse request with arbitrary body returning *UnarchiveAppCanvasesResponse
func (c *ClientWithResponses) UnarchiveAppCanvasesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveAppCanvasesResponse, error) {
	rsp, err := c.UnarchiveAppCanvasesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveAppCanvasesResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveAppCanvasesWithResponse(ctx context.Context, body UnarchiveAppCanvasesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveAppCanvasesResponse, error) {
	rsp, err := c.UnarchiveAppCanvases(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveAppCanvasesResponse(rsp)
}

// ListAppConfigurationItemsWithResponse request returning *ListAppConfigurationItemsResponse
func (c *ClientWithResponses) ListAppConfigurationItemsWithResponse(ctx context.Context, params *ListAppConfigurationItemsParams, reqEditors ...RequestEditorFn) (*ListAppConfigurationItemsResponse, error) {
	rsp, err := c.ListAppConfigurationItems(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAppConfigurationItemsResponse(rsp)
}

// CreateAppConfigurationItemWithBodyWithResponse request with arbitrary body returning *CreateAppConfigurationItemResponse
func (c *ClientWithResponses) CreateAppConfigurationItemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppConfigurationItemResponse, error) {
	rsp, err := c.CreateAppConfigurationItemWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppConfigurationItemResponse(rsp)
}

func (c *ClientWithResponses) CreateAppConfigurationItemWithResponse(ctx context.Context, body CreateAppConfigurationItemJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppConfigurationItemResponse, error) {
	rsp, err := c.CreateAppConfigurationItem(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppConfigurationItemResponse(rsp)
}

// GetAppConfigurationItemByIdWithResponse request returning *GetAppConfigurationItemByIdResponse
func (c *ClientWithResponses) GetAppConfigurationItemByIdWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*GetAppConfigurationItemByIdResponse, error) {
	rsp, err := c.GetAppConfigurationItemById(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppConfigurationItemByIdResponse(rsp)
}

// UpdateAppConfigurationItemWithBodyWithResponse request with arbitrary body returning *UpdateAppConfigurationItemResponse
func (c *ClientWithResponses) UpdateAppConfigurationItemWithBodyWithResponse(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppConfigurationItemResponse, error) {
	rsp, err := c.UpdateAppConfigurationItemWithBody(ctx, itemId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppConfigurationItemResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppConfigurationItemWithResponse(ctx context.Context, itemId string, body UpdateAppConfigurationItemJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppConfigurationItemResponse, error) {
	rsp, err := c.UpdateAppConfigurationItem(ctx, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppConfigurationItemResponse(rsp)
}

// BulkCreateAppConfigurationItemsWithBodyWithResponse request with arbitrary body returning *BulkCreateAppConfigurationItemsResponse
func (c *ClientWithResponses) BulkCreateAppConfigurationItemsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateAppConfigurationItemsResponse, error) {
	rsp, err := c.BulkCreateAppConfigurationItemsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateAppConfigurationItemsResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateAppConfigurationItemsWithResponse(ctx context.Context, body BulkCreateAppConfigurationItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateAppConfigurationItemsResponse, error) {
	rsp, err := c.BulkCreateAppConfigurationItems(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateAppConfigurationItemsResponse(rsp)
}

// BulkUpdateAppConfigurationItemsWithBodyWithResponse request with arbitrary body returning *BulkUpdateAppConfigurationItemsResponse
func (c *ClientWithResponses) BulkUpdateAppConfigurationItemsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateAppConfigurationItemsResponse, error) {
	rsp, err := c.BulkUpdateAppConfigurationItemsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateAppConfigurationItemsResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateAppConfigurationItemsWithResponse(ctx context.Context, body BulkUpdateAppConfigurationItemsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateAppConfigurationItemsResponse, error) {
	rsp, err := c.BulkUpdateAppConfigurationItems(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateAppConfigurationItemsResponse(rsp)
}

// CreateAppSessionWithBodyWithResponse request with arbitrary body returning *CreateAppSessionResponse
func (c *ClientWithResponses) CreateAppSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppSessionResponse, error) {
	rsp, err := c.CreateAppSessionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppSessionResponse(rsp)
}

func (c *ClientWithResponses) CreateAppSessionWithResponse(ctx context.Context, body CreateAppSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppSessionResponse, error) {
	rsp, err := c.CreateAppSession(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppSessionResponse(rsp)
}

// GetAppSessionByIdWithResponse request returning *GetAppSessionByIdResponse
func (c *ClientWithResponses) GetAppSessionByIdWithResponse(ctx context.Context, id string, params *GetAppSessionByIdParams, reqEditors ...RequestEditorFn) (*GetAppSessionByIdResponse, error) {
	rsp, err := c.GetAppSessionById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppSessionByIdResponse(rsp)
}

// UpdateAppSessionWithBodyWithResponse request with arbitrary body returning *UpdateAppSessionResponse
func (c *ClientWithResponses) UpdateAppSessionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppSessionResponse, error) {
	rsp, err := c.UpdateAppSessionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppSessionResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppSessionWithResponse(ctx context.Context, id string, body UpdateAppSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppSessionResponse, error) {
	rsp, err := c.UpdateAppSession(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppSessionResponse(rsp)
}

// ListBenchlingAppsWithResponse request returning *ListBenchlingAppsResponse
func (c *ClientWithResponses) ListBenchlingAppsWithResponse(ctx context.Context, params *ListBenchlingAppsParams, reqEditors ...RequestEditorFn) (*ListBenchlingAppsResponse, error) {
	rsp, err := c.ListBenchlingApps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBenchlingAppsResponse(rsp)
}

// CreateBenchlingAppWithBodyWithResponse request with arbitrary body returning *CreateBenchlingAppResponse
func (c *ClientWithResponses) CreateBenchlingAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBenchlingAppResponse, error) {
	rsp, err := c.CreateBenchlingAppWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBenchlingAppResponse(rsp)
}

func (c *ClientWithResponses) CreateBenchlingAppWithResponse(ctx context.Context, body CreateBenchlingAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBenchlingAppResponse, error) {
	rsp, err := c.CreateBenchlingApp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBenchlingAppResponse(rsp)
}

// GetBenchlingAppByIDWithResponse request returning *GetBenchlingAppByIDResponse
func (c *ClientWithResponses) GetBenchlingAppByIDWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetBenchlingAppByIDResponse, error) {
	rsp, err := c.GetBenchlingAppByID(ctx, appId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBenchlingAppByIDResponse(rsp)
}

// PatchBenchlingAppWithBodyWithResponse request with arbitrary body returning *PatchBenchlingAppResponse
func (c *ClientWithResponses) PatchBenchlingAppWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchBenchlingAppResponse, error) {
	rsp, err := c.PatchBenchlingAppWithBody(ctx, appId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchBenchlingAppResponse(rsp)
}

func (c *ClientWithResponses) PatchBenchlingAppWithResponse(ctx context.Context, appId string, body PatchBenchlingAppJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchBenchlingAppResponse, error) {
	rsp, err := c.PatchBenchlingApp(ctx, appId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchBenchlingAppResponse(rsp)
}

// ArchiveBenchlingAppsWithBodyWithResponse request with arbitrary body returning *ArchiveBenchlingAppsResponse
func (c *ClientWithResponses) ArchiveBenchlingAppsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveBenchlingAppsResponse, error) {
	rsp, err := c.ArchiveBenchlingAppsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveBenchlingAppsResponse(rsp)
}

func (c *ClientWithResponses) ArchiveBenchlingAppsWithResponse(ctx context.Context, body ArchiveBenchlingAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveBenchlingAppsResponse, error) {
	rsp, err := c.ArchiveBenchlingApps(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveBenchlingAppsResponse(rsp)
}

// UnarchiveBenchlingAppsWithBodyWithResponse request with arbitrary body returning *UnarchiveBenchlingAppsResponse
func (c *ClientWithResponses) UnarchiveBenchlingAppsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveBenchlingAppsResponse, error) {
	rsp, err := c.UnarchiveBenchlingAppsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveBenchlingAppsResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveBenchlingAppsWithResponse(ctx context.Context, body UnarchiveBenchlingAppsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveBenchlingAppsResponse, error) {
	rsp, err := c.UnarchiveBenchlingApps(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveBenchlingAppsResponse(rsp)
}

// ListAssayResultSchemasWithResponse request returning *ListAssayResultSchemasResponse
func (c *ClientWithResponses) ListAssayResultSchemasWithResponse(ctx context.Context, params *ListAssayResultSchemasParams, reqEditors ...RequestEditorFn) (*ListAssayResultSchemasResponse, error) {
	rsp, err := c.ListAssayResultSchemas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssayResultSchemasResponse(rsp)
}

// GetResultSchemaWithResponse request returning *GetResultSchemaResponse
func (c *ClientWithResponses) GetResultSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetResultSchemaResponse, error) {
	rsp, err := c.GetResultSchema(ctx, schemaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResultSchemaResponse(rsp)
}

// ListAssayResultsWithResponse request returning *ListAssayResultsResponse
func (c *ClientWithResponses) ListAssayResultsWithResponse(ctx context.Context, params *ListAssayResultsParams, reqEditors ...RequestEditorFn) (*ListAssayResultsResponse, error) {
	rsp, err := c.ListAssayResults(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssayResultsResponse(rsp)
}

// CreateAssayResultsWithBodyWithResponse request with arbitrary body returning *CreateAssayResultsResponse
func (c *ClientWithResponses) CreateAssayResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAssayResultsResponse, error) {
	rsp, err := c.CreateAssayResultsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssayResultsResponse(rsp)
}

func (c *ClientWithResponses) CreateAssayResultsWithResponse(ctx context.Context, body CreateAssayResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAssayResultsResponse, error) {
	rsp, err := c.CreateAssayResults(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssayResultsResponse(rsp)
}

// GetAssayResultWithResponse request returning *GetAssayResultResponse
func (c *ClientWithResponses) GetAssayResultWithResponse(ctx context.Context, assayResultId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAssayResultResponse, error) {
	rsp, err := c.GetAssayResult(ctx, assayResultId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssayResultResponse(rsp)
}

// ArchiveAssayResultsWithBodyWithResponse request with arbitrary body returning *ArchiveAssayResultsResponse
func (c *ClientWithResponses) ArchiveAssayResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveAssayResultsResponse, error) {
	rsp, err := c.ArchiveAssayResultsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveAssayResultsResponse(rsp)
}

func (c *ClientWithResponses) ArchiveAssayResultsWithResponse(ctx context.Context, body ArchiveAssayResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveAssayResultsResponse, error) {
	rsp, err := c.ArchiveAssayResults(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveAssayResultsResponse(rsp)
}

// BulkCreateAssayResultsWithBodyWithResponse request with arbitrary body returning *BulkCreateAssayResultsResponse
func (c *ClientWithResponses) BulkCreateAssayResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateAssayResultsResponse, error) {
	rsp, err := c.BulkCreateAssayResultsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateAssayResultsResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateAssayResultsWithResponse(ctx context.Context, body BulkCreateAssayResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateAssayResultsResponse, error) {
	rsp, err := c.BulkCreateAssayResults(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateAssayResultsResponse(rsp)
}

// BulkGetAssayResultsWithResponse request returning *BulkGetAssayResultsResponse
func (c *ClientWithResponses) BulkGetAssayResultsWithResponse(ctx context.Context, params *BulkGetAssayResultsParams, reqEditors ...RequestEditorFn) (*BulkGetAssayResultsResponse, error) {
	rsp, err := c.BulkGetAssayResults(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkGetAssayResultsResponse(rsp)
}

// UnarchiveAssayResultsWithBodyWithResponse request with arbitrary body returning *UnarchiveAssayResultsResponse
func (c *ClientWithResponses) UnarchiveAssayResultsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveAssayResultsResponse, error) {
	rsp, err := c.UnarchiveAssayResultsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveAssayResultsResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveAssayResultsWithResponse(ctx context.Context, body UnarchiveAssayResultsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveAssayResultsResponse, error) {
	rsp, err := c.UnarchiveAssayResults(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveAssayResultsResponse(rsp)
}

// ListAssayRunSchemasWithResponse request returning *ListAssayRunSchemasResponse
func (c *ClientWithResponses) ListAssayRunSchemasWithResponse(ctx context.Context, params *ListAssayRunSchemasParams, reqEditors ...RequestEditorFn) (*ListAssayRunSchemasResponse, error) {
	rsp, err := c.ListAssayRunSchemas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssayRunSchemasResponse(rsp)
}

// GetRunSchemaWithResponse request returning *GetRunSchemaResponse
func (c *ClientWithResponses) GetRunSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetRunSchemaResponse, error) {
	rsp, err := c.GetRunSchema(ctx, schemaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRunSchemaResponse(rsp)
}

// ListAssayRunsWithResponse request returning *ListAssayRunsResponse
func (c *ClientWithResponses) ListAssayRunsWithResponse(ctx context.Context, params *ListAssayRunsParams, reqEditors ...RequestEditorFn) (*ListAssayRunsResponse, error) {
	rsp, err := c.ListAssayRuns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssayRunsResponse(rsp)
}

// CreateAssayRunsWithBodyWithResponse request with arbitrary body returning *CreateAssayRunsResponse
func (c *ClientWithResponses) CreateAssayRunsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAssayRunsResponse, error) {
	rsp, err := c.CreateAssayRunsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssayRunsResponse(rsp)
}

func (c *ClientWithResponses) CreateAssayRunsWithResponse(ctx context.Context, body CreateAssayRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAssayRunsResponse, error) {
	rsp, err := c.CreateAssayRuns(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssayRunsResponse(rsp)
}

// GetAssayRunWithResponse request returning *GetAssayRunResponse
func (c *ClientWithResponses) GetAssayRunWithResponse(ctx context.Context, assayRunId string, reqEditors ...RequestEditorFn) (*GetAssayRunResponse, error) {
	rsp, err := c.GetAssayRun(ctx, assayRunId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssayRunResponse(rsp)
}

// UpdateAssayRunWithBodyWithResponse request with arbitrary body returning *UpdateAssayRunResponse
func (c *ClientWithResponses) UpdateAssayRunWithBodyWithResponse(ctx context.Context, assayRunId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssayRunResponse, error) {
	rsp, err := c.UpdateAssayRunWithBody(ctx, assayRunId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssayRunResponse(rsp)
}

func (c *ClientWithResponses) UpdateAssayRunWithResponse(ctx context.Context, assayRunId string, body UpdateAssayRunJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssayRunResponse, error) {
	rsp, err := c.UpdateAssayRun(ctx, assayRunId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssayRunResponse(rsp)
}

// ListAutomationInputGeneratorsWithResponse request returning *ListAutomationInputGeneratorsResponse
func (c *ClientWithResponses) ListAutomationInputGeneratorsWithResponse(ctx context.Context, assayRunId string, params *ListAutomationInputGeneratorsParams, reqEditors ...RequestEditorFn) (*ListAutomationInputGeneratorsResponse, error) {
	rsp, err := c.ListAutomationInputGenerators(ctx, assayRunId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAutomationInputGeneratorsResponse(rsp)
}

// ListAutomationOutputProcessorsDeprecatedWithResponse request returning *ListAutomationOutputProcessorsDeprecatedResponse
func (c *ClientWithResponses) ListAutomationOutputProcessorsDeprecatedWithResponse(ctx context.Context, assayRunId string, params *ListAutomationOutputProcessorsDeprecatedParams, reqEditors ...RequestEditorFn) (*ListAutomationOutputProcessorsDeprecatedResponse, error) {
	rsp, err := c.ListAutomationOutputProcessorsDeprecated(ctx, assayRunId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAutomationOutputProcessorsDeprecatedResponse(rsp)
}

// ArchiveAssayRunsWithBodyWithResponse request with arbitrary body returning *ArchiveAssayRunsResponse
func (c *ClientWithResponses) ArchiveAssayRunsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveAssayRunsResponse, error) {
	rsp, err := c.ArchiveAssayRunsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveAssayRunsResponse(rsp)
}

func (c *ClientWithResponses) ArchiveAssayRunsWithResponse(ctx context.Context, body ArchiveAssayRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveAssayRunsResponse, error) {
	rsp, err := c.ArchiveAssayRuns(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveAssayRunsResponse(rsp)
}

// BulkGetAssayRunsWithResponse request returning *BulkGetAssayRunsResponse
func (c *ClientWithResponses) BulkGetAssayRunsWithResponse(ctx context.Context, params *BulkGetAssayRunsParams, reqEditors ...RequestEditorFn) (*BulkGetAssayRunsResponse, error) {
	rsp, err := c.BulkGetAssayRuns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkGetAssayRunsResponse(rsp)
}

// UnarchiveAssayRunsWithBodyWithResponse request with arbitrary body returning *UnarchiveAssayRunsResponse
func (c *ClientWithResponses) UnarchiveAssayRunsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveAssayRunsResponse, error) {
	rsp, err := c.UnarchiveAssayRunsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveAssayRunsResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveAssayRunsWithResponse(ctx context.Context, body UnarchiveAssayRunsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveAssayRunsResponse, error) {
	rsp, err := c.UnarchiveAssayRuns(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveAssayRunsResponse(rsp)
}

// GetLabAutomationTransformWithResponse request returning *GetLabAutomationTransformResponse
func (c *ClientWithResponses) GetLabAutomationTransformWithResponse(ctx context.Context, transformId string, reqEditors ...RequestEditorFn) (*GetLabAutomationTransformResponse, error) {
	rsp, err := c.GetLabAutomationTransform(ctx, transformId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLabAutomationTransformResponse(rsp)
}

// UpdateLabAutomationTransformWithBodyWithResponse request with arbitrary body returning *UpdateLabAutomationTransformResponse
func (c *ClientWithResponses) UpdateLabAutomationTransformWithBodyWithResponse(ctx context.Context, transformId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLabAutomationTransformResponse, error) {
	rsp, err := c.UpdateLabAutomationTransformWithBody(ctx, transformId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLabAutomationTransformResponse(rsp)
}

func (c *ClientWithResponses) UpdateLabAutomationTransformWithResponse(ctx context.Context, transformId string, body UpdateLabAutomationTransformJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLabAutomationTransformResponse, error) {
	rsp, err := c.UpdateLabAutomationTransform(ctx, transformId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLabAutomationTransformResponse(rsp)
}

// GetAutomationInputGeneratorWithResponse request returning *GetAutomationInputGeneratorResponse
func (c *ClientWithResponses) GetAutomationInputGeneratorWithResponse(ctx context.Context, inputGeneratorId string, reqEditors ...RequestEditorFn) (*GetAutomationInputGeneratorResponse, error) {
	rsp, err := c.GetAutomationInputGenerator(ctx, inputGeneratorId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAutomationInputGeneratorResponse(rsp)
}

// UpdateAutomationInputGeneratorWithBodyWithResponse request with arbitrary body returning *UpdateAutomationInputGeneratorResponse
func (c *ClientWithResponses) UpdateAutomationInputGeneratorWithBodyWithResponse(ctx context.Context, inputGeneratorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAutomationInputGeneratorResponse, error) {
	rsp, err := c.UpdateAutomationInputGeneratorWithBody(ctx, inputGeneratorId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAutomationInputGeneratorResponse(rsp)
}

func (c *ClientWithResponses) UpdateAutomationInputGeneratorWithResponse(ctx context.Context, inputGeneratorId string, body UpdateAutomationInputGeneratorJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAutomationInputGeneratorResponse, error) {
	rsp, err := c.UpdateAutomationInputGenerator(ctx, inputGeneratorId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAutomationInputGeneratorResponse(rsp)
}

// GenerateInputWithAutomationInputGeneratorWithResponse request returning *GenerateInputWithAutomationInputGeneratorResponse
func (c *ClientWithResponses) GenerateInputWithAutomationInputGeneratorWithResponse(ctx context.Context, inputGeneratorId string, reqEditors ...RequestEditorFn) (*GenerateInputWithAutomationInputGeneratorResponse, error) {
	rsp, err := c.GenerateInputWithAutomationInputGenerator(ctx, inputGeneratorId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateInputWithAutomationInputGeneratorResponse(rsp)
}

// ListAutomationOutputProcessorsWithResponse request returning *ListAutomationOutputProcessorsResponse
func (c *ClientWithResponses) ListAutomationOutputProcessorsWithResponse(ctx context.Context, params *ListAutomationOutputProcessorsParams, reqEditors ...RequestEditorFn) (*ListAutomationOutputProcessorsResponse, error) {
	rsp, err := c.ListAutomationOutputProcessors(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAutomationOutputProcessorsResponse(rsp)
}

// CreateAutomationOutputProcessorWithBodyWithResponse request with arbitrary body returning *CreateAutomationOutputProcessorResponse
func (c *ClientWithResponses) CreateAutomationOutputProcessorWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAutomationOutputProcessorResponse, error) {
	rsp, err := c.CreateAutomationOutputProcessorWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAutomationOutputProcessorResponse(rsp)
}

func (c *ClientWithResponses) CreateAutomationOutputProcessorWithResponse(ctx context.Context, body CreateAutomationOutputProcessorJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAutomationOutputProcessorResponse, error) {
	rsp, err := c.CreateAutomationOutputProcessor(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAutomationOutputProcessorResponse(rsp)
}

// GetAutomationOutputProcessorWithResponse request returning *GetAutomationOutputProcessorResponse
func (c *ClientWithResponses) GetAutomationOutputProcessorWithResponse(ctx context.Context, outputProcessorId string, reqEditors ...RequestEditorFn) (*GetAutomationOutputProcessorResponse, error) {
	rsp, err := c.GetAutomationOutputProcessor(ctx, outputProcessorId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAutomationOutputProcessorResponse(rsp)
}

// UpdateAutomationOutputProcessorWithBodyWithResponse request with arbitrary body returning *UpdateAutomationOutputProcessorResponse
func (c *ClientWithResponses) UpdateAutomationOutputProcessorWithBodyWithResponse(ctx context.Context, outputProcessorId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAutomationOutputProcessorResponse, error) {
	rsp, err := c.UpdateAutomationOutputProcessorWithBody(ctx, outputProcessorId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAutomationOutputProcessorResponse(rsp)
}

func (c *ClientWithResponses) UpdateAutomationOutputProcessorWithResponse(ctx context.Context, outputProcessorId string, body UpdateAutomationOutputProcessorJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAutomationOutputProcessorResponse, error) {
	rsp, err := c.UpdateAutomationOutputProcessor(ctx, outputProcessorId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAutomationOutputProcessorResponse(rsp)
}

// ProcessOutputWithAutomationOutputProcessorWithResponse request returning *ProcessOutputWithAutomationOutputProcessorResponse
func (c *ClientWithResponses) ProcessOutputWithAutomationOutputProcessorWithResponse(ctx context.Context, outputProcessorId string, reqEditors ...RequestEditorFn) (*ProcessOutputWithAutomationOutputProcessorResponse, error) {
	rsp, err := c.ProcessOutputWithAutomationOutputProcessor(ctx, outputProcessorId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProcessOutputWithAutomationOutputProcessorResponse(rsp)
}

// ArchiveAutomationOutputProcessorsWithBodyWithResponse request with arbitrary body returning *ArchiveAutomationOutputProcessorsResponse
func (c *ClientWithResponses) ArchiveAutomationOutputProcessorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveAutomationOutputProcessorsResponse, error) {
	rsp, err := c.ArchiveAutomationOutputProcessorsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveAutomationOutputProcessorsResponse(rsp)
}

func (c *ClientWithResponses) ArchiveAutomationOutputProcessorsWithResponse(ctx context.Context, body ArchiveAutomationOutputProcessorsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveAutomationOutputProcessorsResponse, error) {
	rsp, err := c.ArchiveAutomationOutputProcessors(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveAutomationOutputProcessorsResponse(rsp)
}

// UnarchiveAutomationOutputProcessorsWithBodyWithResponse request with arbitrary body returning *UnarchiveAutomationOutputProcessorsResponse
func (c *ClientWithResponses) UnarchiveAutomationOutputProcessorsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveAutomationOutputProcessorsResponse, error) {
	rsp, err := c.UnarchiveAutomationOutputProcessorsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveAutomationOutputProcessorsResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveAutomationOutputProcessorsWithResponse(ctx context.Context, body UnarchiveAutomationOutputProcessorsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveAutomationOutputProcessorsResponse, error) {
	rsp, err := c.UnarchiveAutomationOutputProcessors(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveAutomationOutputProcessorsResponse(rsp)
}

// ListBatchSchemasWithResponse request returning *ListBatchSchemasResponse
func (c *ClientWithResponses) ListBatchSchemasWithResponse(ctx context.Context, params *ListBatchSchemasParams, reqEditors ...RequestEditorFn) (*ListBatchSchemasResponse, error) {
	rsp, err := c.ListBatchSchemas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchSchemasResponse(rsp)
}

// GetBatchSchemaWithResponse request returning *GetBatchSchemaResponse
func (c *ClientWithResponses) GetBatchSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetBatchSchemaResponse, error) {
	rsp, err := c.GetBatchSchema(ctx, schemaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBatchSchemaResponse(rsp)
}

// ListBatchesWithResponse request returning *ListBatchesResponse
func (c *ClientWithResponses) ListBatchesWithResponse(ctx context.Context, params *ListBatchesParams, reqEditors ...RequestEditorFn) (*ListBatchesResponse, error) {
	rsp, err := c.ListBatches(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchesResponse(rsp)
}

// CreateBatchWithBodyWithResponse request with arbitrary body returning *CreateBatchResponse
func (c *ClientWithResponses) CreateBatchWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBatchResponse, error) {
	rsp, err := c.CreateBatchWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBatchResponse(rsp)
}

func (c *ClientWithResponses) CreateBatchWithResponse(ctx context.Context, body CreateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBatchResponse, error) {
	rsp, err := c.CreateBatch(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBatchResponse(rsp)
}

// GetBatchWithResponse request returning *GetBatchResponse
func (c *ClientWithResponses) GetBatchWithResponse(ctx context.Context, batchId string, reqEditors ...RequestEditorFn) (*GetBatchResponse, error) {
	rsp, err := c.GetBatch(ctx, batchId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBatchResponse(rsp)
}

// UpdateBatchWithBodyWithResponse request with arbitrary body returning *UpdateBatchResponse
func (c *ClientWithResponses) UpdateBatchWithBodyWithResponse(ctx context.Context, batchId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBatchResponse, error) {
	rsp, err := c.UpdateBatchWithBody(ctx, batchId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBatchResponse(rsp)
}

func (c *ClientWithResponses) UpdateBatchWithResponse(ctx context.Context, batchId string, body UpdateBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBatchResponse, error) {
	rsp, err := c.UpdateBatch(ctx, batchId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBatchResponse(rsp)
}

// ArchiveBatchesWithBodyWithResponse request with arbitrary body returning *ArchiveBatchesResponse
func (c *ClientWithResponses) ArchiveBatchesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveBatchesResponse, error) {
	rsp, err := c.ArchiveBatchesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveBatchesResponse(rsp)
}

func (c *ClientWithResponses) ArchiveBatchesWithResponse(ctx context.Context, body ArchiveBatchesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveBatchesResponse, error) {
	rsp, err := c.ArchiveBatches(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveBatchesResponse(rsp)
}

// BulkGetBatchesWithResponse request returning *BulkGetBatchesResponse
func (c *ClientWithResponses) BulkGetBatchesWithResponse(ctx context.Context, params *BulkGetBatchesParams, reqEditors ...RequestEditorFn) (*BulkGetBatchesResponse, error) {
	rsp, err := c.BulkGetBatches(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkGetBatchesResponse(rsp)
}

// UnarchiveBatchesWithBodyWithResponse request with arbitrary body returning *UnarchiveBatchesResponse
func (c *ClientWithResponses) UnarchiveBatchesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveBatchesResponse, error) {
	rsp, err := c.UnarchiveBatchesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveBatchesResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveBatchesWithResponse(ctx context.Context, body UnarchiveBatchesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveBatchesResponse, error) {
	rsp, err := c.UnarchiveBatches(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveBatchesResponse(rsp)
}

// CreateBlobWithBodyWithResponse request with arbitrary body returning *CreateBlobResponse
func (c *ClientWithResponses) CreateBlobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBlobResponse, error) {
	rsp, err := c.CreateBlobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBlobResponse(rsp)
}

func (c *ClientWithResponses) CreateBlobWithResponse(ctx context.Context, body CreateBlobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBlobResponse, error) {
	rsp, err := c.CreateBlob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBlobResponse(rsp)
}

// GetBlobWithResponse request returning *GetBlobResponse
func (c *ClientWithResponses) GetBlobWithResponse(ctx context.Context, blobId string, params *GetBlobParams, reqEditors ...RequestEditorFn) (*GetBlobResponse, error) {
	rsp, err := c.GetBlob(ctx, blobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlobResponse(rsp)
}

// GetBlobFileWithResponse request returning *GetBlobFileResponse
func (c *ClientWithResponses) GetBlobFileWithResponse(ctx context.Context, blobId string, reqEditors ...RequestEditorFn) (*GetBlobFileResponse, error) {
	rsp, err := c.GetBlobFile(ctx, blobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlobFileResponse(rsp)
}

// GetBlobUrlWithResponse request returning *GetBlobUrlResponse
func (c *ClientWithResponses) GetBlobUrlWithResponse(ctx context.Context, blobId string, reqEditors ...RequestEditorFn) (*GetBlobUrlResponse, error) {
	rsp, err := c.GetBlobUrl(ctx, blobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBlobUrlResponse(rsp)
}

// CreateBlobPartWithBodyWithResponse request with arbitrary body returning *CreateBlobPartResponse
func (c *ClientWithResponses) CreateBlobPartWithBodyWithResponse(ctx context.Context, blobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBlobPartResponse, error) {
	rsp, err := c.CreateBlobPartWithBody(ctx, blobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBlobPartResponse(rsp)
}

func (c *ClientWithResponses) CreateBlobPartWithResponse(ctx context.Context, blobId string, body CreateBlobPartJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBlobPartResponse, error) {
	rsp, err := c.CreateBlobPart(ctx, blobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBlobPartResponse(rsp)
}

// AbortMultipartBlobWithResponse request returning *AbortMultipartBlobResponse
func (c *ClientWithResponses) AbortMultipartBlobWithResponse(ctx context.Context, blobId string, reqEditors ...RequestEditorFn) (*AbortMultipartBlobResponse, error) {
	rsp, err := c.AbortMultipartBlob(ctx, blobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAbortMultipartBlobResponse(rsp)
}

// CompleteMultipartBlobWithBodyWithResponse request with arbitrary body returning *CompleteMultipartBlobResponse
func (c *ClientWithResponses) CompleteMultipartBlobWithBodyWithResponse(ctx context.Context, blobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CompleteMultipartBlobResponse, error) {
	rsp, err := c.CompleteMultipartBlobWithBody(ctx, blobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteMultipartBlobResponse(rsp)
}

func (c *ClientWithResponses) CompleteMultipartBlobWithResponse(ctx context.Context, blobId string, body CompleteMultipartBlobJSONRequestBody, reqEditors ...RequestEditorFn) (*CompleteMultipartBlobResponse, error) {
	rsp, err := c.CompleteMultipartBlob(ctx, blobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompleteMultipartBlobResponse(rsp)
}

// BulkGetBlobsWithResponse request returning *BulkGetBlobsResponse
func (c *ClientWithResponses) BulkGetBlobsWithResponse(ctx context.Context, params *BulkGetBlobsParams, reqEditors ...RequestEditorFn) (*BulkGetBlobsResponse, error) {
	rsp, err := c.BulkGetBlobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkGetBlobsResponse(rsp)
}

// CreateMultipartBlobWithBodyWithResponse request with arbitrary body returning *CreateMultipartBlobResponse
func (c *ClientWithResponses) CreateMultipartBlobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMultipartBlobResponse, error) {
	rsp, err := c.CreateMultipartBlobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMultipartBlobResponse(rsp)
}

func (c *ClientWithResponses) CreateMultipartBlobWithResponse(ctx context.Context, body CreateMultipartBlobJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMultipartBlobResponse, error) {
	rsp, err := c.CreateMultipartBlob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMultipartBlobResponse(rsp)
}

// ListBoxSchemasWithResponse request returning *ListBoxSchemasResponse
func (c *ClientWithResponses) ListBoxSchemasWithResponse(ctx context.Context, params *ListBoxSchemasParams, reqEditors ...RequestEditorFn) (*ListBoxSchemasResponse, error) {
	rsp, err := c.ListBoxSchemas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBoxSchemasResponse(rsp)
}

// GetBoxSchemaWithResponse request returning *GetBoxSchemaResponse
func (c *ClientWithResponses) GetBoxSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetBoxSchemaResponse, error) {
	rsp, err := c.GetBoxSchema(ctx, schemaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBoxSchemaResponse(rsp)
}

// ListBoxesWithResponse request returning *ListBoxesResponse
func (c *ClientWithResponses) ListBoxesWithResponse(ctx context.Context, params *ListBoxesParams, reqEditors ...RequestEditorFn) (*ListBoxesResponse, error) {
	rsp, err := c.ListBoxes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBoxesResponse(rsp)
}

// CreateBoxWithBodyWithResponse request with arbitrary body returning *CreateBoxResponse
func (c *ClientWithResponses) CreateBoxWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBoxResponse, error) {
	rsp, err := c.CreateBoxWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBoxResponse(rsp)
}

func (c *ClientWithResponses) CreateBoxWithResponse(ctx context.Context, body CreateBoxJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBoxResponse, error) {
	rsp, err := c.CreateBox(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBoxResponse(rsp)
}

// GetBoxWithResponse request returning *GetBoxResponse
func (c *ClientWithResponses) GetBoxWithResponse(ctx context.Context, boxId string, reqEditors ...RequestEditorFn) (*GetBoxResponse, error) {
	rsp, err := c.GetBox(ctx, boxId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBoxResponse(rsp)
}

// UpdateBoxWithBodyWithResponse request with arbitrary body returning *UpdateBoxResponse
func (c *ClientWithResponses) UpdateBoxWithBodyWithResponse(ctx context.Context, boxId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateBoxResponse, error) {
	rsp, err := c.UpdateBoxWithBody(ctx, boxId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBoxResponse(rsp)
}

func (c *ClientWithResponses) UpdateBoxWithResponse(ctx context.Context, boxId string, body UpdateBoxJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateBoxResponse, error) {
	rsp, err := c.UpdateBox(ctx, boxId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateBoxResponse(rsp)
}

// ListBoxContentsWithResponse request returning *ListBoxContentsResponse
func (c *ClientWithResponses) ListBoxContentsWithResponse(ctx context.Context, boxId string, params *ListBoxContentsParams, reqEditors ...RequestEditorFn) (*ListBoxContentsResponse, error) {
	rsp, err := c.ListBoxContents(ctx, boxId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBoxContentsResponse(rsp)
}

// ArchiveBoxesWithBodyWithResponse request with arbitrary body returning *ArchiveBoxesResponse
func (c *ClientWithResponses) ArchiveBoxesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveBoxesResponse, error) {
	rsp, err := c.ArchiveBoxesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveBoxesResponse(rsp)
}

func (c *ClientWithResponses) ArchiveBoxesWithResponse(ctx context.Context, body ArchiveBoxesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveBoxesResponse, error) {
	rsp, err := c.ArchiveBoxes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveBoxesResponse(rsp)
}

// BulkGetBoxesWithResponse request returning *BulkGetBoxesResponse
func (c *ClientWithResponses) BulkGetBoxesWithResponse(ctx context.Context, params *BulkGetBoxesParams, reqEditors ...RequestEditorFn) (*BulkGetBoxesResponse, error) {
	rsp, err := c.BulkGetBoxes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkGetBoxesResponse(rsp)
}

// UnarchiveBoxesWithBodyWithResponse request with arbitrary body returning *UnarchiveBoxesResponse
func (c *ClientWithResponses) UnarchiveBoxesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveBoxesResponse, error) {
	rsp, err := c.UnarchiveBoxesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveBoxesResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveBoxesWithResponse(ctx context.Context, body UnarchiveBoxesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveBoxesResponse, error) {
	rsp, err := c.UnarchiveBoxes(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveBoxesResponse(rsp)
}

// ListContainerSchemasWithResponse request returning *ListContainerSchemasResponse
func (c *ClientWithResponses) ListContainerSchemasWithResponse(ctx context.Context, params *ListContainerSchemasParams, reqEditors ...RequestEditorFn) (*ListContainerSchemasResponse, error) {
	rsp, err := c.ListContainerSchemas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListContainerSchemasResponse(rsp)
}

// GetContainerSchemaWithResponse request returning *GetContainerSchemaResponse
func (c *ClientWithResponses) GetContainerSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetContainerSchemaResponse, error) {
	rsp, err := c.GetContainerSchema(ctx, schemaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerSchemaResponse(rsp)
}

// ListContainersWithResponse request returning *ListContainersResponse
func (c *ClientWithResponses) ListContainersWithResponse(ctx context.Context, params *ListContainersParams, reqEditors ...RequestEditorFn) (*ListContainersResponse, error) {
	rsp, err := c.ListContainers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListContainersResponse(rsp)
}

// CreateContainerWithBodyWithResponse request with arbitrary body returning *CreateContainerResponse
func (c *ClientWithResponses) CreateContainerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateContainerResponse, error) {
	rsp, err := c.CreateContainerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateContainerResponse(rsp)
}

func (c *ClientWithResponses) CreateContainerWithResponse(ctx context.Context, body CreateContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateContainerResponse, error) {
	rsp, err := c.CreateContainer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateContainerResponse(rsp)
}

// GetContainerWithResponse request returning *GetContainerResponse
func (c *ClientWithResponses) GetContainerWithResponse(ctx context.Context, containerId string, params *GetContainerParams, reqEditors ...RequestEditorFn) (*GetContainerResponse, error) {
	rsp, err := c.GetContainer(ctx, containerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerResponse(rsp)
}

// UpdateContainerWithBodyWithResponse request with arbitrary body returning *UpdateContainerResponse
func (c *ClientWithResponses) UpdateContainerWithBodyWithResponse(ctx context.Context, containerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateContainerResponse, error) {
	rsp, err := c.UpdateContainerWithBody(ctx, containerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateContainerResponse(rsp)
}

func (c *ClientWithResponses) UpdateContainerWithResponse(ctx context.Context, containerId string, body UpdateContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateContainerResponse, error) {
	rsp, err := c.UpdateContainer(ctx, containerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateContainerResponse(rsp)
}

// ListContainerContentsWithResponse request returning *ListContainerContentsResponse
func (c *ClientWithResponses) ListContainerContentsWithResponse(ctx context.Context, containerId string, reqEditors ...RequestEditorFn) (*ListContainerContentsResponse, error) {
	rsp, err := c.ListContainerContents(ctx, containerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListContainerContentsResponse(rsp)
}

// DeleteContainerContentWithResponse request returning *DeleteContainerContentResponse
func (c *ClientWithResponses) DeleteContainerContentWithResponse(ctx context.Context, containerId string, containableId string, reqEditors ...RequestEditorFn) (*DeleteContainerContentResponse, error) {
	rsp, err := c.DeleteContainerContent(ctx, containerId, containableId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteContainerContentResponse(rsp)
}

// GetContainerContentWithResponse request returning *GetContainerContentResponse
func (c *ClientWithResponses) GetContainerContentWithResponse(ctx context.Context, containerId string, containableId string, reqEditors ...RequestEditorFn) (*GetContainerContentResponse, error) {
	rsp, err := c.GetContainerContent(ctx, containerId, containableId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerContentResponse(rsp)
}

// UpdateContainerContentWithBodyWithResponse request with arbitrary body returning *UpdateContainerContentResponse
func (c *ClientWithResponses) UpdateContainerContentWithBodyWithResponse(ctx context.Context, containerId string, containableId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateContainerContentResponse, error) {
	rsp, err := c.UpdateContainerContentWithBody(ctx, containerId, containableId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateContainerContentResponse(rsp)
}

func (c *ClientWithResponses) UpdateContainerContentWithResponse(ctx context.Context, containerId string, containableId string, body UpdateContainerContentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateContainerContentResponse, error) {
	rsp, err := c.UpdateContainerContent(ctx, containerId, containableId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateContainerContentResponse(rsp)
}

// TransferIntoContainerWithBodyWithResponse request with arbitrary body returning *TransferIntoContainerResponse
func (c *ClientWithResponses) TransferIntoContainerWithBodyWithResponse(ctx context.Context, destinationContainerId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferIntoContainerResponse, error) {
	rsp, err := c.TransferIntoContainerWithBody(ctx, destinationContainerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferIntoContainerResponse(rsp)
}

func (c *ClientWithResponses) TransferIntoContainerWithResponse(ctx context.Context, destinationContainerId string, body TransferIntoContainerJSONRequestBody, reqEditors ...RequestEditorFn) (*TransferIntoContainerResponse, error) {
	rsp, err := c.TransferIntoContainer(ctx, destinationContainerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferIntoContainerResponse(rsp)
}

// ArchiveContainersWithBodyWithResponse request with arbitrary body returning *ArchiveContainersResponse
func (c *ClientWithResponses) ArchiveContainersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveContainersResponse, error) {
	rsp, err := c.ArchiveContainersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveContainersResponse(rsp)
}

func (c *ClientWithResponses) ArchiveContainersWithResponse(ctx context.Context, body ArchiveContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveContainersResponse, error) {
	rsp, err := c.ArchiveContainers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveContainersResponse(rsp)
}

// BulkCreateContainersWithBodyWithResponse request with arbitrary body returning *BulkCreateContainersResponse
func (c *ClientWithResponses) BulkCreateContainersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateContainersResponse, error) {
	rsp, err := c.BulkCreateContainersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateContainersResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateContainersWithResponse(ctx context.Context, body BulkCreateContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateContainersResponse, error) {
	rsp, err := c.BulkCreateContainers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateContainersResponse(rsp)
}

// BulkGetContainersWithResponse request returning *BulkGetContainersResponse
func (c *ClientWithResponses) BulkGetContainersWithResponse(ctx context.Context, params *BulkGetContainersParams, reqEditors ...RequestEditorFn) (*BulkGetContainersResponse, error) {
	rsp, err := c.BulkGetContainers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkGetContainersResponse(rsp)
}

// BulkUpdateContainersWithBodyWithResponse request with arbitrary body returning *BulkUpdateContainersResponse
func (c *ClientWithResponses) BulkUpdateContainersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateContainersResponse, error) {
	rsp, err := c.BulkUpdateContainersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateContainersResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateContainersWithResponse(ctx context.Context, body BulkUpdateContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateContainersResponse, error) {
	rsp, err := c.BulkUpdateContainers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateContainersResponse(rsp)
}

// CheckinContainersWithBodyWithResponse request with arbitrary body returning *CheckinContainersResponse
func (c *ClientWithResponses) CheckinContainersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckinContainersResponse, error) {
	rsp, err := c.CheckinContainersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckinContainersResponse(rsp)
}

func (c *ClientWithResponses) CheckinContainersWithResponse(ctx context.Context, body CheckinContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckinContainersResponse, error) {
	rsp, err := c.CheckinContainers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckinContainersResponse(rsp)
}

// CheckoutContainersWithBodyWithResponse request with arbitrary body returning *CheckoutContainersResponse
func (c *ClientWithResponses) CheckoutContainersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckoutContainersResponse, error) {
	rsp, err := c.CheckoutContainersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckoutContainersResponse(rsp)
}

func (c *ClientWithResponses) CheckoutContainersWithResponse(ctx context.Context, body CheckoutContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckoutContainersResponse, error) {
	rsp, err := c.CheckoutContainers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckoutContainersResponse(rsp)
}

// PrintLabelsWithBodyWithResponse request with arbitrary body returning *PrintLabelsResponse
func (c *ClientWithResponses) PrintLabelsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PrintLabelsResponse, error) {
	rsp, err := c.PrintLabelsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrintLabelsResponse(rsp)
}

func (c *ClientWithResponses) PrintLabelsWithResponse(ctx context.Context, body PrintLabelsJSONRequestBody, reqEditors ...RequestEditorFn) (*PrintLabelsResponse, error) {
	rsp, err := c.PrintLabels(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePrintLabelsResponse(rsp)
}

// ReserveContainersWithBodyWithResponse request with arbitrary body returning *ReserveContainersResponse
func (c *ClientWithResponses) ReserveContainersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReserveContainersResponse, error) {
	rsp, err := c.ReserveContainersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReserveContainersResponse(rsp)
}

func (c *ClientWithResponses) ReserveContainersWithResponse(ctx context.Context, body ReserveContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*ReserveContainersResponse, error) {
	rsp, err := c.ReserveContainers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReserveContainersResponse(rsp)
}

// UnarchiveContainersWithBodyWithResponse request with arbitrary body returning *UnarchiveContainersResponse
func (c *ClientWithResponses) UnarchiveContainersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveContainersResponse, error) {
	rsp, err := c.UnarchiveContainersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveContainersResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveContainersWithResponse(ctx context.Context, body UnarchiveContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveContainersResponse, error) {
	rsp, err := c.UnarchiveContainers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveContainersResponse(rsp)
}

// ListCustomEntitiesWithResponse request returning *ListCustomEntitiesResponse
func (c *ClientWithResponses) ListCustomEntitiesWithResponse(ctx context.Context, params *ListCustomEntitiesParams, reqEditors ...RequestEditorFn) (*ListCustomEntitiesResponse, error) {
	rsp, err := c.ListCustomEntities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomEntitiesResponse(rsp)
}

// CreateCustomEntityWithBodyWithResponse request with arbitrary body returning *CreateCustomEntityResponse
func (c *ClientWithResponses) CreateCustomEntityWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomEntityResponse, error) {
	rsp, err := c.CreateCustomEntityWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomEntityResponse(rsp)
}

func (c *ClientWithResponses) CreateCustomEntityWithResponse(ctx context.Context, body CreateCustomEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomEntityResponse, error) {
	rsp, err := c.CreateCustomEntity(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomEntityResponse(rsp)
}

// GetCustomEntityWithResponse request returning *GetCustomEntityResponse
func (c *ClientWithResponses) GetCustomEntityWithResponse(ctx context.Context, customEntityId string, params *GetCustomEntityParams, reqEditors ...RequestEditorFn) (*GetCustomEntityResponse, error) {
	rsp, err := c.GetCustomEntity(ctx, customEntityId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomEntityResponse(rsp)
}

// UpdateCustomEntityWithBodyWithResponse request with arbitrary body returning *UpdateCustomEntityResponse
func (c *ClientWithResponses) UpdateCustomEntityWithBodyWithResponse(ctx context.Context, customEntityId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomEntityResponse, error) {
	rsp, err := c.UpdateCustomEntityWithBody(ctx, customEntityId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomEntityResponse(rsp)
}

func (c *ClientWithResponses) UpdateCustomEntityWithResponse(ctx context.Context, customEntityId string, body UpdateCustomEntityJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomEntityResponse, error) {
	rsp, err := c.UpdateCustomEntity(ctx, customEntityId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomEntityResponse(rsp)
}

// ArchiveCustomEntitiesWithBodyWithResponse request with arbitrary body returning *ArchiveCustomEntitiesResponse
func (c *ClientWithResponses) ArchiveCustomEntitiesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveCustomEntitiesResponse, error) {
	rsp, err := c.ArchiveCustomEntitiesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveCustomEntitiesResponse(rsp)
}

func (c *ClientWithResponses) ArchiveCustomEntitiesWithResponse(ctx context.Context, body ArchiveCustomEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveCustomEntitiesResponse, error) {
	rsp, err := c.ArchiveCustomEntities(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveCustomEntitiesResponse(rsp)
}

// BulkCreateCustomEntitiesWithBodyWithResponse request with arbitrary body returning *BulkCreateCustomEntitiesResponse
func (c *ClientWithResponses) BulkCreateCustomEntitiesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateCustomEntitiesResponse, error) {
	rsp, err := c.BulkCreateCustomEntitiesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateCustomEntitiesResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateCustomEntitiesWithResponse(ctx context.Context, body BulkCreateCustomEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateCustomEntitiesResponse, error) {
	rsp, err := c.BulkCreateCustomEntities(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateCustomEntitiesResponse(rsp)
}

// BulkGetCustomEntitiesWithResponse request returning *BulkGetCustomEntitiesResponse
func (c *ClientWithResponses) BulkGetCustomEntitiesWithResponse(ctx context.Context, params *BulkGetCustomEntitiesParams, reqEditors ...RequestEditorFn) (*BulkGetCustomEntitiesResponse, error) {
	rsp, err := c.BulkGetCustomEntities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkGetCustomEntitiesResponse(rsp)
}

// BulkUpdateCustomEntitiesWithBodyWithResponse request with arbitrary body returning *BulkUpdateCustomEntitiesResponse
func (c *ClientWithResponses) BulkUpdateCustomEntitiesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateCustomEntitiesResponse, error) {
	rsp, err := c.BulkUpdateCustomEntitiesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateCustomEntitiesResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateCustomEntitiesWithResponse(ctx context.Context, body BulkUpdateCustomEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateCustomEntitiesResponse, error) {
	rsp, err := c.BulkUpdateCustomEntities(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateCustomEntitiesResponse(rsp)
}

// UnarchiveCustomEntitiesWithBodyWithResponse request with arbitrary body returning *UnarchiveCustomEntitiesResponse
func (c *ClientWithResponses) UnarchiveCustomEntitiesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveCustomEntitiesResponse, error) {
	rsp, err := c.UnarchiveCustomEntitiesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveCustomEntitiesResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveCustomEntitiesWithResponse(ctx context.Context, body UnarchiveCustomEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveCustomEntitiesResponse, error) {
	rsp, err := c.UnarchiveCustomEntities(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveCustomEntitiesResponse(rsp)
}

// ListCustomNotationsWithResponse request returning *ListCustomNotationsResponse
func (c *ClientWithResponses) ListCustomNotationsWithResponse(ctx context.Context, params *ListCustomNotationsParams, reqEditors ...RequestEditorFn) (*ListCustomNotationsResponse, error) {
	rsp, err := c.ListCustomNotations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomNotationsResponse(rsp)
}

// ListDNAAlignmentsWithResponse request returning *ListDNAAlignmentsResponse
func (c *ClientWithResponses) ListDNAAlignmentsWithResponse(ctx context.Context, params *ListDNAAlignmentsParams, reqEditors ...RequestEditorFn) (*ListDNAAlignmentsResponse, error) {
	rsp, err := c.ListDNAAlignments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDNAAlignmentsResponse(rsp)
}

// DeleteDNAAlignmentWithResponse request returning *DeleteDNAAlignmentResponse
func (c *ClientWithResponses) DeleteDNAAlignmentWithResponse(ctx context.Context, dnaAlignmentId string, reqEditors ...RequestEditorFn) (*DeleteDNAAlignmentResponse, error) {
	rsp, err := c.DeleteDNAAlignment(ctx, dnaAlignmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDNAAlignmentResponse(rsp)
}

// GetDNAAlignmentWithResponse request returning *GetDNAAlignmentResponse
func (c *ClientWithResponses) GetDNAAlignmentWithResponse(ctx context.Context, dnaAlignmentId string, reqEditors ...RequestEditorFn) (*GetDNAAlignmentResponse, error) {
	rsp, err := c.GetDNAAlignment(ctx, dnaAlignmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDNAAlignmentResponse(rsp)
}

// CreateDnaConsensusAlignmentWithBodyWithResponse request with arbitrary body returning *CreateDnaConsensusAlignmentResponse
func (c *ClientWithResponses) CreateDnaConsensusAlignmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDnaConsensusAlignmentResponse, error) {
	rsp, err := c.CreateDnaConsensusAlignmentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDnaConsensusAlignmentResponse(rsp)
}

func (c *ClientWithResponses) CreateDnaConsensusAlignmentWithResponse(ctx context.Context, body CreateDnaConsensusAlignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDnaConsensusAlignmentResponse, error) {
	rsp, err := c.CreateDnaConsensusAlignment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDnaConsensusAlignmentResponse(rsp)
}

// CreateDnaTemplateAlignmentWithBodyWithResponse request with arbitrary body returning *CreateDnaTemplateAlignmentResponse
func (c *ClientWithResponses) CreateDnaTemplateAlignmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDnaTemplateAlignmentResponse, error) {
	rsp, err := c.CreateDnaTemplateAlignmentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDnaTemplateAlignmentResponse(rsp)
}

func (c *ClientWithResponses) CreateDnaTemplateAlignmentWithResponse(ctx context.Context, body CreateDnaTemplateAlignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDnaTemplateAlignmentResponse, error) {
	rsp, err := c.CreateDnaTemplateAlignment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDnaTemplateAlignmentResponse(rsp)
}

// ListDNAOligosWithResponse request returning *ListDNAOligosResponse
func (c *ClientWithResponses) ListDNAOligosWithResponse(ctx context.Context, params *ListDNAOligosParams, reqEditors ...RequestEditorFn) (*ListDNAOligosResponse, error) {
	rsp, err := c.ListDNAOligos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDNAOligosResponse(rsp)
}

// CreateDNAOligoWithBodyWithResponse request with arbitrary body returning *CreateDNAOligoResponse
func (c *ClientWithResponses) CreateDNAOligoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDNAOligoResponse, error) {
	rsp, err := c.CreateDNAOligoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDNAOligoResponse(rsp)
}

func (c *ClientWithResponses) CreateDNAOligoWithResponse(ctx context.Context, body CreateDNAOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDNAOligoResponse, error) {
	rsp, err := c.CreateDNAOligo(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDNAOligoResponse(rsp)
}

// GetDNAOligoWithResponse request returning *GetDNAOligoResponse
func (c *ClientWithResponses) GetDNAOligoWithResponse(ctx context.Context, oligoId string, params *GetDNAOligoParams, reqEditors ...RequestEditorFn) (*GetDNAOligoResponse, error) {
	rsp, err := c.GetDNAOligo(ctx, oligoId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDNAOligoResponse(rsp)
}

// UpdateDNAOligoWithBodyWithResponse request with arbitrary body returning *UpdateDNAOligoResponse
func (c *ClientWithResponses) UpdateDNAOligoWithBodyWithResponse(ctx context.Context, oligoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDNAOligoResponse, error) {
	rsp, err := c.UpdateDNAOligoWithBody(ctx, oligoId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDNAOligoResponse(rsp)
}

func (c *ClientWithResponses) UpdateDNAOligoWithResponse(ctx context.Context, oligoId string, body UpdateDNAOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDNAOligoResponse, error) {
	rsp, err := c.UpdateDNAOligo(ctx, oligoId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDNAOligoResponse(rsp)
}

// ArchiveDNAOligosWithBodyWithResponse request with arbitrary body returning *ArchiveDNAOligosResponse
func (c *ClientWithResponses) ArchiveDNAOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveDNAOligosResponse, error) {
	rsp, err := c.ArchiveDNAOligosWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveDNAOligosResponse(rsp)
}

func (c *ClientWithResponses) ArchiveDNAOligosWithResponse(ctx context.Context, body ArchiveDNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveDNAOligosResponse, error) {
	rsp, err := c.ArchiveDNAOligos(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveDNAOligosResponse(rsp)
}

// BulkCreateDNAOligosWithBodyWithResponse request with arbitrary body returning *BulkCreateDNAOligosResponse
func (c *ClientWithResponses) BulkCreateDNAOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateDNAOligosResponse, error) {
	rsp, err := c.BulkCreateDNAOligosWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateDNAOligosResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateDNAOligosWithResponse(ctx context.Context, body BulkCreateDNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateDNAOligosResponse, error) {
	rsp, err := c.BulkCreateDNAOligos(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateDNAOligosResponse(rsp)
}

// BulkUpdateDNAOligosWithBodyWithResponse request with arbitrary body returning *BulkUpdateDNAOligosResponse
func (c *ClientWithResponses) BulkUpdateDNAOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateDNAOligosResponse, error) {
	rsp, err := c.BulkUpdateDNAOligosWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateDNAOligosResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateDNAOligosWithResponse(ctx context.Context, body BulkUpdateDNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateDNAOligosResponse, error) {
	rsp, err := c.BulkUpdateDNAOligos(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateDNAOligosResponse(rsp)
}

// UnarchiveDNAOligosWithBodyWithResponse request with arbitrary body returning *UnarchiveDNAOligosResponse
func (c *ClientWithResponses) UnarchiveDNAOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveDNAOligosResponse, error) {
	rsp, err := c.UnarchiveDNAOligosWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveDNAOligosResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveDNAOligosWithResponse(ctx context.Context, body UnarchiveDNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveDNAOligosResponse, error) {
	rsp, err := c.UnarchiveDNAOligos(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveDNAOligosResponse(rsp)
}

// ListDNASequencesWithResponse request returning *ListDNASequencesResponse
func (c *ClientWithResponses) ListDNASequencesWithResponse(ctx context.Context, params *ListDNASequencesParams, reqEditors ...RequestEditorFn) (*ListDNASequencesResponse, error) {
	rsp, err := c.ListDNASequences(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDNASequencesResponse(rsp)
}

// CreateDNASequenceWithBodyWithResponse request with arbitrary body returning *CreateDNASequenceResponse
func (c *ClientWithResponses) CreateDNASequenceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDNASequenceResponse, error) {
	rsp, err := c.CreateDNASequenceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDNASequenceResponse(rsp)
}

func (c *ClientWithResponses) CreateDNASequenceWithResponse(ctx context.Context, body CreateDNASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDNASequenceResponse, error) {
	rsp, err := c.CreateDNASequence(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDNASequenceResponse(rsp)
}

// GetDNASequenceWithResponse request returning *GetDNASequenceResponse
func (c *ClientWithResponses) GetDNASequenceWithResponse(ctx context.Context, dnaSequenceId string, params *GetDNASequenceParams, reqEditors ...RequestEditorFn) (*GetDNASequenceResponse, error) {
	rsp, err := c.GetDNASequence(ctx, dnaSequenceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDNASequenceResponse(rsp)
}

// UpdateDNASequenceWithBodyWithResponse request with arbitrary body returning *UpdateDNASequenceResponse
func (c *ClientWithResponses) UpdateDNASequenceWithBodyWithResponse(ctx context.Context, dnaSequenceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDNASequenceResponse, error) {
	rsp, err := c.UpdateDNASequenceWithBody(ctx, dnaSequenceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDNASequenceResponse(rsp)
}

func (c *ClientWithResponses) UpdateDNASequenceWithResponse(ctx context.Context, dnaSequenceId string, body UpdateDNASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDNASequenceResponse, error) {
	rsp, err := c.UpdateDNASequence(ctx, dnaSequenceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDNASequenceResponse(rsp)
}

// ArchiveDNASequencesWithBodyWithResponse request with arbitrary body returning *ArchiveDNASequencesResponse
func (c *ClientWithResponses) ArchiveDNASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveDNASequencesResponse, error) {
	rsp, err := c.ArchiveDNASequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveDNASequencesResponse(rsp)
}

func (c *ClientWithResponses) ArchiveDNASequencesWithResponse(ctx context.Context, body ArchiveDNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveDNASequencesResponse, error) {
	rsp, err := c.ArchiveDNASequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveDNASequencesResponse(rsp)
}

// AutoAnnotateDnaSequencesWithBodyWithResponse request with arbitrary body returning *AutoAnnotateDnaSequencesResponse
func (c *ClientWithResponses) AutoAnnotateDnaSequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AutoAnnotateDnaSequencesResponse, error) {
	rsp, err := c.AutoAnnotateDnaSequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutoAnnotateDnaSequencesResponse(rsp)
}

func (c *ClientWithResponses) AutoAnnotateDnaSequencesWithResponse(ctx context.Context, body AutoAnnotateDnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*AutoAnnotateDnaSequencesResponse, error) {
	rsp, err := c.AutoAnnotateDnaSequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutoAnnotateDnaSequencesResponse(rsp)
}

// AutofillDNASequencePartsWithBodyWithResponse request with arbitrary body returning *AutofillDNASequencePartsResponse
func (c *ClientWithResponses) AutofillDNASequencePartsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AutofillDNASequencePartsResponse, error) {
	rsp, err := c.AutofillDNASequencePartsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutofillDNASequencePartsResponse(rsp)
}

func (c *ClientWithResponses) AutofillDNASequencePartsWithResponse(ctx context.Context, body AutofillDNASequencePartsJSONRequestBody, reqEditors ...RequestEditorFn) (*AutofillDNASequencePartsResponse, error) {
	rsp, err := c.AutofillDNASequenceParts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutofillDNASequencePartsResponse(rsp)
}

// AutofillDNASequenceTranslationsWithBodyWithResponse request with arbitrary body returning *AutofillDNASequenceTranslationsResponse
func (c *ClientWithResponses) AutofillDNASequenceTranslationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AutofillDNASequenceTranslationsResponse, error) {
	rsp, err := c.AutofillDNASequenceTranslationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutofillDNASequenceTranslationsResponse(rsp)
}

func (c *ClientWithResponses) AutofillDNASequenceTranslationsWithResponse(ctx context.Context, body AutofillDNASequenceTranslationsJSONRequestBody, reqEditors ...RequestEditorFn) (*AutofillDNASequenceTranslationsResponse, error) {
	rsp, err := c.AutofillDNASequenceTranslations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutofillDNASequenceTranslationsResponse(rsp)
}

// BulkCreateDNASequencesWithBodyWithResponse request with arbitrary body returning *BulkCreateDNASequencesResponse
func (c *ClientWithResponses) BulkCreateDNASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateDNASequencesResponse, error) {
	rsp, err := c.BulkCreateDNASequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateDNASequencesResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateDNASequencesWithResponse(ctx context.Context, body BulkCreateDNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateDNASequencesResponse, error) {
	rsp, err := c.BulkCreateDNASequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateDNASequencesResponse(rsp)
}

// BulkGetDNASequencesWithResponse request returning *BulkGetDNASequencesResponse
func (c *ClientWithResponses) BulkGetDNASequencesWithResponse(ctx context.Context, params *BulkGetDNASequencesParams, reqEditors ...RequestEditorFn) (*BulkGetDNASequencesResponse, error) {
	rsp, err := c.BulkGetDNASequences(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkGetDNASequencesResponse(rsp)
}

// BulkUpdateDNASequencesWithBodyWithResponse request with arbitrary body returning *BulkUpdateDNASequencesResponse
func (c *ClientWithResponses) BulkUpdateDNASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateDNASequencesResponse, error) {
	rsp, err := c.BulkUpdateDNASequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateDNASequencesResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateDNASequencesWithResponse(ctx context.Context, body BulkUpdateDNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateDNASequencesResponse, error) {
	rsp, err := c.BulkUpdateDNASequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateDNASequencesResponse(rsp)
}

// MatchBasesDnaSequencesWithBodyWithResponse request with arbitrary body returning *MatchBasesDnaSequencesResponse
func (c *ClientWithResponses) MatchBasesDnaSequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MatchBasesDnaSequencesResponse, error) {
	rsp, err := c.MatchBasesDnaSequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMatchBasesDnaSequencesResponse(rsp)
}

func (c *ClientWithResponses) MatchBasesDnaSequencesWithResponse(ctx context.Context, body MatchBasesDnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*MatchBasesDnaSequencesResponse, error) {
	rsp, err := c.MatchBasesDnaSequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMatchBasesDnaSequencesResponse(rsp)
}

// SearchDnaSequencesWithBodyWithResponse request with arbitrary body returning *SearchDnaSequencesResponse
func (c *ClientWithResponses) SearchDnaSequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDnaSequencesResponse, error) {
	rsp, err := c.SearchDnaSequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDnaSequencesResponse(rsp)
}

func (c *ClientWithResponses) SearchDnaSequencesWithResponse(ctx context.Context, body SearchDnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDnaSequencesResponse, error) {
	rsp, err := c.SearchDnaSequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDnaSequencesResponse(rsp)
}

// UnarchiveDNASequencesWithBodyWithResponse request with arbitrary body returning *UnarchiveDNASequencesResponse
func (c *ClientWithResponses) UnarchiveDNASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveDNASequencesResponse, error) {
	rsp, err := c.UnarchiveDNASequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveDNASequencesResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveDNASequencesWithResponse(ctx context.Context, body UnarchiveDNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveDNASequencesResponse, error) {
	rsp, err := c.UnarchiveDNASequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveDNASequencesResponse(rsp)
}

// ListDropdownsWithResponse request returning *ListDropdownsResponse
func (c *ClientWithResponses) ListDropdownsWithResponse(ctx context.Context, params *ListDropdownsParams, reqEditors ...RequestEditorFn) (*ListDropdownsResponse, error) {
	rsp, err := c.ListDropdowns(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDropdownsResponse(rsp)
}

// CreateDropdownWithBodyWithResponse request with arbitrary body returning *CreateDropdownResponse
func (c *ClientWithResponses) CreateDropdownWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDropdownResponse, error) {
	rsp, err := c.CreateDropdownWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDropdownResponse(rsp)
}

func (c *ClientWithResponses) CreateDropdownWithResponse(ctx context.Context, body CreateDropdownJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDropdownResponse, error) {
	rsp, err := c.CreateDropdown(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDropdownResponse(rsp)
}

// GetDropdownWithResponse request returning *GetDropdownResponse
func (c *ClientWithResponses) GetDropdownWithResponse(ctx context.Context, dropdownId string, reqEditors ...RequestEditorFn) (*GetDropdownResponse, error) {
	rsp, err := c.GetDropdown(ctx, dropdownId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDropdownResponse(rsp)
}

// UpdateDropdownWithBodyWithResponse request with arbitrary body returning *UpdateDropdownResponse
func (c *ClientWithResponses) UpdateDropdownWithBodyWithResponse(ctx context.Context, dropdownId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDropdownResponse, error) {
	rsp, err := c.UpdateDropdownWithBody(ctx, dropdownId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDropdownResponse(rsp)
}

func (c *ClientWithResponses) UpdateDropdownWithResponse(ctx context.Context, dropdownId string, body UpdateDropdownJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDropdownResponse, error) {
	rsp, err := c.UpdateDropdown(ctx, dropdownId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDropdownResponse(rsp)
}

// ArchiveDropdownOptionsWithBodyWithResponse request with arbitrary body returning *ArchiveDropdownOptionsResponse
func (c *ClientWithResponses) ArchiveDropdownOptionsWithBodyWithResponse(ctx context.Context, dropdownId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveDropdownOptionsResponse, error) {
	rsp, err := c.ArchiveDropdownOptionsWithBody(ctx, dropdownId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveDropdownOptionsResponse(rsp)
}

func (c *ClientWithResponses) ArchiveDropdownOptionsWithResponse(ctx context.Context, dropdownId string, body ArchiveDropdownOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveDropdownOptionsResponse, error) {
	rsp, err := c.ArchiveDropdownOptions(ctx, dropdownId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveDropdownOptionsResponse(rsp)
}

// UnarchiveDropdownOptionsWithBodyWithResponse request with arbitrary body returning *UnarchiveDropdownOptionsResponse
func (c *ClientWithResponses) UnarchiveDropdownOptionsWithBodyWithResponse(ctx context.Context, dropdownId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveDropdownOptionsResponse, error) {
	rsp, err := c.UnarchiveDropdownOptionsWithBody(ctx, dropdownId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveDropdownOptionsResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveDropdownOptionsWithResponse(ctx context.Context, dropdownId string, body UnarchiveDropdownOptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveDropdownOptionsResponse, error) {
	rsp, err := c.UnarchiveDropdownOptions(ctx, dropdownId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveDropdownOptionsResponse(rsp)
}

// GetEnitityBatchesWithResponse request returning *GetEnitityBatchesResponse
func (c *ClientWithResponses) GetEnitityBatchesWithResponse(ctx context.Context, entityId string, reqEditors ...RequestEditorFn) (*GetEnitityBatchesResponse, error) {
	rsp, err := c.GetEnitityBatches(ctx, entityId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnitityBatchesResponse(rsp)
}

// ListEntitySchemasWithResponse request returning *ListEntitySchemasResponse
func (c *ClientWithResponses) ListEntitySchemasWithResponse(ctx context.Context, params *ListEntitySchemasParams, reqEditors ...RequestEditorFn) (*ListEntitySchemasResponse, error) {
	rsp, err := c.ListEntitySchemas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEntitySchemasResponse(rsp)
}

// GetEntitySchemaWithResponse request returning *GetEntitySchemaResponse
func (c *ClientWithResponses) GetEntitySchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetEntitySchemaResponse, error) {
	rsp, err := c.GetEntitySchema(ctx, schemaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntitySchemaResponse(rsp)
}

// ListEntriesWithResponse request returning *ListEntriesResponse
func (c *ClientWithResponses) ListEntriesWithResponse(ctx context.Context, params *ListEntriesParams, reqEditors ...RequestEditorFn) (*ListEntriesResponse, error) {
	rsp, err := c.ListEntries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEntriesResponse(rsp)
}

// CreateEntryWithBodyWithResponse request with arbitrary body returning *CreateEntryResponse
func (c *ClientWithResponses) CreateEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEntryResponse, error) {
	rsp, err := c.CreateEntryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEntryResponse(rsp)
}

func (c *ClientWithResponses) CreateEntryWithResponse(ctx context.Context, body CreateEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEntryResponse, error) {
	rsp, err := c.CreateEntry(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEntryResponse(rsp)
}

// GetEntryWithResponse request returning *GetEntryResponse
func (c *ClientWithResponses) GetEntryWithResponse(ctx context.Context, entryId string, params *GetEntryParams, reqEditors ...RequestEditorFn) (*GetEntryResponse, error) {
	rsp, err := c.GetEntry(ctx, entryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntryResponse(rsp)
}

// UpdateEntryWithBodyWithResponse request with arbitrary body returning *UpdateEntryResponse
func (c *ClientWithResponses) UpdateEntryWithBodyWithResponse(ctx context.Context, entryId string, params *UpdateEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEntryResponse, error) {
	rsp, err := c.UpdateEntryWithBody(ctx, entryId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEntryResponse(rsp)
}

func (c *ClientWithResponses) UpdateEntryWithResponse(ctx context.Context, entryId string, params *UpdateEntryParams, body UpdateEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEntryResponse, error) {
	rsp, err := c.UpdateEntry(ctx, entryId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEntryResponse(rsp)
}

// GetExternalFileMetadataWithResponse request returning *GetExternalFileMetadataResponse
func (c *ClientWithResponses) GetExternalFileMetadataWithResponse(ctx context.Context, entryId string, externalFileId string, reqEditors ...RequestEditorFn) (*GetExternalFileMetadataResponse, error) {
	rsp, err := c.GetExternalFileMetadata(ctx, entryId, externalFileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExternalFileMetadataResponse(rsp)
}

// ArchiveEntriesWithBodyWithResponse request with arbitrary body returning *ArchiveEntriesResponse
func (c *ClientWithResponses) ArchiveEntriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveEntriesResponse, error) {
	rsp, err := c.ArchiveEntriesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveEntriesResponse(rsp)
}

func (c *ClientWithResponses) ArchiveEntriesWithResponse(ctx context.Context, body ArchiveEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveEntriesResponse, error) {
	rsp, err := c.ArchiveEntries(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveEntriesResponse(rsp)
}

// BulkGetEntriesWithResponse request returning *BulkGetEntriesResponse
func (c *ClientWithResponses) BulkGetEntriesWithResponse(ctx context.Context, params *BulkGetEntriesParams, reqEditors ...RequestEditorFn) (*BulkGetEntriesResponse, error) {
	rsp, err := c.BulkGetEntries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkGetEntriesResponse(rsp)
}

// UnarchiveEntriesWithBodyWithResponse request with arbitrary body returning *UnarchiveEntriesResponse
func (c *ClientWithResponses) UnarchiveEntriesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveEntriesResponse, error) {
	rsp, err := c.UnarchiveEntriesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveEntriesResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveEntriesWithResponse(ctx context.Context, body UnarchiveEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveEntriesResponse, error) {
	rsp, err := c.UnarchiveEntries(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveEntriesResponse(rsp)
}

// ListEntrySchemasWithResponse request returning *ListEntrySchemasResponse
func (c *ClientWithResponses) ListEntrySchemasWithResponse(ctx context.Context, params *ListEntrySchemasParams, reqEditors ...RequestEditorFn) (*ListEntrySchemasResponse, error) {
	rsp, err := c.ListEntrySchemas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEntrySchemasResponse(rsp)
}

// GetEntrySchemaWithResponse request returning *GetEntrySchemaResponse
func (c *ClientWithResponses) GetEntrySchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetEntrySchemaResponse, error) {
	rsp, err := c.GetEntrySchema(ctx, schemaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntrySchemaResponse(rsp)
}

// ListEntryTemplatesWithResponse request returning *ListEntryTemplatesResponse
func (c *ClientWithResponses) ListEntryTemplatesWithResponse(ctx context.Context, params *ListEntryTemplatesParams, reqEditors ...RequestEditorFn) (*ListEntryTemplatesResponse, error) {
	rsp, err := c.ListEntryTemplates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEntryTemplatesResponse(rsp)
}

// GetEntryTemplateWithResponse request returning *GetEntryTemplateResponse
func (c *ClientWithResponses) GetEntryTemplateWithResponse(ctx context.Context, entryTemplateId string, params *GetEntryTemplateParams, reqEditors ...RequestEditorFn) (*GetEntryTemplateResponse, error) {
	rsp, err := c.GetEntryTemplate(ctx, entryTemplateId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEntryTemplateResponse(rsp)
}

// ListEventsWithResponse request returning *ListEventsResponse
func (c *ClientWithResponses) ListEventsWithResponse(ctx context.Context, params *ListEventsParams, reqEditors ...RequestEditorFn) (*ListEventsResponse, error) {
	rsp, err := c.ListEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEventsResponse(rsp)
}

// ExportItemWithBodyWithResponse request with arbitrary body returning *ExportItemResponse
func (c *ClientWithResponses) ExportItemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExportItemResponse, error) {
	rsp, err := c.ExportItemWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportItemResponse(rsp)
}

func (c *ClientWithResponses) ExportItemWithResponse(ctx context.Context, body ExportItemJSONRequestBody, reqEditors ...RequestEditorFn) (*ExportItemResponse, error) {
	rsp, err := c.ExportItem(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportItemResponse(rsp)
}

// ListFeatureLibrariesWithResponse request returning *ListFeatureLibrariesResponse
func (c *ClientWithResponses) ListFeatureLibrariesWithResponse(ctx context.Context, params *ListFeatureLibrariesParams, reqEditors ...RequestEditorFn) (*ListFeatureLibrariesResponse, error) {
	rsp, err := c.ListFeatureLibraries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFeatureLibrariesResponse(rsp)
}

// CreateFeatureLibraryWithBodyWithResponse request with arbitrary body returning *CreateFeatureLibraryResponse
func (c *ClientWithResponses) CreateFeatureLibraryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFeatureLibraryResponse, error) {
	rsp, err := c.CreateFeatureLibraryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFeatureLibraryResponse(rsp)
}

func (c *ClientWithResponses) CreateFeatureLibraryWithResponse(ctx context.Context, body CreateFeatureLibraryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFeatureLibraryResponse, error) {
	rsp, err := c.CreateFeatureLibrary(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFeatureLibraryResponse(rsp)
}

// GetFeatureLibraryWithResponse request returning *GetFeatureLibraryResponse
func (c *ClientWithResponses) GetFeatureLibraryWithResponse(ctx context.Context, featureLibraryId string, params *GetFeatureLibraryParams, reqEditors ...RequestEditorFn) (*GetFeatureLibraryResponse, error) {
	rsp, err := c.GetFeatureLibrary(ctx, featureLibraryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeatureLibraryResponse(rsp)
}

// UpdateFeatureLibraryWithBodyWithResponse request with arbitrary body returning *UpdateFeatureLibraryResponse
func (c *ClientWithResponses) UpdateFeatureLibraryWithBodyWithResponse(ctx context.Context, featureLibraryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFeatureLibraryResponse, error) {
	rsp, err := c.UpdateFeatureLibraryWithBody(ctx, featureLibraryId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFeatureLibraryResponse(rsp)
}

func (c *ClientWithResponses) UpdateFeatureLibraryWithResponse(ctx context.Context, featureLibraryId string, body UpdateFeatureLibraryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFeatureLibraryResponse, error) {
	rsp, err := c.UpdateFeatureLibrary(ctx, featureLibraryId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFeatureLibraryResponse(rsp)
}

// ListFeaturesWithResponse request returning *ListFeaturesResponse
func (c *ClientWithResponses) ListFeaturesWithResponse(ctx context.Context, params *ListFeaturesParams, reqEditors ...RequestEditorFn) (*ListFeaturesResponse, error) {
	rsp, err := c.ListFeatures(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFeaturesResponse(rsp)
}

// CreateFeatureWithBodyWithResponse request with arbitrary body returning *CreateFeatureResponse
func (c *ClientWithResponses) CreateFeatureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFeatureResponse, error) {
	rsp, err := c.CreateFeatureWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFeatureResponse(rsp)
}

func (c *ClientWithResponses) CreateFeatureWithResponse(ctx context.Context, body CreateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFeatureResponse, error) {
	rsp, err := c.CreateFeature(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFeatureResponse(rsp)
}

// GetFeatureWithResponse request returning *GetFeatureResponse
func (c *ClientWithResponses) GetFeatureWithResponse(ctx context.Context, featureId string, params *GetFeatureParams, reqEditors ...RequestEditorFn) (*GetFeatureResponse, error) {
	rsp, err := c.GetFeature(ctx, featureId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFeatureResponse(rsp)
}

// UpdateFeatureWithBodyWithResponse request with arbitrary body returning *UpdateFeatureResponse
func (c *ClientWithResponses) UpdateFeatureWithBodyWithResponse(ctx context.Context, featureId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFeatureResponse, error) {
	rsp, err := c.UpdateFeatureWithBody(ctx, featureId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFeatureResponse(rsp)
}

func (c *ClientWithResponses) UpdateFeatureWithResponse(ctx context.Context, featureId string, body UpdateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFeatureResponse, error) {
	rsp, err := c.UpdateFeature(ctx, featureId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFeatureResponse(rsp)
}

// BulkCreateFeaturesWithBodyWithResponse request with arbitrary body returning *BulkCreateFeaturesResponse
func (c *ClientWithResponses) BulkCreateFeaturesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateFeaturesResponse, error) {
	rsp, err := c.BulkCreateFeaturesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateFeaturesResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateFeaturesWithResponse(ctx context.Context, body BulkCreateFeaturesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateFeaturesResponse, error) {
	rsp, err := c.BulkCreateFeatures(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateFeaturesResponse(rsp)
}

// ListFoldersWithResponse request returning *ListFoldersResponse
func (c *ClientWithResponses) ListFoldersWithResponse(ctx context.Context, params *ListFoldersParams, reqEditors ...RequestEditorFn) (*ListFoldersResponse, error) {
	rsp, err := c.ListFolders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFoldersResponse(rsp)
}

// CreateFolderWithBodyWithResponse request with arbitrary body returning *CreateFolderResponse
func (c *ClientWithResponses) CreateFolderWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error) {
	rsp, err := c.CreateFolderWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFolderResponse(rsp)
}

func (c *ClientWithResponses) CreateFolderWithResponse(ctx context.Context, body CreateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFolderResponse, error) {
	rsp, err := c.CreateFolder(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFolderResponse(rsp)
}

// GetFolderWithResponse request returning *GetFolderResponse
func (c *ClientWithResponses) GetFolderWithResponse(ctx context.Context, folderId string, reqEditors ...RequestEditorFn) (*GetFolderResponse, error) {
	rsp, err := c.GetFolder(ctx, folderId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFolderResponse(rsp)
}

// ArchiveFoldersWithBodyWithResponse request with arbitrary body returning *ArchiveFoldersResponse
func (c *ClientWithResponses) ArchiveFoldersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveFoldersResponse, error) {
	rsp, err := c.ArchiveFoldersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveFoldersResponse(rsp)
}

func (c *ClientWithResponses) ArchiveFoldersWithResponse(ctx context.Context, body ArchiveFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveFoldersResponse, error) {
	rsp, err := c.ArchiveFolders(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveFoldersResponse(rsp)
}

// UnarchiveFoldersWithBodyWithResponse request with arbitrary body returning *UnarchiveFoldersResponse
func (c *ClientWithResponses) UnarchiveFoldersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveFoldersResponse, error) {
	rsp, err := c.UnarchiveFoldersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveFoldersResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveFoldersWithResponse(ctx context.Context, body UnarchiveFoldersJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveFoldersResponse, error) {
	rsp, err := c.UnarchiveFolders(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveFoldersResponse(rsp)
}

// ListLegacyWorkflowStageRunInputSamplesWithResponse request returning *ListLegacyWorkflowStageRunInputSamplesResponse
func (c *ClientWithResponses) ListLegacyWorkflowStageRunInputSamplesWithResponse(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*ListLegacyWorkflowStageRunInputSamplesResponse, error) {
	rsp, err := c.ListLegacyWorkflowStageRunInputSamples(ctx, stageRunId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLegacyWorkflowStageRunInputSamplesResponse(rsp)
}

// ListLegacyWorkflowStageRunOutputSamplesWithResponse request returning *ListLegacyWorkflowStageRunOutputSamplesResponse
func (c *ClientWithResponses) ListLegacyWorkflowStageRunOutputSamplesWithResponse(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*ListLegacyWorkflowStageRunOutputSamplesResponse, error) {
	rsp, err := c.ListLegacyWorkflowStageRunOutputSamples(ctx, stageRunId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLegacyWorkflowStageRunOutputSamplesResponse(rsp)
}

// ListLegacyWorkflowStageRunRegisteredSamplesWithResponse request returning *ListLegacyWorkflowStageRunRegisteredSamplesResponse
func (c *ClientWithResponses) ListLegacyWorkflowStageRunRegisteredSamplesWithResponse(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*ListLegacyWorkflowStageRunRegisteredSamplesResponse, error) {
	rsp, err := c.ListLegacyWorkflowStageRunRegisteredSamples(ctx, stageRunId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLegacyWorkflowStageRunRegisteredSamplesResponse(rsp)
}

// ListLegacyWorkflowStageRunsWithResponse request returning *ListLegacyWorkflowStageRunsResponse
func (c *ClientWithResponses) ListLegacyWorkflowStageRunsWithResponse(ctx context.Context, stageId string, reqEditors ...RequestEditorFn) (*ListLegacyWorkflowStageRunsResponse, error) {
	rsp, err := c.ListLegacyWorkflowStageRuns(ctx, stageId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLegacyWorkflowStageRunsResponse(rsp)
}

// ListLegacyWorkflowsWithResponse request returning *ListLegacyWorkflowsResponse
func (c *ClientWithResponses) ListLegacyWorkflowsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListLegacyWorkflowsResponse, error) {
	rsp, err := c.ListLegacyWorkflows(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLegacyWorkflowsResponse(rsp)
}

// UpdateLegacyWorkflowMetadataWithBodyWithResponse request with arbitrary body returning *UpdateLegacyWorkflowMetadataResponse
func (c *ClientWithResponses) UpdateLegacyWorkflowMetadataWithBodyWithResponse(ctx context.Context, legacyWorkflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLegacyWorkflowMetadataResponse, error) {
	rsp, err := c.UpdateLegacyWorkflowMetadataWithBody(ctx, legacyWorkflowId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLegacyWorkflowMetadataResponse(rsp)
}

func (c *ClientWithResponses) UpdateLegacyWorkflowMetadataWithResponse(ctx context.Context, legacyWorkflowId string, body UpdateLegacyWorkflowMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLegacyWorkflowMetadataResponse, error) {
	rsp, err := c.UpdateLegacyWorkflowMetadata(ctx, legacyWorkflowId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLegacyWorkflowMetadataResponse(rsp)
}

// ListLegacyWorkflowStagesWithResponse request returning *ListLegacyWorkflowStagesResponse
func (c *ClientWithResponses) ListLegacyWorkflowStagesWithResponse(ctx context.Context, legacyWorkflowId string, reqEditors ...RequestEditorFn) (*ListLegacyWorkflowStagesResponse, error) {
	rsp, err := c.ListLegacyWorkflowStages(ctx, legacyWorkflowId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLegacyWorkflowStagesResponse(rsp)
}

// ListLocationSchemasWithResponse request returning *ListLocationSchemasResponse
func (c *ClientWithResponses) ListLocationSchemasWithResponse(ctx context.Context, params *ListLocationSchemasParams, reqEditors ...RequestEditorFn) (*ListLocationSchemasResponse, error) {
	rsp, err := c.ListLocationSchemas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLocationSchemasResponse(rsp)
}

// GetLocationSchemaWithResponse request returning *GetLocationSchemaResponse
func (c *ClientWithResponses) GetLocationSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetLocationSchemaResponse, error) {
	rsp, err := c.GetLocationSchema(ctx, schemaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationSchemaResponse(rsp)
}

// ListLocationsWithResponse request returning *ListLocationsResponse
func (c *ClientWithResponses) ListLocationsWithResponse(ctx context.Context, params *ListLocationsParams, reqEditors ...RequestEditorFn) (*ListLocationsResponse, error) {
	rsp, err := c.ListLocations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLocationsResponse(rsp)
}

// CreateLocationWithBodyWithResponse request with arbitrary body returning *CreateLocationResponse
func (c *ClientWithResponses) CreateLocationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLocationResponse, error) {
	rsp, err := c.CreateLocationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLocationResponse(rsp)
}

func (c *ClientWithResponses) CreateLocationWithResponse(ctx context.Context, body CreateLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLocationResponse, error) {
	rsp, err := c.CreateLocation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLocationResponse(rsp)
}

// GetLocationWithResponse request returning *GetLocationResponse
func (c *ClientWithResponses) GetLocationWithResponse(ctx context.Context, locationId string, reqEditors ...RequestEditorFn) (*GetLocationResponse, error) {
	rsp, err := c.GetLocation(ctx, locationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationResponse(rsp)
}

// UpdateLocationWithBodyWithResponse request with arbitrary body returning *UpdateLocationResponse
func (c *ClientWithResponses) UpdateLocationWithBodyWithResponse(ctx context.Context, locationId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateLocationResponse, error) {
	rsp, err := c.UpdateLocationWithBody(ctx, locationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLocationResponse(rsp)
}

func (c *ClientWithResponses) UpdateLocationWithResponse(ctx context.Context, locationId string, body UpdateLocationJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateLocationResponse, error) {
	rsp, err := c.UpdateLocation(ctx, locationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateLocationResponse(rsp)
}

// ArchiveLocationsWithBodyWithResponse request with arbitrary body returning *ArchiveLocationsResponse
func (c *ClientWithResponses) ArchiveLocationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveLocationsResponse, error) {
	rsp, err := c.ArchiveLocationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveLocationsResponse(rsp)
}

func (c *ClientWithResponses) ArchiveLocationsWithResponse(ctx context.Context, body ArchiveLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveLocationsResponse, error) {
	rsp, err := c.ArchiveLocations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveLocationsResponse(rsp)
}

// BulkGetLocationsWithResponse request returning *BulkGetLocationsResponse
func (c *ClientWithResponses) BulkGetLocationsWithResponse(ctx context.Context, params *BulkGetLocationsParams, reqEditors ...RequestEditorFn) (*BulkGetLocationsResponse, error) {
	rsp, err := c.BulkGetLocations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkGetLocationsResponse(rsp)
}

// UnarchiveLocationsWithBodyWithResponse request with arbitrary body returning *UnarchiveLocationsResponse
func (c *ClientWithResponses) UnarchiveLocationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveLocationsResponse, error) {
	rsp, err := c.UnarchiveLocationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveLocationsResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveLocationsWithResponse(ctx context.Context, body UnarchiveLocationsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveLocationsResponse, error) {
	rsp, err := c.UnarchiveLocations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveLocationsResponse(rsp)
}

// ListMixturesWithResponse request returning *ListMixturesResponse
func (c *ClientWithResponses) ListMixturesWithResponse(ctx context.Context, params *ListMixturesParams, reqEditors ...RequestEditorFn) (*ListMixturesResponse, error) {
	rsp, err := c.ListMixtures(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMixturesResponse(rsp)
}

// CreateMixtureWithBodyWithResponse request with arbitrary body returning *CreateMixtureResponse
func (c *ClientWithResponses) CreateMixtureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMixtureResponse, error) {
	rsp, err := c.CreateMixtureWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMixtureResponse(rsp)
}

func (c *ClientWithResponses) CreateMixtureWithResponse(ctx context.Context, body CreateMixtureJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMixtureResponse, error) {
	rsp, err := c.CreateMixture(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMixtureResponse(rsp)
}

// GetMixtureWithResponse request returning *GetMixtureResponse
func (c *ClientWithResponses) GetMixtureWithResponse(ctx context.Context, mixtureId string, reqEditors ...RequestEditorFn) (*GetMixtureResponse, error) {
	rsp, err := c.GetMixture(ctx, mixtureId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMixtureResponse(rsp)
}

// UpdateMixtureWithBodyWithResponse request with arbitrary body returning *UpdateMixtureResponse
func (c *ClientWithResponses) UpdateMixtureWithBodyWithResponse(ctx context.Context, mixtureId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMixtureResponse, error) {
	rsp, err := c.UpdateMixtureWithBody(ctx, mixtureId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMixtureResponse(rsp)
}

func (c *ClientWithResponses) UpdateMixtureWithResponse(ctx context.Context, mixtureId string, body UpdateMixtureJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMixtureResponse, error) {
	rsp, err := c.UpdateMixture(ctx, mixtureId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMixtureResponse(rsp)
}

// ArchiveMixturesWithBodyWithResponse request with arbitrary body returning *ArchiveMixturesResponse
func (c *ClientWithResponses) ArchiveMixturesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveMixturesResponse, error) {
	rsp, err := c.ArchiveMixturesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveMixturesResponse(rsp)
}

func (c *ClientWithResponses) ArchiveMixturesWithResponse(ctx context.Context, body ArchiveMixturesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveMixturesResponse, error) {
	rsp, err := c.ArchiveMixtures(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveMixturesResponse(rsp)
}

// BulkCreateMixturesWithBodyWithResponse request with arbitrary body returning *BulkCreateMixturesResponse
func (c *ClientWithResponses) BulkCreateMixturesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateMixturesResponse, error) {
	rsp, err := c.BulkCreateMixturesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateMixturesResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateMixturesWithResponse(ctx context.Context, body BulkCreateMixturesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateMixturesResponse, error) {
	rsp, err := c.BulkCreateMixtures(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateMixturesResponse(rsp)
}

// BulkUpdateMixturesWithBodyWithResponse request with arbitrary body returning *BulkUpdateMixturesResponse
func (c *ClientWithResponses) BulkUpdateMixturesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateMixturesResponse, error) {
	rsp, err := c.BulkUpdateMixturesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateMixturesResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateMixturesWithResponse(ctx context.Context, body BulkUpdateMixturesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateMixturesResponse, error) {
	rsp, err := c.BulkUpdateMixtures(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateMixturesResponse(rsp)
}

// UnarchiveMixturesWithBodyWithResponse request with arbitrary body returning *UnarchiveMixturesResponse
func (c *ClientWithResponses) UnarchiveMixturesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveMixturesResponse, error) {
	rsp, err := c.UnarchiveMixturesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveMixturesResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveMixturesWithResponse(ctx context.Context, body UnarchiveMixturesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveMixturesResponse, error) {
	rsp, err := c.UnarchiveMixtures(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveMixturesResponse(rsp)
}

// ListMoleculesWithResponse request returning *ListMoleculesResponse
func (c *ClientWithResponses) ListMoleculesWithResponse(ctx context.Context, params *ListMoleculesParams, reqEditors ...RequestEditorFn) (*ListMoleculesResponse, error) {
	rsp, err := c.ListMolecules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMoleculesResponse(rsp)
}

// CreateMoleculeWithBodyWithResponse request with arbitrary body returning *CreateMoleculeResponse
func (c *ClientWithResponses) CreateMoleculeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMoleculeResponse, error) {
	rsp, err := c.CreateMoleculeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMoleculeResponse(rsp)
}

func (c *ClientWithResponses) CreateMoleculeWithResponse(ctx context.Context, body CreateMoleculeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMoleculeResponse, error) {
	rsp, err := c.CreateMolecule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMoleculeResponse(rsp)
}

// GetMoleculeWithResponse request returning *GetMoleculeResponse
func (c *ClientWithResponses) GetMoleculeWithResponse(ctx context.Context, moleculeId string, reqEditors ...RequestEditorFn) (*GetMoleculeResponse, error) {
	rsp, err := c.GetMolecule(ctx, moleculeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMoleculeResponse(rsp)
}

// UpdateMoleculeWithBodyWithResponse request with arbitrary body returning *UpdateMoleculeResponse
func (c *ClientWithResponses) UpdateMoleculeWithBodyWithResponse(ctx context.Context, moleculeId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMoleculeResponse, error) {
	rsp, err := c.UpdateMoleculeWithBody(ctx, moleculeId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMoleculeResponse(rsp)
}

func (c *ClientWithResponses) UpdateMoleculeWithResponse(ctx context.Context, moleculeId string, body UpdateMoleculeJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMoleculeResponse, error) {
	rsp, err := c.UpdateMolecule(ctx, moleculeId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMoleculeResponse(rsp)
}

// ArchiveMoleculesWithBodyWithResponse request with arbitrary body returning *ArchiveMoleculesResponse
func (c *ClientWithResponses) ArchiveMoleculesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveMoleculesResponse, error) {
	rsp, err := c.ArchiveMoleculesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveMoleculesResponse(rsp)
}

func (c *ClientWithResponses) ArchiveMoleculesWithResponse(ctx context.Context, body ArchiveMoleculesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveMoleculesResponse, error) {
	rsp, err := c.ArchiveMolecules(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveMoleculesResponse(rsp)
}

// BulkCreateMoleculesWithBodyWithResponse request with arbitrary body returning *BulkCreateMoleculesResponse
func (c *ClientWithResponses) BulkCreateMoleculesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateMoleculesResponse, error) {
	rsp, err := c.BulkCreateMoleculesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateMoleculesResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateMoleculesWithResponse(ctx context.Context, body BulkCreateMoleculesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateMoleculesResponse, error) {
	rsp, err := c.BulkCreateMolecules(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateMoleculesResponse(rsp)
}

// BulkUpdateMoleculesWithBodyWithResponse request with arbitrary body returning *BulkUpdateMoleculesResponse
func (c *ClientWithResponses) BulkUpdateMoleculesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateMoleculesResponse, error) {
	rsp, err := c.BulkUpdateMoleculesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateMoleculesResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateMoleculesWithResponse(ctx context.Context, body BulkUpdateMoleculesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateMoleculesResponse, error) {
	rsp, err := c.BulkUpdateMolecules(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateMoleculesResponse(rsp)
}

// UnarchiveMoleculesWithBodyWithResponse request with arbitrary body returning *UnarchiveMoleculesResponse
func (c *ClientWithResponses) UnarchiveMoleculesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveMoleculesResponse, error) {
	rsp, err := c.UnarchiveMoleculesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveMoleculesResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveMoleculesWithResponse(ctx context.Context, body UnarchiveMoleculesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveMoleculesResponse, error) {
	rsp, err := c.UnarchiveMolecules(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveMoleculesResponse(rsp)
}

// ListMonomersWithResponse request returning *ListMonomersResponse
func (c *ClientWithResponses) ListMonomersWithResponse(ctx context.Context, params *ListMonomersParams, reqEditors ...RequestEditorFn) (*ListMonomersResponse, error) {
	rsp, err := c.ListMonomers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMonomersResponse(rsp)
}

// CreateMonomerWithBodyWithResponse request with arbitrary body returning *CreateMonomerResponse
func (c *ClientWithResponses) CreateMonomerWithBodyWithResponse(ctx context.Context, params *CreateMonomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMonomerResponse, error) {
	rsp, err := c.CreateMonomerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMonomerResponse(rsp)
}

func (c *ClientWithResponses) CreateMonomerWithResponse(ctx context.Context, params *CreateMonomerParams, body CreateMonomerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMonomerResponse, error) {
	rsp, err := c.CreateMonomer(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMonomerResponse(rsp)
}

// UpdateMonomerWithBodyWithResponse request with arbitrary body returning *UpdateMonomerResponse
func (c *ClientWithResponses) UpdateMonomerWithBodyWithResponse(ctx context.Context, monomerId string, params *UpdateMonomerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMonomerResponse, error) {
	rsp, err := c.UpdateMonomerWithBody(ctx, monomerId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMonomerResponse(rsp)
}

func (c *ClientWithResponses) UpdateMonomerWithResponse(ctx context.Context, monomerId string, params *UpdateMonomerParams, body UpdateMonomerJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMonomerResponse, error) {
	rsp, err := c.UpdateMonomer(ctx, monomerId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMonomerResponse(rsp)
}

// ArchiveMonomersWithBodyWithResponse request with arbitrary body returning *ArchiveMonomersResponse
func (c *ClientWithResponses) ArchiveMonomersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveMonomersResponse, error) {
	rsp, err := c.ArchiveMonomersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveMonomersResponse(rsp)
}

func (c *ClientWithResponses) ArchiveMonomersWithResponse(ctx context.Context, body ArchiveMonomersJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveMonomersResponse, error) {
	rsp, err := c.ArchiveMonomers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveMonomersResponse(rsp)
}

// UnarchiveMonomersWithBodyWithResponse request with arbitrary body returning *UnarchiveMonomersResponse
func (c *ClientWithResponses) UnarchiveMonomersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveMonomersResponse, error) {
	rsp, err := c.UnarchiveMonomersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveMonomersResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveMonomersWithResponse(ctx context.Context, body UnarchiveMonomersJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveMonomersResponse, error) {
	rsp, err := c.UnarchiveMonomers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveMonomersResponse(rsp)
}

// ListNucleotideAlignmentsWithResponse request returning *ListNucleotideAlignmentsResponse
func (c *ClientWithResponses) ListNucleotideAlignmentsWithResponse(ctx context.Context, params *ListNucleotideAlignmentsParams, reqEditors ...RequestEditorFn) (*ListNucleotideAlignmentsResponse, error) {
	rsp, err := c.ListNucleotideAlignments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNucleotideAlignmentsResponse(rsp)
}

// DeleteNucleotideAlignmentWithResponse request returning *DeleteNucleotideAlignmentResponse
func (c *ClientWithResponses) DeleteNucleotideAlignmentWithResponse(ctx context.Context, alignmentId string, reqEditors ...RequestEditorFn) (*DeleteNucleotideAlignmentResponse, error) {
	rsp, err := c.DeleteNucleotideAlignment(ctx, alignmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNucleotideAlignmentResponse(rsp)
}

// GetNucleotideAlignmentWithResponse request returning *GetNucleotideAlignmentResponse
func (c *ClientWithResponses) GetNucleotideAlignmentWithResponse(ctx context.Context, alignmentId string, reqEditors ...RequestEditorFn) (*GetNucleotideAlignmentResponse, error) {
	rsp, err := c.GetNucleotideAlignment(ctx, alignmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNucleotideAlignmentResponse(rsp)
}

// CreateConsensusNucleotideAlignmentWithBodyWithResponse request with arbitrary body returning *CreateConsensusNucleotideAlignmentResponse
func (c *ClientWithResponses) CreateConsensusNucleotideAlignmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConsensusNucleotideAlignmentResponse, error) {
	rsp, err := c.CreateConsensusNucleotideAlignmentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConsensusNucleotideAlignmentResponse(rsp)
}

func (c *ClientWithResponses) CreateConsensusNucleotideAlignmentWithResponse(ctx context.Context, body CreateConsensusNucleotideAlignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConsensusNucleotideAlignmentResponse, error) {
	rsp, err := c.CreateConsensusNucleotideAlignment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConsensusNucleotideAlignmentResponse(rsp)
}

// CreateTemplateNucleotideAlignmentWithBodyWithResponse request with arbitrary body returning *CreateTemplateNucleotideAlignmentResponse
func (c *ClientWithResponses) CreateTemplateNucleotideAlignmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTemplateNucleotideAlignmentResponse, error) {
	rsp, err := c.CreateTemplateNucleotideAlignmentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTemplateNucleotideAlignmentResponse(rsp)
}

func (c *ClientWithResponses) CreateTemplateNucleotideAlignmentWithResponse(ctx context.Context, body CreateTemplateNucleotideAlignmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTemplateNucleotideAlignmentResponse, error) {
	rsp, err := c.CreateTemplateNucleotideAlignment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTemplateNucleotideAlignmentResponse(rsp)
}

// ListOligosWithResponse request returning *ListOligosResponse
func (c *ClientWithResponses) ListOligosWithResponse(ctx context.Context, params *ListOligosParams, reqEditors ...RequestEditorFn) (*ListOligosResponse, error) {
	rsp, err := c.ListOligos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOligosResponse(rsp)
}

// CreateOligoWithBodyWithResponse request with arbitrary body returning *CreateOligoResponse
func (c *ClientWithResponses) CreateOligoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOligoResponse, error) {
	rsp, err := c.CreateOligoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOligoResponse(rsp)
}

func (c *ClientWithResponses) CreateOligoWithResponse(ctx context.Context, body CreateOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOligoResponse, error) {
	rsp, err := c.CreateOligo(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOligoResponse(rsp)
}

// GetOligoWithResponse request returning *GetOligoResponse
func (c *ClientWithResponses) GetOligoWithResponse(ctx context.Context, oligoId string, params *GetOligoParams, reqEditors ...RequestEditorFn) (*GetOligoResponse, error) {
	rsp, err := c.GetOligo(ctx, oligoId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOligoResponse(rsp)
}

// UpdateOligoWithBodyWithResponse request with arbitrary body returning *UpdateOligoResponse
func (c *ClientWithResponses) UpdateOligoWithBodyWithResponse(ctx context.Context, oligoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOligoResponse, error) {
	rsp, err := c.UpdateOligoWithBody(ctx, oligoId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOligoResponse(rsp)
}

func (c *ClientWithResponses) UpdateOligoWithResponse(ctx context.Context, oligoId string, body UpdateOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOligoResponse, error) {
	rsp, err := c.UpdateOligo(ctx, oligoId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOligoResponse(rsp)
}

// ArchiveOligosWithBodyWithResponse request with arbitrary body returning *ArchiveOligosResponse
func (c *ClientWithResponses) ArchiveOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveOligosResponse, error) {
	rsp, err := c.ArchiveOligosWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveOligosResponse(rsp)
}

func (c *ClientWithResponses) ArchiveOligosWithResponse(ctx context.Context, body ArchiveOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveOligosResponse, error) {
	rsp, err := c.ArchiveOligos(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveOligosResponse(rsp)
}

// BulkCreateOligosWithBodyWithResponse request with arbitrary body returning *BulkCreateOligosResponse
func (c *ClientWithResponses) BulkCreateOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateOligosResponse, error) {
	rsp, err := c.BulkCreateOligosWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateOligosResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateOligosWithResponse(ctx context.Context, body BulkCreateOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateOligosResponse, error) {
	rsp, err := c.BulkCreateOligos(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateOligosResponse(rsp)
}

// BulkGetOligosWithResponse request returning *BulkGetOligosResponse
func (c *ClientWithResponses) BulkGetOligosWithResponse(ctx context.Context, params *BulkGetOligosParams, reqEditors ...RequestEditorFn) (*BulkGetOligosResponse, error) {
	rsp, err := c.BulkGetOligos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkGetOligosResponse(rsp)
}

// UnarchiveOligosWithBodyWithResponse request with arbitrary body returning *UnarchiveOligosResponse
func (c *ClientWithResponses) UnarchiveOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveOligosResponse, error) {
	rsp, err := c.UnarchiveOligosWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveOligosResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveOligosWithResponse(ctx context.Context, body UnarchiveOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveOligosResponse, error) {
	rsp, err := c.UnarchiveOligos(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveOligosResponse(rsp)
}

// ListOrganizationsWithResponse request returning *ListOrganizationsResponse
func (c *ClientWithResponses) ListOrganizationsWithResponse(ctx context.Context, params *ListOrganizationsParams, reqEditors ...RequestEditorFn) (*ListOrganizationsResponse, error) {
	rsp, err := c.ListOrganizations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOrganizationsResponse(rsp)
}

// GetOrganizationWithResponse request returning *GetOrganizationResponse
func (c *ClientWithResponses) GetOrganizationWithResponse(ctx context.Context, organizationId string, reqEditors ...RequestEditorFn) (*GetOrganizationResponse, error) {
	rsp, err := c.GetOrganization(ctx, organizationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationResponse(rsp)
}

// ListPlateSchemasWithResponse request returning *ListPlateSchemasResponse
func (c *ClientWithResponses) ListPlateSchemasWithResponse(ctx context.Context, params *ListPlateSchemasParams, reqEditors ...RequestEditorFn) (*ListPlateSchemasResponse, error) {
	rsp, err := c.ListPlateSchemas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPlateSchemasResponse(rsp)
}

// GetPlateSchemaWithResponse request returning *GetPlateSchemaResponse
func (c *ClientWithResponses) GetPlateSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetPlateSchemaResponse, error) {
	rsp, err := c.GetPlateSchema(ctx, schemaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlateSchemaResponse(rsp)
}

// ListPlatesWithResponse request returning *ListPlatesResponse
func (c *ClientWithResponses) ListPlatesWithResponse(ctx context.Context, params *ListPlatesParams, reqEditors ...RequestEditorFn) (*ListPlatesResponse, error) {
	rsp, err := c.ListPlates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPlatesResponse(rsp)
}

// CreatePlateWithBodyWithResponse request with arbitrary body returning *CreatePlateResponse
func (c *ClientWithResponses) CreatePlateWithBodyWithResponse(ctx context.Context, params *CreatePlateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePlateResponse, error) {
	rsp, err := c.CreatePlateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlateResponse(rsp)
}

func (c *ClientWithResponses) CreatePlateWithResponse(ctx context.Context, params *CreatePlateParams, body CreatePlateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePlateResponse, error) {
	rsp, err := c.CreatePlate(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePlateResponse(rsp)
}

// GetPlateWithResponse request returning *GetPlateResponse
func (c *ClientWithResponses) GetPlateWithResponse(ctx context.Context, plateId string, params *GetPlateParams, reqEditors ...RequestEditorFn) (*GetPlateResponse, error) {
	rsp, err := c.GetPlate(ctx, plateId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlateResponse(rsp)
}

// UpdatePlateWithBodyWithResponse request with arbitrary body returning *UpdatePlateResponse
func (c *ClientWithResponses) UpdatePlateWithBodyWithResponse(ctx context.Context, plateId string, params *UpdatePlateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePlateResponse, error) {
	rsp, err := c.UpdatePlateWithBody(ctx, plateId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlateResponse(rsp)
}

func (c *ClientWithResponses) UpdatePlateWithResponse(ctx context.Context, plateId string, params *UpdatePlateParams, body UpdatePlateJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePlateResponse, error) {
	rsp, err := c.UpdatePlate(ctx, plateId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePlateResponse(rsp)
}

// ArchivePlatesWithBodyWithResponse request with arbitrary body returning *ArchivePlatesResponse
func (c *ClientWithResponses) ArchivePlatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchivePlatesResponse, error) {
	rsp, err := c.ArchivePlatesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchivePlatesResponse(rsp)
}

func (c *ClientWithResponses) ArchivePlatesWithResponse(ctx context.Context, body ArchivePlatesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchivePlatesResponse, error) {
	rsp, err := c.ArchivePlates(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchivePlatesResponse(rsp)
}

// BulkGetPlatesWithResponse request returning *BulkGetPlatesResponse
func (c *ClientWithResponses) BulkGetPlatesWithResponse(ctx context.Context, params *BulkGetPlatesParams, reqEditors ...RequestEditorFn) (*BulkGetPlatesResponse, error) {
	rsp, err := c.BulkGetPlates(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkGetPlatesResponse(rsp)
}

// UnarchivePlatesWithBodyWithResponse request with arbitrary body returning *UnarchivePlatesResponse
func (c *ClientWithResponses) UnarchivePlatesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchivePlatesResponse, error) {
	rsp, err := c.UnarchivePlatesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchivePlatesResponse(rsp)
}

func (c *ClientWithResponses) UnarchivePlatesWithResponse(ctx context.Context, body UnarchivePlatesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchivePlatesResponse, error) {
	rsp, err := c.UnarchivePlates(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchivePlatesResponse(rsp)
}

// ListProjectsWithResponse request returning *ListProjectsResponse
func (c *ClientWithResponses) ListProjectsWithResponse(ctx context.Context, params *ListProjectsParams, reqEditors ...RequestEditorFn) (*ListProjectsResponse, error) {
	rsp, err := c.ListProjects(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListProjectsResponse(rsp)
}

// GetProjectWithResponse request returning *GetProjectResponse
func (c *ClientWithResponses) GetProjectWithResponse(ctx context.Context, projectId string, reqEditors ...RequestEditorFn) (*GetProjectResponse, error) {
	rsp, err := c.GetProject(ctx, projectId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProjectResponse(rsp)
}

// ArchiveProjectsWithBodyWithResponse request with arbitrary body returning *ArchiveProjectsResponse
func (c *ClientWithResponses) ArchiveProjectsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveProjectsResponse, error) {
	rsp, err := c.ArchiveProjectsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveProjectsResponse(rsp)
}

func (c *ClientWithResponses) ArchiveProjectsWithResponse(ctx context.Context, body ArchiveProjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveProjectsResponse, error) {
	rsp, err := c.ArchiveProjects(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveProjectsResponse(rsp)
}

// UnarchiveProjectsWithBodyWithResponse request with arbitrary body returning *UnarchiveProjectsResponse
func (c *ClientWithResponses) UnarchiveProjectsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveProjectsResponse, error) {
	rsp, err := c.UnarchiveProjectsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveProjectsResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveProjectsWithResponse(ctx context.Context, body UnarchiveProjectsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveProjectsResponse, error) {
	rsp, err := c.UnarchiveProjects(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveProjectsResponse(rsp)
}

// ListRegistriesWithResponse request returning *ListRegistriesResponse
func (c *ClientWithResponses) ListRegistriesWithResponse(ctx context.Context, params *ListRegistriesParams, reqEditors ...RequestEditorFn) (*ListRegistriesResponse, error) {
	rsp, err := c.ListRegistries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRegistriesResponse(rsp)
}

// GetRegistryWithResponse request returning *GetRegistryResponse
func (c *ClientWithResponses) GetRegistryWithResponse(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*GetRegistryResponse, error) {
	rsp, err := c.GetRegistry(ctx, registryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryResponse(rsp)
}

// ListBatchSchemasByRegistryWithResponse request returning *ListBatchSchemasByRegistryResponse
func (c *ClientWithResponses) ListBatchSchemasByRegistryWithResponse(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*ListBatchSchemasByRegistryResponse, error) {
	rsp, err := c.ListBatchSchemasByRegistry(ctx, registryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBatchSchemasByRegistryResponse(rsp)
}

// ListBoxSchemasByRegistryWithResponse request returning *ListBoxSchemasByRegistryResponse
func (c *ClientWithResponses) ListBoxSchemasByRegistryWithResponse(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*ListBoxSchemasByRegistryResponse, error) {
	rsp, err := c.ListBoxSchemasByRegistry(ctx, registryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBoxSchemasByRegistryResponse(rsp)
}

// ListContainerSchemasByRegistryWithResponse request returning *ListContainerSchemasByRegistryResponse
func (c *ClientWithResponses) ListContainerSchemasByRegistryWithResponse(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*ListContainerSchemasByRegistryResponse, error) {
	rsp, err := c.ListContainerSchemasByRegistry(ctx, registryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListContainerSchemasByRegistryResponse(rsp)
}

// ListDropdownsByRegistryWithResponse request returning *ListDropdownsByRegistryResponse
func (c *ClientWithResponses) ListDropdownsByRegistryWithResponse(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*ListDropdownsByRegistryResponse, error) {
	rsp, err := c.ListDropdownsByRegistry(ctx, registryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDropdownsByRegistryResponse(rsp)
}

// ListEntitySchemasByRegistryWithResponse request returning *ListEntitySchemasByRegistryResponse
func (c *ClientWithResponses) ListEntitySchemasByRegistryWithResponse(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*ListEntitySchemasByRegistryResponse, error) {
	rsp, err := c.ListEntitySchemasByRegistry(ctx, registryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEntitySchemasByRegistryResponse(rsp)
}

// ListPrintersWithResponse request returning *ListPrintersResponse
func (c *ClientWithResponses) ListPrintersWithResponse(ctx context.Context, registryId string, params *ListPrintersParams, reqEditors ...RequestEditorFn) (*ListPrintersResponse, error) {
	rsp, err := c.ListPrinters(ctx, registryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPrintersResponse(rsp)
}

// ListLabelTemplatesWithResponse request returning *ListLabelTemplatesResponse
func (c *ClientWithResponses) ListLabelTemplatesWithResponse(ctx context.Context, registryId string, params *ListLabelTemplatesParams, reqEditors ...RequestEditorFn) (*ListLabelTemplatesResponse, error) {
	rsp, err := c.ListLabelTemplates(ctx, registryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLabelTemplatesResponse(rsp)
}

// ListLocationSchemasByRegistryWithResponse request returning *ListLocationSchemasByRegistryResponse
func (c *ClientWithResponses) ListLocationSchemasByRegistryWithResponse(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*ListLocationSchemasByRegistryResponse, error) {
	rsp, err := c.ListLocationSchemasByRegistry(ctx, registryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListLocationSchemasByRegistryResponse(rsp)
}

// ListPlateSchemasByRegistryWithResponse request returning *ListPlateSchemasByRegistryResponse
func (c *ClientWithResponses) ListPlateSchemasByRegistryWithResponse(ctx context.Context, registryId string, reqEditors ...RequestEditorFn) (*ListPlateSchemasByRegistryResponse, error) {
	rsp, err := c.ListPlateSchemasByRegistry(ctx, registryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPlateSchemasByRegistryResponse(rsp)
}

// BulkGetRegisteredEntitiesWithResponse request returning *BulkGetRegisteredEntitiesResponse
func (c *ClientWithResponses) BulkGetRegisteredEntitiesWithResponse(ctx context.Context, registryId string, params *BulkGetRegisteredEntitiesParams, reqEditors ...RequestEditorFn) (*BulkGetRegisteredEntitiesResponse, error) {
	rsp, err := c.BulkGetRegisteredEntities(ctx, registryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkGetRegisteredEntitiesResponse(rsp)
}

// RegisterEntitiesWithBodyWithResponse request with arbitrary body returning *RegisterEntitiesResponse
func (c *ClientWithResponses) RegisterEntitiesWithBodyWithResponse(ctx context.Context, registryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterEntitiesResponse, error) {
	rsp, err := c.RegisterEntitiesWithBody(ctx, registryId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterEntitiesResponse(rsp)
}

func (c *ClientWithResponses) RegisterEntitiesWithResponse(ctx context.Context, registryId string, body RegisterEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterEntitiesResponse, error) {
	rsp, err := c.RegisterEntities(ctx, registryId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterEntitiesResponse(rsp)
}

// UnregisterEntitiesWithBodyWithResponse request with arbitrary body returning *UnregisterEntitiesResponse
func (c *ClientWithResponses) UnregisterEntitiesWithBodyWithResponse(ctx context.Context, registryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnregisterEntitiesResponse, error) {
	rsp, err := c.UnregisterEntitiesWithBody(ctx, registryId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnregisterEntitiesResponse(rsp)
}

func (c *ClientWithResponses) UnregisterEntitiesWithResponse(ctx context.Context, registryId string, body UnregisterEntitiesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnregisterEntitiesResponse, error) {
	rsp, err := c.UnregisterEntities(ctx, registryId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnregisterEntitiesResponse(rsp)
}

// ValidateBarcodesWithBodyWithResponse request with arbitrary body returning *ValidateBarcodesResponse
func (c *ClientWithResponses) ValidateBarcodesWithBodyWithResponse(ctx context.Context, registryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ValidateBarcodesResponse, error) {
	rsp, err := c.ValidateBarcodesWithBody(ctx, registryId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateBarcodesResponse(rsp)
}

func (c *ClientWithResponses) ValidateBarcodesWithResponse(ctx context.Context, registryId string, body ValidateBarcodesJSONRequestBody, reqEditors ...RequestEditorFn) (*ValidateBarcodesResponse, error) {
	rsp, err := c.ValidateBarcodes(ctx, registryId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseValidateBarcodesResponse(rsp)
}

// ListRequestFulfillmentsWithResponse request returning *ListRequestFulfillmentsResponse
func (c *ClientWithResponses) ListRequestFulfillmentsWithResponse(ctx context.Context, params *ListRequestFulfillmentsParams, reqEditors ...RequestEditorFn) (*ListRequestFulfillmentsResponse, error) {
	rsp, err := c.ListRequestFulfillments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRequestFulfillmentsResponse(rsp)
}

// GetRequestFulfillmentWithResponse request returning *GetRequestFulfillmentResponse
func (c *ClientWithResponses) GetRequestFulfillmentWithResponse(ctx context.Context, requestFulfillmentId string, reqEditors ...RequestEditorFn) (*GetRequestFulfillmentResponse, error) {
	rsp, err := c.GetRequestFulfillment(ctx, requestFulfillmentId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRequestFulfillmentResponse(rsp)
}

// ListRequestSchemasWithResponse request returning *ListRequestSchemasResponse
func (c *ClientWithResponses) ListRequestSchemasWithResponse(ctx context.Context, params *ListRequestSchemasParams, reqEditors ...RequestEditorFn) (*ListRequestSchemasResponse, error) {
	rsp, err := c.ListRequestSchemas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRequestSchemasResponse(rsp)
}

// GetRequestSchemaWithResponse request returning *GetRequestSchemaResponse
func (c *ClientWithResponses) GetRequestSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetRequestSchemaResponse, error) {
	rsp, err := c.GetRequestSchema(ctx, schemaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRequestSchemaResponse(rsp)
}

// ListRequestTaskSchemasWithResponse request returning *ListRequestTaskSchemasResponse
func (c *ClientWithResponses) ListRequestTaskSchemasWithResponse(ctx context.Context, params *ListRequestTaskSchemasParams, reqEditors ...RequestEditorFn) (*ListRequestTaskSchemasResponse, error) {
	rsp, err := c.ListRequestTaskSchemas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRequestTaskSchemasResponse(rsp)
}

// GetRequestTaskSchemaWithResponse request returning *GetRequestTaskSchemaResponse
func (c *ClientWithResponses) GetRequestTaskSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetRequestTaskSchemaResponse, error) {
	rsp, err := c.GetRequestTaskSchema(ctx, schemaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRequestTaskSchemaResponse(rsp)
}

// ListRequestsWithResponse request returning *ListRequestsResponse
func (c *ClientWithResponses) ListRequestsWithResponse(ctx context.Context, params *ListRequestsParams, reqEditors ...RequestEditorFn) (*ListRequestsResponse, error) {
	rsp, err := c.ListRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRequestsResponse(rsp)
}

// CreateRequestWithBodyWithResponse request with arbitrary body returning *CreateRequestResponse
func (c *ClientWithResponses) CreateRequestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRequestResponse, error) {
	rsp, err := c.CreateRequestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRequestResponse(rsp)
}

func (c *ClientWithResponses) CreateRequestWithResponse(ctx context.Context, body CreateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRequestResponse, error) {
	rsp, err := c.CreateRequest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRequestResponse(rsp)
}

// GetRequestWithResponse request returning *GetRequestResponse
func (c *ClientWithResponses) GetRequestWithResponse(ctx context.Context, requestId string, params *GetRequestParams, reqEditors ...RequestEditorFn) (*GetRequestResponse, error) {
	rsp, err := c.GetRequest(ctx, requestId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRequestResponse(rsp)
}

// PatchRequestWithBodyWithResponse request with arbitrary body returning *PatchRequestResponse
func (c *ClientWithResponses) PatchRequestWithBodyWithResponse(ctx context.Context, requestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchRequestResponse, error) {
	rsp, err := c.PatchRequestWithBody(ctx, requestId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchRequestResponse(rsp)
}

func (c *ClientWithResponses) PatchRequestWithResponse(ctx context.Context, requestId string, body PatchRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchRequestResponse, error) {
	rsp, err := c.PatchRequest(ctx, requestId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchRequestResponse(rsp)
}

// GetRequestResponseWithResponse request returning *GetRequestResponseResponse
func (c *ClientWithResponses) GetRequestResponseWithResponse(ctx context.Context, requestId string, reqEditors ...RequestEditorFn) (*GetRequestResponseResponse, error) {
	rsp, err := c.GetRequestResponse(ctx, requestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRequestResponseResponse(rsp)
}

// BulkCreateRequestTasksWithBodyWithResponse request with arbitrary body returning *BulkCreateRequestTasksResponse
func (c *ClientWithResponses) BulkCreateRequestTasksWithBodyWithResponse(ctx context.Context, requestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateRequestTasksResponse, error) {
	rsp, err := c.BulkCreateRequestTasksWithBody(ctx, requestId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateRequestTasksResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateRequestTasksWithResponse(ctx context.Context, requestId string, body BulkCreateRequestTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateRequestTasksResponse, error) {
	rsp, err := c.BulkCreateRequestTasks(ctx, requestId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateRequestTasksResponse(rsp)
}

// BulkUpdateRequestTasksWithBodyWithResponse request with arbitrary body returning *BulkUpdateRequestTasksResponse
func (c *ClientWithResponses) BulkUpdateRequestTasksWithBodyWithResponse(ctx context.Context, requestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateRequestTasksResponse, error) {
	rsp, err := c.BulkUpdateRequestTasksWithBody(ctx, requestId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateRequestTasksResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateRequestTasksWithResponse(ctx context.Context, requestId string, body BulkUpdateRequestTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateRequestTasksResponse, error) {
	rsp, err := c.BulkUpdateRequestTasks(ctx, requestId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateRequestTasksResponse(rsp)
}

// ExecuteRequestsSampleGroupsWithBodyWithResponse request with arbitrary body returning *ExecuteRequestsSampleGroupsResponse
func (c *ClientWithResponses) ExecuteRequestsSampleGroupsWithBodyWithResponse(ctx context.Context, requestId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteRequestsSampleGroupsResponse, error) {
	rsp, err := c.ExecuteRequestsSampleGroupsWithBody(ctx, requestId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteRequestsSampleGroupsResponse(rsp)
}

func (c *ClientWithResponses) ExecuteRequestsSampleGroupsWithResponse(ctx context.Context, requestId string, body ExecuteRequestsSampleGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteRequestsSampleGroupsResponse, error) {
	rsp, err := c.ExecuteRequestsSampleGroups(ctx, requestId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteRequestsSampleGroupsResponse(rsp)
}

// BulkGetRequestsWithResponse request returning *BulkGetRequestsResponse
func (c *ClientWithResponses) BulkGetRequestsWithResponse(ctx context.Context, params *BulkGetRequestsParams, reqEditors ...RequestEditorFn) (*BulkGetRequestsResponse, error) {
	rsp, err := c.BulkGetRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkGetRequestsResponse(rsp)
}

// CreateAssayResultsTransactionWithResponse request returning *CreateAssayResultsTransactionResponse
func (c *ClientWithResponses) CreateAssayResultsTransactionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateAssayResultsTransactionResponse, error) {
	rsp, err := c.CreateAssayResultsTransaction(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssayResultsTransactionResponse(rsp)
}

// CreateAssayResultsInTransactionWithBodyWithResponse request with arbitrary body returning *CreateAssayResultsInTransactionResponse
func (c *ClientWithResponses) CreateAssayResultsInTransactionWithBodyWithResponse(ctx context.Context, transactionId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAssayResultsInTransactionResponse, error) {
	rsp, err := c.CreateAssayResultsInTransactionWithBody(ctx, transactionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssayResultsInTransactionResponse(rsp)
}

func (c *ClientWithResponses) CreateAssayResultsInTransactionWithResponse(ctx context.Context, transactionId openapi_types.UUID, body CreateAssayResultsInTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAssayResultsInTransactionResponse, error) {
	rsp, err := c.CreateAssayResultsInTransaction(ctx, transactionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssayResultsInTransactionResponse(rsp)
}

// AbortAssayResultsTransactionWithResponse request returning *AbortAssayResultsTransactionResponse
func (c *ClientWithResponses) AbortAssayResultsTransactionWithResponse(ctx context.Context, transactionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*AbortAssayResultsTransactionResponse, error) {
	rsp, err := c.AbortAssayResultsTransaction(ctx, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAbortAssayResultsTransactionResponse(rsp)
}

// CommitAssayResultsTransactionWithResponse request returning *CommitAssayResultsTransactionResponse
func (c *ClientWithResponses) CommitAssayResultsTransactionWithResponse(ctx context.Context, transactionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*CommitAssayResultsTransactionResponse, error) {
	rsp, err := c.CommitAssayResultsTransaction(ctx, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitAssayResultsTransactionResponse(rsp)
}

// ListRNAOligosWithResponse request returning *ListRNAOligosResponse
func (c *ClientWithResponses) ListRNAOligosWithResponse(ctx context.Context, params *ListRNAOligosParams, reqEditors ...RequestEditorFn) (*ListRNAOligosResponse, error) {
	rsp, err := c.ListRNAOligos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRNAOligosResponse(rsp)
}

// CreateRNAOligoWithBodyWithResponse request with arbitrary body returning *CreateRNAOligoResponse
func (c *ClientWithResponses) CreateRNAOligoWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRNAOligoResponse, error) {
	rsp, err := c.CreateRNAOligoWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRNAOligoResponse(rsp)
}

func (c *ClientWithResponses) CreateRNAOligoWithResponse(ctx context.Context, body CreateRNAOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRNAOligoResponse, error) {
	rsp, err := c.CreateRNAOligo(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRNAOligoResponse(rsp)
}

// GetRNAOligoWithResponse request returning *GetRNAOligoResponse
func (c *ClientWithResponses) GetRNAOligoWithResponse(ctx context.Context, oligoId string, params *GetRNAOligoParams, reqEditors ...RequestEditorFn) (*GetRNAOligoResponse, error) {
	rsp, err := c.GetRNAOligo(ctx, oligoId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRNAOligoResponse(rsp)
}

// UpdateRNAOligoWithBodyWithResponse request with arbitrary body returning *UpdateRNAOligoResponse
func (c *ClientWithResponses) UpdateRNAOligoWithBodyWithResponse(ctx context.Context, oligoId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRNAOligoResponse, error) {
	rsp, err := c.UpdateRNAOligoWithBody(ctx, oligoId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRNAOligoResponse(rsp)
}

func (c *ClientWithResponses) UpdateRNAOligoWithResponse(ctx context.Context, oligoId string, body UpdateRNAOligoJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRNAOligoResponse, error) {
	rsp, err := c.UpdateRNAOligo(ctx, oligoId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRNAOligoResponse(rsp)
}

// ArchiveRNAOligosWithBodyWithResponse request with arbitrary body returning *ArchiveRNAOligosResponse
func (c *ClientWithResponses) ArchiveRNAOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveRNAOligosResponse, error) {
	rsp, err := c.ArchiveRNAOligosWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveRNAOligosResponse(rsp)
}

func (c *ClientWithResponses) ArchiveRNAOligosWithResponse(ctx context.Context, body ArchiveRNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveRNAOligosResponse, error) {
	rsp, err := c.ArchiveRNAOligos(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveRNAOligosResponse(rsp)
}

// BulkCreateRNAOligosWithBodyWithResponse request with arbitrary body returning *BulkCreateRNAOligosResponse
func (c *ClientWithResponses) BulkCreateRNAOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateRNAOligosResponse, error) {
	rsp, err := c.BulkCreateRNAOligosWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateRNAOligosResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateRNAOligosWithResponse(ctx context.Context, body BulkCreateRNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateRNAOligosResponse, error) {
	rsp, err := c.BulkCreateRNAOligos(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateRNAOligosResponse(rsp)
}

// BulkUpdateRNAOligosWithBodyWithResponse request with arbitrary body returning *BulkUpdateRNAOligosResponse
func (c *ClientWithResponses) BulkUpdateRNAOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateRNAOligosResponse, error) {
	rsp, err := c.BulkUpdateRNAOligosWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateRNAOligosResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateRNAOligosWithResponse(ctx context.Context, body BulkUpdateRNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateRNAOligosResponse, error) {
	rsp, err := c.BulkUpdateRNAOligos(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateRNAOligosResponse(rsp)
}

// UnarchiveRNAOligosWithBodyWithResponse request with arbitrary body returning *UnarchiveRNAOligosResponse
func (c *ClientWithResponses) UnarchiveRNAOligosWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveRNAOligosResponse, error) {
	rsp, err := c.UnarchiveRNAOligosWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveRNAOligosResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveRNAOligosWithResponse(ctx context.Context, body UnarchiveRNAOligosJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveRNAOligosResponse, error) {
	rsp, err := c.UnarchiveRNAOligos(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveRNAOligosResponse(rsp)
}

// ListRNASequencesWithResponse request returning *ListRNASequencesResponse
func (c *ClientWithResponses) ListRNASequencesWithResponse(ctx context.Context, params *ListRNASequencesParams, reqEditors ...RequestEditorFn) (*ListRNASequencesResponse, error) {
	rsp, err := c.ListRNASequences(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListRNASequencesResponse(rsp)
}

// CreateRNASequenceWithBodyWithResponse request with arbitrary body returning *CreateRNASequenceResponse
func (c *ClientWithResponses) CreateRNASequenceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRNASequenceResponse, error) {
	rsp, err := c.CreateRNASequenceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRNASequenceResponse(rsp)
}

func (c *ClientWithResponses) CreateRNASequenceWithResponse(ctx context.Context, body CreateRNASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRNASequenceResponse, error) {
	rsp, err := c.CreateRNASequence(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRNASequenceResponse(rsp)
}

// GetRNASequenceWithResponse request returning *GetRNASequenceResponse
func (c *ClientWithResponses) GetRNASequenceWithResponse(ctx context.Context, rnaSequenceId string, params *GetRNASequenceParams, reqEditors ...RequestEditorFn) (*GetRNASequenceResponse, error) {
	rsp, err := c.GetRNASequence(ctx, rnaSequenceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRNASequenceResponse(rsp)
}

// UpdateRNASequenceWithBodyWithResponse request with arbitrary body returning *UpdateRNASequenceResponse
func (c *ClientWithResponses) UpdateRNASequenceWithBodyWithResponse(ctx context.Context, rnaSequenceId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRNASequenceResponse, error) {
	rsp, err := c.UpdateRNASequenceWithBody(ctx, rnaSequenceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRNASequenceResponse(rsp)
}

func (c *ClientWithResponses) UpdateRNASequenceWithResponse(ctx context.Context, rnaSequenceId string, body UpdateRNASequenceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRNASequenceResponse, error) {
	rsp, err := c.UpdateRNASequence(ctx, rnaSequenceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRNASequenceResponse(rsp)
}

// ArchiveRNASequencesWithBodyWithResponse request with arbitrary body returning *ArchiveRNASequencesResponse
func (c *ClientWithResponses) ArchiveRNASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveRNASequencesResponse, error) {
	rsp, err := c.ArchiveRNASequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveRNASequencesResponse(rsp)
}

func (c *ClientWithResponses) ArchiveRNASequencesWithResponse(ctx context.Context, body ArchiveRNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveRNASequencesResponse, error) {
	rsp, err := c.ArchiveRNASequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveRNASequencesResponse(rsp)
}

// AutoAnnotateRnaSequencesWithBodyWithResponse request with arbitrary body returning *AutoAnnotateRnaSequencesResponse
func (c *ClientWithResponses) AutoAnnotateRnaSequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AutoAnnotateRnaSequencesResponse, error) {
	rsp, err := c.AutoAnnotateRnaSequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutoAnnotateRnaSequencesResponse(rsp)
}

func (c *ClientWithResponses) AutoAnnotateRnaSequencesWithResponse(ctx context.Context, body AutoAnnotateRnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*AutoAnnotateRnaSequencesResponse, error) {
	rsp, err := c.AutoAnnotateRnaSequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutoAnnotateRnaSequencesResponse(rsp)
}

// AutofillRNASequencePartsWithBodyWithResponse request with arbitrary body returning *AutofillRNASequencePartsResponse
func (c *ClientWithResponses) AutofillRNASequencePartsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AutofillRNASequencePartsResponse, error) {
	rsp, err := c.AutofillRNASequencePartsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutofillRNASequencePartsResponse(rsp)
}

func (c *ClientWithResponses) AutofillRNASequencePartsWithResponse(ctx context.Context, body AutofillRNASequencePartsJSONRequestBody, reqEditors ...RequestEditorFn) (*AutofillRNASequencePartsResponse, error) {
	rsp, err := c.AutofillRNASequenceParts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutofillRNASequencePartsResponse(rsp)
}

// AutofillRNASequenceTranslationsWithBodyWithResponse request with arbitrary body returning *AutofillRNASequenceTranslationsResponse
func (c *ClientWithResponses) AutofillRNASequenceTranslationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AutofillRNASequenceTranslationsResponse, error) {
	rsp, err := c.AutofillRNASequenceTranslationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutofillRNASequenceTranslationsResponse(rsp)
}

func (c *ClientWithResponses) AutofillRNASequenceTranslationsWithResponse(ctx context.Context, body AutofillRNASequenceTranslationsJSONRequestBody, reqEditors ...RequestEditorFn) (*AutofillRNASequenceTranslationsResponse, error) {
	rsp, err := c.AutofillRNASequenceTranslations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAutofillRNASequenceTranslationsResponse(rsp)
}

// BulkCreateRNASequencesWithBodyWithResponse request with arbitrary body returning *BulkCreateRNASequencesResponse
func (c *ClientWithResponses) BulkCreateRNASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateRNASequencesResponse, error) {
	rsp, err := c.BulkCreateRNASequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateRNASequencesResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateRNASequencesWithResponse(ctx context.Context, body BulkCreateRNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateRNASequencesResponse, error) {
	rsp, err := c.BulkCreateRNASequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateRNASequencesResponse(rsp)
}

// BulkGetRNASequencesWithResponse request returning *BulkGetRNASequencesResponse
func (c *ClientWithResponses) BulkGetRNASequencesWithResponse(ctx context.Context, params *BulkGetRNASequencesParams, reqEditors ...RequestEditorFn) (*BulkGetRNASequencesResponse, error) {
	rsp, err := c.BulkGetRNASequences(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkGetRNASequencesResponse(rsp)
}

// BulkUpdateRNASequencesWithBodyWithResponse request with arbitrary body returning *BulkUpdateRNASequencesResponse
func (c *ClientWithResponses) BulkUpdateRNASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateRNASequencesResponse, error) {
	rsp, err := c.BulkUpdateRNASequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateRNASequencesResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateRNASequencesWithResponse(ctx context.Context, body BulkUpdateRNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateRNASequencesResponse, error) {
	rsp, err := c.BulkUpdateRNASequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateRNASequencesResponse(rsp)
}

// MatchBasesRnaSequencesWithBodyWithResponse request with arbitrary body returning *MatchBasesRnaSequencesResponse
func (c *ClientWithResponses) MatchBasesRnaSequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MatchBasesRnaSequencesResponse, error) {
	rsp, err := c.MatchBasesRnaSequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMatchBasesRnaSequencesResponse(rsp)
}

func (c *ClientWithResponses) MatchBasesRnaSequencesWithResponse(ctx context.Context, body MatchBasesRnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*MatchBasesRnaSequencesResponse, error) {
	rsp, err := c.MatchBasesRnaSequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMatchBasesRnaSequencesResponse(rsp)
}

// SearchRnaSequencesWithBodyWithResponse request with arbitrary body returning *SearchRnaSequencesResponse
func (c *ClientWithResponses) SearchRnaSequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchRnaSequencesResponse, error) {
	rsp, err := c.SearchRnaSequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRnaSequencesResponse(rsp)
}

func (c *ClientWithResponses) SearchRnaSequencesWithResponse(ctx context.Context, body SearchRnaSequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchRnaSequencesResponse, error) {
	rsp, err := c.SearchRnaSequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRnaSequencesResponse(rsp)
}

// UnarchiveRNASequencesWithBodyWithResponse request with arbitrary body returning *UnarchiveRNASequencesResponse
func (c *ClientWithResponses) UnarchiveRNASequencesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveRNASequencesResponse, error) {
	rsp, err := c.UnarchiveRNASequencesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveRNASequencesResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveRNASequencesWithResponse(ctx context.Context, body UnarchiveRNASequencesJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveRNASequencesResponse, error) {
	rsp, err := c.UnarchiveRNASequences(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveRNASequencesResponse(rsp)
}

// GetTaskWithResponse request returning *GetTaskResponse
func (c *ClientWithResponses) GetTaskWithResponse(ctx context.Context, taskId string, reqEditors ...RequestEditorFn) (*GetTaskResponse, error) {
	rsp, err := c.GetTask(ctx, taskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTaskResponse(rsp)
}

// ListTeamsWithResponse request returning *ListTeamsResponse
func (c *ClientWithResponses) ListTeamsWithResponse(ctx context.Context, params *ListTeamsParams, reqEditors ...RequestEditorFn) (*ListTeamsResponse, error) {
	rsp, err := c.ListTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTeamsResponse(rsp)
}

// GetTeamWithResponse request returning *GetTeamResponse
func (c *ClientWithResponses) GetTeamWithResponse(ctx context.Context, teamId string, reqEditors ...RequestEditorFn) (*GetTeamResponse, error) {
	rsp, err := c.GetTeam(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamResponse(rsp)
}

// GenerateTokenWithBodyWithResponse request with arbitrary body returning *GenerateTokenResponse
func (c *ClientWithResponses) GenerateTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GenerateTokenResponse, error) {
	rsp, err := c.GenerateTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTokenResponse(rsp)
}

func (c *ClientWithResponses) GenerateTokenWithFormdataBodyWithResponse(ctx context.Context, body GenerateTokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*GenerateTokenResponse, error) {
	rsp, err := c.GenerateTokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateTokenResponse(rsp)
}

// TransferIntoContainersWithBodyWithResponse request with arbitrary body returning *TransferIntoContainersResponse
func (c *ClientWithResponses) TransferIntoContainersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferIntoContainersResponse, error) {
	rsp, err := c.TransferIntoContainersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferIntoContainersResponse(rsp)
}

func (c *ClientWithResponses) TransferIntoContainersWithResponse(ctx context.Context, body TransferIntoContainersJSONRequestBody, reqEditors ...RequestEditorFn) (*TransferIntoContainersResponse, error) {
	rsp, err := c.TransferIntoContainers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferIntoContainersResponse(rsp)
}

// ListUsersWithResponse request returning *ListUsersResponse
func (c *ClientWithResponses) ListUsersWithResponse(ctx context.Context, params *ListUsersParams, reqEditors ...RequestEditorFn) (*ListUsersResponse, error) {
	rsp, err := c.ListUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// UpdateUserWithBodyWithResponse request with arbitrary body returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUserWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, userId string, body UpdateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error) {
	rsp, err := c.UpdateUser(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserResponse(rsp)
}

// GetUserActivityWithResponse request returning *GetUserActivityResponse
func (c *ClientWithResponses) GetUserActivityWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*GetUserActivityResponse, error) {
	rsp, err := c.GetUserActivity(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserActivityResponse(rsp)
}

// BulkCreateUsersWithBodyWithResponse request with arbitrary body returning *BulkCreateUsersResponse
func (c *ClientWithResponses) BulkCreateUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateUsersResponse, error) {
	rsp, err := c.BulkCreateUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateUsersResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateUsersWithResponse(ctx context.Context, body BulkCreateUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateUsersResponse, error) {
	rsp, err := c.BulkCreateUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateUsersResponse(rsp)
}

// BulkUpdateUsersWithBodyWithResponse request with arbitrary body returning *BulkUpdateUsersResponse
func (c *ClientWithResponses) BulkUpdateUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateUsersResponse, error) {
	rsp, err := c.BulkUpdateUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateUsersResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateUsersWithResponse(ctx context.Context, body BulkUpdateUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateUsersResponse, error) {
	rsp, err := c.BulkUpdateUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateUsersResponse(rsp)
}

// CreateWarehouseCredentialsWithBodyWithResponse request with arbitrary body returning *CreateWarehouseCredentialsResponse
func (c *ClientWithResponses) CreateWarehouseCredentialsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWarehouseCredentialsResponse, error) {
	rsp, err := c.CreateWarehouseCredentialsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWarehouseCredentialsResponse(rsp)
}

func (c *ClientWithResponses) CreateWarehouseCredentialsWithResponse(ctx context.Context, body CreateWarehouseCredentialsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWarehouseCredentialsResponse, error) {
	rsp, err := c.CreateWarehouseCredentials(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWarehouseCredentialsResponse(rsp)
}

// ListWorkflowOutputsWithResponse request returning *ListWorkflowOutputsResponse
func (c *ClientWithResponses) ListWorkflowOutputsWithResponse(ctx context.Context, params *ListWorkflowOutputsParams, reqEditors ...RequestEditorFn) (*ListWorkflowOutputsResponse, error) {
	rsp, err := c.ListWorkflowOutputs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkflowOutputsResponse(rsp)
}

// CreateWorkflowOutputWithBodyWithResponse request with arbitrary body returning *CreateWorkflowOutputResponse
func (c *ClientWithResponses) CreateWorkflowOutputWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkflowOutputResponse, error) {
	rsp, err := c.CreateWorkflowOutputWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkflowOutputResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkflowOutputWithResponse(ctx context.Context, body CreateWorkflowOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkflowOutputResponse, error) {
	rsp, err := c.CreateWorkflowOutput(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkflowOutputResponse(rsp)
}

// GetWorkflowOutputWithResponse request returning *GetWorkflowOutputResponse
func (c *ClientWithResponses) GetWorkflowOutputWithResponse(ctx context.Context, workflowOutputId string, reqEditors ...RequestEditorFn) (*GetWorkflowOutputResponse, error) {
	rsp, err := c.GetWorkflowOutput(ctx, workflowOutputId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkflowOutputResponse(rsp)
}

// UpdateWorkflowOutputWithBodyWithResponse request with arbitrary body returning *UpdateWorkflowOutputResponse
func (c *ClientWithResponses) UpdateWorkflowOutputWithBodyWithResponse(ctx context.Context, workflowOutputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkflowOutputResponse, error) {
	rsp, err := c.UpdateWorkflowOutputWithBody(ctx, workflowOutputId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkflowOutputResponse(rsp)
}

func (c *ClientWithResponses) UpdateWorkflowOutputWithResponse(ctx context.Context, workflowOutputId string, body UpdateWorkflowOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkflowOutputResponse, error) {
	rsp, err := c.UpdateWorkflowOutput(ctx, workflowOutputId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkflowOutputResponse(rsp)
}

// ArchiveWorkflowOutputsWithBodyWithResponse request with arbitrary body returning *ArchiveWorkflowOutputsResponse
func (c *ClientWithResponses) ArchiveWorkflowOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveWorkflowOutputsResponse, error) {
	rsp, err := c.ArchiveWorkflowOutputsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveWorkflowOutputsResponse(rsp)
}

func (c *ClientWithResponses) ArchiveWorkflowOutputsWithResponse(ctx context.Context, body ArchiveWorkflowOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveWorkflowOutputsResponse, error) {
	rsp, err := c.ArchiveWorkflowOutputs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveWorkflowOutputsResponse(rsp)
}

// BulkCreateWorkflowOutputsWithBodyWithResponse request with arbitrary body returning *BulkCreateWorkflowOutputsResponse
func (c *ClientWithResponses) BulkCreateWorkflowOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateWorkflowOutputsResponse, error) {
	rsp, err := c.BulkCreateWorkflowOutputsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateWorkflowOutputsResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateWorkflowOutputsWithResponse(ctx context.Context, body BulkCreateWorkflowOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateWorkflowOutputsResponse, error) {
	rsp, err := c.BulkCreateWorkflowOutputs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateWorkflowOutputsResponse(rsp)
}

// BulkUpdateWorkflowOutputsWithBodyWithResponse request with arbitrary body returning *BulkUpdateWorkflowOutputsResponse
func (c *ClientWithResponses) BulkUpdateWorkflowOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateWorkflowOutputsResponse, error) {
	rsp, err := c.BulkUpdateWorkflowOutputsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateWorkflowOutputsResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateWorkflowOutputsWithResponse(ctx context.Context, body BulkUpdateWorkflowOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateWorkflowOutputsResponse, error) {
	rsp, err := c.BulkUpdateWorkflowOutputs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateWorkflowOutputsResponse(rsp)
}

// UnarchiveWorkflowOutputsWithBodyWithResponse request with arbitrary body returning *UnarchiveWorkflowOutputsResponse
func (c *ClientWithResponses) UnarchiveWorkflowOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveWorkflowOutputsResponse, error) {
	rsp, err := c.UnarchiveWorkflowOutputsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveWorkflowOutputsResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveWorkflowOutputsWithResponse(ctx context.Context, body UnarchiveWorkflowOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveWorkflowOutputsResponse, error) {
	rsp, err := c.UnarchiveWorkflowOutputs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveWorkflowOutputsResponse(rsp)
}

// ListStageRunInputSamplesWithResponse request returning *ListStageRunInputSamplesResponse
func (c *ClientWithResponses) ListStageRunInputSamplesWithResponse(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*ListStageRunInputSamplesResponse, error) {
	rsp, err := c.ListStageRunInputSamples(ctx, stageRunId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStageRunInputSamplesResponse(rsp)
}

// ListStageRunOutputSamplesWithResponse request returning *ListStageRunOutputSamplesResponse
func (c *ClientWithResponses) ListStageRunOutputSamplesWithResponse(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*ListStageRunOutputSamplesResponse, error) {
	rsp, err := c.ListStageRunOutputSamples(ctx, stageRunId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStageRunOutputSamplesResponse(rsp)
}

// ListStageRunRegisteredSamplesWithResponse request returning *ListStageRunRegisteredSamplesResponse
func (c *ClientWithResponses) ListStageRunRegisteredSamplesWithResponse(ctx context.Context, stageRunId string, reqEditors ...RequestEditorFn) (*ListStageRunRegisteredSamplesResponse, error) {
	rsp, err := c.ListStageRunRegisteredSamples(ctx, stageRunId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStageRunRegisteredSamplesResponse(rsp)
}

// ListWorkflowStageRunsWithResponse request returning *ListWorkflowStageRunsResponse
func (c *ClientWithResponses) ListWorkflowStageRunsWithResponse(ctx context.Context, stageId string, reqEditors ...RequestEditorFn) (*ListWorkflowStageRunsResponse, error) {
	rsp, err := c.ListWorkflowStageRuns(ctx, stageId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkflowStageRunsResponse(rsp)
}

// ListWorkflowTaskGroupsWithResponse request returning *ListWorkflowTaskGroupsResponse
func (c *ClientWithResponses) ListWorkflowTaskGroupsWithResponse(ctx context.Context, params *ListWorkflowTaskGroupsParams, reqEditors ...RequestEditorFn) (*ListWorkflowTaskGroupsResponse, error) {
	rsp, err := c.ListWorkflowTaskGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkflowTaskGroupsResponse(rsp)
}

// CreateWorkflowTaskGroupWithBodyWithResponse request with arbitrary body returning *CreateWorkflowTaskGroupResponse
func (c *ClientWithResponses) CreateWorkflowTaskGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkflowTaskGroupResponse, error) {
	rsp, err := c.CreateWorkflowTaskGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkflowTaskGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkflowTaskGroupWithResponse(ctx context.Context, body CreateWorkflowTaskGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkflowTaskGroupResponse, error) {
	rsp, err := c.CreateWorkflowTaskGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkflowTaskGroupResponse(rsp)
}

// GetWorkflowTaskGroupWithResponse request returning *GetWorkflowTaskGroupResponse
func (c *ClientWithResponses) GetWorkflowTaskGroupWithResponse(ctx context.Context, workflowTaskGroupId string, reqEditors ...RequestEditorFn) (*GetWorkflowTaskGroupResponse, error) {
	rsp, err := c.GetWorkflowTaskGroup(ctx, workflowTaskGroupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkflowTaskGroupResponse(rsp)
}

// UpdateWorkflowTaskGroupWithBodyWithResponse request with arbitrary body returning *UpdateWorkflowTaskGroupResponse
func (c *ClientWithResponses) UpdateWorkflowTaskGroupWithBodyWithResponse(ctx context.Context, workflowTaskGroupId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkflowTaskGroupResponse, error) {
	rsp, err := c.UpdateWorkflowTaskGroupWithBody(ctx, workflowTaskGroupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkflowTaskGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateWorkflowTaskGroupWithResponse(ctx context.Context, workflowTaskGroupId string, body UpdateWorkflowTaskGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkflowTaskGroupResponse, error) {
	rsp, err := c.UpdateWorkflowTaskGroup(ctx, workflowTaskGroupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkflowTaskGroupResponse(rsp)
}

// ArchiveWorkflowTaskGroupsWithBodyWithResponse request with arbitrary body returning *ArchiveWorkflowTaskGroupsResponse
func (c *ClientWithResponses) ArchiveWorkflowTaskGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveWorkflowTaskGroupsResponse, error) {
	rsp, err := c.ArchiveWorkflowTaskGroupsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveWorkflowTaskGroupsResponse(rsp)
}

func (c *ClientWithResponses) ArchiveWorkflowTaskGroupsWithResponse(ctx context.Context, body ArchiveWorkflowTaskGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveWorkflowTaskGroupsResponse, error) {
	rsp, err := c.ArchiveWorkflowTaskGroups(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveWorkflowTaskGroupsResponse(rsp)
}

// UnarchiveWorkflowTaskGroupsWithBodyWithResponse request with arbitrary body returning *UnarchiveWorkflowTaskGroupsResponse
func (c *ClientWithResponses) UnarchiveWorkflowTaskGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveWorkflowTaskGroupsResponse, error) {
	rsp, err := c.UnarchiveWorkflowTaskGroupsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveWorkflowTaskGroupsResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveWorkflowTaskGroupsWithResponse(ctx context.Context, body UnarchiveWorkflowTaskGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveWorkflowTaskGroupsResponse, error) {
	rsp, err := c.UnarchiveWorkflowTaskGroups(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveWorkflowTaskGroupsResponse(rsp)
}

// ListWorkflowTaskSchemasWithResponse request returning *ListWorkflowTaskSchemasResponse
func (c *ClientWithResponses) ListWorkflowTaskSchemasWithResponse(ctx context.Context, params *ListWorkflowTaskSchemasParams, reqEditors ...RequestEditorFn) (*ListWorkflowTaskSchemasResponse, error) {
	rsp, err := c.ListWorkflowTaskSchemas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkflowTaskSchemasResponse(rsp)
}

// GetWorkflowTaskSchemaWithResponse request returning *GetWorkflowTaskSchemaResponse
func (c *ClientWithResponses) GetWorkflowTaskSchemaWithResponse(ctx context.Context, schemaId string, reqEditors ...RequestEditorFn) (*GetWorkflowTaskSchemaResponse, error) {
	rsp, err := c.GetWorkflowTaskSchema(ctx, schemaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkflowTaskSchemaResponse(rsp)
}

// ListWorkflowTasksWithResponse request returning *ListWorkflowTasksResponse
func (c *ClientWithResponses) ListWorkflowTasksWithResponse(ctx context.Context, params *ListWorkflowTasksParams, reqEditors ...RequestEditorFn) (*ListWorkflowTasksResponse, error) {
	rsp, err := c.ListWorkflowTasks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkflowTasksResponse(rsp)
}

// CreateWorkflowTaskWithBodyWithResponse request with arbitrary body returning *CreateWorkflowTaskResponse
func (c *ClientWithResponses) CreateWorkflowTaskWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWorkflowTaskResponse, error) {
	rsp, err := c.CreateWorkflowTaskWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkflowTaskResponse(rsp)
}

func (c *ClientWithResponses) CreateWorkflowTaskWithResponse(ctx context.Context, body CreateWorkflowTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWorkflowTaskResponse, error) {
	rsp, err := c.CreateWorkflowTask(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWorkflowTaskResponse(rsp)
}

// GetWorkflowTaskWithResponse request returning *GetWorkflowTaskResponse
func (c *ClientWithResponses) GetWorkflowTaskWithResponse(ctx context.Context, workflowTaskId string, reqEditors ...RequestEditorFn) (*GetWorkflowTaskResponse, error) {
	rsp, err := c.GetWorkflowTask(ctx, workflowTaskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkflowTaskResponse(rsp)
}

// UpdateWorkflowTaskWithBodyWithResponse request with arbitrary body returning *UpdateWorkflowTaskResponse
func (c *ClientWithResponses) UpdateWorkflowTaskWithBodyWithResponse(ctx context.Context, workflowTaskId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkflowTaskResponse, error) {
	rsp, err := c.UpdateWorkflowTaskWithBody(ctx, workflowTaskId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkflowTaskResponse(rsp)
}

func (c *ClientWithResponses) UpdateWorkflowTaskWithResponse(ctx context.Context, workflowTaskId string, body UpdateWorkflowTaskJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkflowTaskResponse, error) {
	rsp, err := c.UpdateWorkflowTask(ctx, workflowTaskId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkflowTaskResponse(rsp)
}

// CopyWorkflowTaskWithResponse request returning *CopyWorkflowTaskResponse
func (c *ClientWithResponses) CopyWorkflowTaskWithResponse(ctx context.Context, workflowTaskId string, reqEditors ...RequestEditorFn) (*CopyWorkflowTaskResponse, error) {
	rsp, err := c.CopyWorkflowTask(ctx, workflowTaskId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyWorkflowTaskResponse(rsp)
}

// ArchiveWorkflowTasksWithBodyWithResponse request with arbitrary body returning *ArchiveWorkflowTasksResponse
func (c *ClientWithResponses) ArchiveWorkflowTasksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveWorkflowTasksResponse, error) {
	rsp, err := c.ArchiveWorkflowTasksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveWorkflowTasksResponse(rsp)
}

func (c *ClientWithResponses) ArchiveWorkflowTasksWithResponse(ctx context.Context, body ArchiveWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveWorkflowTasksResponse, error) {
	rsp, err := c.ArchiveWorkflowTasks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveWorkflowTasksResponse(rsp)
}

// BulkCopyWorkflowTasksWithBodyWithResponse request with arbitrary body returning *BulkCopyWorkflowTasksResponse
func (c *ClientWithResponses) BulkCopyWorkflowTasksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCopyWorkflowTasksResponse, error) {
	rsp, err := c.BulkCopyWorkflowTasksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCopyWorkflowTasksResponse(rsp)
}

func (c *ClientWithResponses) BulkCopyWorkflowTasksWithResponse(ctx context.Context, body BulkCopyWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCopyWorkflowTasksResponse, error) {
	rsp, err := c.BulkCopyWorkflowTasks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCopyWorkflowTasksResponse(rsp)
}

// BulkCreateWorkflowTasksWithBodyWithResponse request with arbitrary body returning *BulkCreateWorkflowTasksResponse
func (c *ClientWithResponses) BulkCreateWorkflowTasksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkCreateWorkflowTasksResponse, error) {
	rsp, err := c.BulkCreateWorkflowTasksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateWorkflowTasksResponse(rsp)
}

func (c *ClientWithResponses) BulkCreateWorkflowTasksWithResponse(ctx context.Context, body BulkCreateWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkCreateWorkflowTasksResponse, error) {
	rsp, err := c.BulkCreateWorkflowTasks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkCreateWorkflowTasksResponse(rsp)
}

// BulkUpdateWorkflowTasksWithBodyWithResponse request with arbitrary body returning *BulkUpdateWorkflowTasksResponse
func (c *ClientWithResponses) BulkUpdateWorkflowTasksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateWorkflowTasksResponse, error) {
	rsp, err := c.BulkUpdateWorkflowTasksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateWorkflowTasksResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateWorkflowTasksWithResponse(ctx context.Context, body BulkUpdateWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateWorkflowTasksResponse, error) {
	rsp, err := c.BulkUpdateWorkflowTasks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateWorkflowTasksResponse(rsp)
}

// UnarchiveWorkflowTasksWithBodyWithResponse request with arbitrary body returning *UnarchiveWorkflowTasksResponse
func (c *ClientWithResponses) UnarchiveWorkflowTasksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnarchiveWorkflowTasksResponse, error) {
	rsp, err := c.UnarchiveWorkflowTasksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveWorkflowTasksResponse(rsp)
}

func (c *ClientWithResponses) UnarchiveWorkflowTasksWithResponse(ctx context.Context, body UnarchiveWorkflowTasksJSONRequestBody, reqEditors ...RequestEditorFn) (*UnarchiveWorkflowTasksResponse, error) {
	rsp, err := c.UnarchiveWorkflowTasks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnarchiveWorkflowTasksResponse(rsp)
}

// ListWorkflowsWithResponse request returning *ListWorkflowsResponse
func (c *ClientWithResponses) ListWorkflowsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListWorkflowsResponse, error) {
	rsp, err := c.ListWorkflows(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkflowsResponse(rsp)
}

// UpdateWorkflowMetadataWithBodyWithResponse request with arbitrary body returning *UpdateWorkflowMetadataResponse
func (c *ClientWithResponses) UpdateWorkflowMetadataWithBodyWithResponse(ctx context.Context, workflowId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWorkflowMetadataResponse, error) {
	rsp, err := c.UpdateWorkflowMetadataWithBody(ctx, workflowId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkflowMetadataResponse(rsp)
}

func (c *ClientWithResponses) UpdateWorkflowMetadataWithResponse(ctx context.Context, workflowId string, body UpdateWorkflowMetadataJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWorkflowMetadataResponse, error) {
	rsp, err := c.UpdateWorkflowMetadata(ctx, workflowId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWorkflowMetadataResponse(rsp)
}

// ListWorkflowStagesWithResponse request returning *ListWorkflowStagesResponse
func (c *ClientWithResponses) ListWorkflowStagesWithResponse(ctx context.Context, workflowId string, reqEditors ...RequestEditorFn) (*ListWorkflowStagesResponse, error) {
	rsp, err := c.ListWorkflowStages(ctx, workflowId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListWorkflowStagesResponse(rsp)
}

// ParseListAASequencesResponse parses an HTTP response from a ListAASequencesWithResponse call
func ParseListAASequencesResponse(rsp *http.Response) (*ListAASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AaSequencesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateAASequenceResponse parses an HTTP response from a CreateAASequenceWithResponse call
func ParseCreateAASequenceResponse(rsp *http.Response) (*CreateAASequenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAASequenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AaSequence
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetAASequenceResponse parses an HTTP response from a GetAASequenceWithResponse call
func ParseGetAASequenceResponse(rsp *http.Response) (*GetAASequenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAASequenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AaSequence
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateAASequenceResponse parses an HTTP response from a UpdateAASequenceWithResponse call
func ParseUpdateAASequenceResponse(rsp *http.Response) (*UpdateAASequenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAASequenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AaSequence
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseArchiveAASequencesResponse parses an HTTP response from a ArchiveAASequencesWithResponse call
func ParseArchiveAASequencesResponse(rsp *http.Response) (*ArchiveAASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveAASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AaSequencesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAutoAnnotateAaSequencesResponse parses an HTTP response from a AutoAnnotateAaSequencesWithResponse call
func ParseAutoAnnotateAaSequencesResponse(rsp *http.Response) (*AutoAnnotateAaSequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AutoAnnotateAaSequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkCreateAASequencesResponse parses an HTTP response from a BulkCreateAASequencesWithResponse call
func ParseBulkCreateAASequencesResponse(rsp *http.Response) (*BulkCreateAASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateAASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkGetAASequencesResponse parses an HTTP response from a BulkGetAASequencesWithResponse call
func ParseBulkGetAASequencesResponse(rsp *http.Response) (*BulkGetAASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkGetAASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AaSequencesBulkGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkUpdateAASequencesResponse parses an HTTP response from a BulkUpdateAASequencesWithResponse call
func ParseBulkUpdateAASequencesResponse(rsp *http.Response) (*BulkUpdateAASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateAASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveAASequencesResponse parses an HTTP response from a UnarchiveAASequencesWithResponse call
func ParseUnarchiveAASequencesResponse(rsp *http.Response) (*UnarchiveAASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveAASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AaSequencesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateAppCanvasResponse parses an HTTP response from a CreateAppCanvasWithResponse call
func ParseCreateAppCanvasResponse(rsp *http.Response) (*CreateAppCanvasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAppCanvasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AppCanvas
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetAppCanvasResponse parses an HTTP response from a GetAppCanvasWithResponse call
func ParseGetAppCanvasResponse(rsp *http.Response) (*GetAppCanvasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppCanvasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppCanvas
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAppCanvasResponse parses an HTTP response from a UpdateAppCanvasWithResponse call
func ParseUpdateAppCanvasResponse(rsp *http.Response) (*UpdateAppCanvasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppCanvasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppCanvas
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseArchiveAppCanvasesResponse parses an HTTP response from a ArchiveAppCanvasesWithResponse call
func ParseArchiveAppCanvasesResponse(rsp *http.Response) (*ArchiveAppCanvasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveAppCanvasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppCanvasesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveAppCanvasesResponse parses an HTTP response from a UnarchiveAppCanvasesWithResponse call
func ParseUnarchiveAppCanvasesResponse(rsp *http.Response) (*UnarchiveAppCanvasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveAppCanvasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppCanvasesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListAppConfigurationItemsResponse parses an HTTP response from a ListAppConfigurationItemsWithResponse call
func ParseListAppConfigurationItemsResponse(rsp *http.Response) (*ListAppConfigurationItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAppConfigurationItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppConfigurationPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateAppConfigurationItemResponse parses an HTTP response from a CreateAppConfigurationItemWithResponse call
func ParseCreateAppConfigurationItemResponse(rsp *http.Response) (*CreateAppConfigurationItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAppConfigurationItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AppConfigItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetAppConfigurationItemByIdResponse parses an HTTP response from a GetAppConfigurationItemByIdWithResponse call
func ParseGetAppConfigurationItemByIdResponse(rsp *http.Response) (*GetAppConfigurationItemByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppConfigurationItemByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppConfigItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAppConfigurationItemResponse parses an HTTP response from a UpdateAppConfigurationItemWithResponse call
func ParseUpdateAppConfigurationItemResponse(rsp *http.Response) (*UpdateAppConfigurationItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppConfigurationItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppConfigItem
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBulkCreateAppConfigurationItemsResponse parses an HTTP response from a BulkCreateAppConfigurationItemsWithResponse call
func ParseBulkCreateAppConfigurationItemsResponse(rsp *http.Response) (*BulkCreateAppConfigurationItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateAppConfigurationItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkUpdateAppConfigurationItemsResponse parses an HTTP response from a BulkUpdateAppConfigurationItemsWithResponse call
func ParseBulkUpdateAppConfigurationItemsResponse(rsp *http.Response) (*BulkUpdateAppConfigurationItemsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateAppConfigurationItemsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateAppSessionResponse parses an HTTP response from a CreateAppSessionWithResponse call
func ParseCreateAppSessionResponse(rsp *http.Response) (*CreateAppSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAppSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AppSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetAppSessionByIdResponse parses an HTTP response from a GetAppSessionByIdWithResponse call
func ParseGetAppSessionByIdResponse(rsp *http.Response) (*GetAppSessionByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppSessionByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateAppSessionResponse parses an HTTP response from a UpdateAppSessionWithResponse call
func ParseUpdateAppSessionResponse(rsp *http.Response) (*UpdateAppSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AppSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListBenchlingAppsResponse parses an HTTP response from a ListBenchlingAppsWithResponse call
func ParseListBenchlingAppsResponse(rsp *http.Response) (*ListBenchlingAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBenchlingAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BenchlingAppsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCreateBenchlingAppResponse parses an HTTP response from a CreateBenchlingAppWithResponse call
func ParseCreateBenchlingAppResponse(rsp *http.Response) (*CreateBenchlingAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBenchlingAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BenchlingApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ConflictError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetBenchlingAppByIDResponse parses an HTTP response from a GetBenchlingAppByIDWithResponse call
func ParseGetBenchlingAppByIDResponse(rsp *http.Response) (*GetBenchlingAppByIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBenchlingAppByIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BenchlingApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchBenchlingAppResponse parses an HTTP response from a PatchBenchlingAppWithResponse call
func ParsePatchBenchlingAppResponse(rsp *http.Response) (*PatchBenchlingAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchBenchlingAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BenchlingApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseArchiveBenchlingAppsResponse parses an HTTP response from a ArchiveBenchlingAppsWithResponse call
func ParseArchiveBenchlingAppsResponse(rsp *http.Response) (*ArchiveBenchlingAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveBenchlingAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BenchlingAppsArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveBenchlingAppsResponse parses an HTTP response from a UnarchiveBenchlingAppsWithResponse call
func ParseUnarchiveBenchlingAppsResponse(rsp *http.Response) (*UnarchiveBenchlingAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveBenchlingAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BenchlingAppsArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListAssayResultSchemasResponse parses an HTTP response from a ListAssayResultSchemasWithResponse call
func ParseListAssayResultSchemasResponse(rsp *http.Response) (*ListAssayResultSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssayResultSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayResultSchemasPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetResultSchemaResponse parses an HTTP response from a GetResultSchemaWithResponse call
func ParseGetResultSchemaResponse(rsp *http.Response) (*GetResultSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResultSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayResultSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListAssayResultsResponse parses an HTTP response from a ListAssayResultsWithResponse call
func ParseListAssayResultsResponse(rsp *http.Response) (*ListAssayResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssayResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayResultsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAssayResultsResponse parses an HTTP response from a CreateAssayResultsWithResponse call
func ParseCreateAssayResultsResponse(rsp *http.Response) (*CreateAssayResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAssayResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayResultsCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetAssayResultResponse parses an HTTP response from a GetAssayResultWithResponse call
func ParseGetAssayResultResponse(rsp *http.Response) (*GetAssayResultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssayResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseArchiveAssayResultsResponse parses an HTTP response from a ArchiveAssayResultsWithResponse call
func ParseArchiveAssayResultsResponse(rsp *http.Response) (*ArchiveAssayResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveAssayResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayResultIdsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkCreateAssayResultsResponse parses an HTTP response from a BulkCreateAssayResultsWithResponse call
func ParseBulkCreateAssayResultsResponse(rsp *http.Response) (*BulkCreateAssayResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateAssayResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkGetAssayResultsResponse parses an HTTP response from a BulkGetAssayResultsWithResponse call
func ParseBulkGetAssayResultsResponse(rsp *http.Response) (*BulkGetAssayResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkGetAssayResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayResultsBulkGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveAssayResultsResponse parses an HTTP response from a UnarchiveAssayResultsWithResponse call
func ParseUnarchiveAssayResultsResponse(rsp *http.Response) (*UnarchiveAssayResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveAssayResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayResultIdsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListAssayRunSchemasResponse parses an HTTP response from a ListAssayRunSchemasWithResponse call
func ParseListAssayRunSchemasResponse(rsp *http.Response) (*ListAssayRunSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssayRunSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayRunSchemasPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetRunSchemaResponse parses an HTTP response from a GetRunSchemaWithResponse call
func ParseGetRunSchemaResponse(rsp *http.Response) (*GetRunSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRunSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayRunSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListAssayRunsResponse parses an HTTP response from a ListAssayRunsWithResponse call
func ParseListAssayRunsResponse(rsp *http.Response) (*ListAssayRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssayRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayRunsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAssayRunsResponse parses an HTTP response from a CreateAssayRunsWithResponse call
func ParseCreateAssayRunsResponse(rsp *http.Response) (*CreateAssayRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAssayRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayRunsBulkCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetAssayRunResponse parses an HTTP response from a GetAssayRunWithResponse call
func ParseGetAssayRunResponse(rsp *http.Response) (*GetAssayRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssayRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateAssayRunResponse parses an HTTP response from a UpdateAssayRunWithResponse call
func ParseUpdateAssayRunResponse(rsp *http.Response) (*UpdateAssayRunResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAssayRunResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayRun
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListAutomationInputGeneratorsResponse parses an HTTP response from a ListAutomationInputGeneratorsWithResponse call
func ParseListAutomationInputGeneratorsResponse(rsp *http.Response) (*ListAutomationInputGeneratorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAutomationInputGeneratorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationFileInputsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListAutomationOutputProcessorsDeprecatedResponse parses an HTTP response from a ListAutomationOutputProcessorsDeprecatedWithResponse call
func ParseListAutomationOutputProcessorsDeprecatedResponse(rsp *http.Response) (*ListAutomationOutputProcessorsDeprecatedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAutomationOutputProcessorsDeprecatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeprecatedAutomationOutputProcessorsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseArchiveAssayRunsResponse parses an HTTP response from a ArchiveAssayRunsWithResponse call
func ParseArchiveAssayRunsResponse(rsp *http.Response) (*ArchiveAssayRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveAssayRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayRunsArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkGetAssayRunsResponse parses an HTTP response from a BulkGetAssayRunsWithResponse call
func ParseBulkGetAssayRunsResponse(rsp *http.Response) (*BulkGetAssayRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkGetAssayRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayRunsBulkGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnarchiveAssayRunsResponse parses an HTTP response from a UnarchiveAssayRunsWithResponse call
func ParseUnarchiveAssayRunsResponse(rsp *http.Response) (*UnarchiveAssayRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveAssayRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayRunsArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetLabAutomationTransformResponse parses an HTTP response from a GetLabAutomationTransformWithResponse call
func ParseGetLabAutomationTransformResponse(rsp *http.Response) (*GetLabAutomationTransformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLabAutomationTransformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LabAutomationTransform
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateLabAutomationTransformResponse parses an HTTP response from a UpdateLabAutomationTransformWithResponse call
func ParseUpdateLabAutomationTransformResponse(rsp *http.Response) (*UpdateLabAutomationTransformResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLabAutomationTransformResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LabAutomationTransform
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetAutomationInputGeneratorResponse parses an HTTP response from a GetAutomationInputGeneratorWithResponse call
func ParseGetAutomationInputGeneratorResponse(rsp *http.Response) (*GetAutomationInputGeneratorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAutomationInputGeneratorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationInputGenerator
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateAutomationInputGeneratorResponse parses an HTTP response from a UpdateAutomationInputGeneratorWithResponse call
func ParseUpdateAutomationInputGeneratorResponse(rsp *http.Response) (*UpdateAutomationInputGeneratorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAutomationInputGeneratorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationInputGenerator
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGenerateInputWithAutomationInputGeneratorResponse parses an HTTP response from a GenerateInputWithAutomationInputGeneratorWithResponse call
func ParseGenerateInputWithAutomationInputGeneratorResponse(rsp *http.Response) (*GenerateInputWithAutomationInputGeneratorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateInputWithAutomationInputGeneratorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListAutomationOutputProcessorsResponse parses an HTTP response from a ListAutomationOutputProcessorsWithResponse call
func ParseListAutomationOutputProcessorsResponse(rsp *http.Response) (*ListAutomationOutputProcessorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAutomationOutputProcessorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationOutputProcessorsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateAutomationOutputProcessorResponse parses an HTTP response from a CreateAutomationOutputProcessorWithResponse call
func ParseCreateAutomationOutputProcessorResponse(rsp *http.Response) (*CreateAutomationOutputProcessorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAutomationOutputProcessorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AutomationOutputProcessor
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetAutomationOutputProcessorResponse parses an HTTP response from a GetAutomationOutputProcessorWithResponse call
func ParseGetAutomationOutputProcessorResponse(rsp *http.Response) (*GetAutomationOutputProcessorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAutomationOutputProcessorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationOutputProcessor
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateAutomationOutputProcessorResponse parses an HTTP response from a UpdateAutomationOutputProcessorWithResponse call
func ParseUpdateAutomationOutputProcessorResponse(rsp *http.Response) (*UpdateAutomationOutputProcessorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAutomationOutputProcessorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationOutputProcessor
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseProcessOutputWithAutomationOutputProcessorResponse parses an HTTP response from a ProcessOutputWithAutomationOutputProcessorWithResponse call
func ParseProcessOutputWithAutomationOutputProcessorResponse(rsp *http.Response) (*ProcessOutputWithAutomationOutputProcessorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProcessOutputWithAutomationOutputProcessorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseArchiveAutomationOutputProcessorsResponse parses an HTTP response from a ArchiveAutomationOutputProcessorsWithResponse call
func ParseArchiveAutomationOutputProcessorsResponse(rsp *http.Response) (*ArchiveAutomationOutputProcessorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveAutomationOutputProcessorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationOutputProcessorArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveAutomationOutputProcessorsResponse parses an HTTP response from a UnarchiveAutomationOutputProcessorsWithResponse call
func ParseUnarchiveAutomationOutputProcessorsResponse(rsp *http.Response) (*UnarchiveAutomationOutputProcessorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveAutomationOutputProcessorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AutomationOutputProcessorArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListBatchSchemasResponse parses an HTTP response from a ListBatchSchemasWithResponse call
func ParseListBatchSchemasResponse(rsp *http.Response) (*ListBatchSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchSchemasPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBatchSchemaResponse parses an HTTP response from a GetBatchSchemaWithResponse call
func ParseGetBatchSchemaResponse(rsp *http.Response) (*GetBatchSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBatchSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListBatchesResponse parses an HTTP response from a ListBatchesWithResponse call
func ParseListBatchesResponse(rsp *http.Response) (*ListBatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateBatchResponse parses an HTTP response from a CreateBatchWithResponse call
func ParseCreateBatchResponse(rsp *http.Response) (*CreateBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Batch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBatchResponse parses an HTTP response from a GetBatchWithResponse call
func ParseGetBatchResponse(rsp *http.Response) (*GetBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Batch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateBatchResponse parses an HTTP response from a UpdateBatchWithResponse call
func ParseUpdateBatchResponse(rsp *http.Response) (*UpdateBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Batch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseArchiveBatchesResponse parses an HTTP response from a ArchiveBatchesWithResponse call
func ParseArchiveBatchesResponse(rsp *http.Response) (*ArchiveBatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveBatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkGetBatchesResponse parses an HTTP response from a BulkGetBatchesWithResponse call
func ParseBulkGetBatchesResponse(rsp *http.Response) (*BulkGetBatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkGetBatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchesBulkGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveBatchesResponse parses an HTTP response from a UnarchiveBatchesWithResponse call
func ParseUnarchiveBatchesResponse(rsp *http.Response) (*UnarchiveBatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveBatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateBlobResponse parses an HTTP response from a CreateBlobWithResponse call
func ParseCreateBlobResponse(rsp *http.Response) (*CreateBlobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBlobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Blob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBlobResponse parses an HTTP response from a GetBlobWithResponse call
func ParseGetBlobResponse(rsp *http.Response) (*GetBlobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Blob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetBlobFileResponse parses an HTTP response from a GetBlobFileWithResponse call
func ParseGetBlobFileResponse(rsp *http.Response) (*GetBlobFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlobFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetBlobUrlResponse parses an HTTP response from a GetBlobUrlWithResponse call
func ParseGetBlobUrlResponse(rsp *http.Response) (*GetBlobUrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBlobUrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlobUrl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateBlobPartResponse parses an HTTP response from a CreateBlobPartWithResponse call
func ParseCreateBlobPartResponse(rsp *http.Response) (*CreateBlobPartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBlobPartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlobPart
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAbortMultipartBlobResponse parses an HTTP response from a AbortMultipartBlobWithResponse call
func ParseAbortMultipartBlobResponse(rsp *http.Response) (*AbortMultipartBlobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AbortMultipartBlobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCompleteMultipartBlobResponse parses an HTTP response from a CompleteMultipartBlobWithResponse call
func ParseCompleteMultipartBlobResponse(rsp *http.Response) (*CompleteMultipartBlobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompleteMultipartBlobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Blob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkGetBlobsResponse parses an HTTP response from a BulkGetBlobsWithResponse call
func ParseBulkGetBlobsResponse(rsp *http.Response) (*BulkGetBlobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkGetBlobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BlobsBulkGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateMultipartBlobResponse parses an HTTP response from a CreateMultipartBlobWithResponse call
func ParseCreateMultipartBlobResponse(rsp *http.Response) (*CreateMultipartBlobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMultipartBlobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Blob
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListBoxSchemasResponse parses an HTTP response from a ListBoxSchemasWithResponse call
func ParseListBoxSchemasResponse(rsp *http.Response) (*ListBoxSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBoxSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BoxSchemasPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBoxSchemaResponse parses an HTTP response from a GetBoxSchemaWithResponse call
func ParseGetBoxSchemaResponse(rsp *http.Response) (*GetBoxSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBoxSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BoxSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListBoxesResponse parses an HTTP response from a ListBoxesWithResponse call
func ParseListBoxesResponse(rsp *http.Response) (*ListBoxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBoxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BoxesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateBoxResponse parses an HTTP response from a CreateBoxWithResponse call
func ParseCreateBoxResponse(rsp *http.Response) (*CreateBoxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBoxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Box
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetBoxResponse parses an HTTP response from a GetBoxWithResponse call
func ParseGetBoxResponse(rsp *http.Response) (*GetBoxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBoxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Box
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateBoxResponse parses an HTTP response from a UpdateBoxWithResponse call
func ParseUpdateBoxResponse(rsp *http.Response) (*UpdateBoxResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateBoxResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Box
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListBoxContentsResponse parses an HTTP response from a ListBoxContentsWithResponse call
func ParseListBoxContentsResponse(rsp *http.Response) (*ListBoxContentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBoxContentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BoxContentsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseArchiveBoxesResponse parses an HTTP response from a ArchiveBoxesWithResponse call
func ParseArchiveBoxesResponse(rsp *http.Response) (*ArchiveBoxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveBoxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BoxesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenRestrictedSampleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBulkGetBoxesResponse parses an HTTP response from a BulkGetBoxesWithResponse call
func ParseBulkGetBoxesResponse(rsp *http.Response) (*BulkGetBoxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkGetBoxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BoxesBulkGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveBoxesResponse parses an HTTP response from a UnarchiveBoxesWithResponse call
func ParseUnarchiveBoxesResponse(rsp *http.Response) (*UnarchiveBoxesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveBoxesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BoxesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListContainerSchemasResponse parses an HTTP response from a ListContainerSchemasWithResponse call
func ParseListContainerSchemasResponse(rsp *http.Response) (*ListContainerSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListContainerSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContainerSchemasPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetContainerSchemaResponse parses an HTTP response from a GetContainerSchemaWithResponse call
func ParseGetContainerSchemaResponse(rsp *http.Response) (*GetContainerSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContainerSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListContainersResponse parses an HTTP response from a ListContainersWithResponse call
func ParseListContainersResponse(rsp *http.Response) (*ListContainersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListContainersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContainersPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateContainerResponse parses an HTTP response from a CreateContainerWithResponse call
func ParseCreateContainerResponse(rsp *http.Response) (*CreateContainerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateContainerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Container
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetContainerResponse parses an HTTP response from a GetContainerWithResponse call
func ParseGetContainerResponse(rsp *http.Response) (*GetContainerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Container
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateContainerResponse parses an HTTP response from a UpdateContainerWithResponse call
func ParseUpdateContainerResponse(rsp *http.Response) (*UpdateContainerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateContainerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Container
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenRestrictedSampleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListContainerContentsResponse parses an HTTP response from a ListContainerContentsWithResponse call
func ParseListContainerContentsResponse(rsp *http.Response) (*ListContainerContentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListContainerContentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContainerContentsList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteContainerContentResponse parses an HTTP response from a DeleteContainerContentWithResponse call
func ParseDeleteContainerContentResponse(rsp *http.Response) (*DeleteContainerContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteContainerContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenRestrictedSampleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetContainerContentResponse parses an HTTP response from a GetContainerContentWithResponse call
func ParseGetContainerContentResponse(rsp *http.Response) (*GetContainerContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContainerContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateContainerContentResponse parses an HTTP response from a UpdateContainerContentWithResponse call
func ParseUpdateContainerContentResponse(rsp *http.Response) (*UpdateContainerContentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateContainerContentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContainerContent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenRestrictedSampleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseTransferIntoContainerResponse parses an HTTP response from a TransferIntoContainerWithResponse call
func ParseTransferIntoContainerResponse(rsp *http.Response) (*TransferIntoContainerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferIntoContainerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenRestrictedSampleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseArchiveContainersResponse parses an HTTP response from a ArchiveContainersWithResponse call
func ParseArchiveContainersResponse(rsp *http.Response) (*ArchiveContainersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveContainersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContainersArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenRestrictedSampleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBulkCreateContainersResponse parses an HTTP response from a BulkCreateContainersWithResponse call
func ParseBulkCreateContainersResponse(rsp *http.Response) (*BulkCreateContainersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateContainersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkGetContainersResponse parses an HTTP response from a BulkGetContainersWithResponse call
func ParseBulkGetContainersResponse(rsp *http.Response) (*BulkGetContainersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkGetContainersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContainersList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkUpdateContainersResponse parses an HTTP response from a BulkUpdateContainersWithResponse call
func ParseBulkUpdateContainersResponse(rsp *http.Response) (*BulkUpdateContainersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateContainersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCheckinContainersResponse parses an HTTP response from a CheckinContainersWithResponse call
func ParseCheckinContainersResponse(rsp *http.Response) (*CheckinContainersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckinContainersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenRestrictedSampleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseCheckoutContainersResponse parses an HTTP response from a CheckoutContainersWithResponse call
func ParseCheckoutContainersResponse(rsp *http.Response) (*CheckoutContainersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckoutContainersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenRestrictedSampleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePrintLabelsResponse parses an HTTP response from a PrintLabelsWithResponse call
func ParsePrintLabelsResponse(rsp *http.Response) (*PrintLabelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PrintLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseReserveContainersResponse parses an HTTP response from a ReserveContainersWithResponse call
func ParseReserveContainersResponse(rsp *http.Response) (*ReserveContainersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReserveContainersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenRestrictedSampleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUnarchiveContainersResponse parses an HTTP response from a UnarchiveContainersWithResponse call
func ParseUnarchiveContainersResponse(rsp *http.Response) (*UnarchiveContainersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveContainersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContainersArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListCustomEntitiesResponse parses an HTTP response from a ListCustomEntitiesWithResponse call
func ParseListCustomEntitiesResponse(rsp *http.Response) (*ListCustomEntitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomEntitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomEntitiesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateCustomEntityResponse parses an HTTP response from a CreateCustomEntityWithResponse call
func ParseCreateCustomEntityResponse(rsp *http.Response) (*CreateCustomEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CustomEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetCustomEntityResponse parses an HTTP response from a GetCustomEntityWithResponse call
func ParseGetCustomEntityResponse(rsp *http.Response) (*GetCustomEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateCustomEntityResponse parses an HTTP response from a UpdateCustomEntityWithResponse call
func ParseUpdateCustomEntityResponse(rsp *http.Response) (*UpdateCustomEntityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomEntityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseArchiveCustomEntitiesResponse parses an HTTP response from a ArchiveCustomEntitiesWithResponse call
func ParseArchiveCustomEntitiesResponse(rsp *http.Response) (*ArchiveCustomEntitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveCustomEntitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomEntitiesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkCreateCustomEntitiesResponse parses an HTTP response from a BulkCreateCustomEntitiesWithResponse call
func ParseBulkCreateCustomEntitiesResponse(rsp *http.Response) (*BulkCreateCustomEntitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateCustomEntitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkGetCustomEntitiesResponse parses an HTTP response from a BulkGetCustomEntitiesWithResponse call
func ParseBulkGetCustomEntitiesResponse(rsp *http.Response) (*BulkGetCustomEntitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkGetCustomEntitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomEntitiesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkUpdateCustomEntitiesResponse parses an HTTP response from a BulkUpdateCustomEntitiesWithResponse call
func ParseBulkUpdateCustomEntitiesResponse(rsp *http.Response) (*BulkUpdateCustomEntitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateCustomEntitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveCustomEntitiesResponse parses an HTTP response from a UnarchiveCustomEntitiesWithResponse call
func ParseUnarchiveCustomEntitiesResponse(rsp *http.Response) (*UnarchiveCustomEntitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveCustomEntitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomEntitiesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListCustomNotationsResponse parses an HTTP response from a ListCustomNotationsWithResponse call
func ParseListCustomNotationsResponse(rsp *http.Response) (*ListCustomNotationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomNotationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomNotationsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListDNAAlignmentsResponse parses an HTTP response from a ListDNAAlignmentsWithResponse call
func ParseListDNAAlignmentsResponse(rsp *http.Response) (*ListDNAAlignmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDNAAlignmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaAlignmentsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteDNAAlignmentResponse parses an HTTP response from a DeleteDNAAlignmentWithResponse call
func ParseDeleteDNAAlignmentResponse(rsp *http.Response) (*DeleteDNAAlignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDNAAlignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDNAAlignmentResponse parses an HTTP response from a GetDNAAlignmentWithResponse call
func ParseGetDNAAlignmentResponse(rsp *http.Response) (*GetDNAAlignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDNAAlignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaAlignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateDnaConsensusAlignmentResponse parses an HTTP response from a CreateDnaConsensusAlignmentWithResponse call
func ParseCreateDnaConsensusAlignmentResponse(rsp *http.Response) (*CreateDnaConsensusAlignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDnaConsensusAlignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseCreateDnaTemplateAlignmentResponse parses an HTTP response from a CreateDnaTemplateAlignmentWithResponse call
func ParseCreateDnaTemplateAlignmentResponse(rsp *http.Response) (*CreateDnaTemplateAlignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDnaTemplateAlignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseListDNAOligosResponse parses an HTTP response from a ListDNAOligosWithResponse call
func ParseListDNAOligosResponse(rsp *http.Response) (*ListDNAOligosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDNAOligosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaOligosPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateDNAOligoResponse parses an HTTP response from a CreateDNAOligoWithResponse call
func ParseCreateDNAOligoResponse(rsp *http.Response) (*CreateDNAOligoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDNAOligoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DnaOligo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetDNAOligoResponse parses an HTTP response from a GetDNAOligoWithResponse call
func ParseGetDNAOligoResponse(rsp *http.Response) (*GetDNAOligoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDNAOligoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaOligo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateDNAOligoResponse parses an HTTP response from a UpdateDNAOligoWithResponse call
func ParseUpdateDNAOligoResponse(rsp *http.Response) (*UpdateDNAOligoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDNAOligoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaOligo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseArchiveDNAOligosResponse parses an HTTP response from a ArchiveDNAOligosWithResponse call
func ParseArchiveDNAOligosResponse(rsp *http.Response) (*ArchiveDNAOligosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveDNAOligosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaOligosArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkCreateDNAOligosResponse parses an HTTP response from a BulkCreateDNAOligosWithResponse call
func ParseBulkCreateDNAOligosResponse(rsp *http.Response) (*BulkCreateDNAOligosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateDNAOligosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkUpdateDNAOligosResponse parses an HTTP response from a BulkUpdateDNAOligosWithResponse call
func ParseBulkUpdateDNAOligosResponse(rsp *http.Response) (*BulkUpdateDNAOligosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateDNAOligosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveDNAOligosResponse parses an HTTP response from a UnarchiveDNAOligosWithResponse call
func ParseUnarchiveDNAOligosResponse(rsp *http.Response) (*UnarchiveDNAOligosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveDNAOligosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaOligosArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListDNASequencesResponse parses an HTTP response from a ListDNASequencesWithResponse call
func ParseListDNASequencesResponse(rsp *http.Response) (*ListDNASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDNASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaSequencesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateDNASequenceResponse parses an HTTP response from a CreateDNASequenceWithResponse call
func ParseCreateDNASequenceResponse(rsp *http.Response) (*CreateDNASequenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDNASequenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DnaSequence
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetDNASequenceResponse parses an HTTP response from a GetDNASequenceWithResponse call
func ParseGetDNASequenceResponse(rsp *http.Response) (*GetDNASequenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDNASequenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaSequence
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateDNASequenceResponse parses an HTTP response from a UpdateDNASequenceWithResponse call
func ParseUpdateDNASequenceResponse(rsp *http.Response) (*UpdateDNASequenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDNASequenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaSequence
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseArchiveDNASequencesResponse parses an HTTP response from a ArchiveDNASequencesWithResponse call
func ParseArchiveDNASequencesResponse(rsp *http.Response) (*ArchiveDNASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveDNASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaSequencesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAutoAnnotateDnaSequencesResponse parses an HTTP response from a AutoAnnotateDnaSequencesWithResponse call
func ParseAutoAnnotateDnaSequencesResponse(rsp *http.Response) (*AutoAnnotateDnaSequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AutoAnnotateDnaSequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAutofillDNASequencePartsResponse parses an HTTP response from a AutofillDNASequencePartsWithResponse call
func ParseAutofillDNASequencePartsResponse(rsp *http.Response) (*AutofillDNASequencePartsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AutofillDNASequencePartsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAutofillDNASequenceTranslationsResponse parses an HTTP response from a AutofillDNASequenceTranslationsWithResponse call
func ParseAutofillDNASequenceTranslationsResponse(rsp *http.Response) (*AutofillDNASequenceTranslationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AutofillDNASequenceTranslationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkCreateDNASequencesResponse parses an HTTP response from a BulkCreateDNASequencesWithResponse call
func ParseBulkCreateDNASequencesResponse(rsp *http.Response) (*BulkCreateDNASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateDNASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkGetDNASequencesResponse parses an HTTP response from a BulkGetDNASequencesWithResponse call
func ParseBulkGetDNASequencesResponse(rsp *http.Response) (*BulkGetDNASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkGetDNASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaSequencesBulkGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkUpdateDNASequencesResponse parses an HTTP response from a BulkUpdateDNASequencesWithResponse call
func ParseBulkUpdateDNASequencesResponse(rsp *http.Response) (*BulkUpdateDNASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateDNASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMatchBasesDnaSequencesResponse parses an HTTP response from a MatchBasesDnaSequencesWithResponse call
func ParseMatchBasesDnaSequencesResponse(rsp *http.Response) (*MatchBasesDnaSequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MatchBasesDnaSequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaSequencesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSearchDnaSequencesResponse parses an HTTP response from a SearchDnaSequencesWithResponse call
func ParseSearchDnaSequencesResponse(rsp *http.Response) (*SearchDnaSequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDnaSequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaSequencesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveDNASequencesResponse parses an HTTP response from a UnarchiveDNASequencesWithResponse call
func ParseUnarchiveDNASequencesResponse(rsp *http.Response) (*UnarchiveDNASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveDNASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaSequencesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListDropdownsResponse parses an HTTP response from a ListDropdownsWithResponse call
func ParseListDropdownsResponse(rsp *http.Response) (*ListDropdownsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDropdownsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DropdownSummariesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateDropdownResponse parses an HTTP response from a CreateDropdownWithResponse call
func ParseCreateDropdownResponse(rsp *http.Response) (*CreateDropdownResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDropdownResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dropdown
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetDropdownResponse parses an HTTP response from a GetDropdownWithResponse call
func ParseGetDropdownResponse(rsp *http.Response) (*GetDropdownResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDropdownResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dropdown
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateDropdownResponse parses an HTTP response from a UpdateDropdownWithResponse call
func ParseUpdateDropdownResponse(rsp *http.Response) (*UpdateDropdownResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDropdownResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Dropdown
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseArchiveDropdownOptionsResponse parses an HTTP response from a ArchiveDropdownOptionsWithResponse call
func ParseArchiveDropdownOptionsResponse(rsp *http.Response) (*ArchiveDropdownOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveDropdownOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DropdownOptionsArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUnarchiveDropdownOptionsResponse parses an HTTP response from a UnarchiveDropdownOptionsWithResponse call
func ParseUnarchiveDropdownOptionsResponse(rsp *http.Response) (*UnarchiveDropdownOptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveDropdownOptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DropdownOptionsArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetEnitityBatchesResponse parses an HTTP response from a GetEnitityBatchesWithResponse call
func ParseGetEnitityBatchesResponse(rsp *http.Response) (*GetEnitityBatchesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnitityBatchesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListEntitySchemasResponse parses an HTTP response from a ListEntitySchemasWithResponse call
func ParseListEntitySchemasResponse(rsp *http.Response) (*ListEntitySchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEntitySchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntitySchemasPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEntitySchemaResponse parses an HTTP response from a GetEntitySchemaWithResponse call
func ParseGetEntitySchemaResponse(rsp *http.Response) (*GetEntitySchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntitySchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntitySchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListEntriesResponse parses an HTTP response from a ListEntriesWithResponse call
func ParseListEntriesResponse(rsp *http.Response) (*ListEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntriesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateEntryResponse parses an HTTP response from a CreateEntryWithResponse call
func ParseCreateEntryResponse(rsp *http.Response) (*CreateEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Entry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEntryResponse parses an HTTP response from a GetEntryWithResponse call
func ParseGetEntryResponse(rsp *http.Response) (*GetEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntryById
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateEntryResponse parses an HTTP response from a UpdateEntryWithResponse call
func ParseUpdateEntryResponse(rsp *http.Response) (*UpdateEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Entry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetExternalFileMetadataResponse parses an HTTP response from a GetExternalFileMetadataWithResponse call
func ParseGetExternalFileMetadataResponse(rsp *http.Response) (*GetExternalFileMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExternalFileMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntryExternalFileById
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseArchiveEntriesResponse parses an HTTP response from a ArchiveEntriesWithResponse call
func ParseArchiveEntriesResponse(rsp *http.Response) (*ArchiveEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntriesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBulkGetEntriesResponse parses an HTTP response from a BulkGetEntriesWithResponse call
func ParseBulkGetEntriesResponse(rsp *http.Response) (*BulkGetEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkGetEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Entries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveEntriesResponse parses an HTTP response from a UnarchiveEntriesWithResponse call
func ParseUnarchiveEntriesResponse(rsp *http.Response) (*UnarchiveEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntriesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEntrySchemasResponse parses an HTTP response from a ListEntrySchemasWithResponse call
func ParseListEntrySchemasResponse(rsp *http.Response) (*ListEntrySchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEntrySchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntrySchemasPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEntrySchemaResponse parses an HTTP response from a GetEntrySchemaWithResponse call
func ParseGetEntrySchemaResponse(rsp *http.Response) (*GetEntrySchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntrySchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntrySchemaDetailed
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListEntryTemplatesResponse parses an HTTP response from a ListEntryTemplatesWithResponse call
func ParseListEntryTemplatesResponse(rsp *http.Response) (*ListEntryTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEntryTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntryTemplatesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEntryTemplateResponse parses an HTTP response from a GetEntryTemplateWithResponse call
func ParseGetEntryTemplateResponse(rsp *http.Response) (*GetEntryTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEntryTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntryTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListEventsResponse parses an HTTP response from a ListEventsWithResponse call
func ParseListEventsResponse(rsp *http.Response) (*ListEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EventsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseExportItemResponse parses an HTTP response from a ExportItemWithResponse call
func ParseExportItemResponse(rsp *http.Response) (*ExportItemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportItemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListFeatureLibrariesResponse parses an HTTP response from a ListFeatureLibrariesWithResponse call
func ParseListFeatureLibrariesResponse(rsp *http.Response) (*ListFeatureLibrariesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFeatureLibrariesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FeatureLibrariesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateFeatureLibraryResponse parses an HTTP response from a CreateFeatureLibraryWithResponse call
func ParseCreateFeatureLibraryResponse(rsp *http.Response) (*CreateFeatureLibraryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFeatureLibraryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FeatureLibrary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFeatureLibraryResponse parses an HTTP response from a GetFeatureLibraryWithResponse call
func ParseGetFeatureLibraryResponse(rsp *http.Response) (*GetFeatureLibraryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeatureLibraryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FeatureLibrary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateFeatureLibraryResponse parses an HTTP response from a UpdateFeatureLibraryWithResponse call
func ParseUpdateFeatureLibraryResponse(rsp *http.Response) (*UpdateFeatureLibraryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFeatureLibraryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FeatureLibrary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListFeaturesResponse parses an HTTP response from a ListFeaturesWithResponse call
func ParseListFeaturesResponse(rsp *http.Response) (*ListFeaturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFeaturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FeaturesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateFeatureResponse parses an HTTP response from a CreateFeatureWithResponse call
func ParseCreateFeatureResponse(rsp *http.Response) (*CreateFeatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFeatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Feature
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFeatureResponse parses an HTTP response from a GetFeatureWithResponse call
func ParseGetFeatureResponse(rsp *http.Response) (*GetFeatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFeatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Feature
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateFeatureResponse parses an HTTP response from a UpdateFeatureWithResponse call
func ParseUpdateFeatureResponse(rsp *http.Response) (*UpdateFeatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFeatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Feature
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBulkCreateFeaturesResponse parses an HTTP response from a BulkCreateFeaturesWithResponse call
func ParseBulkCreateFeaturesResponse(rsp *http.Response) (*BulkCreateFeaturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateFeaturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListFoldersResponse parses an HTTP response from a ListFoldersWithResponse call
func ParseListFoldersResponse(rsp *http.Response) (*ListFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FoldersPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFolderResponse parses an HTTP response from a CreateFolderWithResponse call
func ParseCreateFolderResponse(rsp *http.Response) (*CreateFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Folder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFolderResponse parses an HTTP response from a GetFolderWithResponse call
func ParseGetFolderResponse(rsp *http.Response) (*GetFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Folder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseArchiveFoldersResponse parses an HTTP response from a ArchiveFoldersWithResponse call
func ParseArchiveFoldersResponse(rsp *http.Response) (*ArchiveFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FoldersArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveFoldersResponse parses an HTTP response from a UnarchiveFoldersWithResponse call
func ParseUnarchiveFoldersResponse(rsp *http.Response) (*UnarchiveFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FoldersArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListLegacyWorkflowStageRunInputSamplesResponse parses an HTTP response from a ListLegacyWorkflowStageRunInputSamplesWithResponse call
func ParseListLegacyWorkflowStageRunInputSamplesResponse(rsp *http.Response) (*ListLegacyWorkflowStageRunInputSamplesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLegacyWorkflowStageRunInputSamplesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegacyWorkflowSampleList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListLegacyWorkflowStageRunOutputSamplesResponse parses an HTTP response from a ListLegacyWorkflowStageRunOutputSamplesWithResponse call
func ParseListLegacyWorkflowStageRunOutputSamplesResponse(rsp *http.Response) (*ListLegacyWorkflowStageRunOutputSamplesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLegacyWorkflowStageRunOutputSamplesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegacyWorkflowSampleList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListLegacyWorkflowStageRunRegisteredSamplesResponse parses an HTTP response from a ListLegacyWorkflowStageRunRegisteredSamplesWithResponse call
func ParseListLegacyWorkflowStageRunRegisteredSamplesResponse(rsp *http.Response) (*ListLegacyWorkflowStageRunRegisteredSamplesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLegacyWorkflowStageRunRegisteredSamplesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegacyWorkflowSampleList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListLegacyWorkflowStageRunsResponse parses an HTTP response from a ListLegacyWorkflowStageRunsWithResponse call
func ParseListLegacyWorkflowStageRunsResponse(rsp *http.Response) (*ListLegacyWorkflowStageRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLegacyWorkflowStageRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegacyWorkflowStageRunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListLegacyWorkflowsResponse parses an HTTP response from a ListLegacyWorkflowsWithResponse call
func ParseListLegacyWorkflowsResponse(rsp *http.Response) (*ListLegacyWorkflowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLegacyWorkflowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegacyWorkflowList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateLegacyWorkflowMetadataResponse parses an HTTP response from a UpdateLegacyWorkflowMetadataWithResponse call
func ParseUpdateLegacyWorkflowMetadataResponse(rsp *http.Response) (*UpdateLegacyWorkflowMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLegacyWorkflowMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegacyWorkflow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListLegacyWorkflowStagesResponse parses an HTTP response from a ListLegacyWorkflowStagesWithResponse call
func ParseListLegacyWorkflowStagesResponse(rsp *http.Response) (*ListLegacyWorkflowStagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLegacyWorkflowStagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegacyWorkflowStageList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListLocationSchemasResponse parses an HTTP response from a ListLocationSchemasWithResponse call
func ParseListLocationSchemasResponse(rsp *http.Response) (*ListLocationSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLocationSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LocationSchemasPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetLocationSchemaResponse parses an HTTP response from a GetLocationSchemaWithResponse call
func ParseGetLocationSchemaResponse(rsp *http.Response) (*GetLocationSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LocationSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListLocationsResponse parses an HTTP response from a ListLocationsWithResponse call
func ParseListLocationsResponse(rsp *http.Response) (*ListLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LocationsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateLocationResponse parses an HTTP response from a CreateLocationWithResponse call
func ParseCreateLocationResponse(rsp *http.Response) (*CreateLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Location
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetLocationResponse parses an HTTP response from a GetLocationWithResponse call
func ParseGetLocationResponse(rsp *http.Response) (*GetLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Location
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateLocationResponse parses an HTTP response from a UpdateLocationWithResponse call
func ParseUpdateLocationResponse(rsp *http.Response) (*UpdateLocationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateLocationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Location
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseArchiveLocationsResponse parses an HTTP response from a ArchiveLocationsWithResponse call
func ParseArchiveLocationsResponse(rsp *http.Response) (*ArchiveLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LocationsArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenRestrictedSampleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBulkGetLocationsResponse parses an HTTP response from a BulkGetLocationsWithResponse call
func ParseBulkGetLocationsResponse(rsp *http.Response) (*BulkGetLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkGetLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LocationsBulkGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUnarchiveLocationsResponse parses an HTTP response from a UnarchiveLocationsWithResponse call
func ParseUnarchiveLocationsResponse(rsp *http.Response) (*UnarchiveLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LocationsArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListMixturesResponse parses an HTTP response from a ListMixturesWithResponse call
func ParseListMixturesResponse(rsp *http.Response) (*ListMixturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMixturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MixturesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateMixtureResponse parses an HTTP response from a CreateMixtureWithResponse call
func ParseCreateMixtureResponse(rsp *http.Response) (*CreateMixtureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMixtureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Mixture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetMixtureResponse parses an HTTP response from a GetMixtureWithResponse call
func ParseGetMixtureResponse(rsp *http.Response) (*GetMixtureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMixtureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Mixture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateMixtureResponse parses an HTTP response from a UpdateMixtureWithResponse call
func ParseUpdateMixtureResponse(rsp *http.Response) (*UpdateMixtureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMixtureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Mixture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseArchiveMixturesResponse parses an HTTP response from a ArchiveMixturesWithResponse call
func ParseArchiveMixturesResponse(rsp *http.Response) (*ArchiveMixturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveMixturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MixturesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkCreateMixturesResponse parses an HTTP response from a BulkCreateMixturesWithResponse call
func ParseBulkCreateMixturesResponse(rsp *http.Response) (*BulkCreateMixturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateMixturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkUpdateMixturesResponse parses an HTTP response from a BulkUpdateMixturesWithResponse call
func ParseBulkUpdateMixturesResponse(rsp *http.Response) (*BulkUpdateMixturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateMixturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveMixturesResponse parses an HTTP response from a UnarchiveMixturesWithResponse call
func ParseUnarchiveMixturesResponse(rsp *http.Response) (*UnarchiveMixturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveMixturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MixturesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListMoleculesResponse parses an HTTP response from a ListMoleculesWithResponse call
func ParseListMoleculesResponse(rsp *http.Response) (*ListMoleculesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMoleculesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MoleculesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateMoleculeResponse parses an HTTP response from a CreateMoleculeWithResponse call
func ParseCreateMoleculeResponse(rsp *http.Response) (*CreateMoleculeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMoleculeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Molecule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetMoleculeResponse parses an HTTP response from a GetMoleculeWithResponse call
func ParseGetMoleculeResponse(rsp *http.Response) (*GetMoleculeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMoleculeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Molecule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateMoleculeResponse parses an HTTP response from a UpdateMoleculeWithResponse call
func ParseUpdateMoleculeResponse(rsp *http.Response) (*UpdateMoleculeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMoleculeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Molecule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseArchiveMoleculesResponse parses an HTTP response from a ArchiveMoleculesWithResponse call
func ParseArchiveMoleculesResponse(rsp *http.Response) (*ArchiveMoleculesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveMoleculesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MoleculesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkCreateMoleculesResponse parses an HTTP response from a BulkCreateMoleculesWithResponse call
func ParseBulkCreateMoleculesResponse(rsp *http.Response) (*BulkCreateMoleculesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateMoleculesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkUpdateMoleculesResponse parses an HTTP response from a BulkUpdateMoleculesWithResponse call
func ParseBulkUpdateMoleculesResponse(rsp *http.Response) (*BulkUpdateMoleculesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateMoleculesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveMoleculesResponse parses an HTTP response from a UnarchiveMoleculesWithResponse call
func ParseUnarchiveMoleculesResponse(rsp *http.Response) (*UnarchiveMoleculesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveMoleculesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MoleculesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListMonomersResponse parses an HTTP response from a ListMonomersWithResponse call
func ParseListMonomersResponse(rsp *http.Response) (*ListMonomersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMonomersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MonomersPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateMonomerResponse parses an HTTP response from a CreateMonomerWithResponse call
func ParseCreateMonomerResponse(rsp *http.Response) (*CreateMonomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMonomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Monomer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseUpdateMonomerResponse parses an HTTP response from a UpdateMonomerWithResponse call
func ParseUpdateMonomerResponse(rsp *http.Response) (*UpdateMonomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMonomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Monomer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseArchiveMonomersResponse parses an HTTP response from a ArchiveMonomersWithResponse call
func ParseArchiveMonomersResponse(rsp *http.Response) (*ArchiveMonomersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveMonomersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MonomersArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveMonomersResponse parses an HTTP response from a UnarchiveMonomersWithResponse call
func ParseUnarchiveMonomersResponse(rsp *http.Response) (*UnarchiveMonomersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveMonomersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MonomersArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListNucleotideAlignmentsResponse parses an HTTP response from a ListNucleotideAlignmentsWithResponse call
func ParseListNucleotideAlignmentsResponse(rsp *http.Response) (*ListNucleotideAlignmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNucleotideAlignmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NucleotideAlignmentsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteNucleotideAlignmentResponse parses an HTTP response from a DeleteNucleotideAlignmentWithResponse call
func ParseDeleteNucleotideAlignmentResponse(rsp *http.Response) (*DeleteNucleotideAlignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNucleotideAlignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetNucleotideAlignmentResponse parses an HTTP response from a GetNucleotideAlignmentWithResponse call
func ParseGetNucleotideAlignmentResponse(rsp *http.Response) (*GetNucleotideAlignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNucleotideAlignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NucleotideAlignment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateConsensusNucleotideAlignmentResponse parses an HTTP response from a CreateConsensusNucleotideAlignmentWithResponse call
func ParseCreateConsensusNucleotideAlignmentResponse(rsp *http.Response) (*CreateConsensusNucleotideAlignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateConsensusNucleotideAlignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseCreateTemplateNucleotideAlignmentResponse parses an HTTP response from a CreateTemplateNucleotideAlignmentWithResponse call
func ParseCreateTemplateNucleotideAlignmentResponse(rsp *http.Response) (*CreateTemplateNucleotideAlignmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTemplateNucleotideAlignmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseListOligosResponse parses an HTTP response from a ListOligosWithResponse call
func ParseListOligosResponse(rsp *http.Response) (*ListOligosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOligosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OligosPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateOligoResponse parses an HTTP response from a CreateOligoWithResponse call
func ParseCreateOligoResponse(rsp *http.Response) (*CreateOligoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOligoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DnaOligo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetOligoResponse parses an HTTP response from a GetOligoWithResponse call
func ParseGetOligoResponse(rsp *http.Response) (*GetOligoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOligoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaOligo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateOligoResponse parses an HTTP response from a UpdateOligoWithResponse call
func ParseUpdateOligoResponse(rsp *http.Response) (*UpdateOligoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOligoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DnaOligo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseArchiveOligosResponse parses an HTTP response from a ArchiveOligosWithResponse call
func ParseArchiveOligosResponse(rsp *http.Response) (*ArchiveOligosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveOligosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OligosArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkCreateOligosResponse parses an HTTP response from a BulkCreateOligosWithResponse call
func ParseBulkCreateOligosResponse(rsp *http.Response) (*BulkCreateOligosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateOligosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkGetOligosResponse parses an HTTP response from a BulkGetOligosWithResponse call
func ParseBulkGetOligosResponse(rsp *http.Response) (*BulkGetOligosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkGetOligosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OligosBulkGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveOligosResponse parses an HTTP response from a UnarchiveOligosWithResponse call
func ParseUnarchiveOligosResponse(rsp *http.Response) (*UnarchiveOligosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveOligosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OligosArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListOrganizationsResponse parses an HTTP response from a ListOrganizationsWithResponse call
func ParseListOrganizationsResponse(rsp *http.Response) (*ListOrganizationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOrganizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrganizationsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetOrganizationResponse parses an HTTP response from a GetOrganizationWithResponse call
func ParseGetOrganizationResponse(rsp *http.Response) (*GetOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListPlateSchemasResponse parses an HTTP response from a ListPlateSchemasWithResponse call
func ParseListPlateSchemasResponse(rsp *http.Response) (*ListPlateSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlateSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlateSchemasPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPlateSchemaResponse parses an HTTP response from a GetPlateSchemaWithResponse call
func ParseGetPlateSchemaResponse(rsp *http.Response) (*GetPlateSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlateSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlateSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListPlatesResponse parses an HTTP response from a ListPlatesWithResponse call
func ParseListPlatesResponse(rsp *http.Response) (*ListPlatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreatePlateResponse parses an HTTP response from a CreatePlateWithResponse call
func ParseCreatePlateResponse(rsp *http.Response) (*CreatePlateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePlateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Plate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPlateResponse parses an HTTP response from a GetPlateWithResponse call
func ParseGetPlateResponse(rsp *http.Response) (*GetPlateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePlateResponse parses an HTTP response from a UpdatePlateWithResponse call
func ParseUpdatePlateResponse(rsp *http.Response) (*UpdatePlateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePlateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Plate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseArchivePlatesResponse parses an HTTP response from a ArchivePlatesWithResponse call
func ParseArchivePlatesResponse(rsp *http.Response) (*ArchivePlatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchivePlatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenRestrictedSampleError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseBulkGetPlatesResponse parses an HTTP response from a BulkGetPlatesWithResponse call
func ParseBulkGetPlatesResponse(rsp *http.Response) (*BulkGetPlatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkGetPlatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatesBulkGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUnarchivePlatesResponse parses an HTTP response from a UnarchivePlatesWithResponse call
func ParseUnarchivePlatesResponse(rsp *http.Response) (*UnarchivePlatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchivePlatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlatesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListProjectsResponse parses an HTTP response from a ListProjectsWithResponse call
func ParseListProjectsResponse(rsp *http.Response) (*ListProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProjectResponse parses an HTTP response from a GetProjectWithResponse call
func ParseGetProjectResponse(rsp *http.Response) (*GetProjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Project
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseArchiveProjectsResponse parses an HTTP response from a ArchiveProjectsWithResponse call
func ParseArchiveProjectsResponse(rsp *http.Response) (*ArchiveProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectsArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveProjectsResponse parses an HTTP response from a UnarchiveProjectsWithResponse call
func ParseUnarchiveProjectsResponse(rsp *http.Response) (*UnarchiveProjectsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveProjectsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectsArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListRegistriesResponse parses an HTTP response from a ListRegistriesWithResponse call
func ParseListRegistriesResponse(rsp *http.Response) (*ListRegistriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRegistriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegistriesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryResponse parses an HTTP response from a GetRegistryWithResponse call
func ParseGetRegistryResponse(rsp *http.Response) (*GetRegistryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Registry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListBatchSchemasByRegistryResponse parses an HTTP response from a ListBatchSchemasByRegistryWithResponse call
func ParseListBatchSchemasByRegistryResponse(rsp *http.Response) (*ListBatchSchemasByRegistryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBatchSchemasByRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BatchSchemasList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListBoxSchemasByRegistryResponse parses an HTTP response from a ListBoxSchemasByRegistryWithResponse call
func ParseListBoxSchemasByRegistryResponse(rsp *http.Response) (*ListBoxSchemasByRegistryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBoxSchemasByRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BoxSchemasList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListContainerSchemasByRegistryResponse parses an HTTP response from a ListContainerSchemasByRegistryWithResponse call
func ParseListContainerSchemasByRegistryResponse(rsp *http.Response) (*ListContainerSchemasByRegistryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListContainerSchemasByRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContainerSchemasList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListDropdownsByRegistryResponse parses an HTTP response from a ListDropdownsByRegistryWithResponse call
func ParseListDropdownsByRegistryResponse(rsp *http.Response) (*ListDropdownsByRegistryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDropdownsByRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DropdownsRegistryList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListEntitySchemasByRegistryResponse parses an HTTP response from a ListEntitySchemasByRegistryWithResponse call
func ParseListEntitySchemasByRegistryResponse(rsp *http.Response) (*ListEntitySchemasByRegistryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEntitySchemasByRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeprecatedEntitySchemasList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListPrintersResponse parses an HTTP response from a ListPrintersWithResponse call
func ParseListPrintersResponse(rsp *http.Response) (*ListPrintersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPrintersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PrintersList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListLabelTemplatesResponse parses an HTTP response from a ListLabelTemplatesWithResponse call
func ParseListLabelTemplatesResponse(rsp *http.Response) (*ListLabelTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLabelTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LabelTemplatesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListLocationSchemasByRegistryResponse parses an HTTP response from a ListLocationSchemasByRegistryWithResponse call
func ParseListLocationSchemasByRegistryResponse(rsp *http.Response) (*ListLocationSchemasByRegistryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListLocationSchemasByRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LocationSchemasList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListPlateSchemasByRegistryResponse parses an HTTP response from a ListPlateSchemasByRegistryWithResponse call
func ParseListPlateSchemasByRegistryResponse(rsp *http.Response) (*ListPlateSchemasByRegistryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlateSchemasByRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PlateSchemasList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkGetRegisteredEntitiesResponse parses an HTTP response from a BulkGetRegisteredEntitiesWithResponse call
func ParseBulkGetRegisteredEntitiesResponse(rsp *http.Response) (*BulkGetRegisteredEntitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkGetRegisteredEntitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegisteredEntitiesList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRegisterEntitiesResponse parses an HTTP response from a RegisterEntitiesWithResponse call
func ParseRegisterEntitiesResponse(rsp *http.Response) (*RegisterEntitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterEntitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnregisterEntitiesResponse parses an HTTP response from a UnregisterEntitiesWithResponse call
func ParseUnregisterEntitiesResponse(rsp *http.Response) (*UnregisterEntitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnregisterEntitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EmptyObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseValidateBarcodesResponse parses an HTTP response from a ValidateBarcodesWithResponse call
func ParseValidateBarcodesResponse(rsp *http.Response) (*ValidateBarcodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ValidateBarcodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BarcodeValidationResults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListRequestFulfillmentsResponse parses an HTTP response from a ListRequestFulfillmentsWithResponse call
func ParseListRequestFulfillmentsResponse(rsp *http.Response) (*ListRequestFulfillmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRequestFulfillmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestFulfillmentsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetRequestFulfillmentResponse parses an HTTP response from a GetRequestFulfillmentWithResponse call
func ParseGetRequestFulfillmentResponse(rsp *http.Response) (*GetRequestFulfillmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRequestFulfillmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestFulfillment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListRequestSchemasResponse parses an HTTP response from a ListRequestSchemasWithResponse call
func ParseListRequestSchemasResponse(rsp *http.Response) (*ListRequestSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRequestSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestSchemasPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetRequestSchemaResponse parses an HTTP response from a GetRequestSchemaWithResponse call
func ParseGetRequestSchemaResponse(rsp *http.Response) (*GetRequestSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRequestSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListRequestTaskSchemasResponse parses an HTTP response from a ListRequestTaskSchemasWithResponse call
func ParseListRequestTaskSchemasResponse(rsp *http.Response) (*ListRequestTaskSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRequestTaskSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestTaskSchemasPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetRequestTaskSchemaResponse parses an HTTP response from a GetRequestTaskSchemaWithResponse call
func ParseGetRequestTaskSchemaResponse(rsp *http.Response) (*GetRequestTaskSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRequestTaskSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestTaskSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListRequestsResponse parses an HTTP response from a ListRequestsWithResponse call
func ParseListRequestsResponse(rsp *http.Response) (*ListRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRequestResponse parses an HTTP response from a CreateRequestWithResponse call
func ParseCreateRequestResponse(rsp *http.Response) (*CreateRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Request
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetRequestResponse parses an HTTP response from a GetRequestWithResponse call
func ParseGetRequestResponse(rsp *http.Response) (*GetRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Request
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchRequestResponse parses an HTTP response from a PatchRequestWithResponse call
func ParsePatchRequestResponse(rsp *http.Response) (*PatchRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Request
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetRequestResponseResponse parses an HTTP response from a GetRequestResponseWithResponse call
func ParseGetRequestResponseResponse(rsp *http.Response) (*GetRequestResponseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRequestResponseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBulkCreateRequestTasksResponse parses an HTTP response from a BulkCreateRequestTasksWithResponse call
func ParseBulkCreateRequestTasksResponse(rsp *http.Response) (*BulkCreateRequestTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateRequestTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestTasksBulkCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorBulk
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkUpdateRequestTasksResponse parses an HTTP response from a BulkUpdateRequestTasksWithResponse call
func ParseBulkUpdateRequestTasksResponse(rsp *http.Response) (*BulkUpdateRequestTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateRequestTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestTasksBulkUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseExecuteRequestsSampleGroupsResponse parses an HTTP response from a ExecuteRequestsSampleGroupsWithResponse call
func ParseExecuteRequestsSampleGroupsResponse(rsp *http.Response) (*ExecuteRequestsSampleGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecuteRequestsSampleGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExecuteSampleGroups
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBulkGetRequestsResponse parses an HTTP response from a BulkGetRequestsWithResponse call
func ParseBulkGetRequestsResponse(rsp *http.Response) (*BulkGetRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkGetRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestsBulkGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateAssayResultsTransactionResponse parses an HTTP response from a CreateAssayResultsTransactionWithResponse call
func ParseCreateAssayResultsTransactionResponse(rsp *http.Response) (*CreateAssayResultsTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAssayResultsTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayResultTransactionCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAssayResultsInTransactionResponse parses an HTTP response from a CreateAssayResultsInTransactionWithResponse call
func ParseCreateAssayResultsInTransactionResponse(rsp *http.Response) (*CreateAssayResultsInTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAssayResultsInTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayResultsCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAbortAssayResultsTransactionResponse parses an HTTP response from a AbortAssayResultsTransactionWithResponse call
func ParseAbortAssayResultsTransactionResponse(rsp *http.Response) (*AbortAssayResultsTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AbortAssayResultsTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayResultTransactionCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCommitAssayResultsTransactionResponse parses an HTTP response from a CommitAssayResultsTransactionWithResponse call
func ParseCommitAssayResultsTransactionResponse(rsp *http.Response) (*CommitAssayResultsTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitAssayResultsTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AssayResultTransactionCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListRNAOligosResponse parses an HTTP response from a ListRNAOligosWithResponse call
func ParseListRNAOligosResponse(rsp *http.Response) (*ListRNAOligosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRNAOligosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RnaOligosPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateRNAOligoResponse parses an HTTP response from a CreateRNAOligoWithResponse call
func ParseCreateRNAOligoResponse(rsp *http.Response) (*CreateRNAOligoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRNAOligoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RnaOligo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetRNAOligoResponse parses an HTTP response from a GetRNAOligoWithResponse call
func ParseGetRNAOligoResponse(rsp *http.Response) (*GetRNAOligoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRNAOligoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RnaOligo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateRNAOligoResponse parses an HTTP response from a UpdateRNAOligoWithResponse call
func ParseUpdateRNAOligoResponse(rsp *http.Response) (*UpdateRNAOligoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRNAOligoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RnaOligo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseArchiveRNAOligosResponse parses an HTTP response from a ArchiveRNAOligosWithResponse call
func ParseArchiveRNAOligosResponse(rsp *http.Response) (*ArchiveRNAOligosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveRNAOligosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RnaOligosArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkCreateRNAOligosResponse parses an HTTP response from a BulkCreateRNAOligosWithResponse call
func ParseBulkCreateRNAOligosResponse(rsp *http.Response) (*BulkCreateRNAOligosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateRNAOligosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkUpdateRNAOligosResponse parses an HTTP response from a BulkUpdateRNAOligosWithResponse call
func ParseBulkUpdateRNAOligosResponse(rsp *http.Response) (*BulkUpdateRNAOligosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateRNAOligosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveRNAOligosResponse parses an HTTP response from a UnarchiveRNAOligosWithResponse call
func ParseUnarchiveRNAOligosResponse(rsp *http.Response) (*UnarchiveRNAOligosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveRNAOligosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RnaOligosArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListRNASequencesResponse parses an HTTP response from a ListRNASequencesWithResponse call
func ParseListRNASequencesResponse(rsp *http.Response) (*ListRNASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListRNASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RnaSequencesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateRNASequenceResponse parses an HTTP response from a CreateRNASequenceWithResponse call
func ParseCreateRNASequenceResponse(rsp *http.Response) (*CreateRNASequenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRNASequenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RnaSequence
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetRNASequenceResponse parses an HTTP response from a GetRNASequenceWithResponse call
func ParseGetRNASequenceResponse(rsp *http.Response) (*GetRNASequenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRNASequenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RnaSequence
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateRNASequenceResponse parses an HTTP response from a UpdateRNASequenceWithResponse call
func ParseUpdateRNASequenceResponse(rsp *http.Response) (*UpdateRNASequenceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRNASequenceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RnaSequence
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseArchiveRNASequencesResponse parses an HTTP response from a ArchiveRNASequencesWithResponse call
func ParseArchiveRNASequencesResponse(rsp *http.Response) (*ArchiveRNASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveRNASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RnaSequencesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAutoAnnotateRnaSequencesResponse parses an HTTP response from a AutoAnnotateRnaSequencesWithResponse call
func ParseAutoAnnotateRnaSequencesResponse(rsp *http.Response) (*AutoAnnotateRnaSequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AutoAnnotateRnaSequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAutofillRNASequencePartsResponse parses an HTTP response from a AutofillRNASequencePartsWithResponse call
func ParseAutofillRNASequencePartsResponse(rsp *http.Response) (*AutofillRNASequencePartsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AutofillRNASequencePartsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAutofillRNASequenceTranslationsResponse parses an HTTP response from a AutofillRNASequenceTranslationsWithResponse call
func ParseAutofillRNASequenceTranslationsResponse(rsp *http.Response) (*AutofillRNASequenceTranslationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AutofillRNASequenceTranslationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkCreateRNASequencesResponse parses an HTTP response from a BulkCreateRNASequencesWithResponse call
func ParseBulkCreateRNASequencesResponse(rsp *http.Response) (*BulkCreateRNASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateRNASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkGetRNASequencesResponse parses an HTTP response from a BulkGetRNASequencesWithResponse call
func ParseBulkGetRNASequencesResponse(rsp *http.Response) (*BulkGetRNASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkGetRNASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RnaSequencesBulkGet
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkUpdateRNASequencesResponse parses an HTTP response from a BulkUpdateRNASequencesWithResponse call
func ParseBulkUpdateRNASequencesResponse(rsp *http.Response) (*BulkUpdateRNASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateRNASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseMatchBasesRnaSequencesResponse parses an HTTP response from a MatchBasesRnaSequencesWithResponse call
func ParseMatchBasesRnaSequencesResponse(rsp *http.Response) (*MatchBasesRnaSequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MatchBasesRnaSequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RnaSequencesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseSearchRnaSequencesResponse parses an HTTP response from a SearchRnaSequencesWithResponse call
func ParseSearchRnaSequencesResponse(rsp *http.Response) (*SearchRnaSequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchRnaSequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RnaSequencesPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveRNASequencesResponse parses an HTTP response from a UnarchiveRNASequencesWithResponse call
func ParseUnarchiveRNASequencesResponse(rsp *http.Response) (*UnarchiveRNASequencesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveRNASequencesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RnaSequencesArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetTaskResponse parses an HTTP response from a GetTaskWithResponse call
func ParseGetTaskResponse(rsp *http.Response) (*GetTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListTeamsResponse parses an HTTP response from a ListTeamsWithResponse call
func ParseListTeamsResponse(rsp *http.Response) (*ListTeamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetTeamResponse parses an HTTP response from a GetTeamWithResponse call
func ParseGetTeamResponse(rsp *http.Response) (*GetTeamResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Team
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGenerateTokenResponse parses an HTTP response from a GenerateTokenWithResponse call
func ParseGenerateTokenResponse(rsp *http.Response) (*GenerateTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TokenResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest OAuthBadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest OAuthUnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseTransferIntoContainersResponse parses an HTTP response from a TransferIntoContainersWithResponse call
func ParseTransferIntoContainersResponse(rsp *http.Response) (*TransferIntoContainersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferIntoContainersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListUsersResponse parses an HTTP response from a ListUsersWithResponse call
func ParseListUsersResponse(rsp *http.Response) (*ListUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ForbiddenError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUserActivityResponse parses an HTTP response from a GetUserActivityWithResponse call
func ParseGetUserActivityResponse(rsp *http.Response) (*GetUserActivityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserActivityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserActivity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBulkCreateUsersResponse parses an HTTP response from a BulkCreateUsersWithResponse call
func ParseBulkCreateUsersResponse(rsp *http.Response) (*BulkCreateUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkUpdateUsersResponse parses an HTTP response from a BulkUpdateUsersWithResponse call
func ParseBulkUpdateUsersResponse(rsp *http.Response) (*BulkUpdateUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateWarehouseCredentialsResponse parses an HTTP response from a CreateWarehouseCredentialsWithResponse call
func ParseCreateWarehouseCredentialsResponse(rsp *http.Response) (*CreateWarehouseCredentialsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWarehouseCredentialsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WarehouseCredentials
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListWorkflowOutputsResponse parses an HTTP response from a ListWorkflowOutputsWithResponse call
func ParseListWorkflowOutputsResponse(rsp *http.Response) (*ListWorkflowOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkflowOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowOutputsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateWorkflowOutputResponse parses an HTTP response from a CreateWorkflowOutputWithResponse call
func ParseCreateWorkflowOutputResponse(rsp *http.Response) (*CreateWorkflowOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkflowOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WorkflowOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetWorkflowOutputResponse parses an HTTP response from a GetWorkflowOutputWithResponse call
func ParseGetWorkflowOutputResponse(rsp *http.Response) (*GetWorkflowOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkflowOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateWorkflowOutputResponse parses an HTTP response from a UpdateWorkflowOutputWithResponse call
func ParseUpdateWorkflowOutputResponse(rsp *http.Response) (*UpdateWorkflowOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWorkflowOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseArchiveWorkflowOutputsResponse parses an HTTP response from a ArchiveWorkflowOutputsWithResponse call
func ParseArchiveWorkflowOutputsResponse(rsp *http.Response) (*ArchiveWorkflowOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveWorkflowOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowOutputsArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkCreateWorkflowOutputsResponse parses an HTTP response from a BulkCreateWorkflowOutputsWithResponse call
func ParseBulkCreateWorkflowOutputsResponse(rsp *http.Response) (*BulkCreateWorkflowOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateWorkflowOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkUpdateWorkflowOutputsResponse parses an HTTP response from a BulkUpdateWorkflowOutputsWithResponse call
func ParseBulkUpdateWorkflowOutputsResponse(rsp *http.Response) (*BulkUpdateWorkflowOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateWorkflowOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveWorkflowOutputsResponse parses an HTTP response from a UnarchiveWorkflowOutputsWithResponse call
func ParseUnarchiveWorkflowOutputsResponse(rsp *http.Response) (*UnarchiveWorkflowOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveWorkflowOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowOutputsArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListStageRunInputSamplesResponse parses an HTTP response from a ListStageRunInputSamplesWithResponse call
func ParseListStageRunInputSamplesResponse(rsp *http.Response) (*ListStageRunInputSamplesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStageRunInputSamplesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowSampleList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListStageRunOutputSamplesResponse parses an HTTP response from a ListStageRunOutputSamplesWithResponse call
func ParseListStageRunOutputSamplesResponse(rsp *http.Response) (*ListStageRunOutputSamplesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStageRunOutputSamplesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowSampleList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListStageRunRegisteredSamplesResponse parses an HTTP response from a ListStageRunRegisteredSamplesWithResponse call
func ParseListStageRunRegisteredSamplesResponse(rsp *http.Response) (*ListStageRunRegisteredSamplesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStageRunRegisteredSamplesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowSampleList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkflowStageRunsResponse parses an HTTP response from a ListWorkflowStageRunsWithResponse call
func ParseListWorkflowStageRunsResponse(rsp *http.Response) (*ListWorkflowStageRunsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkflowStageRunsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowStageRunList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkflowTaskGroupsResponse parses an HTTP response from a ListWorkflowTaskGroupsWithResponse call
func ParseListWorkflowTaskGroupsResponse(rsp *http.Response) (*ListWorkflowTaskGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkflowTaskGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowTaskGroupsPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateWorkflowTaskGroupResponse parses an HTTP response from a CreateWorkflowTaskGroupWithResponse call
func ParseCreateWorkflowTaskGroupResponse(rsp *http.Response) (*CreateWorkflowTaskGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkflowTaskGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WorkflowTaskGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetWorkflowTaskGroupResponse parses an HTTP response from a GetWorkflowTaskGroupWithResponse call
func ParseGetWorkflowTaskGroupResponse(rsp *http.Response) (*GetWorkflowTaskGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkflowTaskGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowTaskGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateWorkflowTaskGroupResponse parses an HTTP response from a UpdateWorkflowTaskGroupWithResponse call
func ParseUpdateWorkflowTaskGroupResponse(rsp *http.Response) (*UpdateWorkflowTaskGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWorkflowTaskGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowTaskGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseArchiveWorkflowTaskGroupsResponse parses an HTTP response from a ArchiveWorkflowTaskGroupsWithResponse call
func ParseArchiveWorkflowTaskGroupsResponse(rsp *http.Response) (*ArchiveWorkflowTaskGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveWorkflowTaskGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowTaskGroupsArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveWorkflowTaskGroupsResponse parses an HTTP response from a UnarchiveWorkflowTaskGroupsWithResponse call
func ParseUnarchiveWorkflowTaskGroupsResponse(rsp *http.Response) (*UnarchiveWorkflowTaskGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveWorkflowTaskGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowTaskGroupsArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListWorkflowTaskSchemasResponse parses an HTTP response from a ListWorkflowTaskSchemasWithResponse call
func ParseListWorkflowTaskSchemasResponse(rsp *http.Response) (*ListWorkflowTaskSchemasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkflowTaskSchemasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowTaskSchemasPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetWorkflowTaskSchemaResponse parses an HTTP response from a GetWorkflowTaskSchemaWithResponse call
func ParseGetWorkflowTaskSchemaResponse(rsp *http.Response) (*GetWorkflowTaskSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkflowTaskSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowTaskSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListWorkflowTasksResponse parses an HTTP response from a ListWorkflowTasksWithResponse call
func ParseListWorkflowTasksResponse(rsp *http.Response) (*ListWorkflowTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkflowTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowTasksPaginatedList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateWorkflowTaskResponse parses an HTTP response from a CreateWorkflowTaskWithResponse call
func ParseCreateWorkflowTaskResponse(rsp *http.Response) (*CreateWorkflowTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWorkflowTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WorkflowTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetWorkflowTaskResponse parses an HTTP response from a GetWorkflowTaskWithResponse call
func ParseGetWorkflowTaskResponse(rsp *http.Response) (*GetWorkflowTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkflowTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateWorkflowTaskResponse parses an HTTP response from a UpdateWorkflowTaskWithResponse call
func ParseUpdateWorkflowTaskResponse(rsp *http.Response) (*UpdateWorkflowTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWorkflowTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCopyWorkflowTaskResponse parses an HTTP response from a CopyWorkflowTaskWithResponse call
func ParseCopyWorkflowTaskResponse(rsp *http.Response) (*CopyWorkflowTaskResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CopyWorkflowTaskResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WorkflowTask
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseArchiveWorkflowTasksResponse parses an HTTP response from a ArchiveWorkflowTasksWithResponse call
func ParseArchiveWorkflowTasksResponse(rsp *http.Response) (*ArchiveWorkflowTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveWorkflowTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowTasksArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkCopyWorkflowTasksResponse parses an HTTP response from a BulkCopyWorkflowTasksWithResponse call
func ParseBulkCopyWorkflowTasksResponse(rsp *http.Response) (*BulkCopyWorkflowTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCopyWorkflowTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkCreateWorkflowTasksResponse parses an HTTP response from a BulkCreateWorkflowTasksWithResponse call
func ParseBulkCreateWorkflowTasksResponse(rsp *http.Response) (*BulkCreateWorkflowTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkCreateWorkflowTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseBulkUpdateWorkflowTasksResponse parses an HTTP response from a BulkUpdateWorkflowTasksWithResponse call
func ParseBulkUpdateWorkflowTasksResponse(rsp *http.Response) (*BulkUpdateWorkflowTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateWorkflowTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AsyncTaskLink
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUnarchiveWorkflowTasksResponse parses an HTTP response from a UnarchiveWorkflowTasksWithResponse call
func ParseUnarchiveWorkflowTasksResponse(rsp *http.Response) (*UnarchiveWorkflowTasksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnarchiveWorkflowTasksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowTasksArchivalChange
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListWorkflowsResponse parses an HTTP response from a ListWorkflowsWithResponse call
func ParseListWorkflowsResponse(rsp *http.Response) (*ListWorkflowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkflowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateWorkflowMetadataResponse parses an HTTP response from a UpdateWorkflowMetadataWithResponse call
func ParseUpdateWorkflowMetadataResponse(rsp *http.Response) (*UpdateWorkflowMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWorkflowMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegacyWorkflow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListWorkflowStagesResponse parses an HTTP response from a ListWorkflowStagesWithResponse call
func ParseListWorkflowStagesResponse(rsp *http.Response) (*ListWorkflowStagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListWorkflowStagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkflowStageList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List AA sequences
	// (GET /aa-sequences)
	ListAASequences(ctx echo.Context, params ListAASequencesParams) error
	// Create an AA sequence
	// (POST /aa-sequences)
	CreateAASequence(ctx echo.Context) error
	// Get an AA sequence
	// (GET /aa-sequences/{aa_sequence_id})
	GetAASequence(ctx echo.Context, aaSequenceId string, params GetAASequenceParams) error
	// Update an AA sequence
	// (PATCH /aa-sequences/{aa_sequence_id})
	UpdateAASequence(ctx echo.Context, aaSequenceId string) error
	// Archive AA sequences
	// (POST /aa-sequences:archive)
	ArchiveAASequences(ctx echo.Context) error
	// Auto-annotate AA sequences with matching features from specified Feature Libraries
	// (POST /aa-sequences:auto-annotate)
	AutoAnnotateAaSequences(ctx echo.Context) error
	// Bulk Create AA sequences
	// (POST /aa-sequences:bulk-create)
	BulkCreateAASequences(ctx echo.Context) error
	// Bulk get AA sequences by ID
	// (GET /aa-sequences:bulk-get)
	BulkGetAASequences(ctx echo.Context, params BulkGetAASequencesParams) error
	// Bulk Update AA sequences
	// (POST /aa-sequences:bulk-update)
	BulkUpdateAASequences(ctx echo.Context) error
	// Unarchive AA sequences
	// (POST /aa-sequences:unarchive)
	UnarchiveAASequences(ctx echo.Context) error
	// Create an App Canvas
	// (POST /app-canvases)
	CreateAppCanvas(ctx echo.Context) error
	// Get App Canvas
	// (GET /app-canvases/{canvas_id})
	GetAppCanvas(ctx echo.Context, canvasId string, params GetAppCanvasParams) error
	// Update App Canvas
	// (PATCH /app-canvases/{canvas_id})
	UpdateAppCanvas(ctx echo.Context, canvasId string) error
	// Archive app canvases
	// (POST /app-canvases:archive)
	ArchiveAppCanvases(ctx echo.Context) error
	// Unarchive app canvases
	// (POST /app-canvases:unarchive)
	UnarchiveAppCanvases(ctx echo.Context) error
	// Get app configuration items
	// (GET /app-configuration-items)
	ListAppConfigurationItems(ctx echo.Context, params ListAppConfigurationItemsParams) error
	// Create app configuration item
	// (POST /app-configuration-items)
	CreateAppConfigurationItem(ctx echo.Context) error
	// Get app configuration item
	// (GET /app-configuration-items/{item_id})
	GetAppConfigurationItemById(ctx echo.Context, itemId string) error
	// Update app configuration item
	// (PATCH /app-configuration-items/{item_id})
	UpdateAppConfigurationItem(ctx echo.Context, itemId string) error
	// Bulk Create app configuration items. Limit of 1000 App Config Items per request.
	// (POST /app-configuration-items:bulk-create)
	BulkCreateAppConfigurationItems(ctx echo.Context) error
	// Bulk Update app configuration items. Limit of 1000 App Config Items per request.
	// (POST /app-configuration-items:bulk-update)
	BulkUpdateAppConfigurationItems(ctx echo.Context) error
	// Create a new app session
	// (POST /app-sessions)
	CreateAppSession(ctx echo.Context) error
	// Get an app session
	// (GET /app-sessions/{id})
	GetAppSessionById(ctx echo.Context, id string, params GetAppSessionByIdParams) error
	// Update app session
	// (PATCH /app-sessions/{id})
	UpdateAppSession(ctx echo.Context, id string) error
	// List apps
	// (GET /apps)
	ListBenchlingApps(ctx echo.Context, params ListBenchlingAppsParams) error
	// Create an app
	// (POST /apps)
	CreateBenchlingApp(ctx echo.Context) error
	// Get an app by ID
	// (GET /apps/{app_id})
	GetBenchlingAppByID(ctx echo.Context, appId string) error
	// Update an app
	// (PATCH /apps/{app_id})
	PatchBenchlingApp(ctx echo.Context, appId string) error
	// Archive apps
	// (POST /apps:archive)
	ArchiveBenchlingApps(ctx echo.Context) error
	// Unarchive apps
	// (POST /apps:unarchive)
	UnarchiveBenchlingApps(ctx echo.Context) error
	// List assay result schemas
	// (GET /assay-result-schemas)
	ListAssayResultSchemas(ctx echo.Context, params ListAssayResultSchemasParams) error
	// Get a Result schema by ID
	// (GET /assay-result-schemas/{schema_id})
	GetResultSchema(ctx echo.Context, schemaId string) error
	// List results
	// (GET /assay-results)
	ListAssayResults(ctx echo.Context, params ListAssayResultsParams) error
	// Create 1 or more results.
	// (POST /assay-results)
	CreateAssayResults(ctx echo.Context) error
	// Get a result
	// (GET /assay-results/{assay_result_id})
	GetAssayResult(ctx echo.Context, assayResultId openapi_types.UUID) error
	// Archive 1 or more results.
	// (POST /assay-results:archive)
	ArchiveAssayResults(ctx echo.Context) error
	// Bulk create results
	// (POST /assay-results:bulk-create)
	BulkCreateAssayResults(ctx echo.Context) error
	// Gets multiple results specified by a list of IDs.
	// (GET /assay-results:bulk-get)
	BulkGetAssayResults(ctx echo.Context, params BulkGetAssayResultsParams) error
	// Unarchive 1 or more results.
	// (POST /assay-results:unarchive)
	UnarchiveAssayResults(ctx echo.Context) error
	// List assay run schemas
	// (GET /assay-run-schemas)
	ListAssayRunSchemas(ctx echo.Context, params ListAssayRunSchemasParams) error
	// Get a Run schema by ID
	// (GET /assay-run-schemas/{schema_id})
	GetRunSchema(ctx echo.Context, schemaId string) error
	// List runs
	// (GET /assay-runs)
	ListAssayRuns(ctx echo.Context, params ListAssayRunsParams) error
	// Create 1 or more runs.
	// (POST /assay-runs)
	CreateAssayRuns(ctx echo.Context) error
	// Get a run
	// (GET /assay-runs/{assay_run_id})
	GetAssayRun(ctx echo.Context, assayRunId string) error
	// Update a run
	// (PATCH /assay-runs/{assay_run_id})
	UpdateAssayRun(ctx echo.Context, assayRunId string) error
	// list AutomationInputGenerators by Run
	// (GET /assay-runs/{assay_run_id}/automation-input-generators)
	ListAutomationInputGenerators(ctx echo.Context, assayRunId string, params ListAutomationInputGeneratorsParams) error
	// list AutomationOutputProcessors by Run
	// (GET /assay-runs/{assay_run_id}/automation-output-processors)
	ListAutomationOutputProcessorsDeprecated(ctx echo.Context, assayRunId string, params ListAutomationOutputProcessorsDeprecatedParams) error
	// Archive Assay Runs
	// (POST /assay-runs:archive)
	ArchiveAssayRuns(ctx echo.Context) error
	// Bulk get runs by ID
	// (GET /assay-runs:bulk-get)
	BulkGetAssayRuns(ctx echo.Context, params BulkGetAssayRunsParams) error
	// Unarchive Assay Runs
	// (POST /assay-runs:unarchive)
	UnarchiveAssayRuns(ctx echo.Context) error
	// Get a Lab Automation Transform step
	// (GET /automation-file-transforms/{transform_id})
	GetLabAutomationTransform(ctx echo.Context, transformId string) error
	// Update a Lab Automation Transform step
	// (PATCH /automation-file-transforms/{transform_id})
	UpdateLabAutomationTransform(ctx echo.Context, transformId string) error
	// Get an Automation Input Generator
	// (GET /automation-input-generators/{input_generator_id})
	GetAutomationInputGenerator(ctx echo.Context, inputGeneratorId string) error
	// Update an Automation Input Generator
	// (PATCH /automation-input-generators/{input_generator_id})
	UpdateAutomationInputGenerator(ctx echo.Context, inputGeneratorId string) error
	// Generate Input with an Automation Input Generator
	// (POST /automation-input-generators/{input_generator_id}:generate-input)
	GenerateInputWithAutomationInputGenerator(ctx echo.Context, inputGeneratorId string) error
	// List non-empty Automation Output Processors
	// (GET /automation-output-processors)
	ListAutomationOutputProcessors(ctx echo.Context, params ListAutomationOutputProcessorsParams) error
	// Create Automation Output Processor
	// (POST /automation-output-processors)
	CreateAutomationOutputProcessor(ctx echo.Context) error
	// Get an Automation Output Processor
	// (GET /automation-output-processors/{output_processor_id})
	GetAutomationOutputProcessor(ctx echo.Context, outputProcessorId string) error
	// Update an Automation Output Processor
	// (PATCH /automation-output-processors/{output_processor_id})
	UpdateAutomationOutputProcessor(ctx echo.Context, outputProcessorId string) error
	// Process Output with an Automation Output Processor
	// (POST /automation-output-processors/{output_processor_id}:process-output)
	ProcessOutputWithAutomationOutputProcessor(ctx echo.Context, outputProcessorId string) error
	// Archive Automation Output Processors and linked Results
	// (POST /automation-output-processors:archive)
	ArchiveAutomationOutputProcessors(ctx echo.Context) error
	// Unarchive Automation Output Processors and linked Results
	// (POST /automation-output-processors:unarchive)
	UnarchiveAutomationOutputProcessors(ctx echo.Context) error
	// List batch schemas
	// (GET /batch-schemas)
	ListBatchSchemas(ctx echo.Context, params ListBatchSchemasParams) error
	// Get a batch schema by ID
	// (GET /batch-schemas/{schema_id})
	GetBatchSchema(ctx echo.Context, schemaId string) error
	// List batches
	// (GET /batches)
	ListBatches(ctx echo.Context, params ListBatchesParams) error
	// Create a batch
	// (POST /batches)
	CreateBatch(ctx echo.Context) error
	// Get a batch
	// (GET /batches/{batch_id})
	GetBatch(ctx echo.Context, batchId string) error
	// Update a batch
	// (PATCH /batches/{batch_id})
	UpdateBatch(ctx echo.Context, batchId string) error
	// Archive Batches
	// (POST /batches:archive)
	ArchiveBatches(ctx echo.Context) error
	// Bulk get batches
	// (GET /batches:bulk-get)
	BulkGetBatches(ctx echo.Context, params BulkGetBatchesParams) error
	// Unarchive Batches
	// (POST /batches:unarchive)
	UnarchiveBatches(ctx echo.Context) error
	// Upload single-part blob
	// (POST /blobs)
	CreateBlob(ctx echo.Context) error
	// Get a Blob
	// (GET /blobs/{blob_id})
	GetBlob(ctx echo.Context, blobId string, params GetBlobParams) error
	// Download a blob
	// (GET /blobs/{blob_id}/download)
	GetBlobFile(ctx echo.Context, blobId string) error
	// Get a Blob's download url
	// (GET /blobs/{blob_id}/download-url)
	GetBlobUrl(ctx echo.Context, blobId string) error
	// Upload a part of a multi-part blob
	// (POST /blobs/{blob_id}/parts)
	CreateBlobPart(ctx echo.Context, blobId string) error
	// Abort multi-part blob upload
	// (POST /blobs/{blob_id}:abort-upload)
	AbortMultipartBlob(ctx echo.Context, blobId string) error
	// Complete multi-part blob upload
	// (POST /blobs/{blob_id}:complete-upload)
	CompleteMultipartBlob(ctx echo.Context, blobId string) error
	// Bulk get Blobs by UUID
	// (GET /blobs:bulk-get)
	BulkGetBlobs(ctx echo.Context, params BulkGetBlobsParams) error
	// Initiate multi-part blob upload
	// (POST /blobs:start-multipart-upload)
	CreateMultipartBlob(ctx echo.Context) error
	// List box schemas
	// (GET /box-schemas)
	ListBoxSchemas(ctx echo.Context, params ListBoxSchemasParams) error
	// Get a box schema by ID
	// (GET /box-schemas/{schema_id})
	GetBoxSchema(ctx echo.Context, schemaId string) error
	// List boxes
	// (GET /boxes)
	ListBoxes(ctx echo.Context, params ListBoxesParams) error
	// Create a box
	// (POST /boxes)
	CreateBox(ctx echo.Context) error
	// Get a box
	// (GET /boxes/{box_id})
	GetBox(ctx echo.Context, boxId string) error
	// Update a box
	// (PATCH /boxes/{box_id})
	UpdateBox(ctx echo.Context, boxId string) error
	// List a box's contents
	// (GET /boxes/{box_id}/contents)
	ListBoxContents(ctx echo.Context, boxId string, params ListBoxContentsParams) error
	// Archive boxes
	// (POST /boxes:archive)
	ArchiveBoxes(ctx echo.Context) error
	// BulkGet boxes
	// (GET /boxes:bulk-get)
	BulkGetBoxes(ctx echo.Context, params BulkGetBoxesParams) error
	// Unarchive boxes
	// (POST /boxes:unarchive)
	UnarchiveBoxes(ctx echo.Context) error
	// List container schemas
	// (GET /container-schemas)
	ListContainerSchemas(ctx echo.Context, params ListContainerSchemasParams) error
	// Get a container schema by ID
	// (GET /container-schemas/{schema_id})
	GetContainerSchema(ctx echo.Context, schemaId string) error
	// List containers
	// (GET /containers)
	ListContainers(ctx echo.Context, params ListContainersParams) error
	// Create a new container
	// (POST /containers)
	CreateContainer(ctx echo.Context) error
	// get a container by id
	// (GET /containers/{container_id})
	GetContainer(ctx echo.Context, containerId string, params GetContainerParams) error
	// update a container
	// (PATCH /containers/{container_id})
	UpdateContainer(ctx echo.Context, containerId string) error
	// List a container's contents
	// (GET /containers/{container_id}/contents)
	ListContainerContents(ctx echo.Context, containerId string) error
	// Delete a container content
	// (DELETE /containers/{container_id}/contents/{containable_id})
	DeleteContainerContent(ctx echo.Context, containerId string, containableId string) error
	// Get a container content
	// (GET /containers/{container_id}/contents/{containable_id})
	GetContainerContent(ctx echo.Context, containerId string, containableId string) error
	// Update a container content
	// (PATCH /containers/{container_id}/contents/{containable_id})
	UpdateContainerContent(ctx echo.Context, containerId string, containableId string) error
	// Transfer into container
	// (POST /containers/{destination_container_id}:transfer)
	TransferIntoContainer(ctx echo.Context, destinationContainerId string) error
	// Archive containers
	// (POST /containers:archive)
	ArchiveContainers(ctx echo.Context) error
	// Bulk create containers. Limit of 1000 containers per request.
	// (POST /containers:bulk-create)
	BulkCreateContainers(ctx echo.Context) error
	// Bulk get a set of containers
	// (GET /containers:bulk-get)
	BulkGetContainers(ctx echo.Context, params BulkGetContainersParams) error
	// Bulk update containers
	// (POST /containers:bulk-update)
	BulkUpdateContainers(ctx echo.Context) error
	// Check in containers
	// (POST /containers:check-in)
	CheckinContainers(ctx echo.Context) error
	// Check out containers
	// (POST /containers:check-out)
	CheckoutContainers(ctx echo.Context) error
	// Print labels
	// (POST /containers:print-labels)
	PrintLabels(ctx echo.Context) error
	// Reserve containers
	// (POST /containers:reserve)
	ReserveContainers(ctx echo.Context) error
	// Unarchive containers
	// (POST /containers:unarchive)
	UnarchiveContainers(ctx echo.Context) error
	// List custom entities
	// (GET /custom-entities)
	ListCustomEntities(ctx echo.Context, params ListCustomEntitiesParams) error
	// Create a custom entity
	// (POST /custom-entities)
	CreateCustomEntity(ctx echo.Context) error
	// Get a custom entity
	// (GET /custom-entities/{custom_entity_id})
	GetCustomEntity(ctx echo.Context, customEntityId string, params GetCustomEntityParams) error
	// Update a custom entity
	// (PATCH /custom-entities/{custom_entity_id})
	UpdateCustomEntity(ctx echo.Context, customEntityId string) error
	// Archive custom entities
	// (POST /custom-entities:archive)
	ArchiveCustomEntities(ctx echo.Context) error
	// Bulk Create custom entities
	// (POST /custom-entities:bulk-create)
	BulkCreateCustomEntities(ctx echo.Context) error
	// Bulk get custom entities by ID
	// (GET /custom-entities:bulk-get)
	BulkGetCustomEntities(ctx echo.Context, params BulkGetCustomEntitiesParams) error
	// Bulk Update custom entities
	// (POST /custom-entities:bulk-update)
	BulkUpdateCustomEntities(ctx echo.Context) error
	// Unarchive custom entities
	// (POST /custom-entities:unarchive)
	UnarchiveCustomEntities(ctx echo.Context) error
	// List custom notations
	// (GET /custom-notations)
	ListCustomNotations(ctx echo.Context, params ListCustomNotationsParams) error
	// List DNA Alignments
	// (GET /dna-alignments)
	ListDNAAlignments(ctx echo.Context, params ListDNAAlignmentsParams) error
	// Delete a DNA Alignment
	// (DELETE /dna-alignments/{dna_alignment_id})
	DeleteDNAAlignment(ctx echo.Context, dnaAlignmentId string) error
	// Get a DNA Alignment
	// (GET /dna-alignments/{dna_alignment_id})
	GetDNAAlignment(ctx echo.Context, dnaAlignmentId string) error
	// Create a consensus DNA alignment
	// (POST /dna-alignments:create-consensus-alignment)
	CreateDnaConsensusAlignment(ctx echo.Context) error
	// Create a template DNA alignment
	// (POST /dna-alignments:create-template-alignment)
	CreateDnaTemplateAlignment(ctx echo.Context) error
	// List DNA Oligos
	// (GET /dna-oligos)
	ListDNAOligos(ctx echo.Context, params ListDNAOligosParams) error
	// Create a DNA Oligo
	// (POST /dna-oligos)
	CreateDNAOligo(ctx echo.Context) error
	// Get a DNA Oligo
	// (GET /dna-oligos/{oligo_id})
	GetDNAOligo(ctx echo.Context, oligoId string, params GetDNAOligoParams) error
	// Update a DNA Oligo
	// (PATCH /dna-oligos/{oligo_id})
	UpdateDNAOligo(ctx echo.Context, oligoId string) error
	// Archive DNA Oligos
	// (POST /dna-oligos:archive)
	ArchiveDNAOligos(ctx echo.Context) error
	// Bulk Create DNA Oligos
	// (POST /dna-oligos:bulk-create)
	BulkCreateDNAOligos(ctx echo.Context) error
	// Bulk Update DNA Oligos
	// (POST /dna-oligos:bulk-update)
	BulkUpdateDNAOligos(ctx echo.Context) error
	// Unarchive DNA Oligos
	// (POST /dna-oligos:unarchive)
	UnarchiveDNAOligos(ctx echo.Context) error
	// List DNA sequences
	// (GET /dna-sequences)
	ListDNASequences(ctx echo.Context, params ListDNASequencesParams) error
	// Create a DNA sequence
	// (POST /dna-sequences)
	CreateDNASequence(ctx echo.Context) error
	// Get a DNA sequence
	// (GET /dna-sequences/{dna_sequence_id})
	GetDNASequence(ctx echo.Context, dnaSequenceId string, params GetDNASequenceParams) error
	// Update a DNA sequence
	// (PATCH /dna-sequences/{dna_sequence_id})
	UpdateDNASequence(ctx echo.Context, dnaSequenceId string) error
	// Archive DNA sequences
	// (POST /dna-sequences:archive)
	ArchiveDNASequences(ctx echo.Context) error
	// Auto-annotate DNA sequences with matching features from specified Feature Libraries
	// (POST /dna-sequences:auto-annotate)
	AutoAnnotateDnaSequences(ctx echo.Context) error
	// Autofill DNA sequence parts
	// (POST /dna-sequences:autofill-parts)
	AutofillDNASequenceParts(ctx echo.Context) error
	// Autofill DNA sequence translations
	// (POST /dna-sequences:autofill-translations)
	AutofillDNASequenceTranslations(ctx echo.Context) error
	// Bulk Create DNA sequences
	// (POST /dna-sequences:bulk-create)
	BulkCreateDNASequences(ctx echo.Context) error
	// Bulk get DNA sequences by ID
	// (GET /dna-sequences:bulk-get)
	BulkGetDNASequences(ctx echo.Context, params BulkGetDNASequencesParams) error
	// Bulk Update DNA sequences
	// (POST /dna-sequences:bulk-update)
	BulkUpdateDNASequences(ctx echo.Context) error
	// List entities with matching bases
	// (POST /dna-sequences:match-bases)
	MatchBasesDnaSequences(ctx echo.Context) error
	// Search DNA Sequences
	// (POST /dna-sequences:search-bases)
	SearchDnaSequences(ctx echo.Context) error
	// Unarchive DNA sequences
	// (POST /dna-sequences:unarchive)
	UnarchiveDNASequences(ctx echo.Context) error
	// List dropdowns
	// (GET /dropdowns)
	ListDropdowns(ctx echo.Context, params ListDropdownsParams) error
	// Create a dropdown
	// (POST /dropdowns)
	CreateDropdown(ctx echo.Context) error
	// Get a dropdown
	// (GET /dropdowns/{dropdown_id})
	GetDropdown(ctx echo.Context, dropdownId string) error
	// Update a dropdown
	// (PATCH /dropdowns/{dropdown_id})
	UpdateDropdown(ctx echo.Context, dropdownId string) error
	// Archive dropdown options
	// (POST /dropdowns/{dropdown_id}/options:archive)
	ArchiveDropdownOptions(ctx echo.Context, dropdownId string) error
	// Unarchive dropdown options
	// (POST /dropdowns/{dropdown_id}/options:unarchive)
	UnarchiveDropdownOptions(ctx echo.Context, dropdownId string) error
	// Get an entity's batches
	// (GET /entities/{entity_id}/batches)
	GetEnitityBatches(ctx echo.Context, entityId string) error
	// List entity schemas
	// (GET /entity-schemas)
	ListEntitySchemas(ctx echo.Context, params ListEntitySchemasParams) error
	// Get an entity schema by ID
	// (GET /entity-schemas/{schema_id})
	GetEntitySchema(ctx echo.Context, schemaId string) error
	// List entries
	// (GET /entries)
	ListEntries(ctx echo.Context, params ListEntriesParams) error
	// Create a notebook entry
	// (POST /entries)
	CreateEntry(ctx echo.Context) error
	// Get a notebook entry by ID
	// (GET /entries/{entry_id})
	GetEntry(ctx echo.Context, entryId string, params GetEntryParams) error
	// Update a notebook entry's metadata
	// (PATCH /entries/{entry_id})
	UpdateEntry(ctx echo.Context, entryId string, params UpdateEntryParams) error
	// Retrieves the metadata for an external file. Use the 'downloadURL' to download the actual file.
	// (GET /entries/{entry_id}/external-files/{external_file_id})
	GetExternalFileMetadata(ctx echo.Context, entryId string, externalFileId string) error
	// Archive notebook entries
	// (POST /entries:archive)
	ArchiveEntries(ctx echo.Context) error
	// Get notebook entries using entry IDs or display IDs
	// (GET /entries:bulk-get)
	BulkGetEntries(ctx echo.Context, params BulkGetEntriesParams) error
	// Unarchive notebook entries
	// (POST /entries:unarchive)
	UnarchiveEntries(ctx echo.Context) error
	// List entry schemas
	// (GET /entry-schemas)
	ListEntrySchemas(ctx echo.Context, params ListEntrySchemasParams) error
	// Get an Entry schema by ID
	// (GET /entry-schemas/{schema_id})
	GetEntrySchema(ctx echo.Context, schemaId string) error
	// List entry templates
	// (GET /entry-templates)
	ListEntryTemplates(ctx echo.Context, params ListEntryTemplatesParams) error
	// Get a notebook template entry by ID
	// (GET /entry-templates/{entry_template_id})
	GetEntryTemplate(ctx echo.Context, entryTemplateId string, params GetEntryTemplateParams) error
	// List Events
	// (GET /events)
	ListEvents(ctx echo.Context, params ListEventsParams) error
	// Export Item
	// (POST /exports)
	ExportItem(ctx echo.Context) error
	// List Feature Libraries
	// (GET /feature-libraries)
	ListFeatureLibraries(ctx echo.Context, params ListFeatureLibrariesParams) error
	// Create a Feature Library
	// (POST /feature-libraries)
	CreateFeatureLibrary(ctx echo.Context) error
	// Get a feature library by ID
	// (GET /feature-libraries/{feature_library_id})
	GetFeatureLibrary(ctx echo.Context, featureLibraryId string, params GetFeatureLibraryParams) error
	// Update a feature library
	// (PATCH /feature-libraries/{feature_library_id})
	UpdateFeatureLibrary(ctx echo.Context, featureLibraryId string) error
	// List Features
	// (GET /features)
	ListFeatures(ctx echo.Context, params ListFeaturesParams) error
	// Create a Feature
	// (POST /features)
	CreateFeature(ctx echo.Context) error
	// Get a feature by ID
	// (GET /features/{feature_id})
	GetFeature(ctx echo.Context, featureId string, params GetFeatureParams) error
	// Update a feature
	// (PATCH /features/{feature_id})
	UpdateFeature(ctx echo.Context, featureId string) error
	// Bulk create Features
	// (POST /features:bulk-create)
	BulkCreateFeatures(ctx echo.Context) error
	// List folders
	// (GET /folders)
	ListFolders(ctx echo.Context, params ListFoldersParams) error
	// Create folder
	// (POST /folders)
	CreateFolder(ctx echo.Context) error
	// Get a folder by ID
	// (GET /folders/{folder_id})
	GetFolder(ctx echo.Context, folderId string) error
	// Archive folders
	// (POST /folders:archive)
	ArchiveFolders(ctx echo.Context) error
	// Unarchive folders
	// (POST /folders:unarchive)
	UnarchiveFolders(ctx echo.Context) error
	// List legacy workflow stage run input samples
	// (GET /legacy-workflow-stage-runs/{stage_run_id}/input-samples)
	ListLegacyWorkflowStageRunInputSamples(ctx echo.Context, stageRunId string) error
	// List legacy workflow stage run output samples
	// (GET /legacy-workflow-stage-runs/{stage_run_id}/output-samples)
	ListLegacyWorkflowStageRunOutputSamples(ctx echo.Context, stageRunId string) error
	// List legacy workflow stage run registered samples
	// (GET /legacy-workflow-stage-runs/{stage_run_id}/registered-samples)
	ListLegacyWorkflowStageRunRegisteredSamples(ctx echo.Context, stageRunId string) error
	// List legacy workflow stage runs
	// (GET /legacy-workflow-stages/{stage_id}/workflow-stage-runs)
	ListLegacyWorkflowStageRuns(ctx echo.Context, stageId string) error
	// List legacy workflows
	// (GET /legacy-workflows)
	ListLegacyWorkflows(ctx echo.Context) error
	// Update legacy workflow
	// (PATCH /legacy-workflows/{legacy_workflow_id})
	UpdateLegacyWorkflowMetadata(ctx echo.Context, legacyWorkflowId string) error
	// List legacy workflow stages
	// (GET /legacy-workflows/{legacy_workflow_id}/workflow-stages)
	ListLegacyWorkflowStages(ctx echo.Context, legacyWorkflowId string) error
	// List location schemas
	// (GET /location-schemas)
	ListLocationSchemas(ctx echo.Context, params ListLocationSchemasParams) error
	// Get a location schema by ID
	// (GET /location-schemas/{schema_id})
	GetLocationSchema(ctx echo.Context, schemaId string) error
	// List locations
	// (GET /locations)
	ListLocations(ctx echo.Context, params ListLocationsParams) error
	// Create a location
	// (POST /locations)
	CreateLocation(ctx echo.Context) error
	// Get a location by ID
	// (GET /locations/{location_id})
	GetLocation(ctx echo.Context, locationId string) error
	// Update a location
	// (PATCH /locations/{location_id})
	UpdateLocation(ctx echo.Context, locationId string) error
	// Archive locations
	// (POST /locations:archive)
	ArchiveLocations(ctx echo.Context) error
	// BulkGet locations
	// (GET /locations:bulk-get)
	BulkGetLocations(ctx echo.Context, params BulkGetLocationsParams) error
	// Unarchive locations
	// (POST /locations:unarchive)
	UnarchiveLocations(ctx echo.Context) error
	// List mixtures
	// (GET /mixtures)
	ListMixtures(ctx echo.Context, params ListMixturesParams) error
	// Create a mixture
	// (POST /mixtures)
	CreateMixture(ctx echo.Context) error
	// Get a mixture
	// (GET /mixtures/{mixture_id})
	GetMixture(ctx echo.Context, mixtureId string) error
	// Update a mixture
	// (PATCH /mixtures/{mixture_id})
	UpdateMixture(ctx echo.Context, mixtureId string) error
	// Archive mixtures
	// (POST /mixtures:archive)
	ArchiveMixtures(ctx echo.Context) error
	// Bulk Create mixtures
	// (POST /mixtures:bulk-create)
	BulkCreateMixtures(ctx echo.Context) error
	// Bulk Update mixtures
	// (POST /mixtures:bulk-update)
	BulkUpdateMixtures(ctx echo.Context) error
	// Unarchive mixtures
	// (POST /mixtures:unarchive)
	UnarchiveMixtures(ctx echo.Context) error
	// List Molecules
	// (GET /molecules)
	ListMolecules(ctx echo.Context, params ListMoleculesParams) error
	// Create a Molecule
	// (POST /molecules)
	CreateMolecule(ctx echo.Context) error
	// Get a Molecule
	// (GET /molecules/{molecule_id})
	GetMolecule(ctx echo.Context, moleculeId string) error
	// Update a Molecule
	// (PATCH /molecules/{molecule_id})
	UpdateMolecule(ctx echo.Context, moleculeId string) error
	// Archive Molecules
	// (POST /molecules:archive)
	ArchiveMolecules(ctx echo.Context) error
	// Bulk Create Molecules
	// (POST /molecules:bulk-create)
	BulkCreateMolecules(ctx echo.Context) error
	// Bulk Update Molecules
	// (POST /molecules:bulk-update)
	BulkUpdateMolecules(ctx echo.Context) error
	// Unarchive Molecules
	// (POST /molecules:unarchive)
	UnarchiveMolecules(ctx echo.Context) error
	// List Monomers
	// (GET /monomers)
	ListMonomers(ctx echo.Context, params ListMonomersParams) error
	// Create a monomer
	// (POST /monomers)
	CreateMonomer(ctx echo.Context, params CreateMonomerParams) error
	// Update a Monomer
	// (PATCH /monomers/{monomer_id})
	UpdateMonomer(ctx echo.Context, monomerId string, params UpdateMonomerParams) error
	// Archive Monomers
	// (POST /monomers:archive)
	ArchiveMonomers(ctx echo.Context) error
	// Unarchive Monomers
	// (POST /monomers:unarchive)
	UnarchiveMonomers(ctx echo.Context) error
	// List Nucleotide Alignments
	// (GET /nucleotide-alignments)
	ListNucleotideAlignments(ctx echo.Context, params ListNucleotideAlignmentsParams) error
	// Delete a Nucleotide Alignment
	// (DELETE /nucleotide-alignments/{alignment_id})
	DeleteNucleotideAlignment(ctx echo.Context, alignmentId string) error
	// Get a Nucleotide Alignment
	// (GET /nucleotide-alignments/{alignment_id})
	GetNucleotideAlignment(ctx echo.Context, alignmentId string) error
	// Create a consensus Nucleotide Alignment
	// (POST /nucleotide-alignments:create-consensus-alignment)
	CreateConsensusNucleotideAlignment(ctx echo.Context) error
	// Create a template Nucleotide Alignment
	// (POST /nucleotide-alignments:create-template-alignment)
	CreateTemplateNucleotideAlignment(ctx echo.Context) error
	// List Oligos
	// (GET /oligos)
	ListOligos(ctx echo.Context, params ListOligosParams) error
	// Create an Oligo
	// (POST /oligos)
	CreateOligo(ctx echo.Context) error
	// Get an Oligo
	// (GET /oligos/{oligo_id})
	GetOligo(ctx echo.Context, oligoId string, params GetOligoParams) error
	// Update an Oligo
	// (PATCH /oligos/{oligo_id})
	UpdateOligo(ctx echo.Context, oligoId string) error
	// Archive Oligos
	// (POST /oligos:archive)
	ArchiveOligos(ctx echo.Context) error
	// Bulk Create DNA Oligos
	// (POST /oligos:bulk-create)
	BulkCreateOligos(ctx echo.Context) error
	// Bulk get Oligos by ID
	// (GET /oligos:bulk-get)
	BulkGetOligos(ctx echo.Context, params BulkGetOligosParams) error
	// Unarchive Oligos
	// (POST /oligos:unarchive)
	UnarchiveOligos(ctx echo.Context) error
	// List organizations
	// (GET /organizations)
	ListOrganizations(ctx echo.Context, params ListOrganizationsParams) error
	// Get an organization by ID
	// (GET /organizations/{organization_id})
	GetOrganization(ctx echo.Context, organizationId string) error
	// List plate schemas
	// (GET /plate-schemas)
	ListPlateSchemas(ctx echo.Context, params ListPlateSchemasParams) error
	// Get a plate schema by ID
	// (GET /plate-schemas/{schema_id})
	GetPlateSchema(ctx echo.Context, schemaId string) error
	// List plates
	// (GET /plates)
	ListPlates(ctx echo.Context, params ListPlatesParams) error
	// Create a plate
	// (POST /plates)
	CreatePlate(ctx echo.Context, params CreatePlateParams) error
	// Get a plate
	// (GET /plates/{plate_id})
	GetPlate(ctx echo.Context, plateId string, params GetPlateParams) error
	// Update a plate
	// (PATCH /plates/{plate_id})
	UpdatePlate(ctx echo.Context, plateId string, params UpdatePlateParams) error
	// Archive plates
	// (POST /plates:archive)
	ArchivePlates(ctx echo.Context) error
	// BulkGet plates
	// (GET /plates:bulk-get)
	BulkGetPlates(ctx echo.Context, params BulkGetPlatesParams) error
	// Unarchive plates
	// (POST /plates:unarchive)
	UnarchivePlates(ctx echo.Context) error
	// List projects
	// (GET /projects)
	ListProjects(ctx echo.Context, params ListProjectsParams) error
	// Get a project by ID
	// (GET /projects/{project_id})
	GetProject(ctx echo.Context, projectId string) error
	// Archive projects
	// (POST /projects:archive)
	ArchiveProjects(ctx echo.Context) error
	// Unarchive projects
	// (POST /projects:unarchive)
	UnarchiveProjects(ctx echo.Context) error
	// List registries
	// (GET /registries)
	ListRegistries(ctx echo.Context, params ListRegistriesParams) error
	// Get registry
	// (GET /registries/{registry_id})
	GetRegistry(ctx echo.Context, registryId string) error
	// List batch schemas by registry
	// (GET /registries/{registry_id}/batch-schemas)
	ListBatchSchemasByRegistry(ctx echo.Context, registryId string) error
	// List box schemas by registry
	// (GET /registries/{registry_id}/box-schemas)
	ListBoxSchemasByRegistry(ctx echo.Context, registryId string) error
	// List container schemas by registry
	// (GET /registries/{registry_id}/container-schemas)
	ListContainerSchemasByRegistry(ctx echo.Context, registryId string) error
	// List dropdowns for a given registry
	// (GET /registries/{registry_id}/dropdowns)
	ListDropdownsByRegistry(ctx echo.Context, registryId string) error
	// List entity schemas by registry
	// (GET /registries/{registry_id}/entity-schemas)
	ListEntitySchemasByRegistry(ctx echo.Context, registryId string) error
	// List printers
	// (GET /registries/{registry_id}/label-printers)
	ListPrinters(ctx echo.Context, registryId string, params ListPrintersParams) error
	// List label templates
	// (GET /registries/{registry_id}/label-templates)
	ListLabelTemplates(ctx echo.Context, registryId string, params ListLabelTemplatesParams) error
	// List location schemas by registry
	// (GET /registries/{registry_id}/location-schemas)
	ListLocationSchemasByRegistry(ctx echo.Context, registryId string) error
	// List plate schemas by registry
	// (GET /registries/{registry_id}/plate-schemas)
	ListPlateSchemasByRegistry(ctx echo.Context, registryId string) error
	// Bulk get registered entities
	// (GET /registries/{registry_id}/registered-entities:bulk-get)
	BulkGetRegisteredEntities(ctx echo.Context, registryId string, params BulkGetRegisteredEntitiesParams) error
	// Register entities
	// (POST /registries/{registry_id}:bulk-register-entities)
	RegisterEntities(ctx echo.Context, registryId string) error
	// Unregister entities
	// (POST /registries/{registry_id}:unregister-entities)
	UnregisterEntities(ctx echo.Context, registryId string) error
	// Validate barcodes
	// (POST /registries/{registry_id}:validate-barcodes)
	ValidateBarcodes(ctx echo.Context, registryId string) error
	// List Request Fulfillments
	// (GET /request-fulfillments)
	ListRequestFulfillments(ctx echo.Context, params ListRequestFulfillmentsParams) error
	// Get a request's fulfillment
	// (GET /request-fulfillments/{request_fulfillment_id})
	GetRequestFulfillment(ctx echo.Context, requestFulfillmentId string) error
	// List request schemas
	// (GET /request-schemas)
	ListRequestSchemas(ctx echo.Context, params ListRequestSchemasParams) error
	// Get a Request schema by ID
	// (GET /request-schemas/{schema_id})
	GetRequestSchema(ctx echo.Context, schemaId string) error
	// List request task schemas
	// (GET /request-task-schemas)
	ListRequestTaskSchemas(ctx echo.Context, params ListRequestTaskSchemasParams) error
	// Get a Request Task schema by ID
	// (GET /request-task-schemas/{schema_id})
	GetRequestTaskSchema(ctx echo.Context, schemaId string) error
	// List requests
	// (GET /requests)
	ListRequests(ctx echo.Context, params ListRequestsParams) error
	// Create a request
	// (POST /requests)
	CreateRequest(ctx echo.Context) error
	// Get a request by ID
	// (GET /requests/{request_id})
	GetRequest(ctx echo.Context, requestId string, params GetRequestParams) error
	// Update a request
	// (PATCH /requests/{request_id})
	PatchRequest(ctx echo.Context, requestId string) error
	// Get a request's response
	// (GET /requests/{request_id}/response)
	GetRequestResponse(ctx echo.Context, requestId string) error
	// Create tasks for a request
	// (POST /requests/{request_id}/tasks:bulk-create)
	BulkCreateRequestTasks(ctx echo.Context, requestId string) error
	// Bulk update tasks for a request
	// (POST /requests/{request_id}/tasks:bulk-update)
	BulkUpdateRequestTasks(ctx echo.Context, requestId string) error
	// Update the status of sample groups in a request
	// (POST /requests/{request_id}:execute-sample-groups)
	ExecuteRequestsSampleGroups(ctx echo.Context, requestId string) error
	// Bulk get requests
	// (GET /requests:bulk-get)
	BulkGetRequests(ctx echo.Context, params BulkGetRequestsParams) error
	// Create a transaction
	// (POST /result-transactions)
	CreateAssayResultsTransaction(ctx echo.Context) error
	// Create results in a transaction
	// (POST /result-transactions/{transaction_id}/results)
	CreateAssayResultsInTransaction(ctx echo.Context, transactionId openapi_types.UUID) error
	// Abort a transaction
	// (POST /result-transactions/{transaction_id}:abort)
	AbortAssayResultsTransaction(ctx echo.Context, transactionId openapi_types.UUID) error
	// Commit a transaction
	// (POST /result-transactions/{transaction_id}:commit)
	CommitAssayResultsTransaction(ctx echo.Context, transactionId openapi_types.UUID) error
	// List RNA Oligos
	// (GET /rna-oligos)
	ListRNAOligos(ctx echo.Context, params ListRNAOligosParams) error
	// Create an RNA Oligo
	// (POST /rna-oligos)
	CreateRNAOligo(ctx echo.Context) error
	// Get an RNA Oligo
	// (GET /rna-oligos/{oligo_id})
	GetRNAOligo(ctx echo.Context, oligoId string, params GetRNAOligoParams) error
	// Update an RNA Oligo
	// (PATCH /rna-oligos/{oligo_id})
	UpdateRNAOligo(ctx echo.Context, oligoId string) error
	// Archive RNA Oligos
	// (POST /rna-oligos:archive)
	ArchiveRNAOligos(ctx echo.Context) error
	// Bulk Create RNA Oligos
	// (POST /rna-oligos:bulk-create)
	BulkCreateRNAOligos(ctx echo.Context) error
	// Bulk Update RNA Oligos
	// (POST /rna-oligos:bulk-update)
	BulkUpdateRNAOligos(ctx echo.Context) error
	// Unarchive RNA Oligos
	// (POST /rna-oligos:unarchive)
	UnarchiveRNAOligos(ctx echo.Context) error
	// List RNA sequences
	// (GET /rna-sequences)
	ListRNASequences(ctx echo.Context, params ListRNASequencesParams) error
	// Create an RNA sequence
	// (POST /rna-sequences)
	CreateRNASequence(ctx echo.Context) error
	// Get an RNA sequence
	// (GET /rna-sequences/{rna_sequence_id})
	GetRNASequence(ctx echo.Context, rnaSequenceId string, params GetRNASequenceParams) error
	// Update an RNA sequence
	// (PATCH /rna-sequences/{rna_sequence_id})
	UpdateRNASequence(ctx echo.Context, rnaSequenceId string) error
	// Archive RNA Sequences
	// (POST /rna-sequences:archive)
	ArchiveRNASequences(ctx echo.Context) error
	// Auto-annotate RNA sequences with matching features from specified Feature Libraries
	// (POST /rna-sequences:auto-annotate)
	AutoAnnotateRnaSequences(ctx echo.Context) error
	// Autofill RNA sequence parts
	// (POST /rna-sequences:autofill-parts)
	AutofillRNASequenceParts(ctx echo.Context) error
	// Autofill RNA sequence translations from Amino Acid sequences with matching schemas
	// (POST /rna-sequences:autofill-translations)
	AutofillRNASequenceTranslations(ctx echo.Context) error
	// Bulk Create RNA sequences
	// (POST /rna-sequences:bulk-create)
	BulkCreateRNASequences(ctx echo.Context) error
	// Bulk get RNA sequences by ID
	// (GET /rna-sequences:bulk-get)
	BulkGetRNASequences(ctx echo.Context, params BulkGetRNASequencesParams) error
	// Bulk Update RNA sequences
	// (POST /rna-sequences:bulk-update)
	BulkUpdateRNASequences(ctx echo.Context) error
	// Match RNA sequences by bases
	// (POST /rna-sequences:match-bases)
	MatchBasesRnaSequences(ctx echo.Context) error
	// Search RNA Sequences
	// (POST /rna-sequences:search-bases)
	SearchRnaSequences(ctx echo.Context) error
	// Unarchive RNA sequences
	// (POST /rna-sequences:unarchive)
	UnarchiveRNASequences(ctx echo.Context) error
	// Get a task by id
	// (GET /tasks/{task_id})
	GetTask(ctx echo.Context, taskId string) error
	// List teams
	// (GET /teams)
	ListTeams(ctx echo.Context, params ListTeamsParams) error
	// Get a team by ID
	// (GET /teams/{team_id})
	GetTeam(ctx echo.Context, teamId string) error
	// Generate a token for usage with authenticating via OAuth2 in subsequent API calls.
	// (POST /token)
	GenerateToken(ctx echo.Context) error
	// Transfers into containers
	// (POST /transfers)
	TransferIntoContainers(ctx echo.Context) error
	// List users
	// (GET /users)
	ListUsers(ctx echo.Context, params ListUsersParams) error
	// Create a user
	// (POST /users)
	CreateUser(ctx echo.Context) error
	// Get a user by ID
	// (GET /users/{user_id})
	GetUser(ctx echo.Context, userId string) error
	// Update a user by ID
	// (PATCH /users/{user_id})
	UpdateUser(ctx echo.Context, userId string) error
	// Last user activity
	// (GET /users/{user_id}/activity)
	GetUserActivity(ctx echo.Context, userId string) error
	// Bulk Create Users
	// (POST /users:bulk-create)
	BulkCreateUsers(ctx echo.Context) error
	// Bulk Update Users.
	// (POST /users:bulk-update)
	BulkUpdateUsers(ctx echo.Context) error
	// Create Benchling Warehouse credentials
	// (POST /warehouse-credentials)
	CreateWarehouseCredentials(ctx echo.Context) error
	// List workflow outputs
	// (GET /workflow-outputs)
	ListWorkflowOutputs(ctx echo.Context, params ListWorkflowOutputsParams) error
	// Create a new workflow output
	// (POST /workflow-outputs)
	CreateWorkflowOutput(ctx echo.Context) error
	// Get a workflow output
	// (GET /workflow-outputs/{workflow_output_id})
	GetWorkflowOutput(ctx echo.Context, workflowOutputId string) error
	// Update a workflow output
	// (PATCH /workflow-outputs/{workflow_output_id})
	UpdateWorkflowOutput(ctx echo.Context, workflowOutputId string) error
	// Archive one or more workflow outputs
	// (POST /workflow-outputs:archive)
	ArchiveWorkflowOutputs(ctx echo.Context) error
	// Bulk create new workflow outputs
	// (POST /workflow-outputs:bulk-create)
	BulkCreateWorkflowOutputs(ctx echo.Context) error
	// Bulk update workflow outputs
	// (POST /workflow-outputs:bulk-update)
	BulkUpdateWorkflowOutputs(ctx echo.Context) error
	// Unarchive one or more workflow outputs
	// (POST /workflow-outputs:unarchive)
	UnarchiveWorkflowOutputs(ctx echo.Context) error
	// List stage run input samples
	// (GET /workflow-stage-runs/{stage_run_id}/input-samples)
	ListStageRunInputSamples(ctx echo.Context, stageRunId string) error
	// List stage run output samples
	// (GET /workflow-stage-runs/{stage_run_id}/output-samples)
	ListStageRunOutputSamples(ctx echo.Context, stageRunId string) error
	// List stage run registered samples
	// (GET /workflow-stage-runs/{stage_run_id}/registered-samples)
	ListStageRunRegisteredSamples(ctx echo.Context, stageRunId string) error
	// List workflow stage runs
	// (GET /workflow-stages/{stage_id}/workflow-stage-runs)
	ListWorkflowStageRuns(ctx echo.Context, stageId string) error
	// List workflow task groups
	// (GET /workflow-task-groups)
	ListWorkflowTaskGroups(ctx echo.Context, params ListWorkflowTaskGroupsParams) error
	// Create a new workflow task group
	// (POST /workflow-task-groups)
	CreateWorkflowTaskGroup(ctx echo.Context) error
	// Get a workflow task group
	// (GET /workflow-task-groups/{workflow_task_group_id})
	GetWorkflowTaskGroup(ctx echo.Context, workflowTaskGroupId string) error
	// Update a workflow task group
	// (PATCH /workflow-task-groups/{workflow_task_group_id})
	UpdateWorkflowTaskGroup(ctx echo.Context, workflowTaskGroupId string) error
	// Archive one or more workflows
	// (POST /workflow-task-groups:archive)
	ArchiveWorkflowTaskGroups(ctx echo.Context) error
	// Unarchive one or more workflows
	// (POST /workflow-task-groups:unarchive)
	UnarchiveWorkflowTaskGroups(ctx echo.Context) error
	// List workflow task schemas
	// (GET /workflow-task-schemas)
	ListWorkflowTaskSchemas(ctx echo.Context, params ListWorkflowTaskSchemasParams) error
	// Get a workflow task schema
	// (GET /workflow-task-schemas/{schema_id})
	GetWorkflowTaskSchema(ctx echo.Context, schemaId string) error
	// List workflow tasks
	// (GET /workflow-tasks)
	ListWorkflowTasks(ctx echo.Context, params ListWorkflowTasksParams) error
	// Create a new workflow task
	// (POST /workflow-tasks)
	CreateWorkflowTask(ctx echo.Context) error
	// Get a workflow task
	// (GET /workflow-tasks/{workflow_task_id})
	GetWorkflowTask(ctx echo.Context, workflowTaskId string) error
	// Update a workflow task
	// (PATCH /workflow-tasks/{workflow_task_id})
	UpdateWorkflowTask(ctx echo.Context, workflowTaskId string) error
	// Creates a new workflow task with the same fields and assignee as the provided task and creates a relationship between the two tasks
	// (POST /workflow-tasks/{workflow_task_id}:copy)
	CopyWorkflowTask(ctx echo.Context, workflowTaskId string) error
	// Archive one or more workflow tasks
	// (POST /workflow-tasks:archive)
	ArchiveWorkflowTasks(ctx echo.Context) error
	// Bulk creates new workflow tasks where each new task has the same fields and assignee as one of the provided tasks and creates a relationship between the provided task and its copy
	// (POST /workflow-tasks:bulk-copy)
	BulkCopyWorkflowTasks(ctx echo.Context) error
	// Create one or more workflow tasks
	// (POST /workflow-tasks:bulk-create)
	BulkCreateWorkflowTasks(ctx echo.Context) error
	// Update one or more workflow task
	// (POST /workflow-tasks:bulk-update)
	BulkUpdateWorkflowTasks(ctx echo.Context) error
	// Unarchive one or more workflow tasks
	// (POST /workflow-tasks:unarchive)
	UnarchiveWorkflowTasks(ctx echo.Context) error
	// List workflows
	// (GET /workflows)
	ListWorkflows(ctx echo.Context) error
	// Update workflow
	// (PATCH /workflows/{workflow_id})
	UpdateWorkflowMetadata(ctx echo.Context, workflowId string) error
	// List workflow stages
	// (GET /workflows/{workflow_id}/workflow-stages)
	ListWorkflowStages(ctx echo.Context, workflowId string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// ListAASequences converts echo context to params.
func (w *ServerInterfaceWrapper) ListAASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAASequencesParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "aminoAcids" -------------

	err = runtime.BindQueryParameter("form", true, false, "aminoAcids", ctx.QueryParams(), &params.AminoAcids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter aminoAcids: %s", err))
	}

	// ------------- Optional query parameter "folderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "folderId", ctx.QueryParams(), &params.FolderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter folderId: %s", err))
	}

	// ------------- Optional query parameter "mentionedIn" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentionedIn", ctx.QueryParams(), &params.MentionedIn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentionedIn: %s", err))
	}

	// ------------- Optional query parameter "projectId" -------------

	err = runtime.BindQueryParameter("form", true, false, "projectId", ctx.QueryParams(), &params.ProjectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Optional query parameter "registryId" -------------

	err = runtime.BindQueryParameter("form", true, false, "registryId", ctx.QueryParams(), &params.RegistryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registryId: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "schemaFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaFields", ctx.QueryParams(), &params.SchemaFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaFields: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "mentions" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentions", ctx.QueryParams(), &params.Mentions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentions: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "entityRegistryIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityRegistryIds.anyOf", ctx.QueryParams(), &params.EntityRegistryIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityRegistryIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// ------------- Optional query parameter "authorIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "authorIds.anyOf", ctx.QueryParams(), &params.AuthorIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authorIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAASequences(ctx, params)
	return err
}

// CreateAASequence converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAASequence(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAASequence(ctx)
	return err
}

// GetAASequence converts echo context to params.
func (w *ServerInterfaceWrapper) GetAASequence(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "aa_sequence_id" -------------
	var aaSequenceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "aa_sequence_id", runtime.ParamLocationPath, ctx.Param("aa_sequence_id"), &aaSequenceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter aa_sequence_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAASequenceParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAASequence(ctx, aaSequenceId, params)
	return err
}

// UpdateAASequence converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAASequence(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "aa_sequence_id" -------------
	var aaSequenceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "aa_sequence_id", runtime.ParamLocationPath, ctx.Param("aa_sequence_id"), &aaSequenceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter aa_sequence_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateAASequence(ctx, aaSequenceId)
	return err
}

// ArchiveAASequences converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveAASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveAASequences(ctx)
	return err
}

// AutoAnnotateAaSequences converts echo context to params.
func (w *ServerInterfaceWrapper) AutoAnnotateAaSequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AutoAnnotateAaSequences(ctx)
	return err
}

// BulkCreateAASequences converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateAASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateAASequences(ctx)
	return err
}

// BulkGetAASequences converts echo context to params.
func (w *ServerInterfaceWrapper) BulkGetAASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BulkGetAASequencesParams
	// ------------- Required query parameter "aaSequenceIds" -------------

	err = runtime.BindQueryParameter("form", true, true, "aaSequenceIds", ctx.QueryParams(), &params.AaSequenceIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter aaSequenceIds: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkGetAASequences(ctx, params)
	return err
}

// BulkUpdateAASequences converts echo context to params.
func (w *ServerInterfaceWrapper) BulkUpdateAASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkUpdateAASequences(ctx)
	return err
}

// UnarchiveAASequences converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveAASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveAASequences(ctx)
	return err
}

// CreateAppCanvas converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAppCanvas(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAppCanvas(ctx)
	return err
}

// GetAppCanvas converts echo context to params.
func (w *ServerInterfaceWrapper) GetAppCanvas(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "canvas_id" -------------
	var canvasId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "canvas_id", runtime.ParamLocationPath, ctx.Param("canvas_id"), &canvasId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter canvas_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAppCanvasParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAppCanvas(ctx, canvasId, params)
	return err
}

// UpdateAppCanvas converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAppCanvas(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "canvas_id" -------------
	var canvasId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "canvas_id", runtime.ParamLocationPath, ctx.Param("canvas_id"), &canvasId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter canvas_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateAppCanvas(ctx, canvasId)
	return err
}

// ArchiveAppCanvases converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveAppCanvases(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveAppCanvases(ctx)
	return err
}

// UnarchiveAppCanvases converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveAppCanvases(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveAppCanvases(ctx)
	return err
}

// ListAppConfigurationItems converts echo context to params.
func (w *ServerInterfaceWrapper) ListAppConfigurationItems(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAppConfigurationItemsParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "appId" -------------

	err = runtime.BindQueryParameter("form", true, false, "appId", ctx.QueryParams(), &params.AppId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter appId: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAppConfigurationItems(ctx, params)
	return err
}

// CreateAppConfigurationItem converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAppConfigurationItem(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAppConfigurationItem(ctx)
	return err
}

// GetAppConfigurationItemById converts echo context to params.
func (w *ServerInterfaceWrapper) GetAppConfigurationItemById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "item_id" -------------
	var itemId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "item_id", runtime.ParamLocationPath, ctx.Param("item_id"), &itemId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter item_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAppConfigurationItemById(ctx, itemId)
	return err
}

// UpdateAppConfigurationItem converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAppConfigurationItem(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "item_id" -------------
	var itemId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "item_id", runtime.ParamLocationPath, ctx.Param("item_id"), &itemId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter item_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateAppConfigurationItem(ctx, itemId)
	return err
}

// BulkCreateAppConfigurationItems converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateAppConfigurationItems(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateAppConfigurationItems(ctx)
	return err
}

// BulkUpdateAppConfigurationItems converts echo context to params.
func (w *ServerInterfaceWrapper) BulkUpdateAppConfigurationItems(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkUpdateAppConfigurationItems(ctx)
	return err
}

// CreateAppSession converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAppSession(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAppSession(ctx)
	return err
}

// GetAppSessionById converts echo context to params.
func (w *ServerInterfaceWrapper) GetAppSessionById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAppSessionByIdParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAppSessionById(ctx, id, params)
	return err
}

// UpdateAppSession converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAppSession(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateAppSession(ctx, id)
	return err
}

// ListBenchlingApps converts echo context to params.
func (w *ServerInterfaceWrapper) ListBenchlingApps(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBenchlingAppsParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// ------------- Optional query parameter "memberOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "memberOf", ctx.QueryParams(), &params.MemberOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter memberOf: %s", err))
	}

	// ------------- Optional query parameter "adminOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "adminOf", ctx.QueryParams(), &params.AdminOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter adminOf: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListBenchlingApps(ctx, params)
	return err
}

// CreateBenchlingApp converts echo context to params.
func (w *ServerInterfaceWrapper) CreateBenchlingApp(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateBenchlingApp(ctx)
	return err
}

// GetBenchlingAppByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetBenchlingAppByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "app_id" -------------
	var appId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "app_id", runtime.ParamLocationPath, ctx.Param("app_id"), &appId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter app_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBenchlingAppByID(ctx, appId)
	return err
}

// PatchBenchlingApp converts echo context to params.
func (w *ServerInterfaceWrapper) PatchBenchlingApp(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "app_id" -------------
	var appId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "app_id", runtime.ParamLocationPath, ctx.Param("app_id"), &appId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter app_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchBenchlingApp(ctx, appId)
	return err
}

// ArchiveBenchlingApps converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveBenchlingApps(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveBenchlingApps(ctx)
	return err
}

// UnarchiveBenchlingApps converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveBenchlingApps(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveBenchlingApps(ctx)
	return err
}

// ListAssayResultSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) ListAssayResultSchemas(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAssayResultSchemasParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAssayResultSchemas(ctx, params)
	return err
}

// GetResultSchema converts echo context to params.
func (w *ServerInterfaceWrapper) GetResultSchema(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "schema_id" -------------
	var schemaId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, ctx.Param("schema_id"), &schemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetResultSchema(ctx, schemaId)
	return err
}

// ListAssayResults converts echo context to params.
func (w *ServerInterfaceWrapper) ListAssayResults(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAssayResultsParams
	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "createdAt.lt" -------------

	err = runtime.BindQueryParameter("form", true, false, "createdAt.lt", ctx.QueryParams(), &params.CreatedAtLt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter createdAt.lt: %s", err))
	}

	// ------------- Optional query parameter "createdAt.gt" -------------

	err = runtime.BindQueryParameter("form", true, false, "createdAt.gt", ctx.QueryParams(), &params.CreatedAtGt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter createdAt.gt: %s", err))
	}

	// ------------- Optional query parameter "createdAt.lte" -------------

	err = runtime.BindQueryParameter("form", true, false, "createdAt.lte", ctx.QueryParams(), &params.CreatedAtLte)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter createdAt.lte: %s", err))
	}

	// ------------- Optional query parameter "createdAt.gte" -------------

	err = runtime.BindQueryParameter("form", true, false, "createdAt.gte", ctx.QueryParams(), &params.CreatedAtGte)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter createdAt.gte: %s", err))
	}

	// ------------- Optional query parameter "minCreatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "minCreatedTime", ctx.QueryParams(), &params.MinCreatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minCreatedTime: %s", err))
	}

	// ------------- Optional query parameter "maxCreatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxCreatedTime", ctx.QueryParams(), &params.MaxCreatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxCreatedTime: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "entityIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityIds", ctx.QueryParams(), &params.EntityIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityIds: %s", err))
	}

	// ------------- Optional query parameter "storageIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "storageIds", ctx.QueryParams(), &params.StorageIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter storageIds: %s", err))
	}

	// ------------- Optional query parameter "assayRunIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "assayRunIds", ctx.QueryParams(), &params.AssayRunIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assayRunIds: %s", err))
	}

	// ------------- Optional query parameter "automationOutputProcessorId" -------------

	err = runtime.BindQueryParameter("form", true, false, "automationOutputProcessorId", ctx.QueryParams(), &params.AutomationOutputProcessorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter automationOutputProcessorId: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt.lt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt.lt", ctx.QueryParams(), &params.ModifiedAtLt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt.lt: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt.gt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt.gt", ctx.QueryParams(), &params.ModifiedAtGt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt.gt: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt.lte" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt.lte", ctx.QueryParams(), &params.ModifiedAtLte)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt.lte: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt.gte" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt.gte", ctx.QueryParams(), &params.ModifiedAtGte)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt.gte: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAssayResults(ctx, params)
	return err
}

// CreateAssayResults converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAssayResults(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAssayResults(ctx)
	return err
}

// GetAssayResult converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssayResult(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assay_result_id" -------------
	var assayResultId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "assay_result_id", runtime.ParamLocationPath, ctx.Param("assay_result_id"), &assayResultId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assay_result_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssayResult(ctx, assayResultId)
	return err
}

// ArchiveAssayResults converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveAssayResults(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveAssayResults(ctx)
	return err
}

// BulkCreateAssayResults converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateAssayResults(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateAssayResults(ctx)
	return err
}

// BulkGetAssayResults converts echo context to params.
func (w *ServerInterfaceWrapper) BulkGetAssayResults(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BulkGetAssayResultsParams
	// ------------- Required query parameter "assayResultIds" -------------

	err = runtime.BindQueryParameter("form", true, true, "assayResultIds", ctx.QueryParams(), &params.AssayResultIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assayResultIds: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkGetAssayResults(ctx, params)
	return err
}

// UnarchiveAssayResults converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveAssayResults(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveAssayResults(ctx)
	return err
}

// ListAssayRunSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) ListAssayRunSchemas(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAssayRunSchemasParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAssayRunSchemas(ctx, params)
	return err
}

// GetRunSchema converts echo context to params.
func (w *ServerInterfaceWrapper) GetRunSchema(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "schema_id" -------------
	var schemaId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, ctx.Param("schema_id"), &schemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRunSchema(ctx, schemaId)
	return err
}

// ListAssayRuns converts echo context to params.
func (w *ServerInterfaceWrapper) ListAssayRuns(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAssayRunsParams
	// ------------- Required query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, true, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "minCreatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "minCreatedTime", ctx.QueryParams(), &params.MinCreatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minCreatedTime: %s", err))
	}

	// ------------- Optional query parameter "maxCreatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxCreatedTime", ctx.QueryParams(), &params.MaxCreatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxCreatedTime: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAssayRuns(ctx, params)
	return err
}

// CreateAssayRuns converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAssayRuns(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAssayRuns(ctx)
	return err
}

// GetAssayRun converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssayRun(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assay_run_id" -------------
	var assayRunId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "assay_run_id", runtime.ParamLocationPath, ctx.Param("assay_run_id"), &assayRunId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assay_run_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssayRun(ctx, assayRunId)
	return err
}

// UpdateAssayRun converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAssayRun(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assay_run_id" -------------
	var assayRunId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "assay_run_id", runtime.ParamLocationPath, ctx.Param("assay_run_id"), &assayRunId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assay_run_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateAssayRun(ctx, assayRunId)
	return err
}

// ListAutomationInputGenerators converts echo context to params.
func (w *ServerInterfaceWrapper) ListAutomationInputGenerators(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assay_run_id" -------------
	var assayRunId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "assay_run_id", runtime.ParamLocationPath, ctx.Param("assay_run_id"), &assayRunId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assay_run_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAutomationInputGeneratorsParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAutomationInputGenerators(ctx, assayRunId, params)
	return err
}

// ListAutomationOutputProcessorsDeprecated converts echo context to params.
func (w *ServerInterfaceWrapper) ListAutomationOutputProcessorsDeprecated(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "assay_run_id" -------------
	var assayRunId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "assay_run_id", runtime.ParamLocationPath, ctx.Param("assay_run_id"), &assayRunId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assay_run_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAutomationOutputProcessorsDeprecatedParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAutomationOutputProcessorsDeprecated(ctx, assayRunId, params)
	return err
}

// ArchiveAssayRuns converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveAssayRuns(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveAssayRuns(ctx)
	return err
}

// BulkGetAssayRuns converts echo context to params.
func (w *ServerInterfaceWrapper) BulkGetAssayRuns(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BulkGetAssayRunsParams
	// ------------- Required query parameter "assayRunIds" -------------

	err = runtime.BindQueryParameter("form", true, true, "assayRunIds", ctx.QueryParams(), &params.AssayRunIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assayRunIds: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkGetAssayRuns(ctx, params)
	return err
}

// UnarchiveAssayRuns converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveAssayRuns(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveAssayRuns(ctx)
	return err
}

// GetLabAutomationTransform converts echo context to params.
func (w *ServerInterfaceWrapper) GetLabAutomationTransform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transform_id" -------------
	var transformId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "transform_id", runtime.ParamLocationPath, ctx.Param("transform_id"), &transformId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transform_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLabAutomationTransform(ctx, transformId)
	return err
}

// UpdateLabAutomationTransform converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateLabAutomationTransform(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transform_id" -------------
	var transformId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "transform_id", runtime.ParamLocationPath, ctx.Param("transform_id"), &transformId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transform_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateLabAutomationTransform(ctx, transformId)
	return err
}

// GetAutomationInputGenerator converts echo context to params.
func (w *ServerInterfaceWrapper) GetAutomationInputGenerator(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "input_generator_id" -------------
	var inputGeneratorId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "input_generator_id", runtime.ParamLocationPath, ctx.Param("input_generator_id"), &inputGeneratorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter input_generator_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAutomationInputGenerator(ctx, inputGeneratorId)
	return err
}

// UpdateAutomationInputGenerator converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAutomationInputGenerator(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "input_generator_id" -------------
	var inputGeneratorId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "input_generator_id", runtime.ParamLocationPath, ctx.Param("input_generator_id"), &inputGeneratorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter input_generator_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateAutomationInputGenerator(ctx, inputGeneratorId)
	return err
}

// GenerateInputWithAutomationInputGenerator converts echo context to params.
func (w *ServerInterfaceWrapper) GenerateInputWithAutomationInputGenerator(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "input_generator_id" -------------
	var inputGeneratorId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "input_generator_id", runtime.ParamLocationPath, ctx.Param("input_generator_id"), &inputGeneratorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter input_generator_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GenerateInputWithAutomationInputGenerator(ctx, inputGeneratorId)
	return err
}

// ListAutomationOutputProcessors converts echo context to params.
func (w *ServerInterfaceWrapper) ListAutomationOutputProcessors(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListAutomationOutputProcessorsParams
	// ------------- Optional query parameter "assayRunId" -------------

	err = runtime.BindQueryParameter("form", true, false, "assayRunId", ctx.QueryParams(), &params.AssayRunId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assayRunId: %s", err))
	}

	// ------------- Optional query parameter "automationFileConfigName" -------------

	err = runtime.BindQueryParameter("form", true, false, "automationFileConfigName", ctx.QueryParams(), &params.AutomationFileConfigName)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter automationFileConfigName: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListAutomationOutputProcessors(ctx, params)
	return err
}

// CreateAutomationOutputProcessor converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAutomationOutputProcessor(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAutomationOutputProcessor(ctx)
	return err
}

// GetAutomationOutputProcessor converts echo context to params.
func (w *ServerInterfaceWrapper) GetAutomationOutputProcessor(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "output_processor_id" -------------
	var outputProcessorId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "output_processor_id", runtime.ParamLocationPath, ctx.Param("output_processor_id"), &outputProcessorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter output_processor_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAutomationOutputProcessor(ctx, outputProcessorId)
	return err
}

// UpdateAutomationOutputProcessor converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAutomationOutputProcessor(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "output_processor_id" -------------
	var outputProcessorId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "output_processor_id", runtime.ParamLocationPath, ctx.Param("output_processor_id"), &outputProcessorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter output_processor_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateAutomationOutputProcessor(ctx, outputProcessorId)
	return err
}

// ProcessOutputWithAutomationOutputProcessor converts echo context to params.
func (w *ServerInterfaceWrapper) ProcessOutputWithAutomationOutputProcessor(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "output_processor_id" -------------
	var outputProcessorId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "output_processor_id", runtime.ParamLocationPath, ctx.Param("output_processor_id"), &outputProcessorId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter output_processor_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ProcessOutputWithAutomationOutputProcessor(ctx, outputProcessorId)
	return err
}

// ArchiveAutomationOutputProcessors converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveAutomationOutputProcessors(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveAutomationOutputProcessors(ctx)
	return err
}

// UnarchiveAutomationOutputProcessors converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveAutomationOutputProcessors(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveAutomationOutputProcessors(ctx)
	return err
}

// ListBatchSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) ListBatchSchemas(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBatchSchemasParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListBatchSchemas(ctx, params)
	return err
}

// GetBatchSchema converts echo context to params.
func (w *ServerInterfaceWrapper) GetBatchSchema(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "schema_id" -------------
	var schemaId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, ctx.Param("schema_id"), &schemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBatchSchema(ctx, schemaId)
	return err
}

// ListBatches converts echo context to params.
func (w *ServerInterfaceWrapper) ListBatches(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBatchesParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "schemaFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaFields", ctx.QueryParams(), &params.SchemaFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaFields: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListBatches(ctx, params)
	return err
}

// CreateBatch converts echo context to params.
func (w *ServerInterfaceWrapper) CreateBatch(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateBatch(ctx)
	return err
}

// GetBatch converts echo context to params.
func (w *ServerInterfaceWrapper) GetBatch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "batch_id" -------------
	var batchId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "batch_id", runtime.ParamLocationPath, ctx.Param("batch_id"), &batchId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batch_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBatch(ctx, batchId)
	return err
}

// UpdateBatch converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateBatch(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "batch_id" -------------
	var batchId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "batch_id", runtime.ParamLocationPath, ctx.Param("batch_id"), &batchId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batch_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateBatch(ctx, batchId)
	return err
}

// ArchiveBatches converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveBatches(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveBatches(ctx)
	return err
}

// BulkGetBatches converts echo context to params.
func (w *ServerInterfaceWrapper) BulkGetBatches(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BulkGetBatchesParams
	// ------------- Optional query parameter "batchIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "batchIds", ctx.QueryParams(), &params.BatchIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batchIds: %s", err))
	}

	// ------------- Optional query parameter "batchNames" -------------

	err = runtime.BindQueryParameter("form", true, false, "batchNames", ctx.QueryParams(), &params.BatchNames)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter batchNames: %s", err))
	}

	// ------------- Optional query parameter "registryId" -------------

	err = runtime.BindQueryParameter("form", true, false, "registryId", ctx.QueryParams(), &params.RegistryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registryId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkGetBatches(ctx, params)
	return err
}

// UnarchiveBatches converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveBatches(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveBatches(ctx)
	return err
}

// CreateBlob converts echo context to params.
func (w *ServerInterfaceWrapper) CreateBlob(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateBlob(ctx)
	return err
}

// GetBlob converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "blob_id" -------------
	var blobId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "blob_id", runtime.ParamLocationPath, ctx.Param("blob_id"), &blobId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter blob_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlobParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlob(ctx, blobId, params)
	return err
}

// GetBlobFile converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlobFile(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "blob_id" -------------
	var blobId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "blob_id", runtime.ParamLocationPath, ctx.Param("blob_id"), &blobId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter blob_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlobFile(ctx, blobId)
	return err
}

// GetBlobUrl converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlobUrl(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "blob_id" -------------
	var blobId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "blob_id", runtime.ParamLocationPath, ctx.Param("blob_id"), &blobId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter blob_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlobUrl(ctx, blobId)
	return err
}

// CreateBlobPart converts echo context to params.
func (w *ServerInterfaceWrapper) CreateBlobPart(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "blob_id" -------------
	var blobId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "blob_id", runtime.ParamLocationPath, ctx.Param("blob_id"), &blobId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter blob_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateBlobPart(ctx, blobId)
	return err
}

// AbortMultipartBlob converts echo context to params.
func (w *ServerInterfaceWrapper) AbortMultipartBlob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "blob_id" -------------
	var blobId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "blob_id", runtime.ParamLocationPath, ctx.Param("blob_id"), &blobId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter blob_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AbortMultipartBlob(ctx, blobId)
	return err
}

// CompleteMultipartBlob converts echo context to params.
func (w *ServerInterfaceWrapper) CompleteMultipartBlob(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "blob_id" -------------
	var blobId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "blob_id", runtime.ParamLocationPath, ctx.Param("blob_id"), &blobId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter blob_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CompleteMultipartBlob(ctx, blobId)
	return err
}

// BulkGetBlobs converts echo context to params.
func (w *ServerInterfaceWrapper) BulkGetBlobs(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BulkGetBlobsParams
	// ------------- Optional query parameter "blobIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "blobIds", ctx.QueryParams(), &params.BlobIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter blobIds: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkGetBlobs(ctx, params)
	return err
}

// CreateMultipartBlob converts echo context to params.
func (w *ServerInterfaceWrapper) CreateMultipartBlob(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateMultipartBlob(ctx)
	return err
}

// ListBoxSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) ListBoxSchemas(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBoxSchemasParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListBoxSchemas(ctx, params)
	return err
}

// GetBoxSchema converts echo context to params.
func (w *ServerInterfaceWrapper) GetBoxSchema(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "schema_id" -------------
	var schemaId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, ctx.Param("schema_id"), &schemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBoxSchema(ctx, schemaId)
	return err
}

// ListBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) ListBoxes(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBoxesParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "schemaFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaFields", ctx.QueryParams(), &params.SchemaFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaFields: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "emptyPositions" -------------

	err = runtime.BindQueryParameter("form", true, false, "emptyPositions", ctx.QueryParams(), &params.EmptyPositions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter emptyPositions: %s", err))
	}

	// ------------- Optional query parameter "emptyPositions.gte" -------------

	err = runtime.BindQueryParameter("form", true, false, "emptyPositions.gte", ctx.QueryParams(), &params.EmptyPositionsGte)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter emptyPositions.gte: %s", err))
	}

	// ------------- Optional query parameter "emptyPositions.gt" -------------

	err = runtime.BindQueryParameter("form", true, false, "emptyPositions.gt", ctx.QueryParams(), &params.EmptyPositionsGt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter emptyPositions.gt: %s", err))
	}

	// ------------- Optional query parameter "emptyPositions.lte" -------------

	err = runtime.BindQueryParameter("form", true, false, "emptyPositions.lte", ctx.QueryParams(), &params.EmptyPositionsLte)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter emptyPositions.lte: %s", err))
	}

	// ------------- Optional query parameter "emptyPositions.lt" -------------

	err = runtime.BindQueryParameter("form", true, false, "emptyPositions.lt", ctx.QueryParams(), &params.EmptyPositionsLt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter emptyPositions.lt: %s", err))
	}

	// ------------- Optional query parameter "emptyContainers" -------------

	err = runtime.BindQueryParameter("form", true, false, "emptyContainers", ctx.QueryParams(), &params.EmptyContainers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter emptyContainers: %s", err))
	}

	// ------------- Optional query parameter "emptyContainers.gte" -------------

	err = runtime.BindQueryParameter("form", true, false, "emptyContainers.gte", ctx.QueryParams(), &params.EmptyContainersGte)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter emptyContainers.gte: %s", err))
	}

	// ------------- Optional query parameter "emptyContainers.gt" -------------

	err = runtime.BindQueryParameter("form", true, false, "emptyContainers.gt", ctx.QueryParams(), &params.EmptyContainersGt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter emptyContainers.gt: %s", err))
	}

	// ------------- Optional query parameter "emptyContainers.lte" -------------

	err = runtime.BindQueryParameter("form", true, false, "emptyContainers.lte", ctx.QueryParams(), &params.EmptyContainersLte)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter emptyContainers.lte: %s", err))
	}

	// ------------- Optional query parameter "emptyContainers.lt" -------------

	err = runtime.BindQueryParameter("form", true, false, "emptyContainers.lt", ctx.QueryParams(), &params.EmptyContainersLt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter emptyContainers.lt: %s", err))
	}

	// ------------- Optional query parameter "ancestorStorageId" -------------

	err = runtime.BindQueryParameter("form", true, false, "ancestorStorageId", ctx.QueryParams(), &params.AncestorStorageId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ancestorStorageId: %s", err))
	}

	// ------------- Optional query parameter "storageContentsId" -------------

	err = runtime.BindQueryParameter("form", true, false, "storageContentsId", ctx.QueryParams(), &params.StorageContentsId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter storageContentsId: %s", err))
	}

	// ------------- Optional query parameter "storageContentsIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "storageContentsIds", ctx.QueryParams(), &params.StorageContentsIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter storageContentsIds: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "barcodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "barcodes", ctx.QueryParams(), &params.Barcodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter barcodes: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListBoxes(ctx, params)
	return err
}

// CreateBox converts echo context to params.
func (w *ServerInterfaceWrapper) CreateBox(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateBox(ctx)
	return err
}

// GetBox converts echo context to params.
func (w *ServerInterfaceWrapper) GetBox(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "box_id" -------------
	var boxId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "box_id", runtime.ParamLocationPath, ctx.Param("box_id"), &boxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter box_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBox(ctx, boxId)
	return err
}

// UpdateBox converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateBox(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "box_id" -------------
	var boxId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "box_id", runtime.ParamLocationPath, ctx.Param("box_id"), &boxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter box_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateBox(ctx, boxId)
	return err
}

// ListBoxContents converts echo context to params.
func (w *ServerInterfaceWrapper) ListBoxContents(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "box_id" -------------
	var boxId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "box_id", runtime.ParamLocationPath, ctx.Param("box_id"), &boxId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter box_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListBoxContentsParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListBoxContents(ctx, boxId, params)
	return err
}

// ArchiveBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveBoxes(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveBoxes(ctx)
	return err
}

// BulkGetBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) BulkGetBoxes(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BulkGetBoxesParams
	// ------------- Optional query parameter "boxIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "boxIds", ctx.QueryParams(), &params.BoxIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter boxIds: %s", err))
	}

	// ------------- Optional query parameter "barcodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "barcodes", ctx.QueryParams(), &params.Barcodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter barcodes: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkGetBoxes(ctx, params)
	return err
}

// UnarchiveBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveBoxes(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveBoxes(ctx)
	return err
}

// ListContainerSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) ListContainerSchemas(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListContainerSchemasParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListContainerSchemas(ctx, params)
	return err
}

// GetContainerSchema converts echo context to params.
func (w *ServerInterfaceWrapper) GetContainerSchema(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "schema_id" -------------
	var schemaId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, ctx.Param("schema_id"), &schemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContainerSchema(ctx, schemaId)
	return err
}

// ListContainers converts echo context to params.
func (w *ServerInterfaceWrapper) ListContainers(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListContainersParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "schemaFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaFields", ctx.QueryParams(), &params.SchemaFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaFields: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "ancestorStorageId" -------------

	err = runtime.BindQueryParameter("form", true, false, "ancestorStorageId", ctx.QueryParams(), &params.AncestorStorageId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ancestorStorageId: %s", err))
	}

	// ------------- Optional query parameter "storageContentsId" -------------

	err = runtime.BindQueryParameter("form", true, false, "storageContentsId", ctx.QueryParams(), &params.StorageContentsId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter storageContentsId: %s", err))
	}

	// ------------- Optional query parameter "storageContentsIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "storageContentsIds", ctx.QueryParams(), &params.StorageContentsIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter storageContentsIds: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "checkoutStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "checkoutStatus", ctx.QueryParams(), &params.CheckoutStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter checkoutStatus: %s", err))
	}

	// ------------- Optional query parameter "checkoutAssigneeIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "checkoutAssigneeIds.anyOf", ctx.QueryParams(), &params.CheckoutAssigneeIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter checkoutAssigneeIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "restrictionStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "restrictionStatus", ctx.QueryParams(), &params.RestrictionStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter restrictionStatus: %s", err))
	}

	// ------------- Optional query parameter "sampleOwnerIds.allOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "sampleOwnerIds.allOf", ctx.QueryParams(), &params.SampleOwnerIdsAllOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sampleOwnerIds.allOf: %s", err))
	}

	// ------------- Optional query parameter "sampleOwnerIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "sampleOwnerIds.anyOf", ctx.QueryParams(), &params.SampleOwnerIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sampleOwnerIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "sampleOwnerIds.noneOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "sampleOwnerIds.noneOf", ctx.QueryParams(), &params.SampleOwnerIdsNoneOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sampleOwnerIds.noneOf: %s", err))
	}

	// ------------- Optional query parameter "restrictedSamplePartyIds.allOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "restrictedSamplePartyIds.allOf", ctx.QueryParams(), &params.RestrictedSamplePartyIdsAllOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter restrictedSamplePartyIds.allOf: %s", err))
	}

	// ------------- Optional query parameter "restrictedSamplePartyIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "restrictedSamplePartyIds.anyOf", ctx.QueryParams(), &params.RestrictedSamplePartyIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter restrictedSamplePartyIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "restrictedSamplePartyIds.noneOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "restrictedSamplePartyIds.noneOf", ctx.QueryParams(), &params.RestrictedSamplePartyIdsNoneOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter restrictedSamplePartyIds.noneOf: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "barcodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "barcodes", ctx.QueryParams(), &params.Barcodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter barcodes: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListContainers(ctx, params)
	return err
}

// CreateContainer converts echo context to params.
func (w *ServerInterfaceWrapper) CreateContainer(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateContainer(ctx)
	return err
}

// GetContainer converts echo context to params.
func (w *ServerInterfaceWrapper) GetContainer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "container_id" -------------
	var containerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "container_id", runtime.ParamLocationPath, ctx.Param("container_id"), &containerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter container_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetContainerParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContainer(ctx, containerId, params)
	return err
}

// UpdateContainer converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateContainer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "container_id" -------------
	var containerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "container_id", runtime.ParamLocationPath, ctx.Param("container_id"), &containerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter container_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateContainer(ctx, containerId)
	return err
}

// ListContainerContents converts echo context to params.
func (w *ServerInterfaceWrapper) ListContainerContents(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "container_id" -------------
	var containerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "container_id", runtime.ParamLocationPath, ctx.Param("container_id"), &containerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter container_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListContainerContents(ctx, containerId)
	return err
}

// DeleteContainerContent converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteContainerContent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "container_id" -------------
	var containerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "container_id", runtime.ParamLocationPath, ctx.Param("container_id"), &containerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter container_id: %s", err))
	}

	// ------------- Path parameter "containable_id" -------------
	var containableId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "containable_id", runtime.ParamLocationPath, ctx.Param("containable_id"), &containableId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containable_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteContainerContent(ctx, containerId, containableId)
	return err
}

// GetContainerContent converts echo context to params.
func (w *ServerInterfaceWrapper) GetContainerContent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "container_id" -------------
	var containerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "container_id", runtime.ParamLocationPath, ctx.Param("container_id"), &containerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter container_id: %s", err))
	}

	// ------------- Path parameter "containable_id" -------------
	var containableId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "containable_id", runtime.ParamLocationPath, ctx.Param("containable_id"), &containableId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containable_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetContainerContent(ctx, containerId, containableId)
	return err
}

// UpdateContainerContent converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateContainerContent(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "container_id" -------------
	var containerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "container_id", runtime.ParamLocationPath, ctx.Param("container_id"), &containerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter container_id: %s", err))
	}

	// ------------- Path parameter "containable_id" -------------
	var containableId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "containable_id", runtime.ParamLocationPath, ctx.Param("containable_id"), &containableId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containable_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateContainerContent(ctx, containerId, containableId)
	return err
}

// TransferIntoContainer converts echo context to params.
func (w *ServerInterfaceWrapper) TransferIntoContainer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "destination_container_id" -------------
	var destinationContainerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "destination_container_id", runtime.ParamLocationPath, ctx.Param("destination_container_id"), &destinationContainerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter destination_container_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransferIntoContainer(ctx, destinationContainerId)
	return err
}

// ArchiveContainers converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveContainers(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveContainers(ctx)
	return err
}

// BulkCreateContainers converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateContainers(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateContainers(ctx)
	return err
}

// BulkGetContainers converts echo context to params.
func (w *ServerInterfaceWrapper) BulkGetContainers(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BulkGetContainersParams
	// ------------- Optional query parameter "containerIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "containerIds", ctx.QueryParams(), &params.ContainerIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter containerIds: %s", err))
	}

	// ------------- Optional query parameter "barcodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "barcodes", ctx.QueryParams(), &params.Barcodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter barcodes: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkGetContainers(ctx, params)
	return err
}

// BulkUpdateContainers converts echo context to params.
func (w *ServerInterfaceWrapper) BulkUpdateContainers(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkUpdateContainers(ctx)
	return err
}

// CheckinContainers converts echo context to params.
func (w *ServerInterfaceWrapper) CheckinContainers(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CheckinContainers(ctx)
	return err
}

// CheckoutContainers converts echo context to params.
func (w *ServerInterfaceWrapper) CheckoutContainers(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CheckoutContainers(ctx)
	return err
}

// PrintLabels converts echo context to params.
func (w *ServerInterfaceWrapper) PrintLabels(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PrintLabels(ctx)
	return err
}

// ReserveContainers converts echo context to params.
func (w *ServerInterfaceWrapper) ReserveContainers(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ReserveContainers(ctx)
	return err
}

// UnarchiveContainers converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveContainers(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveContainers(ctx)
	return err
}

// ListCustomEntities converts echo context to params.
func (w *ServerInterfaceWrapper) ListCustomEntities(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCustomEntitiesParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "folderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "folderId", ctx.QueryParams(), &params.FolderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter folderId: %s", err))
	}

	// ------------- Optional query parameter "mentionedIn" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentionedIn", ctx.QueryParams(), &params.MentionedIn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentionedIn: %s", err))
	}

	// ------------- Optional query parameter "projectId" -------------

	err = runtime.BindQueryParameter("form", true, false, "projectId", ctx.QueryParams(), &params.ProjectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Optional query parameter "registryId" -------------

	err = runtime.BindQueryParameter("form", true, false, "registryId", ctx.QueryParams(), &params.RegistryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registryId: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "schemaFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaFields", ctx.QueryParams(), &params.SchemaFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaFields: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "mentions" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentions", ctx.QueryParams(), &params.Mentions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentions: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "entityRegistryIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityRegistryIds.anyOf", ctx.QueryParams(), &params.EntityRegistryIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityRegistryIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// ------------- Optional query parameter "authorIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "authorIds.anyOf", ctx.QueryParams(), &params.AuthorIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authorIds.anyOf: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListCustomEntities(ctx, params)
	return err
}

// CreateCustomEntity converts echo context to params.
func (w *ServerInterfaceWrapper) CreateCustomEntity(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateCustomEntity(ctx)
	return err
}

// GetCustomEntity converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "custom_entity_id" -------------
	var customEntityId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "custom_entity_id", runtime.ParamLocationPath, ctx.Param("custom_entity_id"), &customEntityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter custom_entity_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCustomEntityParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCustomEntity(ctx, customEntityId, params)
	return err
}

// UpdateCustomEntity converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCustomEntity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "custom_entity_id" -------------
	var customEntityId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "custom_entity_id", runtime.ParamLocationPath, ctx.Param("custom_entity_id"), &customEntityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter custom_entity_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateCustomEntity(ctx, customEntityId)
	return err
}

// ArchiveCustomEntities converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveCustomEntities(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveCustomEntities(ctx)
	return err
}

// BulkCreateCustomEntities converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateCustomEntities(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateCustomEntities(ctx)
	return err
}

// BulkGetCustomEntities converts echo context to params.
func (w *ServerInterfaceWrapper) BulkGetCustomEntities(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BulkGetCustomEntitiesParams
	// ------------- Required query parameter "customEntityIds" -------------

	err = runtime.BindQueryParameter("form", true, true, "customEntityIds", ctx.QueryParams(), &params.CustomEntityIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter customEntityIds: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkGetCustomEntities(ctx, params)
	return err
}

// BulkUpdateCustomEntities converts echo context to params.
func (w *ServerInterfaceWrapper) BulkUpdateCustomEntities(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkUpdateCustomEntities(ctx)
	return err
}

// UnarchiveCustomEntities converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveCustomEntities(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveCustomEntities(ctx)
	return err
}

// ListCustomNotations converts echo context to params.
func (w *ServerInterfaceWrapper) ListCustomNotations(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListCustomNotationsParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListCustomNotations(ctx, params)
	return err
}

// ListDNAAlignments converts echo context to params.
func (w *ServerInterfaceWrapper) ListDNAAlignments(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDNAAlignmentsParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "sequenceIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "sequenceIds", ctx.QueryParams(), &params.SequenceIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sequenceIds: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListDNAAlignments(ctx, params)
	return err
}

// DeleteDNAAlignment converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteDNAAlignment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "dna_alignment_id" -------------
	var dnaAlignmentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "dna_alignment_id", runtime.ParamLocationPath, ctx.Param("dna_alignment_id"), &dnaAlignmentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dna_alignment_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteDNAAlignment(ctx, dnaAlignmentId)
	return err
}

// GetDNAAlignment converts echo context to params.
func (w *ServerInterfaceWrapper) GetDNAAlignment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "dna_alignment_id" -------------
	var dnaAlignmentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "dna_alignment_id", runtime.ParamLocationPath, ctx.Param("dna_alignment_id"), &dnaAlignmentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dna_alignment_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDNAAlignment(ctx, dnaAlignmentId)
	return err
}

// CreateDnaConsensusAlignment converts echo context to params.
func (w *ServerInterfaceWrapper) CreateDnaConsensusAlignment(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateDnaConsensusAlignment(ctx)
	return err
}

// CreateDnaTemplateAlignment converts echo context to params.
func (w *ServerInterfaceWrapper) CreateDnaTemplateAlignment(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateDnaTemplateAlignment(ctx)
	return err
}

// ListDNAOligos converts echo context to params.
func (w *ServerInterfaceWrapper) ListDNAOligos(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDNAOligosParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "bases" -------------

	err = runtime.BindQueryParameter("form", true, false, "bases", ctx.QueryParams(), &params.Bases)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bases: %s", err))
	}

	// ------------- Optional query parameter "folderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "folderId", ctx.QueryParams(), &params.FolderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter folderId: %s", err))
	}

	// ------------- Optional query parameter "mentionedIn" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentionedIn", ctx.QueryParams(), &params.MentionedIn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentionedIn: %s", err))
	}

	// ------------- Optional query parameter "projectId" -------------

	err = runtime.BindQueryParameter("form", true, false, "projectId", ctx.QueryParams(), &params.ProjectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Optional query parameter "registryId" -------------

	err = runtime.BindQueryParameter("form", true, false, "registryId", ctx.QueryParams(), &params.RegistryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registryId: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "schemaFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaFields", ctx.QueryParams(), &params.SchemaFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaFields: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "mentions" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentions", ctx.QueryParams(), &params.Mentions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentions: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "entityRegistryIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityRegistryIds.anyOf", ctx.QueryParams(), &params.EntityRegistryIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityRegistryIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// ------------- Optional query parameter "authorIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "authorIds.anyOf", ctx.QueryParams(), &params.AuthorIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authorIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// ------------- Optional query parameter "customNotationId" -------------

	err = runtime.BindQueryParameter("form", true, false, "customNotationId", ctx.QueryParams(), &params.CustomNotationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter customNotationId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListDNAOligos(ctx, params)
	return err
}

// CreateDNAOligo converts echo context to params.
func (w *ServerInterfaceWrapper) CreateDNAOligo(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateDNAOligo(ctx)
	return err
}

// GetDNAOligo converts echo context to params.
func (w *ServerInterfaceWrapper) GetDNAOligo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "oligo_id" -------------
	var oligoId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "oligo_id", runtime.ParamLocationPath, ctx.Param("oligo_id"), &oligoId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter oligo_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDNAOligoParams
	// ------------- Optional query parameter "customNotationId" -------------

	err = runtime.BindQueryParameter("form", true, false, "customNotationId", ctx.QueryParams(), &params.CustomNotationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter customNotationId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDNAOligo(ctx, oligoId, params)
	return err
}

// UpdateDNAOligo converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateDNAOligo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "oligo_id" -------------
	var oligoId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "oligo_id", runtime.ParamLocationPath, ctx.Param("oligo_id"), &oligoId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter oligo_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateDNAOligo(ctx, oligoId)
	return err
}

// ArchiveDNAOligos converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveDNAOligos(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveDNAOligos(ctx)
	return err
}

// BulkCreateDNAOligos converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateDNAOligos(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateDNAOligos(ctx)
	return err
}

// BulkUpdateDNAOligos converts echo context to params.
func (w *ServerInterfaceWrapper) BulkUpdateDNAOligos(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkUpdateDNAOligos(ctx)
	return err
}

// UnarchiveDNAOligos converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveDNAOligos(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveDNAOligos(ctx)
	return err
}

// ListDNASequences converts echo context to params.
func (w *ServerInterfaceWrapper) ListDNASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDNASequencesParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "bases" -------------

	err = runtime.BindQueryParameter("form", true, false, "bases", ctx.QueryParams(), &params.Bases)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bases: %s", err))
	}

	// ------------- Optional query parameter "folderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "folderId", ctx.QueryParams(), &params.FolderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter folderId: %s", err))
	}

	// ------------- Optional query parameter "mentionedIn" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentionedIn", ctx.QueryParams(), &params.MentionedIn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentionedIn: %s", err))
	}

	// ------------- Optional query parameter "projectId" -------------

	err = runtime.BindQueryParameter("form", true, false, "projectId", ctx.QueryParams(), &params.ProjectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Optional query parameter "registryId" -------------

	err = runtime.BindQueryParameter("form", true, false, "registryId", ctx.QueryParams(), &params.RegistryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registryId: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "schemaFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaFields", ctx.QueryParams(), &params.SchemaFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaFields: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "mentions" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentions", ctx.QueryParams(), &params.Mentions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentions: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "entityRegistryIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityRegistryIds.anyOf", ctx.QueryParams(), &params.EntityRegistryIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityRegistryIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// ------------- Optional query parameter "authorIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "authorIds.anyOf", ctx.QueryParams(), &params.AuthorIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authorIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListDNASequences(ctx, params)
	return err
}

// CreateDNASequence converts echo context to params.
func (w *ServerInterfaceWrapper) CreateDNASequence(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateDNASequence(ctx)
	return err
}

// GetDNASequence converts echo context to params.
func (w *ServerInterfaceWrapper) GetDNASequence(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "dna_sequence_id" -------------
	var dnaSequenceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "dna_sequence_id", runtime.ParamLocationPath, ctx.Param("dna_sequence_id"), &dnaSequenceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dna_sequence_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDNASequenceParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDNASequence(ctx, dnaSequenceId, params)
	return err
}

// UpdateDNASequence converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateDNASequence(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "dna_sequence_id" -------------
	var dnaSequenceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "dna_sequence_id", runtime.ParamLocationPath, ctx.Param("dna_sequence_id"), &dnaSequenceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dna_sequence_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateDNASequence(ctx, dnaSequenceId)
	return err
}

// ArchiveDNASequences converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveDNASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveDNASequences(ctx)
	return err
}

// AutoAnnotateDnaSequences converts echo context to params.
func (w *ServerInterfaceWrapper) AutoAnnotateDnaSequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AutoAnnotateDnaSequences(ctx)
	return err
}

// AutofillDNASequenceParts converts echo context to params.
func (w *ServerInterfaceWrapper) AutofillDNASequenceParts(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AutofillDNASequenceParts(ctx)
	return err
}

// AutofillDNASequenceTranslations converts echo context to params.
func (w *ServerInterfaceWrapper) AutofillDNASequenceTranslations(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AutofillDNASequenceTranslations(ctx)
	return err
}

// BulkCreateDNASequences converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateDNASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateDNASequences(ctx)
	return err
}

// BulkGetDNASequences converts echo context to params.
func (w *ServerInterfaceWrapper) BulkGetDNASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BulkGetDNASequencesParams
	// ------------- Required query parameter "dnaSequenceIds" -------------

	err = runtime.BindQueryParameter("form", true, true, "dnaSequenceIds", ctx.QueryParams(), &params.DnaSequenceIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dnaSequenceIds: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkGetDNASequences(ctx, params)
	return err
}

// BulkUpdateDNASequences converts echo context to params.
func (w *ServerInterfaceWrapper) BulkUpdateDNASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkUpdateDNASequences(ctx)
	return err
}

// MatchBasesDnaSequences converts echo context to params.
func (w *ServerInterfaceWrapper) MatchBasesDnaSequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MatchBasesDnaSequences(ctx)
	return err
}

// SearchDnaSequences converts echo context to params.
func (w *ServerInterfaceWrapper) SearchDnaSequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchDnaSequences(ctx)
	return err
}

// UnarchiveDNASequences converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveDNASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveDNASequences(ctx)
	return err
}

// ListDropdowns converts echo context to params.
func (w *ServerInterfaceWrapper) ListDropdowns(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDropdownsParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListDropdowns(ctx, params)
	return err
}

// CreateDropdown converts echo context to params.
func (w *ServerInterfaceWrapper) CreateDropdown(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateDropdown(ctx)
	return err
}

// GetDropdown converts echo context to params.
func (w *ServerInterfaceWrapper) GetDropdown(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "dropdown_id" -------------
	var dropdownId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "dropdown_id", runtime.ParamLocationPath, ctx.Param("dropdown_id"), &dropdownId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dropdown_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetDropdown(ctx, dropdownId)
	return err
}

// UpdateDropdown converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateDropdown(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "dropdown_id" -------------
	var dropdownId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "dropdown_id", runtime.ParamLocationPath, ctx.Param("dropdown_id"), &dropdownId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dropdown_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateDropdown(ctx, dropdownId)
	return err
}

// ArchiveDropdownOptions converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveDropdownOptions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "dropdown_id" -------------
	var dropdownId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "dropdown_id", runtime.ParamLocationPath, ctx.Param("dropdown_id"), &dropdownId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dropdown_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveDropdownOptions(ctx, dropdownId)
	return err
}

// UnarchiveDropdownOptions converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveDropdownOptions(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "dropdown_id" -------------
	var dropdownId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "dropdown_id", runtime.ParamLocationPath, ctx.Param("dropdown_id"), &dropdownId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter dropdown_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveDropdownOptions(ctx, dropdownId)
	return err
}

// GetEnitityBatches converts echo context to params.
func (w *ServerInterfaceWrapper) GetEnitityBatches(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "entity_id" -------------
	var entityId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "entity_id", runtime.ParamLocationPath, ctx.Param("entity_id"), &entityId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entity_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEnitityBatches(ctx, entityId)
	return err
}

// ListEntitySchemas converts echo context to params.
func (w *ServerInterfaceWrapper) ListEntitySchemas(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListEntitySchemasParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListEntitySchemas(ctx, params)
	return err
}

// GetEntitySchema converts echo context to params.
func (w *ServerInterfaceWrapper) GetEntitySchema(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "schema_id" -------------
	var schemaId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, ctx.Param("schema_id"), &schemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEntitySchema(ctx, schemaId)
	return err
}

// ListEntries converts echo context to params.
func (w *ServerInterfaceWrapper) ListEntries(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListEntriesParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "projectId" -------------

	err = runtime.BindQueryParameter("form", true, false, "projectId", ctx.QueryParams(), &params.ProjectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "reviewStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "reviewStatus", ctx.QueryParams(), &params.ReviewStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reviewStatus: %s", err))
	}

	// ------------- Optional query parameter "mentionedIn" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentionedIn", ctx.QueryParams(), &params.MentionedIn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentionedIn: %s", err))
	}

	// ------------- Optional query parameter "mentions" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentions", ctx.QueryParams(), &params.Mentions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentions: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "assignedReviewerIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "assignedReviewerIds.anyOf", ctx.QueryParams(), &params.AssignedReviewerIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assignedReviewerIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// ------------- Optional query parameter "authorIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "authorIds.anyOf", ctx.QueryParams(), &params.AuthorIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authorIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "displayIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "displayIds", ctx.QueryParams(), &params.DisplayIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter displayIds: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListEntries(ctx, params)
	return err
}

// CreateEntry converts echo context to params.
func (w *ServerInterfaceWrapper) CreateEntry(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateEntry(ctx)
	return err
}

// GetEntry converts echo context to params.
func (w *ServerInterfaceWrapper) GetEntry(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "entry_id" -------------
	var entryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "entry_id", runtime.ParamLocationPath, ctx.Param("entry_id"), &entryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entry_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEntryParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEntry(ctx, entryId, params)
	return err
}

// UpdateEntry converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateEntry(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "entry_id" -------------
	var entryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "entry_id", runtime.ParamLocationPath, ctx.Param("entry_id"), &entryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entry_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateEntryParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateEntry(ctx, entryId, params)
	return err
}

// GetExternalFileMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) GetExternalFileMetadata(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "entry_id" -------------
	var entryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "entry_id", runtime.ParamLocationPath, ctx.Param("entry_id"), &entryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entry_id: %s", err))
	}

	// ------------- Path parameter "external_file_id" -------------
	var externalFileId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "external_file_id", runtime.ParamLocationPath, ctx.Param("external_file_id"), &externalFileId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter external_file_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetExternalFileMetadata(ctx, entryId, externalFileId)
	return err
}

// ArchiveEntries converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveEntries(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveEntries(ctx)
	return err
}

// BulkGetEntries converts echo context to params.
func (w *ServerInterfaceWrapper) BulkGetEntries(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BulkGetEntriesParams
	// ------------- Optional query parameter "entryIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "entryIds", ctx.QueryParams(), &params.EntryIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entryIds: %s", err))
	}

	// ------------- Optional query parameter "displayIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "displayIds", ctx.QueryParams(), &params.DisplayIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter displayIds: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkGetEntries(ctx, params)
	return err
}

// UnarchiveEntries converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveEntries(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveEntries(ctx)
	return err
}

// ListEntrySchemas converts echo context to params.
func (w *ServerInterfaceWrapper) ListEntrySchemas(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListEntrySchemasParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListEntrySchemas(ctx, params)
	return err
}

// GetEntrySchema converts echo context to params.
func (w *ServerInterfaceWrapper) GetEntrySchema(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "schema_id" -------------
	var schemaId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, ctx.Param("schema_id"), &schemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEntrySchema(ctx, schemaId)
	return err
}

// ListEntryTemplates converts echo context to params.
func (w *ServerInterfaceWrapper) ListEntryTemplates(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListEntryTemplatesParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "templateCollectionId" -------------

	err = runtime.BindQueryParameter("form", true, false, "templateCollectionId", ctx.QueryParams(), &params.TemplateCollectionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter templateCollectionId: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListEntryTemplates(ctx, params)
	return err
}

// GetEntryTemplate converts echo context to params.
func (w *ServerInterfaceWrapper) GetEntryTemplate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "entry_template_id" -------------
	var entryTemplateId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "entry_template_id", runtime.ParamLocationPath, ctx.Param("entry_template_id"), &entryTemplateId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entry_template_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEntryTemplateParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetEntryTemplate(ctx, entryTemplateId, params)
	return err
}

// ListEvents converts echo context to params.
func (w *ServerInterfaceWrapper) ListEvents(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListEventsParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "createdAt.gte" -------------

	err = runtime.BindQueryParameter("form", true, false, "createdAt.gte", ctx.QueryParams(), &params.CreatedAtGte)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter createdAt.gte: %s", err))
	}

	// ------------- Optional query parameter "startingAfter" -------------

	err = runtime.BindQueryParameter("form", true, false, "startingAfter", ctx.QueryParams(), &params.StartingAfter)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter startingAfter: %s", err))
	}

	// ------------- Optional query parameter "eventTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "eventTypes", ctx.QueryParams(), &params.EventTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter eventTypes: %s", err))
	}

	// ------------- Optional query parameter "poll" -------------

	err = runtime.BindQueryParameter("form", true, false, "poll", ctx.QueryParams(), &params.Poll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter poll: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListEvents(ctx, params)
	return err
}

// ExportItem converts echo context to params.
func (w *ServerInterfaceWrapper) ExportItem(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExportItem(ctx)
	return err
}

// ListFeatureLibraries converts echo context to params.
func (w *ServerInterfaceWrapper) ListFeatureLibraries(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFeatureLibrariesParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListFeatureLibraries(ctx, params)
	return err
}

// CreateFeatureLibrary converts echo context to params.
func (w *ServerInterfaceWrapper) CreateFeatureLibrary(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateFeatureLibrary(ctx)
	return err
}

// GetFeatureLibrary converts echo context to params.
func (w *ServerInterfaceWrapper) GetFeatureLibrary(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "feature_library_id" -------------
	var featureLibraryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "feature_library_id", runtime.ParamLocationPath, ctx.Param("feature_library_id"), &featureLibraryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter feature_library_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFeatureLibraryParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFeatureLibrary(ctx, featureLibraryId, params)
	return err
}

// UpdateFeatureLibrary converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateFeatureLibrary(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "feature_library_id" -------------
	var featureLibraryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "feature_library_id", runtime.ParamLocationPath, ctx.Param("feature_library_id"), &featureLibraryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter feature_library_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateFeatureLibrary(ctx, featureLibraryId)
	return err
}

// ListFeatures converts echo context to params.
func (w *ServerInterfaceWrapper) ListFeatures(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFeaturesParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "featureLibraryId" -------------

	err = runtime.BindQueryParameter("form", true, false, "featureLibraryId", ctx.QueryParams(), &params.FeatureLibraryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter featureLibraryId: %s", err))
	}

	// ------------- Optional query parameter "featureType" -------------

	err = runtime.BindQueryParameter("form", true, false, "featureType", ctx.QueryParams(), &params.FeatureType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter featureType: %s", err))
	}

	// ------------- Optional query parameter "matchType" -------------

	err = runtime.BindQueryParameter("form", true, false, "matchType", ctx.QueryParams(), &params.MatchType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter matchType: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListFeatures(ctx, params)
	return err
}

// CreateFeature converts echo context to params.
func (w *ServerInterfaceWrapper) CreateFeature(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateFeature(ctx)
	return err
}

// GetFeature converts echo context to params.
func (w *ServerInterfaceWrapper) GetFeature(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "feature_id" -------------
	var featureId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "feature_id", runtime.ParamLocationPath, ctx.Param("feature_id"), &featureId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter feature_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFeatureParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFeature(ctx, featureId, params)
	return err
}

// UpdateFeature converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateFeature(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "feature_id" -------------
	var featureId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "feature_id", runtime.ParamLocationPath, ctx.Param("feature_id"), &featureId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter feature_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateFeature(ctx, featureId)
	return err
}

// BulkCreateFeatures converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateFeatures(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateFeatures(ctx)
	return err
}

// ListFolders converts echo context to params.
func (w *ServerInterfaceWrapper) ListFolders(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListFoldersParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "parentFolderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "parentFolderId", ctx.QueryParams(), &params.ParentFolderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter parentFolderId: %s", err))
	}

	// ------------- Optional query parameter "projectId" -------------

	err = runtime.BindQueryParameter("form", true, false, "projectId", ctx.QueryParams(), &params.ProjectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "section" -------------

	err = runtime.BindQueryParameter("form", true, false, "section", ctx.QueryParams(), &params.Section)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter section: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListFolders(ctx, params)
	return err
}

// CreateFolder converts echo context to params.
func (w *ServerInterfaceWrapper) CreateFolder(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateFolder(ctx)
	return err
}

// GetFolder converts echo context to params.
func (w *ServerInterfaceWrapper) GetFolder(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "folder_id" -------------
	var folderId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "folder_id", runtime.ParamLocationPath, ctx.Param("folder_id"), &folderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter folder_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetFolder(ctx, folderId)
	return err
}

// ArchiveFolders converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveFolders(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveFolders(ctx)
	return err
}

// UnarchiveFolders converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveFolders(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveFolders(ctx)
	return err
}

// ListLegacyWorkflowStageRunInputSamples converts echo context to params.
func (w *ServerInterfaceWrapper) ListLegacyWorkflowStageRunInputSamples(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stage_run_id" -------------
	var stageRunId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "stage_run_id", runtime.ParamLocationPath, ctx.Param("stage_run_id"), &stageRunId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stage_run_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListLegacyWorkflowStageRunInputSamples(ctx, stageRunId)
	return err
}

// ListLegacyWorkflowStageRunOutputSamples converts echo context to params.
func (w *ServerInterfaceWrapper) ListLegacyWorkflowStageRunOutputSamples(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stage_run_id" -------------
	var stageRunId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "stage_run_id", runtime.ParamLocationPath, ctx.Param("stage_run_id"), &stageRunId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stage_run_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListLegacyWorkflowStageRunOutputSamples(ctx, stageRunId)
	return err
}

// ListLegacyWorkflowStageRunRegisteredSamples converts echo context to params.
func (w *ServerInterfaceWrapper) ListLegacyWorkflowStageRunRegisteredSamples(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stage_run_id" -------------
	var stageRunId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "stage_run_id", runtime.ParamLocationPath, ctx.Param("stage_run_id"), &stageRunId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stage_run_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListLegacyWorkflowStageRunRegisteredSamples(ctx, stageRunId)
	return err
}

// ListLegacyWorkflowStageRuns converts echo context to params.
func (w *ServerInterfaceWrapper) ListLegacyWorkflowStageRuns(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stage_id" -------------
	var stageId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "stage_id", runtime.ParamLocationPath, ctx.Param("stage_id"), &stageId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stage_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListLegacyWorkflowStageRuns(ctx, stageId)
	return err
}

// ListLegacyWorkflows converts echo context to params.
func (w *ServerInterfaceWrapper) ListLegacyWorkflows(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListLegacyWorkflows(ctx)
	return err
}

// UpdateLegacyWorkflowMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateLegacyWorkflowMetadata(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "legacy_workflow_id" -------------
	var legacyWorkflowId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "legacy_workflow_id", runtime.ParamLocationPath, ctx.Param("legacy_workflow_id"), &legacyWorkflowId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter legacy_workflow_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateLegacyWorkflowMetadata(ctx, legacyWorkflowId)
	return err
}

// ListLegacyWorkflowStages converts echo context to params.
func (w *ServerInterfaceWrapper) ListLegacyWorkflowStages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "legacy_workflow_id" -------------
	var legacyWorkflowId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "legacy_workflow_id", runtime.ParamLocationPath, ctx.Param("legacy_workflow_id"), &legacyWorkflowId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter legacy_workflow_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListLegacyWorkflowStages(ctx, legacyWorkflowId)
	return err
}

// ListLocationSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) ListLocationSchemas(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListLocationSchemasParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListLocationSchemas(ctx, params)
	return err
}

// GetLocationSchema converts echo context to params.
func (w *ServerInterfaceWrapper) GetLocationSchema(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "schema_id" -------------
	var schemaId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, ctx.Param("schema_id"), &schemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLocationSchema(ctx, schemaId)
	return err
}

// ListLocations converts echo context to params.
func (w *ServerInterfaceWrapper) ListLocations(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListLocationsParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "schemaFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaFields", ctx.QueryParams(), &params.SchemaFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaFields: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "ancestorStorageId" -------------

	err = runtime.BindQueryParameter("form", true, false, "ancestorStorageId", ctx.QueryParams(), &params.AncestorStorageId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ancestorStorageId: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "barcodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "barcodes", ctx.QueryParams(), &params.Barcodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter barcodes: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListLocations(ctx, params)
	return err
}

// CreateLocation converts echo context to params.
func (w *ServerInterfaceWrapper) CreateLocation(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateLocation(ctx)
	return err
}

// GetLocation converts echo context to params.
func (w *ServerInterfaceWrapper) GetLocation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "location_id" -------------
	var locationId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "location_id", runtime.ParamLocationPath, ctx.Param("location_id"), &locationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter location_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLocation(ctx, locationId)
	return err
}

// UpdateLocation converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateLocation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "location_id" -------------
	var locationId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "location_id", runtime.ParamLocationPath, ctx.Param("location_id"), &locationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter location_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateLocation(ctx, locationId)
	return err
}

// ArchiveLocations converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveLocations(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveLocations(ctx)
	return err
}

// BulkGetLocations converts echo context to params.
func (w *ServerInterfaceWrapper) BulkGetLocations(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BulkGetLocationsParams
	// ------------- Optional query parameter "locationIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "locationIds", ctx.QueryParams(), &params.LocationIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter locationIds: %s", err))
	}

	// ------------- Optional query parameter "barcodes" -------------

	err = runtime.BindQueryParameter("form", false, false, "barcodes", ctx.QueryParams(), &params.Barcodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter barcodes: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkGetLocations(ctx, params)
	return err
}

// UnarchiveLocations converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveLocations(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveLocations(ctx)
	return err
}

// ListMixtures converts echo context to params.
func (w *ServerInterfaceWrapper) ListMixtures(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMixturesParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "folderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "folderId", ctx.QueryParams(), &params.FolderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter folderId: %s", err))
	}

	// ------------- Optional query parameter "mentionedIn" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentionedIn", ctx.QueryParams(), &params.MentionedIn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentionedIn: %s", err))
	}

	// ------------- Optional query parameter "projectId" -------------

	err = runtime.BindQueryParameter("form", true, false, "projectId", ctx.QueryParams(), &params.ProjectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Optional query parameter "registryId" -------------

	err = runtime.BindQueryParameter("form", true, false, "registryId", ctx.QueryParams(), &params.RegistryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registryId: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "schemaFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaFields", ctx.QueryParams(), &params.SchemaFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaFields: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "mentions" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentions", ctx.QueryParams(), &params.Mentions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentions: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "entityRegistryIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityRegistryIds.anyOf", ctx.QueryParams(), &params.EntityRegistryIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityRegistryIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "ingredientComponentEntityIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "ingredientComponentEntityIds", ctx.QueryParams(), &params.IngredientComponentEntityIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredientComponentEntityIds: %s", err))
	}

	// ------------- Optional query parameter "ingredientComponentEntityIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "ingredientComponentEntityIds.anyOf", ctx.QueryParams(), &params.IngredientComponentEntityIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ingredientComponentEntityIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "authorIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "authorIds.anyOf", ctx.QueryParams(), &params.AuthorIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authorIds.anyOf: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListMixtures(ctx, params)
	return err
}

// CreateMixture converts echo context to params.
func (w *ServerInterfaceWrapper) CreateMixture(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateMixture(ctx)
	return err
}

// GetMixture converts echo context to params.
func (w *ServerInterfaceWrapper) GetMixture(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "mixture_id" -------------
	var mixtureId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "mixture_id", runtime.ParamLocationPath, ctx.Param("mixture_id"), &mixtureId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mixture_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMixture(ctx, mixtureId)
	return err
}

// UpdateMixture converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateMixture(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "mixture_id" -------------
	var mixtureId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "mixture_id", runtime.ParamLocationPath, ctx.Param("mixture_id"), &mixtureId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mixture_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateMixture(ctx, mixtureId)
	return err
}

// ArchiveMixtures converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveMixtures(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveMixtures(ctx)
	return err
}

// BulkCreateMixtures converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateMixtures(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateMixtures(ctx)
	return err
}

// BulkUpdateMixtures converts echo context to params.
func (w *ServerInterfaceWrapper) BulkUpdateMixtures(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkUpdateMixtures(ctx)
	return err
}

// UnarchiveMixtures converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveMixtures(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveMixtures(ctx)
	return err
}

// ListMolecules converts echo context to params.
func (w *ServerInterfaceWrapper) ListMolecules(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMoleculesParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "folderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "folderId", ctx.QueryParams(), &params.FolderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter folderId: %s", err))
	}

	// ------------- Optional query parameter "mentionedIn" -------------

	err = runtime.BindQueryParameter("form", false, false, "mentionedIn", ctx.QueryParams(), &params.MentionedIn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentionedIn: %s", err))
	}

	// ------------- Optional query parameter "projectId" -------------

	err = runtime.BindQueryParameter("form", true, false, "projectId", ctx.QueryParams(), &params.ProjectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Optional query parameter "registryId" -------------

	err = runtime.BindQueryParameter("form", true, false, "registryId", ctx.QueryParams(), &params.RegistryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registryId: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "schemaFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaFields", ctx.QueryParams(), &params.SchemaFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaFields: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "mentions" -------------

	err = runtime.BindQueryParameter("form", false, false, "mentions", ctx.QueryParams(), &params.Mentions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentions: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "entityRegistryIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityRegistryIds.anyOf", ctx.QueryParams(), &params.EntityRegistryIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityRegistryIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "authorIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "authorIds.anyOf", ctx.QueryParams(), &params.AuthorIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authorIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "chemicalSubstructure.mol" -------------

	err = runtime.BindQueryParameter("form", true, false, "chemicalSubstructure.mol", ctx.QueryParams(), &params.ChemicalSubstructureMol)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chemicalSubstructure.mol: %s", err))
	}

	// ------------- Optional query parameter "chemicalSubstructure.smiles" -------------

	err = runtime.BindQueryParameter("form", true, false, "chemicalSubstructure.smiles", ctx.QueryParams(), &params.ChemicalSubstructureSmiles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter chemicalSubstructure.smiles: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListMolecules(ctx, params)
	return err
}

// CreateMolecule converts echo context to params.
func (w *ServerInterfaceWrapper) CreateMolecule(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateMolecule(ctx)
	return err
}

// GetMolecule converts echo context to params.
func (w *ServerInterfaceWrapper) GetMolecule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "molecule_id" -------------
	var moleculeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "molecule_id", runtime.ParamLocationPath, ctx.Param("molecule_id"), &moleculeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter molecule_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetMolecule(ctx, moleculeId)
	return err
}

// UpdateMolecule converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateMolecule(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "molecule_id" -------------
	var moleculeId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "molecule_id", runtime.ParamLocationPath, ctx.Param("molecule_id"), &moleculeId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter molecule_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateMolecule(ctx, moleculeId)
	return err
}

// ArchiveMolecules converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveMolecules(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveMolecules(ctx)
	return err
}

// BulkCreateMolecules converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateMolecules(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateMolecules(ctx)
	return err
}

// BulkUpdateMolecules converts echo context to params.
func (w *ServerInterfaceWrapper) BulkUpdateMolecules(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkUpdateMolecules(ctx)
	return err
}

// UnarchiveMolecules converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveMolecules(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveMolecules(ctx)
	return err
}

// ListMonomers converts echo context to params.
func (w *ServerInterfaceWrapper) ListMonomers(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListMonomersParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListMonomers(ctx, params)
	return err
}

// CreateMonomer converts echo context to params.
func (w *ServerInterfaceWrapper) CreateMonomer(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateMonomerParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateMonomer(ctx, params)
	return err
}

// UpdateMonomer converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateMonomer(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "monomer_id" -------------
	var monomerId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "monomer_id", runtime.ParamLocationPath, ctx.Param("monomer_id"), &monomerId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter monomer_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateMonomerParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateMonomer(ctx, monomerId, params)
	return err
}

// ArchiveMonomers converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveMonomers(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveMonomers(ctx)
	return err
}

// UnarchiveMonomers converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveMonomers(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveMonomers(ctx)
	return err
}

// ListNucleotideAlignments converts echo context to params.
func (w *ServerInterfaceWrapper) ListNucleotideAlignments(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListNucleotideAlignmentsParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "sequenceIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "sequenceIds", ctx.QueryParams(), &params.SequenceIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sequenceIds: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListNucleotideAlignments(ctx, params)
	return err
}

// DeleteNucleotideAlignment converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteNucleotideAlignment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "alignment_id" -------------
	var alignmentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "alignment_id", runtime.ParamLocationPath, ctx.Param("alignment_id"), &alignmentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter alignment_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.DeleteNucleotideAlignment(ctx, alignmentId)
	return err
}

// GetNucleotideAlignment converts echo context to params.
func (w *ServerInterfaceWrapper) GetNucleotideAlignment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "alignment_id" -------------
	var alignmentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "alignment_id", runtime.ParamLocationPath, ctx.Param("alignment_id"), &alignmentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter alignment_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetNucleotideAlignment(ctx, alignmentId)
	return err
}

// CreateConsensusNucleotideAlignment converts echo context to params.
func (w *ServerInterfaceWrapper) CreateConsensusNucleotideAlignment(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateConsensusNucleotideAlignment(ctx)
	return err
}

// CreateTemplateNucleotideAlignment converts echo context to params.
func (w *ServerInterfaceWrapper) CreateTemplateNucleotideAlignment(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateTemplateNucleotideAlignment(ctx)
	return err
}

// ListOligos converts echo context to params.
func (w *ServerInterfaceWrapper) ListOligos(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListOligosParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "bases" -------------

	err = runtime.BindQueryParameter("form", true, false, "bases", ctx.QueryParams(), &params.Bases)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bases: %s", err))
	}

	// ------------- Optional query parameter "folderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "folderId", ctx.QueryParams(), &params.FolderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter folderId: %s", err))
	}

	// ------------- Optional query parameter "mentionedIn" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentionedIn", ctx.QueryParams(), &params.MentionedIn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentionedIn: %s", err))
	}

	// ------------- Optional query parameter "projectId" -------------

	err = runtime.BindQueryParameter("form", true, false, "projectId", ctx.QueryParams(), &params.ProjectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Optional query parameter "registryId" -------------

	err = runtime.BindQueryParameter("form", true, false, "registryId", ctx.QueryParams(), &params.RegistryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registryId: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "schemaFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaFields", ctx.QueryParams(), &params.SchemaFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaFields: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "mentions" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentions", ctx.QueryParams(), &params.Mentions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentions: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "entityRegistryIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityRegistryIds.anyOf", ctx.QueryParams(), &params.EntityRegistryIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityRegistryIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListOligos(ctx, params)
	return err
}

// CreateOligo converts echo context to params.
func (w *ServerInterfaceWrapper) CreateOligo(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateOligo(ctx)
	return err
}

// GetOligo converts echo context to params.
func (w *ServerInterfaceWrapper) GetOligo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "oligo_id" -------------
	var oligoId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "oligo_id", runtime.ParamLocationPath, ctx.Param("oligo_id"), &oligoId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter oligo_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOligoParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOligo(ctx, oligoId, params)
	return err
}

// UpdateOligo converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateOligo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "oligo_id" -------------
	var oligoId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "oligo_id", runtime.ParamLocationPath, ctx.Param("oligo_id"), &oligoId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter oligo_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateOligo(ctx, oligoId)
	return err
}

// ArchiveOligos converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveOligos(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveOligos(ctx)
	return err
}

// BulkCreateOligos converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateOligos(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateOligos(ctx)
	return err
}

// BulkGetOligos converts echo context to params.
func (w *ServerInterfaceWrapper) BulkGetOligos(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BulkGetOligosParams
	// ------------- Required query parameter "oligoIds" -------------

	err = runtime.BindQueryParameter("form", true, true, "oligoIds", ctx.QueryParams(), &params.OligoIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter oligoIds: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkGetOligos(ctx, params)
	return err
}

// UnarchiveOligos converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveOligos(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveOligos(ctx)
	return err
}

// ListOrganizations converts echo context to params.
func (w *ServerInterfaceWrapper) ListOrganizations(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListOrganizationsParams
	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "hasMembers" -------------

	err = runtime.BindQueryParameter("form", true, false, "hasMembers", ctx.QueryParams(), &params.HasMembers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hasMembers: %s", err))
	}

	// ------------- Optional query parameter "hasAdmins" -------------

	err = runtime.BindQueryParameter("form", true, false, "hasAdmins", ctx.QueryParams(), &params.HasAdmins)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hasAdmins: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListOrganizations(ctx, params)
	return err
}

// GetOrganization converts echo context to params.
func (w *ServerInterfaceWrapper) GetOrganization(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "organization_id" -------------
	var organizationId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "organization_id", runtime.ParamLocationPath, ctx.Param("organization_id"), &organizationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organization_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetOrganization(ctx, organizationId)
	return err
}

// ListPlateSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) ListPlateSchemas(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPlateSchemasParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListPlateSchemas(ctx, params)
	return err
}

// GetPlateSchema converts echo context to params.
func (w *ServerInterfaceWrapper) GetPlateSchema(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "schema_id" -------------
	var schemaId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, ctx.Param("schema_id"), &schemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPlateSchema(ctx, schemaId)
	return err
}

// ListPlates converts echo context to params.
func (w *ServerInterfaceWrapper) ListPlates(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPlatesParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "schemaFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaFields", ctx.QueryParams(), &params.SchemaFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaFields: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "ancestorStorageId" -------------

	err = runtime.BindQueryParameter("form", true, false, "ancestorStorageId", ctx.QueryParams(), &params.AncestorStorageId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ancestorStorageId: %s", err))
	}

	// ------------- Optional query parameter "storageContentsId" -------------

	err = runtime.BindQueryParameter("form", true, false, "storageContentsId", ctx.QueryParams(), &params.StorageContentsId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter storageContentsId: %s", err))
	}

	// ------------- Optional query parameter "storageContentsIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "storageContentsIds", ctx.QueryParams(), &params.StorageContentsIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter storageContentsIds: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "barcodes" -------------

	err = runtime.BindQueryParameter("form", true, false, "barcodes", ctx.QueryParams(), &params.Barcodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter barcodes: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListPlates(ctx, params)
	return err
}

// CreatePlate converts echo context to params.
func (w *ServerInterfaceWrapper) CreatePlate(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreatePlateParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreatePlate(ctx, params)
	return err
}

// GetPlate converts echo context to params.
func (w *ServerInterfaceWrapper) GetPlate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "plate_id" -------------
	var plateId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "plate_id", runtime.ParamLocationPath, ctx.Param("plate_id"), &plateId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter plate_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPlateParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPlate(ctx, plateId, params)
	return err
}

// UpdatePlate converts echo context to params.
func (w *ServerInterfaceWrapper) UpdatePlate(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "plate_id" -------------
	var plateId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "plate_id", runtime.ParamLocationPath, ctx.Param("plate_id"), &plateId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter plate_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdatePlateParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdatePlate(ctx, plateId, params)
	return err
}

// ArchivePlates converts echo context to params.
func (w *ServerInterfaceWrapper) ArchivePlates(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchivePlates(ctx)
	return err
}

// BulkGetPlates converts echo context to params.
func (w *ServerInterfaceWrapper) BulkGetPlates(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BulkGetPlatesParams
	// ------------- Optional query parameter "plateIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "plateIds", ctx.QueryParams(), &params.PlateIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter plateIds: %s", err))
	}

	// ------------- Optional query parameter "barcodes" -------------

	err = runtime.BindQueryParameter("form", false, false, "barcodes", ctx.QueryParams(), &params.Barcodes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter barcodes: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkGetPlates(ctx, params)
	return err
}

// UnarchivePlates converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchivePlates(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchivePlates(ctx)
	return err
}

// ListProjects converts echo context to params.
func (w *ServerInterfaceWrapper) ListProjects(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListProjectsParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListProjects(ctx, params)
	return err
}

// GetProject converts echo context to params.
func (w *ServerInterfaceWrapper) GetProject(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "project_id" -------------
	var projectId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "project_id", runtime.ParamLocationPath, ctx.Param("project_id"), &projectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter project_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetProject(ctx, projectId)
	return err
}

// ArchiveProjects converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveProjects(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveProjects(ctx)
	return err
}

// UnarchiveProjects converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveProjects(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveProjects(ctx)
	return err
}

// ListRegistries converts echo context to params.
func (w *ServerInterfaceWrapper) ListRegistries(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRegistriesParams
	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListRegistries(ctx, params)
	return err
}

// GetRegistry converts echo context to params.
func (w *ServerInterfaceWrapper) GetRegistry(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "registry_id" -------------
	var registryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, ctx.Param("registry_id"), &registryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registry_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRegistry(ctx, registryId)
	return err
}

// ListBatchSchemasByRegistry converts echo context to params.
func (w *ServerInterfaceWrapper) ListBatchSchemasByRegistry(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "registry_id" -------------
	var registryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, ctx.Param("registry_id"), &registryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registry_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListBatchSchemasByRegistry(ctx, registryId)
	return err
}

// ListBoxSchemasByRegistry converts echo context to params.
func (w *ServerInterfaceWrapper) ListBoxSchemasByRegistry(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "registry_id" -------------
	var registryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, ctx.Param("registry_id"), &registryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registry_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListBoxSchemasByRegistry(ctx, registryId)
	return err
}

// ListContainerSchemasByRegistry converts echo context to params.
func (w *ServerInterfaceWrapper) ListContainerSchemasByRegistry(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "registry_id" -------------
	var registryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, ctx.Param("registry_id"), &registryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registry_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListContainerSchemasByRegistry(ctx, registryId)
	return err
}

// ListDropdownsByRegistry converts echo context to params.
func (w *ServerInterfaceWrapper) ListDropdownsByRegistry(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "registry_id" -------------
	var registryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, ctx.Param("registry_id"), &registryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registry_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListDropdownsByRegistry(ctx, registryId)
	return err
}

// ListEntitySchemasByRegistry converts echo context to params.
func (w *ServerInterfaceWrapper) ListEntitySchemasByRegistry(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "registry_id" -------------
	var registryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, ctx.Param("registry_id"), &registryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registry_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListEntitySchemasByRegistry(ctx, registryId)
	return err
}

// ListPrinters converts echo context to params.
func (w *ServerInterfaceWrapper) ListPrinters(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "registry_id" -------------
	var registryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, ctx.Param("registry_id"), &registryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registry_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPrintersParams
	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListPrinters(ctx, registryId, params)
	return err
}

// ListLabelTemplates converts echo context to params.
func (w *ServerInterfaceWrapper) ListLabelTemplates(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "registry_id" -------------
	var registryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, ctx.Param("registry_id"), &registryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registry_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListLabelTemplatesParams
	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListLabelTemplates(ctx, registryId, params)
	return err
}

// ListLocationSchemasByRegistry converts echo context to params.
func (w *ServerInterfaceWrapper) ListLocationSchemasByRegistry(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "registry_id" -------------
	var registryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, ctx.Param("registry_id"), &registryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registry_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListLocationSchemasByRegistry(ctx, registryId)
	return err
}

// ListPlateSchemasByRegistry converts echo context to params.
func (w *ServerInterfaceWrapper) ListPlateSchemasByRegistry(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "registry_id" -------------
	var registryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, ctx.Param("registry_id"), &registryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registry_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListPlateSchemasByRegistry(ctx, registryId)
	return err
}

// BulkGetRegisteredEntities converts echo context to params.
func (w *ServerInterfaceWrapper) BulkGetRegisteredEntities(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "registry_id" -------------
	var registryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, ctx.Param("registry_id"), &registryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registry_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BulkGetRegisteredEntitiesParams
	// ------------- Required query parameter "entityRegistryIds" -------------

	err = runtime.BindQueryParameter("form", true, true, "entityRegistryIds", ctx.QueryParams(), &params.EntityRegistryIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityRegistryIds: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkGetRegisteredEntities(ctx, registryId, params)
	return err
}

// RegisterEntities converts echo context to params.
func (w *ServerInterfaceWrapper) RegisterEntities(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "registry_id" -------------
	var registryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, ctx.Param("registry_id"), &registryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registry_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.RegisterEntities(ctx, registryId)
	return err
}

// UnregisterEntities converts echo context to params.
func (w *ServerInterfaceWrapper) UnregisterEntities(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "registry_id" -------------
	var registryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, ctx.Param("registry_id"), &registryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registry_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnregisterEntities(ctx, registryId)
	return err
}

// ValidateBarcodes converts echo context to params.
func (w *ServerInterfaceWrapper) ValidateBarcodes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "registry_id" -------------
	var registryId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "registry_id", runtime.ParamLocationPath, ctx.Param("registry_id"), &registryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registry_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ValidateBarcodes(ctx, registryId)
	return err
}

// ListRequestFulfillments converts echo context to params.
func (w *ServerInterfaceWrapper) ListRequestFulfillments(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRequestFulfillmentsParams
	// ------------- Required query parameter "entryId" -------------

	err = runtime.BindQueryParameter("form", true, true, "entryId", ctx.QueryParams(), &params.EntryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entryId: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListRequestFulfillments(ctx, params)
	return err
}

// GetRequestFulfillment converts echo context to params.
func (w *ServerInterfaceWrapper) GetRequestFulfillment(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "request_fulfillment_id" -------------
	var requestFulfillmentId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "request_fulfillment_id", runtime.ParamLocationPath, ctx.Param("request_fulfillment_id"), &requestFulfillmentId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter request_fulfillment_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRequestFulfillment(ctx, requestFulfillmentId)
	return err
}

// ListRequestSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) ListRequestSchemas(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRequestSchemasParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListRequestSchemas(ctx, params)
	return err
}

// GetRequestSchema converts echo context to params.
func (w *ServerInterfaceWrapper) GetRequestSchema(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "schema_id" -------------
	var schemaId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, ctx.Param("schema_id"), &schemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRequestSchema(ctx, schemaId)
	return err
}

// ListRequestTaskSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) ListRequestTaskSchemas(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRequestTaskSchemasParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListRequestTaskSchemas(ctx, params)
	return err
}

// GetRequestTaskSchema converts echo context to params.
func (w *ServerInterfaceWrapper) GetRequestTaskSchema(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "schema_id" -------------
	var schemaId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, ctx.Param("schema_id"), &schemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRequestTaskSchema(ctx, schemaId)
	return err
}

// ListRequests converts echo context to params.
func (w *ServerInterfaceWrapper) ListRequests(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRequestsParams
	// ------------- Required query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, true, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "requestStatus" -------------

	err = runtime.BindQueryParameter("form", true, false, "requestStatus", ctx.QueryParams(), &params.RequestStatus)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter requestStatus: %s", err))
	}

	// ------------- Optional query parameter "minCreatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "minCreatedTime", ctx.QueryParams(), &params.MinCreatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter minCreatedTime: %s", err))
	}

	// ------------- Optional query parameter "maxCreatedTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "maxCreatedTime", ctx.QueryParams(), &params.MaxCreatedTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter maxCreatedTime: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListRequests(ctx, params)
	return err
}

// CreateRequest converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRequest(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateRequest(ctx)
	return err
}

// GetRequest converts echo context to params.
func (w *ServerInterfaceWrapper) GetRequest(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "request_id" -------------
	var requestId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "request_id", runtime.ParamLocationPath, ctx.Param("request_id"), &requestId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter request_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRequestParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRequest(ctx, requestId, params)
	return err
}

// PatchRequest converts echo context to params.
func (w *ServerInterfaceWrapper) PatchRequest(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "request_id" -------------
	var requestId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "request_id", runtime.ParamLocationPath, ctx.Param("request_id"), &requestId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter request_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PatchRequest(ctx, requestId)
	return err
}

// GetRequestResponse converts echo context to params.
func (w *ServerInterfaceWrapper) GetRequestResponse(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "request_id" -------------
	var requestId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "request_id", runtime.ParamLocationPath, ctx.Param("request_id"), &requestId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter request_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRequestResponse(ctx, requestId)
	return err
}

// BulkCreateRequestTasks converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateRequestTasks(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "request_id" -------------
	var requestId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "request_id", runtime.ParamLocationPath, ctx.Param("request_id"), &requestId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter request_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateRequestTasks(ctx, requestId)
	return err
}

// BulkUpdateRequestTasks converts echo context to params.
func (w *ServerInterfaceWrapper) BulkUpdateRequestTasks(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "request_id" -------------
	var requestId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "request_id", runtime.ParamLocationPath, ctx.Param("request_id"), &requestId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter request_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkUpdateRequestTasks(ctx, requestId)
	return err
}

// ExecuteRequestsSampleGroups converts echo context to params.
func (w *ServerInterfaceWrapper) ExecuteRequestsSampleGroups(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "request_id" -------------
	var requestId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "request_id", runtime.ParamLocationPath, ctx.Param("request_id"), &requestId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter request_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ExecuteRequestsSampleGroups(ctx, requestId)
	return err
}

// BulkGetRequests converts echo context to params.
func (w *ServerInterfaceWrapper) BulkGetRequests(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BulkGetRequestsParams
	// ------------- Optional query parameter "requestIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "requestIds", ctx.QueryParams(), &params.RequestIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter requestIds: %s", err))
	}

	// ------------- Optional query parameter "displayIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "displayIds", ctx.QueryParams(), &params.DisplayIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter displayIds: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkGetRequests(ctx, params)
	return err
}

// CreateAssayResultsTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAssayResultsTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAssayResultsTransaction(ctx)
	return err
}

// CreateAssayResultsInTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) CreateAssayResultsInTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_id" -------------
	var transactionId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, ctx.Param("transaction_id"), &transactionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateAssayResultsInTransaction(ctx, transactionId)
	return err
}

// AbortAssayResultsTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) AbortAssayResultsTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_id" -------------
	var transactionId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, ctx.Param("transaction_id"), &transactionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AbortAssayResultsTransaction(ctx, transactionId)
	return err
}

// CommitAssayResultsTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) CommitAssayResultsTransaction(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "transaction_id" -------------
	var transactionId openapi_types.UUID

	err = runtime.BindStyledParameterWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, ctx.Param("transaction_id"), &transactionId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter transaction_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CommitAssayResultsTransaction(ctx, transactionId)
	return err
}

// ListRNAOligos converts echo context to params.
func (w *ServerInterfaceWrapper) ListRNAOligos(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRNAOligosParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "bases" -------------

	err = runtime.BindQueryParameter("form", true, false, "bases", ctx.QueryParams(), &params.Bases)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bases: %s", err))
	}

	// ------------- Optional query parameter "folderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "folderId", ctx.QueryParams(), &params.FolderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter folderId: %s", err))
	}

	// ------------- Optional query parameter "mentionedIn" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentionedIn", ctx.QueryParams(), &params.MentionedIn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentionedIn: %s", err))
	}

	// ------------- Optional query parameter "projectId" -------------

	err = runtime.BindQueryParameter("form", true, false, "projectId", ctx.QueryParams(), &params.ProjectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Optional query parameter "registryId" -------------

	err = runtime.BindQueryParameter("form", true, false, "registryId", ctx.QueryParams(), &params.RegistryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registryId: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "schemaFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaFields", ctx.QueryParams(), &params.SchemaFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaFields: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "mentions" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentions", ctx.QueryParams(), &params.Mentions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentions: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "entityRegistryIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityRegistryIds.anyOf", ctx.QueryParams(), &params.EntityRegistryIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityRegistryIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// ------------- Optional query parameter "authorIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "authorIds.anyOf", ctx.QueryParams(), &params.AuthorIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authorIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// ------------- Optional query parameter "customNotationId" -------------

	err = runtime.BindQueryParameter("form", true, false, "customNotationId", ctx.QueryParams(), &params.CustomNotationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter customNotationId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListRNAOligos(ctx, params)
	return err
}

// CreateRNAOligo converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRNAOligo(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateRNAOligo(ctx)
	return err
}

// GetRNAOligo converts echo context to params.
func (w *ServerInterfaceWrapper) GetRNAOligo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "oligo_id" -------------
	var oligoId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "oligo_id", runtime.ParamLocationPath, ctx.Param("oligo_id"), &oligoId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter oligo_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRNAOligoParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// ------------- Optional query parameter "customNotationId" -------------

	err = runtime.BindQueryParameter("form", true, false, "customNotationId", ctx.QueryParams(), &params.CustomNotationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter customNotationId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRNAOligo(ctx, oligoId, params)
	return err
}

// UpdateRNAOligo converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRNAOligo(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "oligo_id" -------------
	var oligoId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "oligo_id", runtime.ParamLocationPath, ctx.Param("oligo_id"), &oligoId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter oligo_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateRNAOligo(ctx, oligoId)
	return err
}

// ArchiveRNAOligos converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveRNAOligos(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveRNAOligos(ctx)
	return err
}

// BulkCreateRNAOligos converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateRNAOligos(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateRNAOligos(ctx)
	return err
}

// BulkUpdateRNAOligos converts echo context to params.
func (w *ServerInterfaceWrapper) BulkUpdateRNAOligos(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkUpdateRNAOligos(ctx)
	return err
}

// UnarchiveRNAOligos converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveRNAOligos(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveRNAOligos(ctx)
	return err
}

// ListRNASequences converts echo context to params.
func (w *ServerInterfaceWrapper) ListRNASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListRNASequencesParams
	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "bases" -------------

	err = runtime.BindQueryParameter("form", true, false, "bases", ctx.QueryParams(), &params.Bases)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter bases: %s", err))
	}

	// ------------- Optional query parameter "folderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "folderId", ctx.QueryParams(), &params.FolderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter folderId: %s", err))
	}

	// ------------- Optional query parameter "mentionedIn" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentionedIn", ctx.QueryParams(), &params.MentionedIn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentionedIn: %s", err))
	}

	// ------------- Optional query parameter "projectId" -------------

	err = runtime.BindQueryParameter("form", true, false, "projectId", ctx.QueryParams(), &params.ProjectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Optional query parameter "registryId" -------------

	err = runtime.BindQueryParameter("form", true, false, "registryId", ctx.QueryParams(), &params.RegistryId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter registryId: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "schemaFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaFields", ctx.QueryParams(), &params.SchemaFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaFields: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// ------------- Optional query parameter "mentions" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentions", ctx.QueryParams(), &params.Mentions)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentions: %s", err))
	}

	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "entityRegistryIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "entityRegistryIds.anyOf", ctx.QueryParams(), &params.EntityRegistryIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter entityRegistryIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// ------------- Optional query parameter "authorIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "authorIds.anyOf", ctx.QueryParams(), &params.AuthorIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter authorIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "customNotationId" -------------

	err = runtime.BindQueryParameter("form", true, false, "customNotationId", ctx.QueryParams(), &params.CustomNotationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter customNotationId: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListRNASequences(ctx, params)
	return err
}

// CreateRNASequence converts echo context to params.
func (w *ServerInterfaceWrapper) CreateRNASequence(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateRNASequence(ctx)
	return err
}

// GetRNASequence converts echo context to params.
func (w *ServerInterfaceWrapper) GetRNASequence(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "rna_sequence_id" -------------
	var rnaSequenceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "rna_sequence_id", runtime.ParamLocationPath, ctx.Param("rna_sequence_id"), &rnaSequenceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rna_sequence_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetRNASequenceParams
	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// ------------- Optional query parameter "customNotationId" -------------

	err = runtime.BindQueryParameter("form", true, false, "customNotationId", ctx.QueryParams(), &params.CustomNotationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter customNotationId: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetRNASequence(ctx, rnaSequenceId, params)
	return err
}

// UpdateRNASequence converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRNASequence(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "rna_sequence_id" -------------
	var rnaSequenceId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "rna_sequence_id", runtime.ParamLocationPath, ctx.Param("rna_sequence_id"), &rnaSequenceId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rna_sequence_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateRNASequence(ctx, rnaSequenceId)
	return err
}

// ArchiveRNASequences converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveRNASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveRNASequences(ctx)
	return err
}

// AutoAnnotateRnaSequences converts echo context to params.
func (w *ServerInterfaceWrapper) AutoAnnotateRnaSequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AutoAnnotateRnaSequences(ctx)
	return err
}

// AutofillRNASequenceParts converts echo context to params.
func (w *ServerInterfaceWrapper) AutofillRNASequenceParts(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AutofillRNASequenceParts(ctx)
	return err
}

// AutofillRNASequenceTranslations converts echo context to params.
func (w *ServerInterfaceWrapper) AutofillRNASequenceTranslations(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AutofillRNASequenceTranslations(ctx)
	return err
}

// BulkCreateRNASequences converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateRNASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateRNASequences(ctx)
	return err
}

// BulkGetRNASequences converts echo context to params.
func (w *ServerInterfaceWrapper) BulkGetRNASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params BulkGetRNASequencesParams
	// ------------- Required query parameter "rnaSequenceIds" -------------

	err = runtime.BindQueryParameter("form", true, true, "rnaSequenceIds", ctx.QueryParams(), &params.RnaSequenceIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rnaSequenceIds: %s", err))
	}

	// ------------- Optional query parameter "returning" -------------

	err = runtime.BindQueryParameter("form", true, false, "returning", ctx.QueryParams(), &params.Returning)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter returning: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkGetRNASequences(ctx, params)
	return err
}

// BulkUpdateRNASequences converts echo context to params.
func (w *ServerInterfaceWrapper) BulkUpdateRNASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkUpdateRNASequences(ctx)
	return err
}

// MatchBasesRnaSequences converts echo context to params.
func (w *ServerInterfaceWrapper) MatchBasesRnaSequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.MatchBasesRnaSequences(ctx)
	return err
}

// SearchRnaSequences converts echo context to params.
func (w *ServerInterfaceWrapper) SearchRnaSequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SearchRnaSequences(ctx)
	return err
}

// UnarchiveRNASequences converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveRNASequences(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveRNASequences(ctx)
	return err
}

// GetTask converts echo context to params.
func (w *ServerInterfaceWrapper) GetTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "task_id" -------------
	var taskId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "task_id", runtime.ParamLocationPath, ctx.Param("task_id"), &taskId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter task_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTask(ctx, taskId)
	return err
}

// ListTeams converts echo context to params.
func (w *ServerInterfaceWrapper) ListTeams(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListTeamsParams
	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "mentionedIn" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentionedIn", ctx.QueryParams(), &params.MentionedIn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentionedIn: %s", err))
	}

	// ------------- Optional query parameter "organizationId" -------------

	err = runtime.BindQueryParameter("form", true, false, "organizationId", ctx.QueryParams(), &params.OrganizationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter organizationId: %s", err))
	}

	// ------------- Optional query parameter "hasMembers" -------------

	err = runtime.BindQueryParameter("form", true, false, "hasMembers", ctx.QueryParams(), &params.HasMembers)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hasMembers: %s", err))
	}

	// ------------- Optional query parameter "hasAdmins" -------------

	err = runtime.BindQueryParameter("form", true, false, "hasAdmins", ctx.QueryParams(), &params.HasAdmins)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hasAdmins: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListTeams(ctx, params)
	return err
}

// GetTeam converts echo context to params.
func (w *ServerInterfaceWrapper) GetTeam(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "team_id" -------------
	var teamId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "team_id", runtime.ParamLocationPath, ctx.Param("team_id"), &teamId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter team_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTeam(ctx, teamId)
	return err
}

// GenerateToken converts echo context to params.
func (w *ServerInterfaceWrapper) GenerateToken(ctx echo.Context) error {
	var err error

	ctx.Set(BasicClientIdSecretAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GenerateToken(ctx)
	return err
}

// TransferIntoContainers converts echo context to params.
func (w *ServerInterfaceWrapper) TransferIntoContainers(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransferIntoContainers(ctx)
	return err
}

// ListUsers converts echo context to params.
func (w *ServerInterfaceWrapper) ListUsers(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListUsersParams
	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf", ctx.QueryParams(), &params.NamesAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf: %s", err))
	}

	// ------------- Optional query parameter "names.anyOf.caseSensitive" -------------

	err = runtime.BindQueryParameter("form", true, false, "names.anyOf.caseSensitive", ctx.QueryParams(), &params.NamesAnyOfCaseSensitive)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter names.anyOf.caseSensitive: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "memberOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "memberOf", ctx.QueryParams(), &params.MemberOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter memberOf: %s", err))
	}

	// ------------- Optional query parameter "adminOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "adminOf", ctx.QueryParams(), &params.AdminOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter adminOf: %s", err))
	}

	// ------------- Optional query parameter "handles" -------------

	err = runtime.BindQueryParameter("form", true, false, "handles", ctx.QueryParams(), &params.Handles)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter handles: %s", err))
	}

	// ------------- Optional query parameter "email.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "email.anyOf", ctx.QueryParams(), &params.EmailAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter email.anyOf: %s", err))
	}

	// ------------- Optional query parameter "passwordLastChangedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "passwordLastChangedAt", ctx.QueryParams(), &params.PasswordLastChangedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter passwordLastChangedAt: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListUsers(ctx, params)
	return err
}

// CreateUser converts echo context to params.
func (w *ServerInterfaceWrapper) CreateUser(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateUser(ctx)
	return err
}

// GetUser converts echo context to params.
func (w *ServerInterfaceWrapper) GetUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "user_id" -------------
	var userId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "user_id", runtime.ParamLocationPath, ctx.Param("user_id"), &userId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUser(ctx, userId)
	return err
}

// UpdateUser converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUser(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "user_id" -------------
	var userId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "user_id", runtime.ParamLocationPath, ctx.Param("user_id"), &userId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateUser(ctx, userId)
	return err
}

// GetUserActivity converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserActivity(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "user_id" -------------
	var userId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "user_id", runtime.ParamLocationPath, ctx.Param("user_id"), &userId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetUserActivity(ctx, userId)
	return err
}

// BulkCreateUsers converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateUsers(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateUsers(ctx)
	return err
}

// BulkUpdateUsers converts echo context to params.
func (w *ServerInterfaceWrapper) BulkUpdateUsers(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkUpdateUsers(ctx)
	return err
}

// CreateWarehouseCredentials converts echo context to params.
func (w *ServerInterfaceWrapper) CreateWarehouseCredentials(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateWarehouseCredentials(ctx)
	return err
}

// ListWorkflowOutputs converts echo context to params.
func (w *ServerInterfaceWrapper) ListWorkflowOutputs(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListWorkflowOutputsParams
	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "workflowTaskGroupIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "workflowTaskGroupIds", ctx.QueryParams(), &params.WorkflowTaskGroupIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workflowTaskGroupIds: %s", err))
	}

	// ------------- Optional query parameter "workflowTaskIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "workflowTaskIds", ctx.QueryParams(), &params.WorkflowTaskIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workflowTaskIds: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "watcherIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "watcherIds", ctx.QueryParams(), &params.WatcherIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter watcherIds: %s", err))
	}

	// ------------- Optional query parameter "responsibleTeamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "responsibleTeamIds", ctx.QueryParams(), &params.ResponsibleTeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter responsibleTeamIds: %s", err))
	}

	// ------------- Optional query parameter "creationOriginIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creationOriginIds", ctx.QueryParams(), &params.CreationOriginIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creationOriginIds: %s", err))
	}

	// ------------- Optional query parameter "linkedItemIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "linkedItemIds.anyOf", ctx.QueryParams(), &params.LinkedItemIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter linkedItemIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "linkedItemIds.allOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "linkedItemIds.allOf", ctx.QueryParams(), &params.LinkedItemIdsAllOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter linkedItemIds.allOf: %s", err))
	}

	// ------------- Optional query parameter "linkedItemIds.noneOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "linkedItemIds.noneOf", ctx.QueryParams(), &params.LinkedItemIdsNoneOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter linkedItemIds.noneOf: %s", err))
	}

	// ------------- Optional query parameter "schemaFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaFields", ctx.QueryParams(), &params.SchemaFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaFields: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "displayIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "displayIds", ctx.QueryParams(), &params.DisplayIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter displayIds: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListWorkflowOutputs(ctx, params)
	return err
}

// CreateWorkflowOutput converts echo context to params.
func (w *ServerInterfaceWrapper) CreateWorkflowOutput(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateWorkflowOutput(ctx)
	return err
}

// GetWorkflowOutput converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkflowOutput(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workflow_output_id" -------------
	var workflowOutputId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workflow_output_id", runtime.ParamLocationPath, ctx.Param("workflow_output_id"), &workflowOutputId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workflow_output_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkflowOutput(ctx, workflowOutputId)
	return err
}

// UpdateWorkflowOutput converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateWorkflowOutput(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workflow_output_id" -------------
	var workflowOutputId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workflow_output_id", runtime.ParamLocationPath, ctx.Param("workflow_output_id"), &workflowOutputId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workflow_output_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateWorkflowOutput(ctx, workflowOutputId)
	return err
}

// ArchiveWorkflowOutputs converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveWorkflowOutputs(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveWorkflowOutputs(ctx)
	return err
}

// BulkCreateWorkflowOutputs converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateWorkflowOutputs(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateWorkflowOutputs(ctx)
	return err
}

// BulkUpdateWorkflowOutputs converts echo context to params.
func (w *ServerInterfaceWrapper) BulkUpdateWorkflowOutputs(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkUpdateWorkflowOutputs(ctx)
	return err
}

// UnarchiveWorkflowOutputs converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveWorkflowOutputs(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveWorkflowOutputs(ctx)
	return err
}

// ListStageRunInputSamples converts echo context to params.
func (w *ServerInterfaceWrapper) ListStageRunInputSamples(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stage_run_id" -------------
	var stageRunId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "stage_run_id", runtime.ParamLocationPath, ctx.Param("stage_run_id"), &stageRunId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stage_run_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListStageRunInputSamples(ctx, stageRunId)
	return err
}

// ListStageRunOutputSamples converts echo context to params.
func (w *ServerInterfaceWrapper) ListStageRunOutputSamples(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stage_run_id" -------------
	var stageRunId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "stage_run_id", runtime.ParamLocationPath, ctx.Param("stage_run_id"), &stageRunId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stage_run_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListStageRunOutputSamples(ctx, stageRunId)
	return err
}

// ListStageRunRegisteredSamples converts echo context to params.
func (w *ServerInterfaceWrapper) ListStageRunRegisteredSamples(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stage_run_id" -------------
	var stageRunId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "stage_run_id", runtime.ParamLocationPath, ctx.Param("stage_run_id"), &stageRunId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stage_run_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListStageRunRegisteredSamples(ctx, stageRunId)
	return err
}

// ListWorkflowStageRuns converts echo context to params.
func (w *ServerInterfaceWrapper) ListWorkflowStageRuns(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "stage_id" -------------
	var stageId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "stage_id", runtime.ParamLocationPath, ctx.Param("stage_id"), &stageId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter stage_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListWorkflowStageRuns(ctx, stageId)
	return err
}

// ListWorkflowTaskGroups converts echo context to params.
func (w *ServerInterfaceWrapper) ListWorkflowTaskGroups(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListWorkflowTaskGroupsParams
	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "folderId" -------------

	err = runtime.BindQueryParameter("form", true, false, "folderId", ctx.QueryParams(), &params.FolderId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter folderId: %s", err))
	}

	// ------------- Optional query parameter "projectId" -------------

	err = runtime.BindQueryParameter("form", true, false, "projectId", ctx.QueryParams(), &params.ProjectId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter projectId: %s", err))
	}

	// ------------- Optional query parameter "mentionedIn" -------------

	err = runtime.BindQueryParameter("form", true, false, "mentionedIn", ctx.QueryParams(), &params.MentionedIn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter mentionedIn: %s", err))
	}

	// ------------- Optional query parameter "watcherIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "watcherIds", ctx.QueryParams(), &params.WatcherIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter watcherIds: %s", err))
	}

	// ------------- Optional query parameter "executionTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "executionTypes", ctx.QueryParams(), &params.ExecutionTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter executionTypes: %s", err))
	}

	// ------------- Optional query parameter "responsibleTeamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "responsibleTeamIds", ctx.QueryParams(), &params.ResponsibleTeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter responsibleTeamIds: %s", err))
	}

	// ------------- Optional query parameter "statusIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "statusIds.anyOf", ctx.QueryParams(), &params.StatusIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statusIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "statusIds.noneOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "statusIds.noneOf", ctx.QueryParams(), &params.StatusIdsNoneOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statusIds.noneOf: %s", err))
	}

	// ------------- Optional query parameter "statusIds.only" -------------

	err = runtime.BindQueryParameter("form", true, false, "statusIds.only", ctx.QueryParams(), &params.StatusIdsOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statusIds.only: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "displayIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "displayIds", ctx.QueryParams(), &params.DisplayIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter displayIds: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListWorkflowTaskGroups(ctx, params)
	return err
}

// CreateWorkflowTaskGroup converts echo context to params.
func (w *ServerInterfaceWrapper) CreateWorkflowTaskGroup(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateWorkflowTaskGroup(ctx)
	return err
}

// GetWorkflowTaskGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkflowTaskGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workflow_task_group_id" -------------
	var workflowTaskGroupId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workflow_task_group_id", runtime.ParamLocationPath, ctx.Param("workflow_task_group_id"), &workflowTaskGroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workflow_task_group_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkflowTaskGroup(ctx, workflowTaskGroupId)
	return err
}

// UpdateWorkflowTaskGroup converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateWorkflowTaskGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workflow_task_group_id" -------------
	var workflowTaskGroupId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workflow_task_group_id", runtime.ParamLocationPath, ctx.Param("workflow_task_group_id"), &workflowTaskGroupId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workflow_task_group_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateWorkflowTaskGroup(ctx, workflowTaskGroupId)
	return err
}

// ArchiveWorkflowTaskGroups converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveWorkflowTaskGroups(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveWorkflowTaskGroups(ctx)
	return err
}

// UnarchiveWorkflowTaskGroups converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveWorkflowTaskGroups(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveWorkflowTaskGroups(ctx)
	return err
}

// ListWorkflowTaskSchemas converts echo context to params.
func (w *ServerInterfaceWrapper) ListWorkflowTaskSchemas(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListWorkflowTaskSchemasParams
	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListWorkflowTaskSchemas(ctx, params)
	return err
}

// GetWorkflowTaskSchema converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkflowTaskSchema(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "schema_id" -------------
	var schemaId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "schema_id", runtime.ParamLocationPath, ctx.Param("schema_id"), &schemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schema_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkflowTaskSchema(ctx, schemaId)
	return err
}

// ListWorkflowTasks converts echo context to params.
func (w *ServerInterfaceWrapper) ListWorkflowTasks(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params ListWorkflowTasksParams
	// ------------- Optional query parameter "ids" -------------

	err = runtime.BindQueryParameter("form", true, false, "ids", ctx.QueryParams(), &params.Ids)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ids: %s", err))
	}

	// ------------- Optional query parameter "workflowTaskGroupIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "workflowTaskGroupIds", ctx.QueryParams(), &params.WorkflowTaskGroupIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workflowTaskGroupIds: %s", err))
	}

	// ------------- Optional query parameter "schemaId" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaId", ctx.QueryParams(), &params.SchemaId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaId: %s", err))
	}

	// ------------- Optional query parameter "statusIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "statusIds", ctx.QueryParams(), &params.StatusIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter statusIds: %s", err))
	}

	// ------------- Optional query parameter "assigneeIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "assigneeIds", ctx.QueryParams(), &params.AssigneeIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter assigneeIds: %s", err))
	}

	// ------------- Optional query parameter "watcherIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "watcherIds", ctx.QueryParams(), &params.WatcherIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter watcherIds: %s", err))
	}

	// ------------- Optional query parameter "responsibleTeamIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "responsibleTeamIds", ctx.QueryParams(), &params.ResponsibleTeamIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter responsibleTeamIds: %s", err))
	}

	// ------------- Optional query parameter "executionOriginIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "executionOriginIds", ctx.QueryParams(), &params.ExecutionOriginIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter executionOriginIds: %s", err))
	}

	// ------------- Optional query parameter "executionTypes" -------------

	err = runtime.BindQueryParameter("form", true, false, "executionTypes", ctx.QueryParams(), &params.ExecutionTypes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter executionTypes: %s", err))
	}

	// ------------- Optional query parameter "linkedItemIds.anyOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "linkedItemIds.anyOf", ctx.QueryParams(), &params.LinkedItemIdsAnyOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter linkedItemIds.anyOf: %s", err))
	}

	// ------------- Optional query parameter "linkedItemIds.allOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "linkedItemIds.allOf", ctx.QueryParams(), &params.LinkedItemIdsAllOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter linkedItemIds.allOf: %s", err))
	}

	// ------------- Optional query parameter "linkedItemIds.noneOf" -------------

	err = runtime.BindQueryParameter("form", true, false, "linkedItemIds.noneOf", ctx.QueryParams(), &params.LinkedItemIdsNoneOf)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter linkedItemIds.noneOf: %s", err))
	}

	// ------------- Optional query parameter "schemaFields" -------------

	err = runtime.BindQueryParameter("form", true, false, "schemaFields", ctx.QueryParams(), &params.SchemaFields)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter schemaFields: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "nameIncludes" -------------

	err = runtime.BindQueryParameter("form", true, false, "nameIncludes", ctx.QueryParams(), &params.NameIncludes)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nameIncludes: %s", err))
	}

	// ------------- Optional query parameter "creatorIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "creatorIds", ctx.QueryParams(), &params.CreatorIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creatorIds: %s", err))
	}

	// ------------- Optional query parameter "scheduledOn" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheduledOn", ctx.QueryParams(), &params.ScheduledOn)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduledOn: %s", err))
	}

	// ------------- Optional query parameter "scheduledOn.lt" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheduledOn.lt", ctx.QueryParams(), &params.ScheduledOnLt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduledOn.lt: %s", err))
	}

	// ------------- Optional query parameter "scheduledOn.lte" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheduledOn.lte", ctx.QueryParams(), &params.ScheduledOnLte)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduledOn.lte: %s", err))
	}

	// ------------- Optional query parameter "scheduledOn.gte" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheduledOn.gte", ctx.QueryParams(), &params.ScheduledOnGte)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduledOn.gte: %s", err))
	}

	// ------------- Optional query parameter "scheduledOn.gt" -------------

	err = runtime.BindQueryParameter("form", true, false, "scheduledOn.gt", ctx.QueryParams(), &params.ScheduledOnGt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter scheduledOn.gt: %s", err))
	}

	// ------------- Optional query parameter "modifiedAt" -------------

	err = runtime.BindQueryParameter("form", true, false, "modifiedAt", ctx.QueryParams(), &params.ModifiedAt)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter modifiedAt: %s", err))
	}

	// ------------- Optional query parameter "nextToken" -------------

	err = runtime.BindQueryParameter("form", true, false, "nextToken", ctx.QueryParams(), &params.NextToken)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter nextToken: %s", err))
	}

	// ------------- Optional query parameter "pageSize" -------------

	err = runtime.BindQueryParameter("form", true, false, "pageSize", ctx.QueryParams(), &params.PageSize)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter pageSize: %s", err))
	}

	// ------------- Optional query parameter "displayIds" -------------

	err = runtime.BindQueryParameter("form", true, false, "displayIds", ctx.QueryParams(), &params.DisplayIds)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter displayIds: %s", err))
	}

	// ------------- Optional query parameter "archiveReason" -------------

	err = runtime.BindQueryParameter("form", true, false, "archiveReason", ctx.QueryParams(), &params.ArchiveReason)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter archiveReason: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListWorkflowTasks(ctx, params)
	return err
}

// CreateWorkflowTask converts echo context to params.
func (w *ServerInterfaceWrapper) CreateWorkflowTask(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CreateWorkflowTask(ctx)
	return err
}

// GetWorkflowTask converts echo context to params.
func (w *ServerInterfaceWrapper) GetWorkflowTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workflow_task_id" -------------
	var workflowTaskId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workflow_task_id", runtime.ParamLocationPath, ctx.Param("workflow_task_id"), &workflowTaskId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workflow_task_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetWorkflowTask(ctx, workflowTaskId)
	return err
}

// UpdateWorkflowTask converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateWorkflowTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workflow_task_id" -------------
	var workflowTaskId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workflow_task_id", runtime.ParamLocationPath, ctx.Param("workflow_task_id"), &workflowTaskId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workflow_task_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateWorkflowTask(ctx, workflowTaskId)
	return err
}

// CopyWorkflowTask converts echo context to params.
func (w *ServerInterfaceWrapper) CopyWorkflowTask(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workflow_task_id" -------------
	var workflowTaskId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workflow_task_id", runtime.ParamLocationPath, ctx.Param("workflow_task_id"), &workflowTaskId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workflow_task_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.CopyWorkflowTask(ctx, workflowTaskId)
	return err
}

// ArchiveWorkflowTasks converts echo context to params.
func (w *ServerInterfaceWrapper) ArchiveWorkflowTasks(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ArchiveWorkflowTasks(ctx)
	return err
}

// BulkCopyWorkflowTasks converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCopyWorkflowTasks(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCopyWorkflowTasks(ctx)
	return err
}

// BulkCreateWorkflowTasks converts echo context to params.
func (w *ServerInterfaceWrapper) BulkCreateWorkflowTasks(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkCreateWorkflowTasks(ctx)
	return err
}

// BulkUpdateWorkflowTasks converts echo context to params.
func (w *ServerInterfaceWrapper) BulkUpdateWorkflowTasks(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.BulkUpdateWorkflowTasks(ctx)
	return err
}

// UnarchiveWorkflowTasks converts echo context to params.
func (w *ServerInterfaceWrapper) UnarchiveWorkflowTasks(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UnarchiveWorkflowTasks(ctx)
	return err
}

// ListWorkflows converts echo context to params.
func (w *ServerInterfaceWrapper) ListWorkflows(ctx echo.Context) error {
	var err error

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListWorkflows(ctx)
	return err
}

// UpdateWorkflowMetadata converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateWorkflowMetadata(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workflow_id" -------------
	var workflowId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, ctx.Param("workflow_id"), &workflowId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workflow_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.UpdateWorkflowMetadata(ctx, workflowId)
	return err
}

// ListWorkflowStages converts echo context to params.
func (w *ServerInterfaceWrapper) ListWorkflowStages(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "workflow_id" -------------
	var workflowId string

	err = runtime.BindStyledParameterWithLocation("simple", false, "workflow_id", runtime.ParamLocationPath, ctx.Param("workflow_id"), &workflowId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter workflow_id: %s", err))
	}

	ctx.Set(OAuthScopes, []string{})

	ctx.Set(BasicApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.ListWorkflowStages(ctx, workflowId)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/aa-sequences", wrapper.ListAASequences)
	router.POST(baseURL+"/aa-sequences", wrapper.CreateAASequence)
	router.GET(baseURL+"/aa-sequences/:aa_sequence_id", wrapper.GetAASequence)
	router.PATCH(baseURL+"/aa-sequences/:aa_sequence_id", wrapper.UpdateAASequence)
	router.POST(baseURL+"/aa-sequences:archive", wrapper.ArchiveAASequences)
	router.POST(baseURL+"/aa-sequences:auto-annotate", wrapper.AutoAnnotateAaSequences)
	router.POST(baseURL+"/aa-sequences:bulk-create", wrapper.BulkCreateAASequences)
	router.GET(baseURL+"/aa-sequences:bulk-get", wrapper.BulkGetAASequences)
	router.POST(baseURL+"/aa-sequences:bulk-update", wrapper.BulkUpdateAASequences)
	router.POST(baseURL+"/aa-sequences:unarchive", wrapper.UnarchiveAASequences)
	router.POST(baseURL+"/app-canvases", wrapper.CreateAppCanvas)
	router.GET(baseURL+"/app-canvases/:canvas_id", wrapper.GetAppCanvas)
	router.PATCH(baseURL+"/app-canvases/:canvas_id", wrapper.UpdateAppCanvas)
	router.POST(baseURL+"/app-canvases:archive", wrapper.ArchiveAppCanvases)
	router.POST(baseURL+"/app-canvases:unarchive", wrapper.UnarchiveAppCanvases)
	router.GET(baseURL+"/app-configuration-items", wrapper.ListAppConfigurationItems)
	router.POST(baseURL+"/app-configuration-items", wrapper.CreateAppConfigurationItem)
	router.GET(baseURL+"/app-configuration-items/:item_id", wrapper.GetAppConfigurationItemById)
	router.PATCH(baseURL+"/app-configuration-items/:item_id", wrapper.UpdateAppConfigurationItem)
	router.POST(baseURL+"/app-configuration-items:bulk-create", wrapper.BulkCreateAppConfigurationItems)
	router.POST(baseURL+"/app-configuration-items:bulk-update", wrapper.BulkUpdateAppConfigurationItems)
	router.POST(baseURL+"/app-sessions", wrapper.CreateAppSession)
	router.GET(baseURL+"/app-sessions/:id", wrapper.GetAppSessionById)
	router.PATCH(baseURL+"/app-sessions/:id", wrapper.UpdateAppSession)
	router.GET(baseURL+"/apps", wrapper.ListBenchlingApps)
	router.POST(baseURL+"/apps", wrapper.CreateBenchlingApp)
	router.GET(baseURL+"/apps/:app_id", wrapper.GetBenchlingAppByID)
	router.PATCH(baseURL+"/apps/:app_id", wrapper.PatchBenchlingApp)
	router.POST(baseURL+"/apps:archive", wrapper.ArchiveBenchlingApps)
	router.POST(baseURL+"/apps:unarchive", wrapper.UnarchiveBenchlingApps)
	router.GET(baseURL+"/assay-result-schemas", wrapper.ListAssayResultSchemas)
	router.GET(baseURL+"/assay-result-schemas/:schema_id", wrapper.GetResultSchema)
	router.GET(baseURL+"/assay-results", wrapper.ListAssayResults)
	router.POST(baseURL+"/assay-results", wrapper.CreateAssayResults)
	router.GET(baseURL+"/assay-results/:assay_result_id", wrapper.GetAssayResult)
	router.POST(baseURL+"/assay-results:archive", wrapper.ArchiveAssayResults)
	router.POST(baseURL+"/assay-results:bulk-create", wrapper.BulkCreateAssayResults)
	router.GET(baseURL+"/assay-results:bulk-get", wrapper.BulkGetAssayResults)
	router.POST(baseURL+"/assay-results:unarchive", wrapper.UnarchiveAssayResults)
	router.GET(baseURL+"/assay-run-schemas", wrapper.ListAssayRunSchemas)
	router.GET(baseURL+"/assay-run-schemas/:schema_id", wrapper.GetRunSchema)
	router.GET(baseURL+"/assay-runs", wrapper.ListAssayRuns)
	router.POST(baseURL+"/assay-runs", wrapper.CreateAssayRuns)
	router.GET(baseURL+"/assay-runs/:assay_run_id", wrapper.GetAssayRun)
	router.PATCH(baseURL+"/assay-runs/:assay_run_id", wrapper.UpdateAssayRun)
	router.GET(baseURL+"/assay-runs/:assay_run_id/automation-input-generators", wrapper.ListAutomationInputGenerators)
	router.GET(baseURL+"/assay-runs/:assay_run_id/automation-output-processors", wrapper.ListAutomationOutputProcessorsDeprecated)
	router.POST(baseURL+"/assay-runs:archive", wrapper.ArchiveAssayRuns)
	router.GET(baseURL+"/assay-runs:bulk-get", wrapper.BulkGetAssayRuns)
	router.POST(baseURL+"/assay-runs:unarchive", wrapper.UnarchiveAssayRuns)
	router.GET(baseURL+"/automation-file-transforms/:transform_id", wrapper.GetLabAutomationTransform)
	router.PATCH(baseURL+"/automation-file-transforms/:transform_id", wrapper.UpdateLabAutomationTransform)
	router.GET(baseURL+"/automation-input-generators/:input_generator_id", wrapper.GetAutomationInputGenerator)
	router.PATCH(baseURL+"/automation-input-generators/:input_generator_id", wrapper.UpdateAutomationInputGenerator)
	router.POST(baseURL+"/automation-input-generators/:input_generator_id:generate-input", wrapper.GenerateInputWithAutomationInputGenerator)
	router.GET(baseURL+"/automation-output-processors", wrapper.ListAutomationOutputProcessors)
	router.POST(baseURL+"/automation-output-processors", wrapper.CreateAutomationOutputProcessor)
	router.GET(baseURL+"/automation-output-processors/:output_processor_id", wrapper.GetAutomationOutputProcessor)
	router.PATCH(baseURL+"/automation-output-processors/:output_processor_id", wrapper.UpdateAutomationOutputProcessor)
	router.POST(baseURL+"/automation-output-processors/:output_processor_id:process-output", wrapper.ProcessOutputWithAutomationOutputProcessor)
	router.POST(baseURL+"/automation-output-processors:archive", wrapper.ArchiveAutomationOutputProcessors)
	router.POST(baseURL+"/automation-output-processors:unarchive", wrapper.UnarchiveAutomationOutputProcessors)
	router.GET(baseURL+"/batch-schemas", wrapper.ListBatchSchemas)
	router.GET(baseURL+"/batch-schemas/:schema_id", wrapper.GetBatchSchema)
	router.GET(baseURL+"/batches", wrapper.ListBatches)
	router.POST(baseURL+"/batches", wrapper.CreateBatch)
	router.GET(baseURL+"/batches/:batch_id", wrapper.GetBatch)
	router.PATCH(baseURL+"/batches/:batch_id", wrapper.UpdateBatch)
	router.POST(baseURL+"/batches:archive", wrapper.ArchiveBatches)
	router.GET(baseURL+"/batches:bulk-get", wrapper.BulkGetBatches)
	router.POST(baseURL+"/batches:unarchive", wrapper.UnarchiveBatches)
	router.POST(baseURL+"/blobs", wrapper.CreateBlob)
	router.GET(baseURL+"/blobs/:blob_id", wrapper.GetBlob)
	router.GET(baseURL+"/blobs/:blob_id/download", wrapper.GetBlobFile)
	router.GET(baseURL+"/blobs/:blob_id/download-url", wrapper.GetBlobUrl)
	router.POST(baseURL+"/blobs/:blob_id/parts", wrapper.CreateBlobPart)
	router.POST(baseURL+"/blobs/:blob_id:abort-upload", wrapper.AbortMultipartBlob)
	router.POST(baseURL+"/blobs/:blob_id:complete-upload", wrapper.CompleteMultipartBlob)
	router.GET(baseURL+"/blobs:bulk-get", wrapper.BulkGetBlobs)
	router.POST(baseURL+"/blobs:start-multipart-upload", wrapper.CreateMultipartBlob)
	router.GET(baseURL+"/box-schemas", wrapper.ListBoxSchemas)
	router.GET(baseURL+"/box-schemas/:schema_id", wrapper.GetBoxSchema)
	router.GET(baseURL+"/boxes", wrapper.ListBoxes)
	router.POST(baseURL+"/boxes", wrapper.CreateBox)
	router.GET(baseURL+"/boxes/:box_id", wrapper.GetBox)
	router.PATCH(baseURL+"/boxes/:box_id", wrapper.UpdateBox)
	router.GET(baseURL+"/boxes/:box_id/contents", wrapper.ListBoxContents)
	router.POST(baseURL+"/boxes:archive", wrapper.ArchiveBoxes)
	router.GET(baseURL+"/boxes:bulk-get", wrapper.BulkGetBoxes)
	router.POST(baseURL+"/boxes:unarchive", wrapper.UnarchiveBoxes)
	router.GET(baseURL+"/container-schemas", wrapper.ListContainerSchemas)
	router.GET(baseURL+"/container-schemas/:schema_id", wrapper.GetContainerSchema)
	router.GET(baseURL+"/containers", wrapper.ListContainers)
	router.POST(baseURL+"/containers", wrapper.CreateContainer)
	router.GET(baseURL+"/containers/:container_id", wrapper.GetContainer)
	router.PATCH(baseURL+"/containers/:container_id", wrapper.UpdateContainer)
	router.GET(baseURL+"/containers/:container_id/contents", wrapper.ListContainerContents)
	router.DELETE(baseURL+"/containers/:container_id/contents/:containable_id", wrapper.DeleteContainerContent)
	router.GET(baseURL+"/containers/:container_id/contents/:containable_id", wrapper.GetContainerContent)
	router.PATCH(baseURL+"/containers/:container_id/contents/:containable_id", wrapper.UpdateContainerContent)
	router.POST(baseURL+"/containers/:destination_container_id:transfer", wrapper.TransferIntoContainer)
	router.POST(baseURL+"/containers:archive", wrapper.ArchiveContainers)
	router.POST(baseURL+"/containers:bulk-create", wrapper.BulkCreateContainers)
	router.GET(baseURL+"/containers:bulk-get", wrapper.BulkGetContainers)
	router.POST(baseURL+"/containers:bulk-update", wrapper.BulkUpdateContainers)
	router.POST(baseURL+"/containers:check-in", wrapper.CheckinContainers)
	router.POST(baseURL+"/containers:check-out", wrapper.CheckoutContainers)
	router.POST(baseURL+"/containers:print-labels", wrapper.PrintLabels)
	router.POST(baseURL+"/containers:reserve", wrapper.ReserveContainers)
	router.POST(baseURL+"/containers:unarchive", wrapper.UnarchiveContainers)
	router.GET(baseURL+"/custom-entities", wrapper.ListCustomEntities)
	router.POST(baseURL+"/custom-entities", wrapper.CreateCustomEntity)
	router.GET(baseURL+"/custom-entities/:custom_entity_id", wrapper.GetCustomEntity)
	router.PATCH(baseURL+"/custom-entities/:custom_entity_id", wrapper.UpdateCustomEntity)
	router.POST(baseURL+"/custom-entities:archive", wrapper.ArchiveCustomEntities)
	router.POST(baseURL+"/custom-entities:bulk-create", wrapper.BulkCreateCustomEntities)
	router.GET(baseURL+"/custom-entities:bulk-get", wrapper.BulkGetCustomEntities)
	router.POST(baseURL+"/custom-entities:bulk-update", wrapper.BulkUpdateCustomEntities)
	router.POST(baseURL+"/custom-entities:unarchive", wrapper.UnarchiveCustomEntities)
	router.GET(baseURL+"/custom-notations", wrapper.ListCustomNotations)
	router.GET(baseURL+"/dna-alignments", wrapper.ListDNAAlignments)
	router.DELETE(baseURL+"/dna-alignments/:dna_alignment_id", wrapper.DeleteDNAAlignment)
	router.GET(baseURL+"/dna-alignments/:dna_alignment_id", wrapper.GetDNAAlignment)
	router.POST(baseURL+"/dna-alignments:create-consensus-alignment", wrapper.CreateDnaConsensusAlignment)
	router.POST(baseURL+"/dna-alignments:create-template-alignment", wrapper.CreateDnaTemplateAlignment)
	router.GET(baseURL+"/dna-oligos", wrapper.ListDNAOligos)
	router.POST(baseURL+"/dna-oligos", wrapper.CreateDNAOligo)
	router.GET(baseURL+"/dna-oligos/:oligo_id", wrapper.GetDNAOligo)
	router.PATCH(baseURL+"/dna-oligos/:oligo_id", wrapper.UpdateDNAOligo)
	router.POST(baseURL+"/dna-oligos:archive", wrapper.ArchiveDNAOligos)
	router.POST(baseURL+"/dna-oligos:bulk-create", wrapper.BulkCreateDNAOligos)
	router.POST(baseURL+"/dna-oligos:bulk-update", wrapper.BulkUpdateDNAOligos)
	router.POST(baseURL+"/dna-oligos:unarchive", wrapper.UnarchiveDNAOligos)
	router.GET(baseURL+"/dna-sequences", wrapper.ListDNASequences)
	router.POST(baseURL+"/dna-sequences", wrapper.CreateDNASequence)
	router.GET(baseURL+"/dna-sequences/:dna_sequence_id", wrapper.GetDNASequence)
	router.PATCH(baseURL+"/dna-sequences/:dna_sequence_id", wrapper.UpdateDNASequence)
	router.POST(baseURL+"/dna-sequences:archive", wrapper.ArchiveDNASequences)
	router.POST(baseURL+"/dna-sequences:auto-annotate", wrapper.AutoAnnotateDnaSequences)
	router.POST(baseURL+"/dna-sequences:autofill-parts", wrapper.AutofillDNASequenceParts)
	router.POST(baseURL+"/dna-sequences:autofill-translations", wrapper.AutofillDNASequenceTranslations)
	router.POST(baseURL+"/dna-sequences:bulk-create", wrapper.BulkCreateDNASequences)
	router.GET(baseURL+"/dna-sequences:bulk-get", wrapper.BulkGetDNASequences)
	router.POST(baseURL+"/dna-sequences:bulk-update", wrapper.BulkUpdateDNASequences)
	router.POST(baseURL+"/dna-sequences:match-bases", wrapper.MatchBasesDnaSequences)
	router.POST(baseURL+"/dna-sequences:search-bases", wrapper.SearchDnaSequences)
	router.POST(baseURL+"/dna-sequences:unarchive", wrapper.UnarchiveDNASequences)
	router.GET(baseURL+"/dropdowns", wrapper.ListDropdowns)
	router.POST(baseURL+"/dropdowns", wrapper.CreateDropdown)
	router.GET(baseURL+"/dropdowns/:dropdown_id", wrapper.GetDropdown)
	router.PATCH(baseURL+"/dropdowns/:dropdown_id", wrapper.UpdateDropdown)
	router.POST(baseURL+"/dropdowns/:dropdown_id/options:archive", wrapper.ArchiveDropdownOptions)
	router.POST(baseURL+"/dropdowns/:dropdown_id/options:unarchive", wrapper.UnarchiveDropdownOptions)
	router.GET(baseURL+"/entities/:entity_id/batches", wrapper.GetEnitityBatches)
	router.GET(baseURL+"/entity-schemas", wrapper.ListEntitySchemas)
	router.GET(baseURL+"/entity-schemas/:schema_id", wrapper.GetEntitySchema)
	router.GET(baseURL+"/entries", wrapper.ListEntries)
	router.POST(baseURL+"/entries", wrapper.CreateEntry)
	router.GET(baseURL+"/entries/:entry_id", wrapper.GetEntry)
	router.PATCH(baseURL+"/entries/:entry_id", wrapper.UpdateEntry)
	router.GET(baseURL+"/entries/:entry_id/external-files/:external_file_id", wrapper.GetExternalFileMetadata)
	router.POST(baseURL+"/entries:archive", wrapper.ArchiveEntries)
	router.GET(baseURL+"/entries:bulk-get", wrapper.BulkGetEntries)
	router.POST(baseURL+"/entries:unarchive", wrapper.UnarchiveEntries)
	router.GET(baseURL+"/entry-schemas", wrapper.ListEntrySchemas)
	router.GET(baseURL+"/entry-schemas/:schema_id", wrapper.GetEntrySchema)
	router.GET(baseURL+"/entry-templates", wrapper.ListEntryTemplates)
	router.GET(baseURL+"/entry-templates/:entry_template_id", wrapper.GetEntryTemplate)
	router.GET(baseURL+"/events", wrapper.ListEvents)
	router.POST(baseURL+"/exports", wrapper.ExportItem)
	router.GET(baseURL+"/feature-libraries", wrapper.ListFeatureLibraries)
	router.POST(baseURL+"/feature-libraries", wrapper.CreateFeatureLibrary)
	router.GET(baseURL+"/feature-libraries/:feature_library_id", wrapper.GetFeatureLibrary)
	router.PATCH(baseURL+"/feature-libraries/:feature_library_id", wrapper.UpdateFeatureLibrary)
	router.GET(baseURL+"/features", wrapper.ListFeatures)
	router.POST(baseURL+"/features", wrapper.CreateFeature)
	router.GET(baseURL+"/features/:feature_id", wrapper.GetFeature)
	router.PATCH(baseURL+"/features/:feature_id", wrapper.UpdateFeature)
	router.POST(baseURL+"/features:bulk-create", wrapper.BulkCreateFeatures)
	router.GET(baseURL+"/folders", wrapper.ListFolders)
	router.POST(baseURL+"/folders", wrapper.CreateFolder)
	router.GET(baseURL+"/folders/:folder_id", wrapper.GetFolder)
	router.POST(baseURL+"/folders:archive", wrapper.ArchiveFolders)
	router.POST(baseURL+"/folders:unarchive", wrapper.UnarchiveFolders)
	router.GET(baseURL+"/legacy-workflow-stage-runs/:stage_run_id/input-samples", wrapper.ListLegacyWorkflowStageRunInputSamples)
	router.GET(baseURL+"/legacy-workflow-stage-runs/:stage_run_id/output-samples", wrapper.ListLegacyWorkflowStageRunOutputSamples)
	router.GET(baseURL+"/legacy-workflow-stage-runs/:stage_run_id/registered-samples", wrapper.ListLegacyWorkflowStageRunRegisteredSamples)
	router.GET(baseURL+"/legacy-workflow-stages/:stage_id/workflow-stage-runs", wrapper.ListLegacyWorkflowStageRuns)
	router.GET(baseURL+"/legacy-workflows", wrapper.ListLegacyWorkflows)
	router.PATCH(baseURL+"/legacy-workflows/:legacy_workflow_id", wrapper.UpdateLegacyWorkflowMetadata)
	router.GET(baseURL+"/legacy-workflows/:legacy_workflow_id/workflow-stages", wrapper.ListLegacyWorkflowStages)
	router.GET(baseURL+"/location-schemas", wrapper.ListLocationSchemas)
	router.GET(baseURL+"/location-schemas/:schema_id", wrapper.GetLocationSchema)
	router.GET(baseURL+"/locations", wrapper.ListLocations)
	router.POST(baseURL+"/locations", wrapper.CreateLocation)
	router.GET(baseURL+"/locations/:location_id", wrapper.GetLocation)
	router.PATCH(baseURL+"/locations/:location_id", wrapper.UpdateLocation)
	router.POST(baseURL+"/locations:archive", wrapper.ArchiveLocations)
	router.GET(baseURL+"/locations:bulk-get", wrapper.BulkGetLocations)
	router.POST(baseURL+"/locations:unarchive", wrapper.UnarchiveLocations)
	router.GET(baseURL+"/mixtures", wrapper.ListMixtures)
	router.POST(baseURL+"/mixtures", wrapper.CreateMixture)
	router.GET(baseURL+"/mixtures/:mixture_id", wrapper.GetMixture)
	router.PATCH(baseURL+"/mixtures/:mixture_id", wrapper.UpdateMixture)
	router.POST(baseURL+"/mixtures:archive", wrapper.ArchiveMixtures)
	router.POST(baseURL+"/mixtures:bulk-create", wrapper.BulkCreateMixtures)
	router.POST(baseURL+"/mixtures:bulk-update", wrapper.BulkUpdateMixtures)
	router.POST(baseURL+"/mixtures:unarchive", wrapper.UnarchiveMixtures)
	router.GET(baseURL+"/molecules", wrapper.ListMolecules)
	router.POST(baseURL+"/molecules", wrapper.CreateMolecule)
	router.GET(baseURL+"/molecules/:molecule_id", wrapper.GetMolecule)
	router.PATCH(baseURL+"/molecules/:molecule_id", wrapper.UpdateMolecule)
	router.POST(baseURL+"/molecules:archive", wrapper.ArchiveMolecules)
	router.POST(baseURL+"/molecules:bulk-create", wrapper.BulkCreateMolecules)
	router.POST(baseURL+"/molecules:bulk-update", wrapper.BulkUpdateMolecules)
	router.POST(baseURL+"/molecules:unarchive", wrapper.UnarchiveMolecules)
	router.GET(baseURL+"/monomers", wrapper.ListMonomers)
	router.POST(baseURL+"/monomers", wrapper.CreateMonomer)
	router.PATCH(baseURL+"/monomers/:monomer_id", wrapper.UpdateMonomer)
	router.POST(baseURL+"/monomers:archive", wrapper.ArchiveMonomers)
	router.POST(baseURL+"/monomers:unarchive", wrapper.UnarchiveMonomers)
	router.GET(baseURL+"/nucleotide-alignments", wrapper.ListNucleotideAlignments)
	router.DELETE(baseURL+"/nucleotide-alignments/:alignment_id", wrapper.DeleteNucleotideAlignment)
	router.GET(baseURL+"/nucleotide-alignments/:alignment_id", wrapper.GetNucleotideAlignment)
	router.POST(baseURL+"/nucleotide-alignments:create-consensus-alignment", wrapper.CreateConsensusNucleotideAlignment)
	router.POST(baseURL+"/nucleotide-alignments:create-template-alignment", wrapper.CreateTemplateNucleotideAlignment)
	router.GET(baseURL+"/oligos", wrapper.ListOligos)
	router.POST(baseURL+"/oligos", wrapper.CreateOligo)
	router.GET(baseURL+"/oligos/:oligo_id", wrapper.GetOligo)
	router.PATCH(baseURL+"/oligos/:oligo_id", wrapper.UpdateOligo)
	router.POST(baseURL+"/oligos:archive", wrapper.ArchiveOligos)
	router.POST(baseURL+"/oligos:bulk-create", wrapper.BulkCreateOligos)
	router.GET(baseURL+"/oligos:bulk-get", wrapper.BulkGetOligos)
	router.POST(baseURL+"/oligos:unarchive", wrapper.UnarchiveOligos)
	router.GET(baseURL+"/organizations", wrapper.ListOrganizations)
	router.GET(baseURL+"/organizations/:organization_id", wrapper.GetOrganization)
	router.GET(baseURL+"/plate-schemas", wrapper.ListPlateSchemas)
	router.GET(baseURL+"/plate-schemas/:schema_id", wrapper.GetPlateSchema)
	router.GET(baseURL+"/plates", wrapper.ListPlates)
	router.POST(baseURL+"/plates", wrapper.CreatePlate)
	router.GET(baseURL+"/plates/:plate_id", wrapper.GetPlate)
	router.PATCH(baseURL+"/plates/:plate_id", wrapper.UpdatePlate)
	router.POST(baseURL+"/plates:archive", wrapper.ArchivePlates)
	router.GET(baseURL+"/plates:bulk-get", wrapper.BulkGetPlates)
	router.POST(baseURL+"/plates:unarchive", wrapper.UnarchivePlates)
	router.GET(baseURL+"/projects", wrapper.ListProjects)
	router.GET(baseURL+"/projects/:project_id", wrapper.GetProject)
	router.POST(baseURL+"/projects:archive", wrapper.ArchiveProjects)
	router.POST(baseURL+"/projects:unarchive", wrapper.UnarchiveProjects)
	router.GET(baseURL+"/registries", wrapper.ListRegistries)
	router.GET(baseURL+"/registries/:registry_id", wrapper.GetRegistry)
	router.GET(baseURL+"/registries/:registry_id/batch-schemas", wrapper.ListBatchSchemasByRegistry)
	router.GET(baseURL+"/registries/:registry_id/box-schemas", wrapper.ListBoxSchemasByRegistry)
	router.GET(baseURL+"/registries/:registry_id/container-schemas", wrapper.ListContainerSchemasByRegistry)
	router.GET(baseURL+"/registries/:registry_id/dropdowns", wrapper.ListDropdownsByRegistry)
	router.GET(baseURL+"/registries/:registry_id/entity-schemas", wrapper.ListEntitySchemasByRegistry)
	router.GET(baseURL+"/registries/:registry_id/label-printers", wrapper.ListPrinters)
	router.GET(baseURL+"/registries/:registry_id/label-templates", wrapper.ListLabelTemplates)
	router.GET(baseURL+"/registries/:registry_id/location-schemas", wrapper.ListLocationSchemasByRegistry)
	router.GET(baseURL+"/registries/:registry_id/plate-schemas", wrapper.ListPlateSchemasByRegistry)
	router.GET(baseURL+"/registries/:registry_id/registered-entities:bulk-get", wrapper.BulkGetRegisteredEntities)
	router.POST(baseURL+"/registries/:registry_id:bulk-register-entities", wrapper.RegisterEntities)
	router.POST(baseURL+"/registries/:registry_id:unregister-entities", wrapper.UnregisterEntities)
	router.POST(baseURL+"/registries/:registry_id:validate-barcodes", wrapper.ValidateBarcodes)
	router.GET(baseURL+"/request-fulfillments", wrapper.ListRequestFulfillments)
	router.GET(baseURL+"/request-fulfillments/:request_fulfillment_id", wrapper.GetRequestFulfillment)
	router.GET(baseURL+"/request-schemas", wrapper.ListRequestSchemas)
	router.GET(baseURL+"/request-schemas/:schema_id", wrapper.GetRequestSchema)
	router.GET(baseURL+"/request-task-schemas", wrapper.ListRequestTaskSchemas)
	router.GET(baseURL+"/request-task-schemas/:schema_id", wrapper.GetRequestTaskSchema)
	router.GET(baseURL+"/requests", wrapper.ListRequests)
	router.POST(baseURL+"/requests", wrapper.CreateRequest)
	router.GET(baseURL+"/requests/:request_id", wrapper.GetRequest)
	router.PATCH(baseURL+"/requests/:request_id", wrapper.PatchRequest)
	router.GET(baseURL+"/requests/:request_id/response", wrapper.GetRequestResponse)
	router.POST(baseURL+"/requests/:request_id/tasks:bulk-create", wrapper.BulkCreateRequestTasks)
	router.POST(baseURL+"/requests/:request_id/tasks:bulk-update", wrapper.BulkUpdateRequestTasks)
	router.POST(baseURL+"/requests/:request_id:execute-sample-groups", wrapper.ExecuteRequestsSampleGroups)
	router.GET(baseURL+"/requests:bulk-get", wrapper.BulkGetRequests)
	router.POST(baseURL+"/result-transactions", wrapper.CreateAssayResultsTransaction)
	router.POST(baseURL+"/result-transactions/:transaction_id/results", wrapper.CreateAssayResultsInTransaction)
	router.POST(baseURL+"/result-transactions/:transaction_id:abort", wrapper.AbortAssayResultsTransaction)
	router.POST(baseURL+"/result-transactions/:transaction_id:commit", wrapper.CommitAssayResultsTransaction)
	router.GET(baseURL+"/rna-oligos", wrapper.ListRNAOligos)
	router.POST(baseURL+"/rna-oligos", wrapper.CreateRNAOligo)
	router.GET(baseURL+"/rna-oligos/:oligo_id", wrapper.GetRNAOligo)
	router.PATCH(baseURL+"/rna-oligos/:oligo_id", wrapper.UpdateRNAOligo)
	router.POST(baseURL+"/rna-oligos:archive", wrapper.ArchiveRNAOligos)
	router.POST(baseURL+"/rna-oligos:bulk-create", wrapper.BulkCreateRNAOligos)
	router.POST(baseURL+"/rna-oligos:bulk-update", wrapper.BulkUpdateRNAOligos)
	router.POST(baseURL+"/rna-oligos:unarchive", wrapper.UnarchiveRNAOligos)
	router.GET(baseURL+"/rna-sequences", wrapper.ListRNASequences)
	router.POST(baseURL+"/rna-sequences", wrapper.CreateRNASequence)
	router.GET(baseURL+"/rna-sequences/:rna_sequence_id", wrapper.GetRNASequence)
	router.PATCH(baseURL+"/rna-sequences/:rna_sequence_id", wrapper.UpdateRNASequence)
	router.POST(baseURL+"/rna-sequences:archive", wrapper.ArchiveRNASequences)
	router.POST(baseURL+"/rna-sequences:auto-annotate", wrapper.AutoAnnotateRnaSequences)
	router.POST(baseURL+"/rna-sequences:autofill-parts", wrapper.AutofillRNASequenceParts)
	router.POST(baseURL+"/rna-sequences:autofill-translations", wrapper.AutofillRNASequenceTranslations)
	router.POST(baseURL+"/rna-sequences:bulk-create", wrapper.BulkCreateRNASequences)
	router.GET(baseURL+"/rna-sequences:bulk-get", wrapper.BulkGetRNASequences)
	router.POST(baseURL+"/rna-sequences:bulk-update", wrapper.BulkUpdateRNASequences)
	router.POST(baseURL+"/rna-sequences:match-bases", wrapper.MatchBasesRnaSequences)
	router.POST(baseURL+"/rna-sequences:search-bases", wrapper.SearchRnaSequences)
	router.POST(baseURL+"/rna-sequences:unarchive", wrapper.UnarchiveRNASequences)
	router.GET(baseURL+"/tasks/:task_id", wrapper.GetTask)
	router.GET(baseURL+"/teams", wrapper.ListTeams)
	router.GET(baseURL+"/teams/:team_id", wrapper.GetTeam)
	router.POST(baseURL+"/token", wrapper.GenerateToken)
	router.POST(baseURL+"/transfers", wrapper.TransferIntoContainers)
	router.GET(baseURL+"/users", wrapper.ListUsers)
	router.POST(baseURL+"/users", wrapper.CreateUser)
	router.GET(baseURL+"/users/:user_id", wrapper.GetUser)
	router.PATCH(baseURL+"/users/:user_id", wrapper.UpdateUser)
	router.GET(baseURL+"/users/:user_id/activity", wrapper.GetUserActivity)
	router.POST(baseURL+"/users:bulk-create", wrapper.BulkCreateUsers)
	router.POST(baseURL+"/users:bulk-update", wrapper.BulkUpdateUsers)
	router.POST(baseURL+"/warehouse-credentials", wrapper.CreateWarehouseCredentials)
	router.GET(baseURL+"/workflow-outputs", wrapper.ListWorkflowOutputs)
	router.POST(baseURL+"/workflow-outputs", wrapper.CreateWorkflowOutput)
	router.GET(baseURL+"/workflow-outputs/:workflow_output_id", wrapper.GetWorkflowOutput)
	router.PATCH(baseURL+"/workflow-outputs/:workflow_output_id", wrapper.UpdateWorkflowOutput)
	router.POST(baseURL+"/workflow-outputs:archive", wrapper.ArchiveWorkflowOutputs)
	router.POST(baseURL+"/workflow-outputs:bulk-create", wrapper.BulkCreateWorkflowOutputs)
	router.POST(baseURL+"/workflow-outputs:bulk-update", wrapper.BulkUpdateWorkflowOutputs)
	router.POST(baseURL+"/workflow-outputs:unarchive", wrapper.UnarchiveWorkflowOutputs)
	router.GET(baseURL+"/workflow-stage-runs/:stage_run_id/input-samples", wrapper.ListStageRunInputSamples)
	router.GET(baseURL+"/workflow-stage-runs/:stage_run_id/output-samples", wrapper.ListStageRunOutputSamples)
	router.GET(baseURL+"/workflow-stage-runs/:stage_run_id/registered-samples", wrapper.ListStageRunRegisteredSamples)
	router.GET(baseURL+"/workflow-stages/:stage_id/workflow-stage-runs", wrapper.ListWorkflowStageRuns)
	router.GET(baseURL+"/workflow-task-groups", wrapper.ListWorkflowTaskGroups)
	router.POST(baseURL+"/workflow-task-groups", wrapper.CreateWorkflowTaskGroup)
	router.GET(baseURL+"/workflow-task-groups/:workflow_task_group_id", wrapper.GetWorkflowTaskGroup)
	router.PATCH(baseURL+"/workflow-task-groups/:workflow_task_group_id", wrapper.UpdateWorkflowTaskGroup)
	router.POST(baseURL+"/workflow-task-groups:archive", wrapper.ArchiveWorkflowTaskGroups)
	router.POST(baseURL+"/workflow-task-groups:unarchive", wrapper.UnarchiveWorkflowTaskGroups)
	router.GET(baseURL+"/workflow-task-schemas", wrapper.ListWorkflowTaskSchemas)
	router.GET(baseURL+"/workflow-task-schemas/:schema_id", wrapper.GetWorkflowTaskSchema)
	router.GET(baseURL+"/workflow-tasks", wrapper.ListWorkflowTasks)
	router.POST(baseURL+"/workflow-tasks", wrapper.CreateWorkflowTask)
	router.GET(baseURL+"/workflow-tasks/:workflow_task_id", wrapper.GetWorkflowTask)
	router.PATCH(baseURL+"/workflow-tasks/:workflow_task_id", wrapper.UpdateWorkflowTask)
	router.POST(baseURL+"/workflow-tasks/:workflow_task_id:copy", wrapper.CopyWorkflowTask)
	router.POST(baseURL+"/workflow-tasks:archive", wrapper.ArchiveWorkflowTasks)
	router.POST(baseURL+"/workflow-tasks:bulk-copy", wrapper.BulkCopyWorkflowTasks)
	router.POST(baseURL+"/workflow-tasks:bulk-create", wrapper.BulkCreateWorkflowTasks)
	router.POST(baseURL+"/workflow-tasks:bulk-update", wrapper.BulkUpdateWorkflowTasks)
	router.POST(baseURL+"/workflow-tasks:unarchive", wrapper.UnarchiveWorkflowTasks)
	router.GET(baseURL+"/workflows", wrapper.ListWorkflows)
	router.PATCH(baseURL+"/workflows/:workflow_id", wrapper.UpdateWorkflowMetadata)
	router.GET(baseURL+"/workflows/:workflow_id/workflow-stages", wrapper.ListWorkflowStages)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9eXcauRIo/lX04905mbkPCGDj7Z0572EbOyTeAthOcuPHFd0CFDetTkttm8zJd/8d",
	"Lb3vDXYy8zJ/ZAxoKZVKpapSLX/VNLK0iIlMRmsHf9XQE1xaBhJ/9wanp8hENmRoYFoOG0N6P0TUIiZF",
	"/PcHaDjiDzvwJbTw9fCsdlBbMGbRg9evp8jUFgY2502NLF9DC79+6LyGDiNLyDAxG5gP3ZjLiYhNX0M8",
	"mxxtPZ729t+c1Oo1SClcDR1zoNcOat29PajBVqfRhp1WY3u6v92A261ZY7o124Kt1l57d3uf9/GGP8EG",
	"OiLmDM85cCZcotpB7Xw1MCmznSUy2QX/6nu9NsOGgB/zabStrRnqdvTGDO3Axra2v9eAuqY3Ou32VJ/t",
	"7O7uzXZr9doSL9F4ZfEhGXpirzX6UKsnTSLQx0FpyiZMdhr2bicng7N+rV5zLINAfcQgc2jtoDa4mFwN",
	"L0+H/dGIAyeAiuCFum1H10dH/f5x/5i3TPr2e73Wu7y6somGKL102LNtJRFjNyw5k9hLYoX20tYW+AEN",
	"kUZsXU4HKTE5tqCOADYBsm1i84X82nZ328MoLLftcIS+OsjUED3Bpn4OmbbA5nyI5piYxWjAG0F05ozh",
	"P3/VlmqgXs/9daDzX2qWzczJeDDAuwYjtbr83Po6hoPBcb92V68xaM8RC/arHchWt+33iz2G+rXvd+kL",
	"OnSM+0tLsKTA2kquRK4BGhhS8XetL5keEF9xKOESm6SnYV1syrtxb9wbDvtnvf54dDs+PR6e3Z6ejI4v",
	"bntXvbPh8Gp0Neqdnb7jFGiahAkKlJNoxCB27aD2P/a6x70+p1Fk6rWDdkttLl85NM0J2f12fnXauvLp",
	"yIPJG1Fuvs1qB63vHMZipxM2qLvs1wLPu+b54eX5slXuOGo2ggzpPVY7qHVanXajtdtob49buwdb2wed",
	"brPd3flUU834iv+qLaCp87NVMyxIGXLsmlozMtkEtkY96+vWN3+9Z8TBFFyppnxGhzKyPMHI0MVtdIbm",
	"UFuBwXFgh2uj8bDdagnSQCbDbMVJmzJ7JeiKHl60WnyhM28UqOuYIxMaVzax2vwrHVPLgKsbNWRvaXFI",
	"6bljMFw7YLaD6uKchxuos6ybcOIieGJg875Wd4H7T42ir5Mv+mzv8KazXbvjQM6IoSNbAGfg6WRpf7o9",
	"t2esFiCHyeV0qrPTxVGtXjOQOWeL2kGrXlsSHc9w5g7sfoqTT68HXLKv1Wu2xI4gp0sbz7HJEUDEX33T",
	"RRti9mTrEaOH68FbrxOy8+b+7o2vsG9rkwvEPur7O5DTrrZAS+jxWkYnxxCfLOhFLw71SLb9Xq89omkW",
	"lXufXs9ec4R2u9dP2sCiDReSMM037pGuLSA22+3XSMfsc60otzkiJoPYRHYxZqN5zSWvKX7QptDWiI4E",
	"otut1k6j1eryg7VA2j1xmD8EpBTPTYQ2ctbIkt9XgR1wv0knvHbnoLN70Nlt7rcF4Xk47N30Bme9w7O+",
	"HNlkUrb8z1+1Kb82BOxrM57o7BtkPJKRCDCzrogQpy/Mj3UzyJA5g4D0/QpuG/fl+PFUAlY7HfdOj3q9",
	"3mnvYtwTH456p0fj0/Fpb9zr9canY/G5x5ucnp72RIPxae1HIPb/BY6+OHzz9d30W99FDe8wXTjH14/7",
	"xwKII2xrjgFtF44CLD66JRFmqeiVC1t4KTnO3d+R1TMbmtQIHqmSzN/FPT9g8my5mG8otbYhcSV4v5T+",
	"fxIqEniaQja5vhzYe4MvZ7XK5HAomOwPu2+nMzz5yND8/N39uCEYfoMhyjyUa8TUkKkIk0PnmJhfDzXn",
	"3EdR9xcb/sWGNylY/2LDPy8b5sqsdwo+117sHPxczF8j5uTT4dn++/e3x9WZv6d3cDqENjLZiBEbzqWd",
	"xSDa5HzJLq7fD3rRBqMwsRhEo9piMibD+92+sfRnOnSwoWNzzjFo2eQL0phHe+3l9vb2Vp8v96sDPf7t",
	"cvjlmY+Hdut7VQJ9IIazRJkD51AslTbu176Wxv+cnHx736bs235hnVAw0j5fJy5ohNJCXaJ2KMVWC99i",
	"cjR5mjCi4u59Orr+cHGzOi1pbXXYgihldb1zdffLVvRjbEUlDUTeev/RNqHh3juNflncNqAGdbTEWkhQ",
	"bbiHpUGnZqvVUhdSsdN/bMJLA89JsYOvu63zbc+FBVgiBnwdkW0qSK+9ozH/L00a3Rp32get1sH2frOz",
	"3f11dDctjebKnvENiJyN44seEOTFf3I0AxGGdfeN6licpo0e8yhAP4Pp1xM7E46FUEHlDw041cqe83IP",
	"TbpZ5qWp+INRkYch/pcNeY+WR7vxDkD88v2foi1vjdtbB+2dg+3t5lb778Cf/vODGdRdIQ4V2OMK+nJ8",
	"UyL0S/1nKV9j/sujkaPe+Ijv+BSb+hWhWJqLWnX/hJx093rdvntCurEJ5Ki1ek2c+4G7rDdvV/2trQ4/",
	"NeQB2Qtozs/8xcQPUqP9vbgeH6apdPYZxk0S+4Rou/Vla/wpkX2a20a7Y85aCVhN0+P/Cj9qv3vnIq4l",
	"J3dbud8Fn5rjSBE4Kcmgv92v9ra0s3lDI0vLYUhvyPMgGMrS/LjnbE9pQzzPNdqlWPQJgsyxC7LnmWoc",
	"Zre73aOdHme36uczPLWh2g7+FV+AdvtxcbJ8+uq3UjesZZMlYchjLfzXyYfFxy+nh9YJ+bT9eAPtFRfR",
	"IdMWqo9/TfubaEDtEzSsBQSBES3IGLI5P53P4ZxBjc2ZpjFNm8O5tt5XLPBVUVwPS4m99obFXjtR7K0q",
	"9V7z/35JvX9XqXf4S+p9Nql3WFbqtf9xUq+9aan32pN6r3viA5dyr0+vT3vXvV7v+vRafA5Lvde/pN4M",
	"BmWnM6gwf1pT5p1BgwaE3m63stRrmzBf8r3+OSTfX4LvhgVf9fy1hsDLWfEJxAbSQ4xY8BpxULGpoyd5",
	"qSJK4ZyjaGA+QAPrQBxEIDt9Dzb4SBwb2JwqKQOPkAIsezSDbl0nvcGZguTYhEeCJfUMPDeXyCzoT85b",
	"Iz18TaxvEwjYWzxSP/+4pOao7fh0copM1Gq1+YoyGjMbL/t8n3da8sOotMetbsIGdPEi7g1oGpOdTzf6",
	"h/09lsHNOwfd/YNuu7nf2voU4EmR3ql8J9I9em+6ENVKk+/JqnPUenNphMj32vr2+HDtcGXOpMikDhUE",
	"/L+9ef6Mgp5O2P2lxVYjR9MQLSRrZIz0ZBGbFTTTkUfTIFBPQUWDoaXVpFtNuITfiAkfaRg54vfXw9Hi",
	"/upq1NK/tL9Qs332zpxaxu7y23anfW+ibudCt/au35qHrzVoYcOA9uo1EjBOMENL+ppLnm++Xa7wxZe9",
	"5jds/W8XwoZynGzw+1FdAn9CxqC24Nj97LRanZ0Pjd7yW6NnzImN2WL5Z+92tN14c947aoze9DrdnWCr",
	"Ixvp/JaGxp+90aB3c3F4/PHk49HJh8vh2cX2zm+dE05Mrd329m+dE4c2EKSs0f6tc0K3fuucwEe6PVEc",
	"IjjqMWToT7fjuL29vddtfQo26D9Z2Eb0z72d7VYr+MNI8II3COrIpn8uSHjcEdIcG7NVY0zukfnn4D15",
	"O916a33qGM6Hzs2X/uE2PPpw8+3s9mahbb1n56O3o+OL6/bgzae99onVH11A/P7MQTvGb53DL99a2ye3",
	"97uzi+vF+RPuT88+HrHu2fFFD/d7i4vp+Hy/r6Oe82R82aYPi1GrfbF8HL79NF6dbB1++Wb/1jlcvOt0",
	"ekfa1986h+/PBydPvd6pjaYX3/rty+P7zsX44+PFlzk+fvMObs2+bm3hT4/0vP1OP7Jve3u6eXn7niPy",
	"A/1o29Nv97va0eB45+tV77fOydb5+ze/dU52T+B7cn50/fDhS2sHojc7w8X5cff20+orgYPRof1b5+Rq",
	"++Tagb91Dn/rnJyM9N7t3jU5sRy7NXi4H52M8fZu56i3u5idLufaF2od6nR8ZF/29oZtMptT7ePj5cOp",
	"dmIjZD52jfbN4sOn4xH6cHa0vzp7++Hq8PbkG3KsPWe4uvjw/mTw5kRbXrx5oGf47Px6/LE16qL+odb9",
	"ZO6PevD2UltuX55+6Tm2df32qzUeX132nO7Np8txR2+/63w4X/3WOSFvdp9a7Q+z1vlw0Ndbq9nq8uzd",
	"TktfmPMpRKut/YfH9uP57OpyufX28OFydaMvTuft22GHDk/aw9N2i+3qg108uOx83P609XG6//hb50R/",
	"vzDg7GRvRLe7H9lw+NAZDtm3mfVIbvt72zs91rZuHxZXLdZrDdrTBUMLfefauv+tc9LCZ2hx2X17e40/",
	"fv3WJuczNNM/wa3W295o//pCf3fx9Sv9sPdb5+TLojfcP5m19p/efbs85hv37Sv69Dget/q37HRn8RXZ",
	"7z7si504vD6bfeE7sr3Ntk6+nHWt4Qf7aXg8WLWcTzeDra+LL2RIWPditnu23Ee6pr19+1vnEDpfzDeX",
	"5/r+zvKprx1297ZvLnfQdGdrsL8/RzfLi8vfOienluMcPpw/zTrkZrt3sbd12H+Hrbf9861325cfTwbd",
	"m95opo2fOjdb5vng7Mveyfm73vhj//bqo0lb757Onb71vnUx29VHoz4+eTeYvW9bT13cfzh/N7tytrXT",
	"y6/Xh9fwsnXUmV/00eU13TtZbWu4s6Bnj9vnt7tfbsxx98tZ/73eOTzc3l58+vb1/vxhiS4/Ijx+es/X",
	"PT+0vvaOfuuczD4NTzq95ZZ5tDqDveP3H0+t4cKat96fDO8P3+w596Onr5dPv3UOH88ezno33a1d1u3N",
	"Ts60r1+gvX20D1vHHy73F/Pb2cnW6uPOm8HI+LR90d+/Of2AcPvx62oXdz8da9MrfpKM2e3XNztn1HrX",
	"sc/fns57xlu2mO0eo986h8b77urt8uPtb52TN7vvTruIQ+d0zm+izEcY8P6ctvY0qLf39/d3OlNN13b0",
	"1nR72tU72619tN+a7uzC7e29bYi63W0N7W1vzbpbu3pb395tI7jb0jOutRRZzRe7POkJmISBGXHMVIlL",
	"3GiOaWJzHhrMazu8vrgYXJzKxlwAnhUNVdARZdgU4vLRr6iFX1ELv9xlf0Ut/HKX/RW18Ctq4VfUwi82",
	"/Ctq4Rcb/hW18Ctq4W8dteABnZjWp0dXpsZVRXlrGZczofb8y0az2kHtf7z2EwS9VqO89rt8r0cJEdky",
	"tEG9mVmBr8KKZ+YEXiYXAeKpmx1IsHZFr2TKt1E86Ea+iee7+bnXKGG8ctPmFF4k7Pmv4Qd/RcBQr4V/",
	"uf0os9UBEC9dQvHXbGzJ3rVWg0sFOkBPmuFQ/MCvBh2I56QmGC/kRzIDbCGSSriMAmAKoPEIVxTYyLIR",
	"RSZDOoAUtJo+a8EmQ3NkuzltvDRTyRlQYgDLQ/VXbQmf3AfLTreb0FC916WtDZvu2kRDtbpEMOU3QUBH",
	"mCHhw5UJw/fEffJScMR2yZMSozD3bBuuOMLdFvWaeDJI3FH1BeR9RDhP4MUzNjD/DUD+Y8J+cmz4ay6T",
	"+iYGVEjITV+e758hMUYBMZOg8lafeaaCRyIJMUrOjoLDCVyDJjGxBg3g2EYANSOP1BVcV4Mwlqon4JkR",
	"ewn5XenYWEhQUL80jZV3VcdQGpXxC7KyUDfOS0zHMOCUQ89nChusorg5hgyN8RLFjv4jpED1awYXo0OG",
	"GgwvUZElBUSjrCVcU2SPnOUS2qskbaAYHo6CvTgawguVP8tncgooYomUmKhbRHHm/gYGx4lMcwZ8ablZ",
	"i+5HApp8sS9rge7SgppFFDQfItkGsAVkrghGk05eLnA4c5pU7hKNYIuN66o30bEvnOUU2YJ7BJgZTmQb",
	"cdYeFFJL0boBKQNu7+oU795mkTXBJUrBWGyEZPWs2BkYxvvGGUJ0FRGVLZXaE4QDn84BNgtRky9fF1uR",
	"lLE95pDE3VzJOgr49fDMxbllE4YkhHmcff2kU2U5f7ZUcQgpGsq3+TIChvwBMAKgrvP/RXbvWSSOGbFj",
	"JP7ZLC8++D9yyOUtlMSuxdibER1EiPQgaYGDYyFKORTZAhx+dcAYK31FgQqzbpZC7Qvcdak00AT9B2Sv",
	"lOsYXRDH0MECPiCAGQWck/GFQnCPVnWwhJaFzbkYzZXmwCNmC4BNSe9cyoNT4jAxj9B9vcuIz8C3K2zj",
	"KLTW1FWeeMtLuc3BuUP55WdLpU2X4PJWcuxXVC1dRzNsCg2Q/iCcFL/Q1V0upi101MrdSMljSHwNikoC",
	"r6jCcOJwhfndCbGlJ2IJYTiRb3Id30ZfHWwjvXbwnyA/U/i5E/aVQG/HuA/MnWUfKAuYGjZhwmtLLzdh",
	"+DKQglo+sithMAztM6Emce/zAJbNRNaN1cBkxJVXojCrgd2ffZYbxmKS+F+KgF1ZJWXksWt7MJ2loEXf",
	"Llu7SxW/S8jVrnFDR5aNNK6/VZI7ShNjtWNZrFfy3kU2+BazRT+E47LACYjW37SiBj7PV1qq8NA4WkBz",
	"jlJFEGgYQEgWUqt7RDYCymigA2IDx3Q/1cHcJo6FdDBdARtR4tgaEiEyTTBeYCqNZTqSYowaPsDAKYAG",
	"MefyLoPmym0ylWmik+Z/HZhesv2IqApD2aT/KiEjiVlL9vpeBOP55B03JLme9FOir4TAKxfN7+MgAjeM",
	"Ave5N5uSJfV7BiHR5bvo7d99aqR6BJocCvXvw4AuUsJsHsrP/VdRmT3hNv4ujLQD2b/darVKbjwf6hQl",
	"qVJrQViaAP37/kchVDH4soBfwTk2+a1yhukLoLFeM9ETE47ipW9ieu1ypE2cc5e9PetJjxzWAmdUht1c",
	"eBGy6a8RU9dU4AsT1X1EYuuIBOokyR/+vNEonjyrkavDBCD3In5ijS2I7UdM0UD3/XUimqMNNfkowa80",
	"iiiYIvaIkAm8qCAATR2ogCF53Yn4fnFfMrS0DMiQ7NsEl6axAup5TJDK2G3gOQHT/wVusWGAKQJoaTFJ",
	"UUdudE2gnaQmb52tZrfVDRiUZgaBzF+0KWylQkML4b46pr0YqcAgO63ERzQ/gCrQNqHp93Sy/UWsv4j1",
	"b0CslnUEzQdYwmjldeH6ToJaAS2r1GD+69hfQuuJaoWa+UAn77eXV2+3tmGCySVZAwkBWX5t1/jQINq9",
	"EAQSlhh9zoxuZ9SxooiE683tifABMTe2QB0ymGBe9gQBwBsI6x2lRMP8EHgmQk1M0wRH0OQHwaFo5hji",
	"JFjIppgyLgeI/l5nPdobTB0GHon5ivEhbGTq4qlEWWIdiuwmGMwAtZAmnp3qADOwdKhoLsN6344uLwA2",
	"gdxJIM8WMBAVSpgJuvdT8TZGGDQix7H21+faPVp9rh2Az9IV6XPte5FjhUz+c4Kx7/IB2VwJ1YjJbCKx",
	"8bhAbIHs4KqFfskQ51t8IK6amoSJpf5XyFv/rQMkrKxTTj+8vY6pmFNwskfOfMgDsm2sy8c6bOr4AesO",
	"NGSXVxT8V0H5X6DoaCUn4Gv6L58STjmLq6v+Ehz8gNkKSDcqOY2OZhx4uSMZYwcNmVNCDASl4VamCkq0",
	"jAqOPsPyLVNYcGVjaW4WT2bg0H1tAj3LAufQxDMudDKuoyts+vZrChhJeTKUGn4xMDx7gDJYc/oXsafu",
	"jCmzUEQpJmb+JBCoplHqhpblIl8FSlEws8lS2uRlH7kt4rhYxGYSTYEDGaFxiqg5GT2+Y/fzw24+cecw",
	"ws3aNcOjpt8ExbaNI488KsO/Rx5NcEJsMIXa/SO0dU4tSwsyPMUGZqu6bOkSsYdaLhMQG9rYWAFiKV7o",
	"mAwbikC+OphihgDDS84STZ08isM+tRG85xBowlIlnuWniEGATN0i2GQULCAFFqTUtQIVsUcHVR5xBmkt",
	"eLRCBF5XGLsrspMVLzbZOXq9Fep6a2N3qwvAF5wiLgJLTAS1Rx1zGllyBVx61agXKP7n4fV4fHmRBuCh",
	"wxgx1XyKzOu1ozeDq1S7+gJb0fbHw8ur48vb1FmObWLp5NFM6zc5vz4bD256Z9f9vCGEW7NwZY4Odt4b",
	"vssC4hza90lAjPq94dGbyeDi6nqc6m6AuNgi3FKzuhdYR2Ck9KWM+kfjQfqmjZCQ/OO9zvpH48th3lIM",
	"pDFipywmOESh5QRGS1/QWARZpowx5ow51qP/YZy9kDF6YgmL+O5JkKsL6ZctU0DVa8REBU570onIfWuK",
	"nYm8HsknomivNETn9U8+Anm9Uom/RMeqECeSen6nVBIv1bUq0KmUmdMtfg74ZRHm/u4zXvz+DN6W4te7",
	"YjZc9+o5Q3B2QfTsy0dbYEO3pdF109dP8Yun/JWzocum/DVT+YLZ7NWy1vWw+YuhEoPfLGsvw9TLsvPq",
	"jLwsC6/AvNdi25V475pctzS/fQa2GWzl8cBMSf4HyfC/mOgzM9ESkvlPyHSLyuG/GPQ/l0GHSPTvwc9L",
	"SM4vKjNv1hsuPGoBa1GgYYVnGtH5Wa1Z8Sle8CZUe1P4PvTal7wVY/3WuRu9wUrekF6/avdkYvc1b8vA",
	"mCXuzECvqjdnyhBr35/euIVvUb9H6bvUd8Pa3I3qjVn4Xi3YI/lEVL5jC/ZPPgLl79vyHatCnEjqVW7g",
	"Kl2rAp1KmcXvZLfLC97M/hUVuhnD0/9yBPjlCPDLEeCXI0BhR4CkmIwSDsSlAzYywjI0BVCVoAvZV/kg",
	"e7j6T8xdTHyGF986928vHmp39fXCLGI+WiV920NQp2QWURQ6OKZBKtjgyuqb8EhLDLzwl1eIBN3xEgLz",
	"+fcqw4NLJNBGYIo4H/FJq6cxzjAlAACZzhI8QBsjCqYrwJAJTSYi41Vw0yVn4xw2/3DJrxJYQQDa4s72",
	"P+FuRy2/uVtEzBmeDxha5imywVCxFBISCbCw1rOwxz718Bx1CecEGUglRU5JBWPDVV+2iQ7g3lVp+oP8",
	"Od7raR2op+Rp4mZ8qD6Kn0FuE4NsAiARXz9xPbarDySNSilaE2Qoqb3IRJLRh/8e62fCiSgXtBaw5mZI",
	"WVfq4CbGmBCXV1QeSu5iDlXIyDqZjCRhAHu1JgT2agNkKTIKZKZRiPUQHvppPfiPsR4iC8E6ULqu9ilD",
	"DOTP0V5faPouv6UkxrgMosF1KcMdYwNbs8RPXOJfawhiIM0x1hpDBHqsPcAG8KHSdK4zhJuPZ70xRJDf",
	"BhZkI+oYGxloE6za3hCrtp1NED9FmmOjCUNPLMNg5thojJ5iDCerV1L7R2LfzwzyOGGQ3m8A+Mh4bgbW",
	"tcYzxAtJ1THWNRWnS4m5htyYSFKkR1wgyesVZ+h5PdLv57yeCfdiXpdEWTmvU+K9lgtc/AouYsUt16MI",
	"xeWauxNP73p24DzNq2fhc/yEE7Lj+olAS+fglHF5SYl14iHi2MuZ61vvoGUBRsDjAov4S0yBJgB2ZFI+",
	"YQ4CU2QQc06LpUYqmryTzyznkpMEEnhWzmaI3VoD2c0KJ11MgjGUeLEypBZMyiUpWJ3KD+xlMIZuNG0A",
	"klcUuNKea2ZkNhJZYYmtI1tZJ4nY3ClhjCybYVPE+UrlAwftWp1/EowFtMvZnPzkPSFiW1koGAYUALxg",
	"eq3guVHsK5JxqrBPQXScgs9E4a7e3PIEf78rCHTpfGDBMWRnNWMsEItFcvy4BpOQIcz9MoECvfpb0ceB",
	"79EQJ9my7j53FV27v1kvBXg9A+xcoEPktaaFLDSyuq8CE+Rat3LoP9POVWDuPCNX7hC5Fq7iI6wNShHb",
	"Vu4oWYatUGd+PcR6Zpm4Yr154/AIeRpUPvTmBkgyz8xVeIAcG1fuOIUMXEVGsVfr9V4XhEz7Vn7vLFtX",
	"qLeQusN9M61euVPnmLxC/ZWeEOqfZfwKdeaKU6hnnhksF/SCNrDccXIMYPn9c6xfuQNkmr6K9V4XBzlG",
	"r9z+eRavAgMUMXcVGKaArSt/lLXZtL0JNp1v4sodooB9K3eMtTqXsXmVHSzT4FVosCxrV84Aa5u68oYv",
	"r+5U7R7n66W6R++kUp0jQlbpvhERq1T/yJX0vCahqF6ZYsrx1SKo4QlE+537w4d9eDEyuvuiPls2LFjP",
	"h8RXVJ9B9fGC5yuoPYG+TxXnrKLueN0rqTrx3muBUFXF8UYopd6EepVWbfzeVe7LUO+1SK2KOhPrXEGV",
	"8caorMYER7BX1XuuM3Vp1cXvWU5t8fuVVlm8rhXUFa9vKVXF61VFTYl1Xmd/Kqgnft8KqonXubRaEu65",
	"zporqCNe3yqqSKBzVTUkMERFFcQfYS12aq/LTqupHV73iiqH179yx3VVjbSBSqsZoYHKqhgbSiGUOXR5",
	"1aJK1zD/La9SVOkYEGoqqRJV+gaui+dVIYKPRAcFk/X1LAtgPfHdN/TgG64/Bi1r8nZr34StrbO2Sc9G",
	"W9uk9k992ozshViTl8ovb08i+mu11z8+yMu8VQbOx0s8VIol3WU97Pk012l1Oo1Wt9Hair60JyUNXvPd",
	"MoDxg80vYqvR3stV1cu9WSbYOqrTGh/o5egtwFdfiuaEKlt6y0Cre9DePtjqgqvzKA0qZ4/noMPAbhy8",
	"2OI2SZtRA2C1XRajvAxVBsWLlyBJqSiHnB4iCegTNjEvV/3atBdE+MGPWcI6VBe3mVfbSjXOy1BeWBJ/",
	"CdqLmSWj5qqIuh43WoTsqiH1MKrsxvTniHkqRUcLWPDi9jjXQKUUw3ot6owR1jiVmSdgBvDsTa6VLaCX",
	"+ZaGFK0vYp0MmjrrIRN51HTr220CVpigah9R1KXRO2iDDpieXFvMXQEXqY1dTeFzcfCLzn7RWQFNthwP",
	"j788VmOJapyX4eFhu8ZL8HDX6h26ft0vC+yVX0JmXaYQRvTBywG+DpVF3nmr7Rgf5GXoK2BPegniEnws",
	"tEGKs6XvTjzewCsfDQHv7RVGl9k7VK3qKZI/WtCmCE4N1HwGjSqwTwfPsPRNcr9n9UFex/+4qu/xmn7H",
	"6/kcb8TfeH1f42p+xuv5GK/nX7y2b/FafsWb8Cle35+4ui/x2n7E1X2Iq/oPr+E7vI7fcDWf4bX8hTfh",
	"K7yOn/BaPsLV/YPX9g1exy94LZ/gDfgDr+8LvJ4f8No+wGv6/67r+1vZ73djPr8b8/ddy9f3Gf181/Dx",
	"XcO/t7Jvb1Xf3HV8eqv6876IL29yzfnYe/xRMLx64L5GF6s7nuCwW6S+fKhCdyIExRYXq//+bIsLu9Q/",
	"9wJVy1il+A2kTldjcgklsZTiphCW4MCQphWPZLrKsvX71ywAHMoKkBgynxLMHw/eVwk4E1xMTADdDHz/",
	"Vcs8l63/C2TTqSxHiYDm2DYymZe8k98jSKakLIr98AyiknZyDk8vWj6cd6AYFtzq3JGlgqmN0QwEvg0E",
	"3L+iQNbgpiLTrUORTZvgDJlztvDS9LpVubca7VYLaAvI2wz4TxpZIgrwcumoNLimhgBU5hxMAUUi/+IS",
	"PskhxbnkorDpft5KysKqbuqieB3J9pyw8RIRh42QRsyktItj+bvINizb1D1w3VW21U8iT+9WC+hwJYqL",
	"a4gvR+Qv1qAJiGmsOHKwyQmWIr0OTMKAjtRHSSFL+ISXzrJ20Onud1pq7fKbduES3WqZBUu4pvh15ZyO",
	"GXQMVjv4z139Zzoq/tUVPSDJxD5eIMB/cSncS9JbhKJvXKp1LwlBARHirkbRf3+6jFycolyt2IPY4rIv",
	"E5cHlrohEmmi0DyVzoxGTCZykcZ5qTo0Kld5XTgWBtKeQwosA2ITcOVHpkr3E+hoC2zRJhiiGbK5Ukd5",
	"b/9nmU75d0d4K7ZbwEI2WNL5H4Fs0f4sYizX6dEf4/pDE/RUWnXbnYeTNAym4b4aAKzXgWWjGX5yU7p/",
	"rmH94HNNUJdrAtXBdAWmNtSQqsasLN0H4HPtL6wfIJNNYGvUs75ufW9+roV8QMc2NOkM2Rzg7aXBT2Sk",
	"y7fvfKX8S42YXqzadwXO578sGxMbs9UBsLY+f/4eOXadQhfJykClmc5I9IolzlVEUYjsRu7EHmOtXVxe",
	"9AOpiPvD4eWwVq8NLk4ua3X319H10VF/NKrVa7e94cXg4jTxLTV288UJ1TCARSjFnG8JNiKzdgPV7xVV",
	"ScrrKjE3pwu6ogwtG46QpiWb4fKA94UcR2UnV8s4ujy/OuuP+8eT28H4zURBzRdw0huc9Y9r9drw+kKs",
	"RK2ufyy+HQ/O+5fX45z1FSxOFF687OSnaH8VSMVObI8xgjDfasZSjP+k4mOyOhe/IctKURJt/4/IUqHF",
	"xpZ2I0+Mm3+cg+al+AePC2QCcSbcLVb5/oMHrNwR8Q9G2nFQOtK6CdyaBZNquenZNWLr8Un99PE+uz+H",
	"unC8R7ZN7KKzpGVrrPZu7WXNE2pkj1K4Eu78NE8ICKlgAfj4CENhBU4wYURRVBDgULfvcWk7+DsYumUs",
	"sFfWwjGYuM8j1RUo4BplvB0/RuEyCmHNs2AWPsi8+A8UnGETmfhEf/lsXQyH1xTZntEghsHArz7+yAw8",
	"LogLqlqBNE5FIfyunuISa4Acu6dKNJEMQoTEBHZG1BkRJXCKFKIRr3Y3XGBTr1NpRJqPk8Ao36NYuZSe",
	"FMovAIhZhaYkhFAIwv0DiJP9ZsSWixUdm2BMwL//TRH797+lsCl78VZQoaIOVsQB/+YK17+5GCHRJIcL",
	"VZrxz5sYmxanA3m4E0hABvEosUeCzvebObYpQoo4fE1wZQgpwCRMkvQ9WgkejqC2UAiCtvxJfHpFwSO0",
	"0YLw1Qgl83d/pyacO/wBsEkZgh7vdfvpmFoGXMV68f39g2PDs2Gl0ZsEOtH2RYfoAaPHpGJGt6pwkaxO",
	"lEGpAJoAahqy+Olw3Q/jpYAKZcPM4hUbyogpXxWzT6hqxBeHTYpsFuKMZrHT6T4+FSVJGUyWzpxUsJni",
	"Gx44KohOsgyGmbhRZVvFAlbKi0gdtSOyXCoNNRdbfi9f3Mnp9D37NvTv0/Cd+EK87BgLiyVn8Cn8LIWb",
	"0XzGY65KMJ68x6WYBBIniMBayMwlBwlPnEPJVQo+5Rqy0rmTEqEDnCdSV+qv2nKlHJQmBjbv+TfKT602",
	"neEJbB22Nb2zJQ7+SrwDT5SPid+QkiUSxg7hepfIxK6vB8e1cqd4HDy/7lmBHJ0uinyXQMcyCNQFF+Oa",
	"hbGSRmxpReB0LhgbpW4BNHdc16oiTHuMyKbReZrgDMEHKedjCtDSYivZ02MkUnkRmp4UZMBC9gjMnSR5",
	"pXKbdLbmrl0yEcfUke2yWqLwEOTxuWFa3nzeEbjLPvgDnQbe9MpYoUNjhB6u/DzWDtaT6CT7DS88cBH4",
	"qUVMmsC9NgpjFhSjkpfKIaRIdFcd48+DhbNUi2GABMONfE66l4MRgO3dRmu70d4bt7oH3e7B9l5zZ6+7",
	"td39n63WQauVdomnoMh3nhXonihKvauXv5LukrBKY0+zqZusOhR/RY3t4PdUqP1nCvTExuQemcm+A1lk",
	"Igyo8nHO9RVII13JdnOoNGe6whXtCiq6iVwjTrp2Sgm4sZCORFk3oVYI4FyDi2WTB6x7sjxtgp4rvMo+",
	"FCzhCuh4NkM2kJkEiKkKwoXT1gcMNVEThkIIR6VXOK4sVQZcPQamqCcbZKBlMZngOJLgoM9nGUSywVFm",
	"s6kxGcD7XndvYOZeDYFzksRV01e59v1Q6UCmvROWW1V8Tacom4dUArb0hUHzzn8qRJu9uEow1w0hpioD",
	"dTJLZ8Q5jQZNYmINGsCxDVeDHDpeWpHe1SCc4WTBmEUPXr+eutbVpkaWr6GFXz90Xgs8NGzHpK877Vm3",
	"1WptNVpbe/uN7WkHNvY7+1sN2N7d39md7nX3d9rBK7RoMY9NWR+zrYGhRABtkV1jZ9zeOtjeOuh0m7vd",
	"Tnd/1xMDsgx7hc15IeObPz1i9uSNTtsfevBrYataLul5elwseebuLpxtdVrdxk4Xzhrb3d1ZY2931m3s",
	"drd3OtO9bmu3C/ONMXEDSkjnCXBnW5t8/Hbdtbb14cuYJQJaIF+7PLpUW0xmJ2fvlvry1H3eP6gpmdEx",
	"E/2Wyhkr/CUP3dLH8rFaaGsmARp8QJDRIkhIsmvkMxrHvIn2y+QjmbaOH2MzULZcMnNVVcdUJoNsO6LX",
	"eoPauGO+gCrumBvVw0vr3RIMGrDd+avnwiSxl67tLp1IA6cgtVY/NuVFgIkJ4JQ4EtUBC7sX7v28p6Gq",
	"kcA9Lnr/QS21GH8Szbmam+T6GrjQiyxI3CF8vHFE4XzoNN2xmu6bVTmJ3jEvCENX0GbllHevV/rqojdC",
	"d28ParDVabRhp9XYnu5vN+B2a9aYbs22YKu1197d3i/CJN3xRwESD+Rpc7n+ki7aZ6udeQnF3TFLY2/z",
	"hg/oMCLPy8C0HHaCDSTfg8PyZ7iT6zpYQJqMSqP+fJcOe4kJy1p2HPPnMOtI6ljDpuNSSzGdw2tdUu3w",
	"aPLZTDlOUR+mNPGiiFCRP70um67FlzOFeDGLaJ+WOOBZGLnyTWvGrqZiNHaTcGuGD9m5emhBWLyk3vTO",
	"uExgg8GF+DNgPnI/u78kuvKoeZWxDRpHC2jOUZLgIf2JDMM/2coh6RHZyPPpAK+BY4YdPNIumPDZqGwJ",
	"8IAv65Y39p0uwJToq4hdz1/mBpdRX9O+GACquokx7DEZsCpGDY4ZVsagRKaWVA8hJUso25B5zjHLs9dS",
	"hjk+QeF1ZNvCorCuQ+45hsAqaCkJQcE7cBNwVL/n6LXLiDbBGFyu9mysIYUC08/SytTGkN7H0S+Ob8LV",
	"cSUzF0vFVHiNKkdRTIF0/VQeU1PHuAcM0vsmOJKe9zRFFcSmjh+w7kBDMg0vBMAfItnFYemHXZQFMhco",
	"AUkzSTi0A6e0+LSeN2wTuAO4XrhS8ZdejjaSDo5Ahwx6gRjSyauZhAOacsWPg17aTOQdkgZggc8A6072",
	"ZFdevLlsW02fSVxnyg8j+qJD7weVn/gcRnqmSfjCenCkEgrQsjeA13OQ5Avec73hez3g5iwAg2PhVF/8",
	"rp4hyBwbneGpDe1V9kSqLTBk47KTRU9/aHlJkNzloPbYrIxb3SyI3OOLvyd2Iwusgt5hdfS+4LpF0o5i",
	"ezkstZel4trt6uieYcO4gjajoeuu6Du124XrfiU2KHBLJKlrGaCuQRU/4UZlrfSn5i3Zxz1rWcLHxRAC",
	"xd+A5KTkc4KNDLWjoiE3brgNzSdtjOmWxUAczmpgUmY7S2SyC5iYdD7RA9YoEZJ7aJBp8utxSiIGX/Jy",
	"RakEAapeu7gcT0bj3nAcihu8Kyzm+PgS1uBctSlsPBbJdSBTonwxNSplhFy1yt+vwbJr6KvD1qcPF63B",
	"/M8/ayVXG5m4+NEJ03NSypGS7hL+iEAABTyoKnpReOM1MB+vMfc26DXEs8nR1uNpb//NSQX3iSIhTzlL",
	"2lw0Q6xwZ3ht8Sum8JPAS0DPRJg3sSPpaIoR4Rmc+kCO3ZGSWUueueQu41gcEY5bhvSbziFicJOvkxkH",
	"sdTxSzN1N6aIwWbaNPy8yJUVN32nDFXxmcJ1NYwzCT8Uh7cCv08NMv0DQEqJhkUUnnALkFYNTp3e8W6C",
	"ERJxO//lRPBf6RGwJA8IQBOgJ0yZDPkwkCrwtECBzvmvotkMVT7sXdlEQ5T+NBxVQgU8sNZmqUQM2LDc",
	"AelrSKx1eOozuqQpGr/FbNFPsbWNVHg2BY8q5k3Qh1qeyG4g3VTcwST1SSNaE5xw4gZLBE0KoLmS3wun",
	"Eon36GAR1xOTeFmUpkik+iDLJWZMxOfajjuyeL7BM2CTx4aBHpBnxCOa5th1vqEmmEEsorVt8khF2Dxb",
	"IGy7LV1XGQofZOCe+J4TXF009pI58YNBHeH1MnMMOZrb2YcuMcqvwu0YI88CgcExCvKWsjlJNHCrhql7",
	"I7dq4qoLXatJ7ldzG1E6YpCVEDuvQt1+3us4wlRLvH7KrDgJD5+BNwKk18HcJo4lE9bYbvAyB8kNkBdZ",
	"TkROB6HeiuHNFTCweY90FRGT/8Aaf3xIW2KFh8qkyKMq71ZpIL2EFJRwez6LGBSZZy05KIqmSmnWQup/",
	"IW3+Itkr6Nd999L3Xb4QCwEXXgWz4DAoxIQFL03f6Wx3t3Ya2s4UNrbb0/3GdK/Vaexv77R39vZRB8Gt",
	"3LAbBUoGwQRf/Wt3ZY7/Mwn4L42bkmuWHsn/QI7nOluvz/AK+/OUu/pSDM1+N5fZeDoIv5jLvbbkO/d4",
	"DuvRyajI7iHZl59NZ0NOPlHPniFigozrtf6ThUxd/DlaYMsSf4kH9qW0Vco2qvU5Fvy3uG9Q5qaUOjpx",
	"62k0F6LlNgAGpixnb6mKVF9Aqcd7yUf4sS4hV1UxzkaP6MtZZ6PAF3eR+cnO2ubI7Cqq6UQdQzyhw9WJ",
	"gm4ncUrhN/0JxEYo5MrLAlcXv4+4YID0rCbXpkJNcqOkbT6EunKnE1JaimNQOXd3OVKRkm4i4GPi1rmQ",
	"UyWwh+93RWA/dIz7MoCGFx4HF2UgJMtTHps6egrg3630GnJgKu1GH2+RfEMeQlsjOvKdgtOSv01lwzj1",
	"qhG4IKQCclAzOU5QTJKesUn4dKnBMJWDJUuvqZ5dg1lwBJMwOUodwEgWW4CeRNJa1/vV8+eqYEdNQWHC",
	"Vj8kNSnE2NO2qZB2rDrTQpn7E3c9i+G6TaIEUJHNejPeJa6Eos2mTYwd49Aq/0ry75Ow+s/TUfpMri0Q",
	"DewpGciaCKnNBbgTmwg05MZFEXsOTfzNy1MVHm0BTd1IVs5TXrhLhPjINLsXRTvcKXwdq/pm14NDg2gR",
	"bh1BhmqaaIyIOmv4be9S9yrlfkvnyfW0ein1mkORfV6KmYdC6BKvDJN5G+klXG7VE3Iim4Qh6smgga5A",
	"2icaggGqMTjbbAkXXZOotjILNhd3ReZkv/scPyDqDo+RzcW8FWhI515hmJJCsrDCaAts6DYy+QRLoiND",
	"5vQmpsr1ZUFbtQxO0QYzYhjkURo5vYY03rJTF1ArMVbkzXYT5bbqCfKPu1dxJYr/4r5G8RmbAHBNFeiI",
	"IXuJTWF/ggwQZYJChi71Kkv69xbMN8t3eIQ4zsSbZAES5wzV1ZkzGUZgVCxGHbg9I4G/+Zdd8Nh48wcG",
	"ST8/I2QgjRG76OpkCcN13NndEdJgYtqirAryMikn/o4JaGMJZBUDOSKmhkxme8wpa9BzBKlji2TIKg2G",
	"qBy6fnFXzxnPBblgddIj0agv2vhdixT5DPhCBxJ7RMqgycnHpYqhJQ6cQ3+leyStO14PLAB+7h0baHu3",
	"geQkU8gm15cDe2/w5awIfReoJZQ7hpn2WLF+KpIo443Bkppi5BFNlUNFhXymggdWeuupcrqPE/qEk95g",
	"lphyWhbr4L/PML9iVTZj2cG3bk75avxEGrrKwlFbOzdOKuou7YEps2pgkdVMvrmK26vQWZZ3UN5hTJxD",
	"ycRMW5TVH4aqpmiqHiHxGsyWUN1TQED4ouH4adqDhyma7Ak7DbQooYb7G5AbPp9KRmlR/kUtUZGlxXe0",
	"XDijh69Kr2XPwBk2dFpRmYjzqeyR5w2R4XSREKYpBt2Ae0NoORuOQVdjbwr8daPPXXD+9q9SXsS6h8W7",
	"9J1NDbdWZFmOQZUiqpyAgQ0BUD7EWoH3bAHWG6b7mBUza9NdP9WeKhu6furZ4JCBOsCliibia9sIS93Z",
	"jrWWRfk/E9Tdp1/OOltXX82t1tOb+c/jSJugplZSvKFl/aRad8zlM3k/SupLZfGymbAKrtoUo0AdPSCD",
	"E+8GiTBFLgqcq4qKU+g5IVArUNUwWq7ADNuUgZ5l/X/hcn977f1Ohl4aDIADJ+4YkYqB3W5OxcAI4xKD",
	"R1deUTD82VceWWWCuFjiwnkh/13LqpYSybLUhebhTtQ0nbzd2jdha+usbdKz0dY2qdXF125lSngxMrr7",
	"W9/U17FTdldfT7CNo79Ssd9MhxDLUo4fP2zp6ULxMOCxJfY22UGLOdBwhWcu2YIHaGNEOeVIEbhZSOQt",
	"nWxJ4jZPhqE/ojZ8CZE0KG4lVYKPLqeyx9LfgBSTyhqn7LBBpsWLLzomfkA2hYax4n9/dVDQhPf79fXg",
	"+A/Pkjc1yDTiLbu1NUPdjt6YoR3Y2Nb29xpQ1/RGp92e6rOd3d292W7oSk/J7b7ESzROfNpD8ybHv4E1",
	"QVSvv1hoHgKBoSf2WqMPCZWuC5advwhU4eZLDA0fDFL3Enc2k+ZrZaScjGRFNsV8w97t5GRw1uf3y81g",
	"dN07G3zqjQeXF00wmIW/qXvACX16itxqSfI5FpoAL+FcvGU+YPQY1qXdeWr1WmjQxLR/0ld3FIuCH1xM",
	"roaXp0NZ8tctFFqr13qHlyIKvljsO6dON7ij5DEVL8jFuYdBpiqRbZELjYNVSU6EDO5sx7d4Cina2QbI",
	"1IiuPEeBKstMgwdiumKJQVZLvZt8YM+Pu2AB6SJIsOJxvQkuCEMHMuu0n+iatwm2t+GjzEIV7V9XdffC",
	"zYPr4GJ8clbq8PF1y0gHjy3RGGINymwEl7V6sTO+ueP8zzuoSeK/alR3iVJSUdodce4YDPONr0T3v3b8",
	"J9rxtC1O9kJCYzgPa2Ofazuz7n6rA7XO1m6rsz3V9ZbW3t3RpvtbrZ0tXdsWBfPjkaDQZhfS7VW89aua",
	"1xzhFSpeuxCvyYdDrJVm8Nac5cTKqCvgAwXDGQHtVp0vVip9FD8IJVC5RUmPYK/+oRKvLGTLn6GpiySJ",
	"GmRKWSS2joSXq1sXlDfDJsW6Wz3RhIaUwqKzUKATwcBNJIPPRCyZSZHmMA5VuCp5sR0KklsANwX5i7IJ",
	"RbaJPJpcvkhMLgD5GWlQPDeRDtyWwLGNZtwqFI/IFiZ/mmQIU3Luk6ii779DezNcD8+A6g5g0A8sl1wz",
	"HgD4r6WElYKCivRWrehMG/fDzXffd/1jg5VYvC+Tqzs4KMNLLc/fljw9YwXzmENXwD0+1xE3ZINe25Jc",
	"ps7Q0mIrldkU2SlpQRW3ITMhZ8qWXspV8iTpXriTmsQTRZvpQAecLsX8V4Riz9Uva3qZ+NRym8tXQ10X",
	"thG/fkgikMXAKeuUNMOGgfTC8AcgU6lWjVVpGHERh4wN+zdZkAM7YsSGc1TIUzRSS+cFijkVL8pE8bcU",
	"T1/+iyfukSfwO26iJliQR7CE5ipEWUxk46WM2OiPYhu3nqMWeTpSJyvnfVYLneZCl4THAG4xWxwRYuti",
	"ArqRV1vyVEnsCrDPtQublaHrbDrOrJpUsM7wXQaWMJH1MTdQYifz9DDb0ZhjI13M1rPwwDPN0YSbe0qe",
	"kmvnTMkT1RaT89701OizWZHaKFPyNNHUWieiTGfh4O1DF4wN+rp5x8UfOcpJkuyd68S+LBCeL1higF8C",
	"sgqUkKnXHrHOFgkj5uAxzRPO+724nOltTTUvOG/Gqj5w4SVtxAOOPL1A1Zpn5E4piC7lBfeML5dTDgqA",
	"BhGpVdhC5GBRvwVu2gpvm1PyVNpJzZtxE955PpJLX3se6GnBleRpYxkigm+Najfij40/yHmuXpOW5qFI",
	"eniYGnUqf/diTptAfMFX4IWhirQ4HvFg8wGZjNjKb1ztuyJ04TsODeolWwwPIgorKkLRZZeQ3drXQCPO",
	"X3JXvZ24SyOadK2f/1qGG5eg1DyHv/WnriQ2osrPrs9wiJI3NHEfvfI8gUITPyitd2r9ihIJRLw+FVMK",
	"ZKLINz38HBhaR3l6Fvz4YVj4Z6EiLQRTcTwFIsqeA1XHJrw08Jz8JFjSXXAKI8hdwDMh5yfjRbpZgRkF",
	"lvEcWDqRJUJ+EgypgiXFsaPAfw7MDH+uw2WXPlzDZzxcw5/ucNlVDtfwuQ6XtMEg+wdfYyUglnr/Tye/",
	"9X4i+U2i6Jf8loOfX/JbUVT9kt+ykfNLfsvF0i8pJRs5v6SUVCwxRkyVG6k4TgYmQzbUGH5Abt8Erxf0",
	"xMKPZkcG1u7BUiRIpM50iVmRd7PD6/G4iPue8tQU097lrzbwOFvsoSWEqvzxA08omxr/aIG0+yl52sAj",
	"aeRm5AOjhHiGgedM9xhITakpOACmQHUFIk8aSzYK12sGNu+z7JLid2CjGbI5gevCOQQ9MfCAIYAm+D+N",
	"JTJ5pzpYrCxk8/Z1oGIodBvOG2ZDt4llId31CvVzDDPiZzAT8BU6b32T2StRkTfBquvSdkLONPQkQpRc",
	"d6BQ/rQi5G5gyiYuhou9ENcTPG4/c5yjzzWZpF2MZ8gHQklGxGG+71e4+78hFR6DSKZ0+zffZopELn+/",
	"TPPn2rA/6g9v+sd8Dht8rh296R+96x9PLq/Hn2tic0zHMKK9eje9wVnv8Kz/udb8bH42/62RJd/byFyi",
	"KLQn1PqhtTaiyBYPbx7hOUxM5n7GJiNyZN8zKDC4IBjIkCw2gJcodarQBP7oYjIXjOSC5AJ5SQ/qxXLj",
	"hF3VstuOEVz6zkCyfMRS5bmv4ipVoHijt4O1ukcDtXpw+wsGrhwtsJV49ST5Hfi3iEORPVEVv5A+SY5+",
	"ip6qozeDq8THNs+3stDlIlvfpXBnbzll75YgJvLGLnuv5I9NzJmBtRdIY62pmRLfmVPTN6fksPbV15fy",
	"bU1IOlDK1zXGdotuYKhfYvIDLw6qtPKvnOvyvVc27ay7obQP66bT04g5+XR4tv/+/e3xD0+nV8ndNNhn",
	"9Mz5+Eq7t351oJfKshA9vnc7yKJYzMYaQ/pIbBeXXqOWG2iunvtKTajVJcDCxPSDOgviW6xjGBtAzEPF",
	"j5ePMSveD1gjfX5CeiCGs0T5CdIsG3EVRPdI5EZ0PCH20NWw13Uy9ob2rQblokB8R2IbM5RSNUiLJoYr",
	"NnYoNWxM1g9ljvPCyj1xtgk4KmQ2evErxebcD5wN+Js1wQUX14WE4xfPwnOT2J4zlMs1/6o5Jua3TW3+",
	"ennmyUUH7db3sEdZIpdbiyesTzUi5Dwm4AWBvhNHInZFJmcEK5muMCVxZkrp001kEC5Y7kq0Lw5d5jFS",
	"GKvkRVp90fEdDQx0VwBemh5Y8MzCVTY2i4URbJBTZcUgVAlvSWIE9dojhyBwJRSPGwgdzzM4RQbNLNPi",
	"i3s3g95Zq9WuFajErpls0u5sbXdrRfMv+SpJuVvnfYAhhrm7+4uy4rgd6uARGYY0gIlCrZzRjxzLIjaj",
	"YAkprQPJKGWdRJmgX/FdjGi8jpLi577CzLm6YO0O/8fk/1j8nzk0wO/Xoz9q9dpX5v5leX/d840Vcef8",
	"H4f/I/ba4v8Y01q9Rr7xX4nB/5X/c+T/TPk/S/5PQ4ZBa/Xa70/t1v/d+gOEPm9HPncjn3cin3cjn/ci",
	"n/f9z/KA1xVC6pzAQ2GaAie5ZO9ZFbyO7VZqt/SYhQCNbDz+o3AiYw+EF01mHDfheNRfIDDkezbLyAwC",
	"iQTGVGD76wSERGGsGBaSuNRNBId4A48V49n0veSOm3I16YgylQ3rKHAvRw3xmAIbqTIkqkqJKxcHrfKB",
	"0QImYJXqxSDkHhj4HgGLUNbwOG3xN4TYoo7j0KuY8ZgGFgAteD+UxKYvOt/Vc5Ck8MGvX5UW4Wvg9knF",
	"Vl1iR8eGI3IOg8EMrIgDdGK+YuARmgwwAsTPKGsU3keDJiBLzGTGHQvacIlY2bvtsxlB342nMhRDXgHl",
	"IYZMvw9oAIeGVuld4tikDEGhTMUKMSWQ9V2hJ9zkgxN/c06wpawSgwVUJJJDkU2FhIHgkqr8FxQxADnV",
	"uIMBabQQeTMwop4CmrjJgjZMwgBV9av1etZQbuCJiqoK0AqeuSWG6rGqB4AtCEWZJKtiswjXjEXKHFmy",
	"jTJo6g1oEBMF9eLwcS9SyX3z1qF6LPjHa+O+rmWfUYTFMRn2R+Ph4GjcP+Y7e33hf07aG1Vpp8xM3nbw",
	"FktiBwZ48DYle0P5oU4eOw4LoqX2Evx+ZUCGhPQsY76g8QhX8smREXBxOZ70rq7OBke9w7P+H4qVBOxy",
	"VQ+MIm0ibHu/DklNQnsoU4MnYdRPlsZElmXIfMpSfM4Wz7FNcO5QF1krUUWNzBQ2+qquSh2E5hN6k/zm",
	"yLf6pORhi7XLgtYn1R8OcT+1powPbrCMzI+B1Z3t5SScqEzjhuyS+OKV30jK6SgjkoChuuoBNoFlQE0e",
	"PTWbFC4Uswl/+cJCS3Q7ohJLvvCRJuAe/LUxM1+4XlKR2lspuSc84AvaKTdoYHvBR7TNGczD+l80ZUr5",
	"k5uAl7mNdT9fXCxLBP/ZTTpUXmP1NyQecvSMqQuSuK/iI6LOuejhR2fXhRYkQrFdtguB5iFaCA+WIXzy",
	"OK+R4eu/o+a8CSyDTTrT3j3d158OYOePRH+zdRWBxwVRJVTFOwHnnJx1wKCQEmCTJ/gJ6RJgV+wydeCY",
	"Sa29jHti/FSh56eUyPv5AvZPKqjyDeUzJMuomVsZ3K5Q93Jb9D14StdJ0rFmYo7E5BvZGTc2mT0jioIK",
	"L2chWFJ8bX0h9TnSaQRw+CunxrPk1Ahtc2ZmDZ+gAjGbshJUVdKq8ggqny+/i2SpA9k1lEA4OdNEYMr8",
	"talIjxdfW8Rf5Pum1iR8/rBZeiXC9zf5MFfhDs3qiUJC0xVYLHHK7pvraJ0kZV1TZPMbbozgEvSuBmBw",
	"nCgMZXlL/0iE1YOry8be5pMhlr2t1n2i8h+nilZBCYn1lbPlPPN9WfpAuIlhKDKpQ3sGnpucOH9UzFpO",
	"PKMHX9FYM7k+ZTUyGXFfqBNczkUb9/ek8y1HAbZqAgbHQpZGzJNbbRV7j3Rl5mqCI2j6dtUVmBK2ANGp",
	"hHZicjFjPmI2ZGi+AurtkMIlEhEjKbasGTH0PAOhbBNU/3w7nAAQTBEw0IyplL8iNsX2ocPUtek2U7xS",
	"AoDnbeJFuLWg13SUDwO4FrYxWQBP2RD96hg+4pvyGQ+7MrZXL8MdSY4gygmqsqVIOilCqeppjgE5G59D",
	"E38TR/+zOSZgjhiADxALo0kAO7QujVgLBP7zWn3NtSxk6hbBJrv7/X94bhGvDUzZ0Gvzx2fzsxk00om8",
	"8QIWpIx4bgZ46QQPdGwjLZDG2AUjkTi+px6HC0czEGFY/5scfB/eiuffH2CMlkKX/Gev92+xysrsHBPz",
	"0sZzKanGSoC5tUiSjJy5QRJEjJtsIS3Y+Zzo0Lh2pGNftGBWxTHdCi0luydygHCOjJ8iN6nMkeEzveQs",
	"pRklwn8PwfDH5oppB7J3rDZhbElA/obriUdwmWg+qr6ooDkm37Hbi20TXVLLHEbhucvF3NqWhfWTsvgg",
	"hI0MnW6+kSE8+13i8tYyLmxmeV4h6w0vL0V5fJlEOVFg8vL7PwdU5RO0hmF+tqLsz8s80umkyLFPUNmg",
	"gSGN7IrvE0wPL1rC8zeXp0ELJxYy4vjSoElMrEEDOLbhKhMSLNB336vFl72rQbioZmb5drn6hovq19MZ",
	"njwdXX+4uFmd/jwV3PnIDluQEhadSM2bzHjeVAfu7YPuTrOzvdvNc+D+AcG/cudOCj3eHgXbek4EYSND",
	"AsXmPs6XLp0TMBP48xl4OhnuvdPol8VtkVmjwSoRms0JW17fW79wjHMRJqB054g6USrOIdi3UPSpnbbx",
	"tja5QOyjvr8Di2zE+oGygahKvqs1Rif983anY8ze1lw81kbMhlg88sa4gh/5msfvvE+vZ69dYmtADepo",
	"ibWGixHO/xouLTXo1Gy1Wq+RLpI1raflrA4hDcpRqVdIxBIrfwCMAKh76XyCF+Sq1DOmZKP5L+TKoghp",
	"fL5XFChm3Cw1dZRhFbSUh1hXPARYQiYZURaWmqD/gOyVbOma7MTjPWYUcEoT5TXBPVrVwRJaljBQEgBN",
	"IPdTKoLYlCwBExPAKXGkeVSEPHl2Tj6D8kqYlVxt6jpV+JG/Tr47xExap/Ba1IgtDSC6hFsYccUYr6jC",
	"gY5m2JQ1zH4Qcoobjb0qi8rkiilYkgflqVgrk2Yiu3ZT0RN8QuzSeW5SeMH3+l9JlVj9CNDvd1E4fJ1v",
	"Q257gcFdZTJp0jxfQckX10THXaHaSxEhHutRBW/1bBhKJIO8F7zUB6AYotXQbgOfX+a/E5WkZ/ciThl7",
	"HI1BFF0n6tK524Bg5tdMdh0wK96tm3VizTioRfslb2Jsr28xW/RDyC4PYoInabX9K2j69u/jOOFkJBTL",
	"Goim71xh4UAW7fWkyTM0h9oKDI4DYNVG42G71coC54Iwz2qfnYmNmuxpYgxRq7W7+lQsSv4jcWxXZ/cm",
	"KkHrbp9UKVKLrSH6jKkeUOUV7UYBqMyqgNiAGHhOXEuCkitMNZ4flAOmKxCea5CYiC7WJuOi92ZxqIzS",
	"wSZDtmUj9QAtBgWWTR6wrnJkeiC6M0jpogpKq/pxBB0z6tnbUdZq521jUla4hAUdQ4ZesI6zYLh3hcL/",
	"a51Wp9NotRsi90SOVik97fliuLb9wgsSCn6pRW012nug1T1obx9sdcHVeeEFohl0DBbKYJR6H3sJKiKO",
	"Xvxrfn6WfohIM7OGdkS3XBLHZOkDZOVm8GMmeg4jUua/dJjlsCubaIhSkuAblRGB0wOW2xoYmAqooDcy",
	"IGJofvzV2PHUo6lgFK+akDZEruncp4rBsmvoq8PWpw8XrcH8zz+LMaP8CJQE7MlodRniojxHspOkfFbx",
	"MJ9r4iWUa3PSUdmXvzhf7V0NXPM8/V+eV4mIZ7WQvcSU4gcEPnuROYHhgjFTuVlWLC+5iuMlXDn78VlH",
	"CiVdWydUr55k3w9sQcI2+dsi56d+nIzrdm0Ss6FowQ++E2Qxhdp9g4MGGZ5ig6vPlmNbRAQQX6vtzd1O",
	"xbVcKJUGUdIAGOqVz5LDEmu9pptw4kortXoNhj4t8ZMohCSbCUGmVq/Zgb+XxECaYyDhhs91r6q5VJLR",
	"kPKgiIJNihdNSMZ0pbQqIQ+X4kGVgV7B1Ioxw+XcRHqFEjXhjkXeTO9y1pYc3gaNObExWyyDlLWEsxmr",
	"1Wua4VAGDZJ46c+wEVmQn8M6PIdLhjGDOvo62dKepjfa0azQTZC7JTGXqhNsoOQ0lnEFZLkCJnoE0COG",
	"vLICPu5cbOTtQaoMU/px8/iiB7xhqz1u6iZseIulryn6Ck1jsvPpRv+wv8fiz5vJr3YF0kSFYRVOnbJn",
	"4YRPOE45EVhznrVKQRfNYFUMxlSbqle7YBQ6B/GN9tU9puhYZK93vT8FpO4YAFJKNCyuRM+EHVpKiBD4",
	"UTv/uKTmqO0kAe+/FMXBOnSJBzyiKbgeCDJkBIhSCknTZtNNHg9+FmVTD05QpjZPApMvpm+asGeaAVtD",
	"wTdAtb2qbmFKjDgyEyio1ZhCinSAnjjb5kIoMrnEqqOnJhgv5MeoUQNTN3zUS4aAdAApaAU0HWwyNJfB",
	"H5Sp4iLJcwu/QTG3aKhmTxnJhnIZS/iEl/ziaXMxxZR/N9pJnVwRqJgcYsK45/RG7d6x6zUpjdqjd4nH",
	"Y8tTH/y/vj/5uHX7/k2x4xO+YJM1areMUmFSdKsuxa4qj6yTHmT9H933NzFOs2hetPC5yXQDKnHNCRlX",
	"XHGT6cI5vn7cP07iglP3ldkfunc05v/l2++K2hML2hC92AGhaaoMzHgGTOK35neV16NZRA0Mg3yhbqww",
	"2PxbL2vNC8O3QMayNCLf9M/OAV2ZDD7VleeyiCw2V4ATlZCc5G2uKbIN3ozDi177L/333h9WU//96I//",
	"jKh119R/H4vPif9+/9e//vWvm04zwWElfNaKPArG+E2x173SkrEAyPUVDQJZ9qE22OmnYw4/mn7+g5eW",
	"3jm9Ex9OPWLqlSCgehnrd+Yr+V1on8sWhwkRzK99/kn2ObijVZ9HA0U5iz2N+hajqs+ifiHTnyKUhSss",
	"Ep7yUSyvc9J+VAthcUurbiB8JYLrDUeu+KhLWnzFZTxLwEoQlkyaXDdOpXpZ3BL5L7LBXycOpTr44fCT",
	"EiA/k4a/ueLEIT77fJEcz3KYoumD849BuoKaFLuR70Qblg02rfaVMJB6xrLK9lFXs5a6I6TvV3DbuP+p",
	"Qj88pTXbPrt2YEaJcJJNB188a6RFwYCK+Nf0CNsiD0Hg52BhW2TO2SLwW8CO9dyl4lil+uOqBHDs7Fk2",
	"XpZJF3Ml2idf8z86nOMFojZiJ1T4GBglOeLY75SEybWKmgX2fJNxF5zlBp6cK98Y6dokI+rpyNUrg1OW",
	"qL6Qf91UCgQJQlM1DmSajHG+T8CCOJB/Mb72FHvfCwaVhGD6e8eUnCQFk4TX90+MJYkkICpAZOGLMDz8",
	"baA2fHAoUR9e9eIKvYFNBO20GvFmrqG6AJg/8bUYjLpJ254Ib5FdsnKnG2kMNXCz5HFUEGorUsEGvZxV",
	"6QgINLKcuonQyQy8Eq9/r0TGrFfI1F8pZiE87qDnwchvZnEkDglbcCneJAxMkefGXIKhZ96Wxa/AcODS",
	"Rh4Iky7aqLlW8vzQSapHbLjeMOHoprJQBOOXIqP+LC8ViQiLwPsCm7Sp4KUoIym8a35+qQgjirlXeS/p",
	"vnNnvfireurjuTvt84ZcBSYqGXEV8ne8K+Y1NLmcTnV2ujjaeMBVYB0bjbfKYCEFu2VEWwVarfGaEPBS",
	"3MjOFX5T8Pwqf55nBc9g9BO9LPh+Z5t4XIgg/RneFzwcplhFK67nuV4ZguDkEeoG3hrKOxMniw9VXx1C",
	"azlFCWaDdYEsT4obeANZG60lX0K8+XJyW20emeUTWwXBfdbHkGc6+fEnkQJnNuZL/tKug64T8CjDfd7+",
	"8PVra/DmOtdXPWGwuzTBL9mLPk6ZkMGQ+Xq6YmU8oxMpzSaWTh5LmIXdHhlBGM/29EKsNJulmyFcV9AB",
	"t2lRA6Xqd2kVVWnjJbzUEFJvd63gjUesI8AFMRXepHvN3JIz0NbxN2EPoBYyDOkj46a+BhoRhS34YuoA",
	"CXMANAx5nPHSIjaDJgNLxCCnD1kk10YU86E1BJbQvkc2bQY3u+DBijjW5tqE3JUlkWTqzkmE02jO8MBY",
	"FfbPv3FTHkQyqvF5KbGxqbJi+yabIGTBSnIzsHQMhi0/B7ZIdv2EKUtyw7QgY8jmU/5famuTz58f/2cu",
	"P1F5WFw83mWcZaFwHHsm0JKm2UDHhEd/NUXBt51YULO7q3dFQ9tUh3OO3htoOOgaHxpEuy+XuU4ErcbH",
	"yNPp+D3hQnA98PtkhwkeDy+vji9vLybn12fjwU3v7LqfvN7QdcF/vfueta0x+EubpVKRWW7esp6NFedV",
	"rPjg5a6XlIfnCtdpiA3FVpA+YNynNHcSfzeS7INp1u3IPSlKx4mB6qLqN5NcTbA9cR+JSD3ZNuzRQWd0",
	"sq+dvh98HW3VwqxtRlNYW73EZRKYdCPo2rzpIlF0Ds25CTtA0iLKXuGJUBUTpJ6lQFlUWFujTFlaubEC",
	"uKxas+blsJm1CCmG56ds9sTO4jptTNBfX6+NDFmRaa3HUWqliKS6vPEyUsZGRIs1BYpC1/mawkOxOYo9",
	"BIQx+7KqSYbVKrhpReR86r4wvNiJTzoo/aXFVpfyo88FAr97acr9dAVl3jcyZbriTc9VPo6ioVu5DYdF",
	"G4az4yVtaJIBPNHxVl6qEQs+p0kvEZmXpB70NA1ZXI6TnShYwhXQ8WyGbCCDh/k1jExoMq/mk3jP/3GV",
	"QSUezuAUGQXfOwPhQv3eacE04Ul5Idudre1usbx5xwgTE39DOriFDNnFrhO5tEt7YMpazXgqahmLZ67i",
	"ZyOQYjGrWeIkGZQ39OqE9R9KJWURzVNj5ovUST9FJrKx5teEQHzI6PvlQ6ep0gn7Jc0K2xCq5QZy6Sw1",
	"O5BGTCoygbMkU0hCTXPfsMKlkpIvaQtIr0381eH7iXUn5IAerE4b22HlXsZhi2L14vKiz8/oxXgw/lir",
	"1w5746M3iQezcG4PVftBpYdOyu2xfr77XCvTc+VpqpSfqV5jmIn1RjMnBT9vNLFgVo8zbN4j3evjcodz",
	"/IST7H3UmbrYzffJPkbiQjC11Uh2o0m7I7dloty+Q6nVwj8Vy3vI6AR19+mXs85W0WSHoSxZOWpTtXRZ",
	"5ZJkldej+qawMCeCa5epyNMXiceKyXly6J/D80OtU5X6FqDozSRDjMistgH7S2j1ZTWMIBApBgLR5FmM",
	"LC6qEmwr4NIU2vF/PofFvM+1OvjsSnrygxDaPtfuNmCPCao5HmYyi6cr5Ocf1U3QfuXTWNWO9EzUkYbp",
	"NASvEkv7eqRjEuaeNxmJoUETMHgvTilavbKRWx1WnuTPNR2u6Oca+F0+ovExeMeGp2tMDfSHeOhcEh0Z",
	"Kq0WJyaoLYAOV9Iv3/Vd/lwTEDQ/10CfN+CfwEI0EfkhGzIOAPNrgTKRZwl8rjH0xFQGyTqYOkwMR+uA",
	"8dlpXUyPnhiyTWgAkVJOACpSWVLHsojNhA3ys/nvC8LQwb9VlhbbRiYDAm0+z5LQzNAjMPASqxCag89m",
	"A5wIOUZY0oOBBJjyZYAVYoHJwBsEVcFb1acOpsTQxR8cXiJ8wClb8bVgLWlEL7NUk89+DBkUEZli0YHC",
	"xTLzFMeRm5SqAUxnyQVyGdpAwSM2DGAimQN7ioAFbarqXICZQSCjnJsr31aOUAqgxenbxpAhgTmBOA+I",
	"IaKOwagLjCIt4CssgC1s4swXsmJx72oANGgYzXBHIN66NVmkmf/OAfT6Ia+x2z3Rv6V0iKvc70qxrYo5",
	"vUbMnrCH3eXu4e7ej4xqjTKawO/AFQoBnrlFTmxR48S/OMaqmrSpshCFmon9DNnv4+XTZEl9fYgeMHpU",
	"QR0pzE+yG7cHp0MbeanwxKR1DgI0VyXiF3LqsQXKu6VAFRjAQxh1CUV1dz8KIBXSdJlpm3pVgWTAr2BO",
	"ip6X0HSEi4cr2GxsWUUTSMqtDCSOBJD9uFpzkTTjCYh3Ec1JBTwuiAe2t5jahkvW8cst672H/09cr7Qp",
	"7yv/G3VPcByqqLTfJbLkbSgvWvUDdAcU39YBerJ4m5lji0tgRmygIwaxIRL/iDtRKF5/lKAZwdWOYSLB",
	"6JhaBkz0luH70JjZGJm6sQqk0nTRHaMD8YPr6pYdeyUZrdtW3gT9GE3ObLJ87rKARQpBKRMLzV5+9tNW",
	"arfCphf/zEZNLgXfysaYGSgXHsl7/QsoqngIzmzLiwTPAEUsyQEqYklburmgk0ZD9isKjmQbmgQSZZA5",
	"NBWYkfg5ujBXhekdHfWvxv3jWr120e8fjybD/s2gf8uVmf7b/pH8ZdgfD3vqb9mhd3HUn4wuelejN5fj",
	"yeBicjW8PB32RyPRmo+Q9mv4U+9oPLi8mAz7768Hw/5xwRdsWj7RuW/JjHFUebJk2/Q9c81Ychil1QRI",
	"xIcuLbft9fAsh7zStKvVoWJBCZpTQTUvdehKzpChcHXfdp8byFQvEdwuVheIagfHyaJDhNXnqIV3PyJK",
	"Hbmqdok7wEvJzAjQDGIGuZzi/Bmc/jli0ZUYVyUIvVqFQaF8uRUVsi8XPhE0xkKpSkrpADxJQupPXDHi",
	"tMelialBpgDrKtuBWDMXnaSCxlEd3o/HBTaQ7xoWEnDVn/4Oc4URLhFDNlhyvE2RwCgjqpIHV0bdFnKA",
	"MHwqYH+KXJ0LDHRkMn61+fK1q9hKJM3xAzI9cIUGPJgBGCAoMQOXwjhV2eSx7gfzq1Eg498DqInTqGR2",
	"twWXugRF6q5xLXMS3zWYPFIxlY2kmhQeWOwFWxAqW0pDhK4jv4CoP+cqGO0WegDW6INQjgMgeZCE1yFA",
	"WUki45o9sRzDLboCTWHXsJDG8AMCjimImQ9PDGdperjOmi26PlpPGEeQlzuKBwtaWmzljmkSv4GwXaiV",
	"yhozYr66TwYgeFQSFicw9riADD0g291Rjmovwa636vBelpCoB4HTWMsohZDuq5R60ItkLnAvjrR3lGTP",
	"co853WXflBt+Iy58gWc+DdurplvioMSzsFR7kuJskspTAS5uq8pviVI1V9HKWZ8vCEvNdqHkrWSnJGgA",
	"5orrEFBOsMSUspvmu1Ii8exbJBN0qnTUV8ZRNyIpbikLtvBtoZQRG1E/LMXPmTLDhrQZc+7qQAMQkVtK",
	"2V9dG4hOHk2DQF0akx3q3jSv3B+uh2evgNq3VaILrt8waTPpgtisYYj3KC6YSk1OTu7W/HOHkGltg2Cm",
	"5AFBwt2FJulq1xeDD4DhJaIMLi3wuEAmCIAIVNfk3P05umPQgJ3INPC3hM0b4W+oztnedCVsC9mjZaQv",
	"SCCVFHk9Qky55yNEfekzn2HzPr4+/q08B24dMu+JQT1mEOCVCvEoV71xcMIAxGEU6yhixusBA5v36v3D",
	"nnOB3fSx5p2ABwz5DwvGrN/pHwevX4PFykK26CtuLr/MR6jP/2ksVbiXEAh0G84bZkO3iZVE5UmUcSLz",
	"+9wjPWEOce1j6t2MLFAHhUs9Lii/o+a8WQevKPo6GS4+nt6Yb05e/dEElyo6gN++n2t8GvW+QtNy43hJ",
	"HqKcQ7zbiIgrNad8npSgNwFfhocyegBe8f+/kt9nLY+IR80D8IorVa/q4JWKguV/yquxLhLmzNHE+2jZ",
	"hBGNGPzvR2LfzwzyyP8OuZLwLwLOI/xj0LWEfxYpA8Qf5En0d+ut8Q8GkXmuxYRcsHgVfk3li6rVaxzs",
	"mryiEWVedTBh53BhlnQgQK7Vay7EtXrM9yXs7BLxhBHQ8v+Tp5rnKSQmd0Hl8xhppTXT9Pwj7+0koPGn",
	"7hj4Hc/AijgyKRc/eghSBob93rFSffE3VU6V2GEi/UNWFBRMyzKwhpmY0ZMQIQ2cuQSCBfJpyl0sBboo",
	"puC+7xkrBRMfNekho/g16l30calPsCLOpURZQ67pTR0snvu4YqbdB/0dmoG3T18DpUA8fBkroXULfWpu",
	"Q2shQdYxn064ZEojvEpyJiQ4SuFqYjtm6sMRbzB0TA9+QSwTqfwRc8IkMlK8k8jTkWooROHAIBrRU7uN",
	"xBtuoLHLWyfiRkq7LwJXRaCvgSmbTB3DQKzwfKKPtkDaPT8YadYQ9Xu0n6rlWHguQu4dKxuPZ6JNFIXK",
	"cW1i2Sinv3J9vrJRbBBxuAtu5xVvm7ahwUSj2cME04rGRxHPtnkDiEbRvpl9Yo3RU3F64I0nGaQwRk/s",
	"MEAJ371LeiUrvkim8L1e0Ms3AkCeS194bbmtY8DmWP2idJ7XIfEg5jryR/lMrh9jwpnI9dhPIpz8Tmnk",
	"mtcz47zkhgSlcc6CUQ7xo/79rp4SUFQkeCjtWvOdqtNfFAqJrBHjBUh3AS3jimy/tCdyQcNOlmUmC9HH",
	"4qkX6Rv0Yk/wzl2jEm0A1iLeelX8amO4eCb32pW03sUtB9JoweBUpFJVZku2UDZb0zdt8h1HT97rARfa",
	"kjQ42dwPeknxKJDw0rqcjOs4HGPAEhlk+Qjh9yEuqNZdzxzhFoFpwIyiDLPSJw5TYZMPNl5Aquzo0KtJ",
	"xqnYtUTLGcMW0YLZIMqYQaVFtxFymuF6KRCb0w46zdiID6enKKF8czKQa5NHz12jlNuEgGNIHos7Ecsu",
	"R8gw4mfCUHaMEo+6wvSR4NAF+A8RTy5MgYb8FyWuIPn6URMIl91HTFFdGjhcC4GbD8B7CRKDyFU1we9S",
	"h8IiSQ2xV+IICBoSOpbn4Bd2cvxDPohJMSzRNoCexDnjsCKTefXxkGE0wcD/IDi7a5ozVgAKv0nHgAlm",
	"DvQADUc8AjwgmwYqVqkuibSTvY986+O3H9fR+AlypUDwioNKX0ntFXM24b/HBbBJ48yB9yvHHn36KkGT",
	"6qWjZIoxecW6zyRKi/U+RXyFp5AikUWCM8IpIfeeZzqZzQCZbdBD03McquyquWp463jNlpaxjs9mUac7",
	"/4H1n+F3567nZ3S9W8lKueB3Zdb+ka53LrWmuOCV9V4rIl4Htqa6gB2i1034nGVB9XN7PLmQHxHDkA9w",
	"2S+0mtcuwYMwCw0FXKvSu+ey/5TX0ITIkLY8P0gXZ4niuSk8MsTV3OI3nI2YY5tIr8sFLhFUq4tOKCM1",
	"3BdMmb1XvW1y6c4kgQz4x3DVrAWya7eS3sr+kc+wLsISKrmVDDTyRiopVbhUtaF4qVWlVB3VqsREHeme",
	"1XNMGRxmqQ5kz+sIlqJTcbFrU+4lim266VDKunLKjdclAtfyJcmUZcQson1abPMmnU9k7jS9qciolA+K",
	"Qsgw4Fj9T0NLyGm8MHJcJGS9YD10GtCwFrApHkf7IU+gNPO61zLk0FTnY00Rg03oMCLj6UQeJ5GiQjja",
	"8sEMlDF0L6XnkdvxpnOIGEyf8NJhlsOubKIhSsvNGOlaeUrHkn43pWe8Vh2jEzahMu7nbYz7CBDbFn+E",
	"yDnLGSiB1dSTc4lkxvFH06PU405nWcckvpxEnpE1RMZC0k5ZgeHiHEcMqhwP8tamEr/HV+f2L7Y+NUza",
	"Cl3XBklreTDdhlrHQYuMVgzC8KB5gI4hvS8KJm+bDqQYyQVRhT+iIkMqEHuqS97QxVYfGDh77e6wfADd",
	"MZB+aZYYe+T3yp1Ahf0UH1t0SBn21CaOVWbjRIfs3ZNjuvA+ikokNi08uAL7VvWTk8Qfl/0ruPALczJf",
	"y33ZjXGzQj0SqKZMvziXyuudcsEX71YB4ljn8mAnMdSCfSoAnHjZFu1UZb4yolHxwYpIPZVHS5Jo8gbL",
	"ZhFlelfuWGF3crhlhe7h26fK/NGboDTmU/hnsVESRIhyXZN2IeaEEVKfclLleE095UiofDGDXX4V8pja",
	"H4xbDCTXUjaYeH1Q9CRSMulXYUth9I2GIuCDJn0ppwiZIoOqFXxRtOBK+NnrjnhipvgbKhfVmJq73bcb",
	"Z8cgr5v6PdHcwfco1w9CNCpujHOFgLWNcE9Icxgaia0Wx4Wm5RylFjGpCFnD4jFW2OqMlRelVUsc3vr/",
	"2fsX5bZtbn8YvhWMnv2fJP3LiuzEbZJvOrMVSU7U+lRJTpo2HhUSIYs1RSoEaVvpZOa7jff23it5B0eC",
	"JECCOtnp42f2Ti2SABaABWBhHX4rCKNW7LjRcXDVwkt/QtZlBcgSWYQsuwo6QkFvVTTvdLhIxsi3wvxf",
	"GkelF6H5ammzim071CEkCgCiraQMnigKR/u/77e83847pQFhriEGjFaLH+dSDIfGz7EScmPKq88cKaPT",
	"xg6VqI1MyA7LMkRjpd5lYlPI6ycA+c4icP2Ixb9EoYtuUDZQy40MjjQ0FqPA+krfJ2E1jgwUhQz4nkfF",
	"yCCXeuKBIp35lZAXckosONwPjCJIZALhhJQ4VNmbMZi7jMbKY3REEYTLJN8e4pSQHjRs8EjT/uuW6Tfz",
	"Adyi+xRFTWjpWJTWt3rtCEGKY2pvwWAFDJGZroHpXEeOBG9Q3WbIs9HLTx++/P761VetcZnIYkNjRBB9",
	"LeOClFYoU7OYPBShcO76CMyCWwDjKNijeaxhxItzP5Q5dFBDCa7xZXZfHjuDXG0aIp0vFSeCyStQ/vTc",
	"cQhDrUFYHdy8gBZ4QWjgNvJKokixflE74hW7L7FwyNTAnPCweghuoOc6YIbukiDVZGr+c3T4qnXY1dq+",
	"WFXHrDs925kX/U89GyMv8K8wiIIcY3jueLT/+tp5DTtfCsgYlsaL8Q/rLNcZGZk6kTPnQYTCOkDRRAT2",
	"CJQy6m41diNKLWuwzlDKfJqZzSa0x+jBQHYixbSWLAtNQnyeG0dXB3/JYk+nQciY2fWvgBOHFLVTYXVj",
	"QhwjI66QxZwXVTOYpx9tJjFj8T70HWwYmdzyIpxe4eZk6tUdULPwLvO7D9WWYA524KPbPIPlJpvVpwNM",
	"tZsRXkyfAW6aacP65pIiToc5rNt5F6IHEgc0vfm4CJcOxLIyy/NyBpa09efjlQFem+rWZx1Q4FbdjLW7",
	"7o9/fHB+f/0qWsvdS9edrNeXXaeCWx8xt0R/aTEpZwxWNmFIex/GAo8pMopJMOotGoOLHvUkjQIg0SUz",
	"fc47f1aRHsrFBZXv8n5YarW63ihPpHOGse0VjzVzRd9Ku7WNU6N4pQYK55jEGvUbxdkmuPV1/WbAFdzC",
	"SRiHer4KZCMiZzhz12cBY4kgp7ZBXeRiP3FqY6g/GUKg5wW3GCxQiKmXWXDrc8TiaIYEUE2aiCKyWZi5",
	"irM/gs1Ba/Hlxdea9Ymmjl3xQaWkDazM/JZ+YatzSRHh1FRXlfBtULwKqQUkrpAG39jwOPaus4khEwq0",
	"wkJlIWHdrPmi21sUgLAOcCQlomC5Cy/gFbJVU4h7/JrykV4scpGngWXhIK8fRHKN7E2oNNLAxTS1K9PY",
	"ab9VbAcRuos+5PN4tOYLzSWstGmha6ngtclM5ZeaqASZXiSPp4Jd/8pjKBbct7POEexUYYxqYJdBDG4h",
	"06/R75+iqwb4TNPH/+1MX739cPDyc+1Z47NPKqbocHu5etUIIdfBagPY0MKf2SYun2kvtomLQB6cMjdd",
	"8hHHNVCeSL76pwL4ZEbVzEb80sSrDzUtTlbDR2cuncuGPbLNYTMdocPX8MXYPomNJsn3btMkp8l///uF",
	"3/YuXteKt4f8duDivuQH3ft8/rV+ktz+HfILM0JZ7gXfTPyXdWxV8XNGHK4H5h+lQHjEw/Qvgd7Bfyo5",
	"JRcwjMTjKIQ+9hioBn809oKxfI3uGIaIfzXif1NIH/EeR0EIr5BCQSgJ4NAvTBrIPsSxl30WJxTwyanX",
	"aAIIcrDx6Is6vffxa5/DYlD+Tid1SeZIgZ/VyiEWs1fTT5zvnHDdWR9d0WzJ92SyyixImazyhKmdUlKR",
	"Ru3l+letlihTMYdRvcawydQKLC3DZeKVnXlMMw0dHz6MmXD8FaZCyUu64lykatjtZJCFutHDtOQ8pBtD",
	"+jzke4XFebivqFlEMcOZKKSSb+Zuaw7KCsKiUjDfbQdN3DnhRDRxMa+7hNB6zUNX0Buiu0hk22W8UG5+",
	"YIl5TuCdVTPic9eOKuMM5uiIfbfCVerCdyM1pjgjTOgjP45o6NPORBrNTYCJOKW3D4N7ED3EkR8dWYR5",
	"sS95tBdF7HAjgO5cTNEASrliEQZk3MrCTWnkGLmv8+/L48e/yXlYCSDfTqtIdQe0kYbeYFY8imkviNRI",
	"NmxhjzNtJOz3QDIdsu5gFe8b+sv0W4GSoZKQNKsFVlj9LJso6awrF3bWOERXSeWYhFpWLMbl88rlaNLY",
	"yqUElucGElWmmLfqqk0NVlbXJDVMjOcIB0aBYPXGRvJW2uU450tiBynOLbNY8u6ozHZpnpoSh1DeO3uV",
	"KTssN+ASyulbNY/lCswjN6nG6okty8Y8HLuOg/wundy8+63+setTZ5qe3it4jjCGV6iAVs2LGKPwxFjQ",
	"zqNY9qaPSMFJhBzmwFvWO3tRn9WkcQgTI1L16pMRLHk9UvPASDT4VcgrQbr9P2u//RjPTv+4uWWwxaOz",
	"23m3//Fdl//8GneOZqc3X0m1cq5qn4L4icg2SY5fPoAA0zaYEY3sOjiYc0VrCoxdR3ZmVldq4hvTiubm",
	"mmfGby1cmfHku9GHSijpJJc3Q5qVPwXmcvJkHNwlP8JYecP1UcpvNgfyAVNsyZ8iBG8UQXydPFZ0bOLP",
	"UbDgKNccv3YpN3EFd5vUR/avmhS3842wWMQcwraaUz4NxZ0F6k7y0Mt88+k09GEGu3s1zO4bk5FH58lg",
	"4kkm/FXF7vBciFHF3SMBANtdatR8stL/gmSgDw5irAhZLIHG3yiwGFKiYoUf7FaTSxrcvUp8tFabKqOq",
	"QkXuPqNAipXhZdWyVuqVsNoYVwX/Yhg8ZrWTEdor5S9WGQG3Xuv5SR5rsQ9UDfFRqjBwiVAdDHOiVVJ0",
	"JD7SngLlOTkipo9Q0nKTLacBukwi44mz3oDP6YPsc61OHolTif2kpxH7Uz0eP9cybknZI9FqwK9C5Lgc",
	"KCZz4MyD2DdEdbB3PO9a0l1RGbkNuhEG/FCmWXIYGTwtO3gaBSyLeniDwDT2PPKLaYGfNcA5dEOmq/kr",
	"9t0I/9UAA4Z9igGeuEycmwDhyw2e7jcOXqCXzxrgzEcqHdQnzZWE0EOB5aTwc33463Ptt8Hn2l+NzLDu",
	"H9goEicwgl5wlWTXSxtdO72z01Gz+dKqKrEiFTnBFrTPjZYcCjmfK5OnF3SjJccW9d0vMfKWwBVEY45y",
	"K6pu8HyX4vdxELWlxGSf+FIUEZTlDq5homRFIQgRz68vNBeyTuAFEfcKSvFbklA98L2lSM8vEJnF5HPg",
	"LSw4KVUtTcn3uSZxeD/XOKs2dPnX1RFZb5a0Y8Fn6TsbiKE+CAzdRffakwjdRalO5FflHtvrR83mvs0C",
	"nUF8TtXeBpcLgaBYjujNbMwFG63IkMX2Ks04ARxPZmw9Z948YQDKQchAFVM7MrilaUHlDkwF6y+xewM9",
	"tn0bK1EsBbwu3Xad2UBfrOKaRqsqTxUpKD1BEMchmiM/uqAlSw683PeKJOAf1+q1mPwzJ//QP65q9Rr5",
	"f/ZxyjZLPyqd7KTpj6FLI1ehzl7+eOw+jGPXZDCreoKqfRpP3dGLn2bO1ataEQHqMWsiY4PH5W3o8tSv",
	"mzomFJnUj0b7By9eHlaaAXmqlkzCg+46meyVur7Nc3SdDm/+ILU/KTdxGKhWj/xi1+0ldbEbCwI0E2Vg",
	"W/NyFt2+1B5PSubjahffCb7pwEiTTGjsBeMedbGGPpBx7xN8QxOXs4ic9uCDkiqczbDM9syylYAZgg5P",
	"Gv4Xe9Rz/gK3M3cyE8q2aRD7ErLgzxTw8eXTcnDkZyw55Tyg6aQZFRQ7QNDNIiYI2XXw58RzJ9dghkJ0",
	"+VQkJHCCCW6ksxKQR89l8T24R4rvRcGe/OyZHoWAE0XnotfRLchUqnKWcd322k0dPnfoUSZcTFNyS+J3",
	"WlnPnaSz/XZp7uAWfcd2686lDN99OHSR4Qwhzap+4b71gsm1LiEURUkv6J7qNZ5xQY8xCkc8t/zIdVaF",
	"uPkFB/4OmVr4Rif9+Jv5EdgEDfzzuQbHk8+1N+AzuaF8rn2zDR04huME8k7GwLYWC4MVeV7Bal1Wu+bC",
	"EAWLY3SDvOS9wROX2lxPKhFT7i+TIncYQh+TfVtzramaiiYSdWWy0FRNH8OOvzSOUUxZvFwoowpV2akV",
	"a0FyXgotxiXTbrZuuCk8SEuTgH2WEjkNuYD1xsqpdYI0TqStGYMD1iYbwOnZcDQYtvrDLjl4+xenp73T",
	"d7V67ajVO6aPBhftdrfb6XasYINM3LxSrgUz3xVwiJVdsmT/sV22yFPTVlUBSvNIYZkopbFaJkeLSr4u",
	"UiTmN44/zo+TNDpJ8PmY4kx5DD0L+g6gqkOW3DkkR3loif6SGiWs9zfzUt9UmURlAuzmDF3ByVKgZJYA",
	"VxqWNBkiKrHTtU2mgVYKhDuGDcpG6fIuhFroKDALghXSNNhsqjzmVqcfuMAo3JuGLvIdb6n4N+dbsYIL",
	"KaogkSZup7ej+P3brz9dw4Mq5uSC9VFOrpXzOv9IkyiptIVyJtQvCVFjhdWQZu0VlsM5zcVfEedwbT79",
	"t87rQPoNZg41MsrFdNFP9OpNqQMp8gXinvnya1zJM3qlPZC7F25i6yveQVhDm9kfZF0rTq5+6bJaV124",
	"nG1WWL4U/31LRxpNbbOD2dW2u5XDQFZdfe5JweJdm36yMgdQwlZlgH7sb5UHwti/Lz4gbW+RF3j1BXem",
	"TJo1+tymSnHXap+dnB932U2r0xu0W/0O/bt32hv2Wse9P+wvWdqJt2DKfuyvxZeEvexYU+++TTGxrBKE",
	"GCpIvEnLDBkaPzitorXQ0VybIBs5Kc86K+WcaTysFJhGIsVorI/hPZwJ/bvkaNqkjBJMyeoZuJAVEd1k",
	"AKLrJ0B4qXaYjwgYVDmohQ/6DuFIxjCcBI7euTW19xa5L1fwo14tIW+JBqtqaPGAQXvckwNtyk9WEzgs",
	"2GCl0OGi+aw69lVGsTAZplUssSxwWbA0BhXnQviji2TGpVYFGQdyWa/uw3yZo9SkNkp/ZH+spYfhm5HG",
	"ouMt3faKKG+6bmrsdJWCKNXhW0nrukMGLxrZBxL8LpjMFP4u39fBOLhDuA6YFrOuXL81lOki4sfBXfVQ",
	"+IxGwL6kILx6pDjp3wbCxDMTXZVNM/SbkkHwr8h0bSQ+vM9iw+mMKrxBceepb0VqgleP767XmDNJH82D",
	"G/SWHUhYRw95D/iJhRuAPiCUiEc8Z4BYEtLnKqX24kuI6v6hhwMQputNEiUJjnN49KiapEOaxzOHkzpX",
	"cmiLTiiKFvoOFWz61bf7ilxZEiO/STqqx8lLKleNlN/q6imYff2kB9fxgjoJVc9iM4jCeBLFIXJoBWqs",
	"coitRBXS+Ig6IFnnhT6B4bUT3PqKJ0nl61fGc0Rm1xjpDZxZuk9a/V87Zx9Pi0NsleQbSSoKMOfkgzGh",
	"/rO/32DH2g8/jAPPARG6i374oRy+JmIpBMwAmplhqpr9ITvK3yzaUCSeTbYRTWZvIUZ4tZxZ8uKZHCk0",
	"6Lb2hprfW/32+94HqglSrfLKY3ZI1Gv8pHS0kz4Wsc35i1zB7kLEtCs0cL+iFGGHTQp67M4JPftN8sv1",
	"2a9m3oMtG06pU+tBIL4hZxTDJcCABdbz6OMAI5BkxGZOKy5Wyg0oZPmSnG5/kevgXyBEURz6GMS+WjA5",
	"mMrvpUEYpackuRW/If1QZkV5A+mL/KdEGOYv6Z/0cSl6C5s6LeslXrj5M0h69KbHuw195qk8RoD0H7hT",
	"HitAVj853MlTm8ExoBHrGqC0WDYgIfN0SLzCT1g7GhyhIK/a0UT2J3vfUf+k2Wyad1Ul2N/zgls+5k7i",
	"C411ts2QilNSLuJu4E8wdwRvmFXVihdhUajKIsBu5N6QMaael9DTR68IB/RdhapoIpPyUAhVfdVOkk4o",
	"nmpJO8I9Oe2ZDBfu85uD53wE8PP5XTS6a1/8fvph+W4FR7edADhsHDghGaSD5v5Pe82Xe/uvhs3DN4cv",
	"3xz+2Dh4+dPhy8P/22y+oUvgnlAWto6SoFntFYATKrhU6wJOOfPiJEorXpAjLfCzkX4MYb2RhWFIqPfc",
	"8aj/6tcJ/nv20aYPWWEyswI0ro4Fm5pIH6B8lA1Ea9hCfyhx8Tpwu5Tq2cjBh29evmr8+OrwxdocnAfx",
	"Np8K949HkVCJw8noFEWfnNc/Qit5Zm09u4p45VBbz6h7sn9w4E1/qYlxrJ2HaEEPcKuoIr4+8iFFqhK/",
	"bK+Xv55Pn4sVsgcn0EFzd7Inxo8cAXtiAezhsd9sNp8jx7XBGzVLHG9j73qjSVZ4vbxOU/JLNc7kKhy9",
	"+BvPLtzVIgsuk85sNAtSviOFOzltmkd4+VEg9vCaIeGPulspxg0pI6rdqhiNfFWr164N0chWwci8WbIS",
	"VtRd5DLwblLRwffrgWJBUu23I/Tu9Hz6pf27jbJBpApYhKiyqiTFHyvjdWUUVOwF9Ud2ZDbeBL+sArrX",
	"v1X+pvKmVrvHDRcxppaJAGAUAYgzdxgur1bDVM3KdJbYJinpLidbsdc8M41+xhuge4PCJftGBGFSMYzc",
	"SanHAcQAgmu0rIM5XCxo6G8AyDWWsiqbBjVekuWgJm0ocy2kt89+uRTab5+zCN7tSZ1saSsjQ2Yy8NMj",
	"Q3PzToKQpSLg4ajU+ZGWfoL5qDkyUhDvfjh7U5pQCIaI9EFGZutEZxqtWqef05x3VN3AUtktwV/KefEX",
	"m6WpBQA6R4TlCCAyNJ4s7YCZTGgu4WqydAdhcpiBqetDD2Ca7FVk4yqSrz/7XTiZqVAQpK+ihyI4g6WN",
	"VaaT4rWTgcvVnUSoJ4DEqbB31t06DfNQ8lGSltg9s85SvSGaHt1BHqKhIgnNT3CqVRwkQ6n2PrNfZkqJ",
	"RLjLIA4FvF7js58hKEST4Mp3v/JYFegvU5WoQ0U/YNl5NWOS4a2ncmyy4/KMsqXrz1DoRsjhpmIerY0R",
	"8kWNTBWJnBQX/uleNiTWzV8ARlHojuNKWeP1oCc6I5LJEF/gRbKuAF8gM390oxmT9IaVMqQJJV9epEGp",
	"2jLCiW1WexO5VfwNhL6p1OVAZ+Y34Lqnr/DO37ev4UW5yvJbaYdQxTyLSnZRMA6cZQYGXXR96z1TTfDl",
	"WGCtlInFiI6uUFjECtVzVWoHwl7dl76Z2SScVLsnm7vM9IFJ3bvtg3JV1iSQTOgrsa+v2vwmrOuCRHvj",
	"usUSEpvCTheRnlGM7C9gnzd1TRN+BPyLareJ6iYETv6a0e7bMwJIqt2vyBnMXU83aKnukQ8BaYD2FQsV",
	"AOnh4KR33B1ooYROJ/v+5OnPZ8/8p3++f7N/+Wwy2W/vt9va64htLnk5ukr0R2MTBoUKZpAdXDCVO5To",
	"ccN028t6YrF3igt9wpFTxbDdqGabqA7qbHPPSYU7Jj2tHKmjFlX2qMAbjWdx5+L2dWetlP8prtsQdEJ5",
	"fFDheARUqw+9ogUsvtGtXRwvFp7LvFAlvnhuQYNTbliXnziuQ9M6iLq9JatqyUva7wGlzHf/BhDD0kov",
	"Kpz2Fmnsxj5SEIeQiaLvHxevknI7h2oN3BNZGfBzsrykjUM83hdmjmoH3rcCQeAtxCtKjxVVt+r4VJAQ",
	"VlJyirZW1nLyJS0V8hWutrzppKjmOMrvGFkmYpqtnWtbZfv3om7dmNr0SKcvTfr2XShMK574SvbFLCOt",
	"dz7qK1D1TWVyQ+IvpavLcnM6CsLKzqWaLc5ghMwveG53FFWsYhzWmXvLO2/XJ3H9VoncrNG3aApWtwGr",
	"9KZ3V/uDR+6aR/wUTBSFmAlsNL3R1PUQVZeYXByL7lwUYJNWse71q4i/12Qp3YVlUwyWWjTqrGmUqBX0",
	"JruJ6JK0GiK6xtwQoWn8eYlql2O7VE30yQnaQExVZh42rPuVtWv1Vqv1Yt1MnAlN28/F2b1bIN+hfw5m",
	"7mJB/6K4xHOmymTf8K9PXIxZPHvVHJ7qUBbp6dbXU4uK7LWs6eOkGlOurZJemdxCpXQRyfnA3vVPT16n",
	"HpR39T7q1O2pvXlr6uxt7AtZzXXpkvCD+Q4TtpPbZxTByWyO/Og8cLUuAEnOWWpw54I/PbJkNhYYAQQn",
	"syTU7nZGjhxqtmd9orZmCh8KwVjeSAKyp4hPsCp//Fk7e082nfdkoCpca6E3iT3C6nw6YfgRuVczg3PU",
	"XHwEbulXopeCaIhBUiM5nvudX90o7YIgO5gTttT+7B80Gy8PDjQQ01JNvkVd+tmf5//7v5dPfx48e/rn",
	"GZXmyH8OLtdRpYt+b0aTTm/spXN2tmCrPT9x7IIpPTaorpGwHD9iqR/7DQpD+jcdUDmt2bpS07b/mk1b",
	"KVJ4sYKZD1ZGvexvRr2szsSGtMu8yoo+D0ohummX38F14/K0v3i2dz4L8GIWhEE0cwNy4mmv+FEcQq/l",
	"Qy+40kBbLefjwJPuSvxrNb1Rmgghe1EUf/E1pJXzNH1CEge9i/NWm24DuA5C5nS0SC+5oRbQMfCWqw7r",
	"uVKWji6m/TPgnnIM9yQhTZjpbZ0nrcluY/TekepJHy+0UOoujqHXDjxmAMvvWTN0BybkNZgETnbGASsO",
	"eCfU9v7zU/Nw/6htFdpHKxnIgag0oB/UwpYIVrxoRqWcwam71yH5/nfSLe8auOiY3ebB+iDW62bWStHa",
	"2LCOLrfeNNBC39k58C2ropU6Pa6rTXdIco5Q2OaOA4PjP/1AyUSr9LAdhyHyI2/JQqD7py0phTMHZubD",
	"z0QIoVPon7a0MfsnaWFBQwoM5SD78cRDQUR2j2SRyd1GcPWUxmH7UVAHbgM1wBhOrseBj0AQgnEIfYos",
	"LOh622r/+vbstFur1972W6ft90VUbjYASsOeyhx9yCy5/MjgGVwUnwPqBHR6rZOz087oqHd8zPE32YP3",
	"Z8fHZx+VB53W4D1LfDBs9ZPv6S/58bDfa52+O+4m7+WTpMJPLbU98ku+ax+ffegqtfPfqfo76cqV0v1u",
	"e5hpPnkkvzruDofd/mB0rv49KJrgh6O93aBulfZsI6pVdYw2rllllesVKHZdSLmMbl7NygnclpZVQpus",
	"oi6VA1SgGroPVR5Xzthr8phwVtWFVd04t6nl2zKP5lR+xdMae5G78JDMC4hZspmV0mqLouQ40sykg3DE",
	"57kwqyjTWiR5RVP5VCLeRsgjihr64DAfer/FUCbEtiJfFhA1fAi8mF0Fisp30CJEE7IkZE2s4FEQ9vxF",
	"HDGAHLIttwN/gnzu1qUxl6qvFSjxQPaaRdO4CFM5hJnYGuA0iABcLDx3QkXGaRAmo7cXBXvKUPJ6MHjK",
	"UeiUBgWePztBZKH/9////2D6iwb+iHmIMXKepbwNBFNlGNAw65d2USVG9sRW+08GtUyUtd9LzMsjtQ4P",
	"y8MLksZ1HT2Fc9e/GpCpQFdLzR2ChmO53AY7RjN44wYhO2t4CqYJdWaUCGjUYwaD2xnypYMfhVb0eUhW",
	"47O/B067H0e9zuAN4Hm7EPDRrcSKAr0OJl/1OoPRUf/sZHTaOumqH6sfJucWj/yjBJDine5xd9jNFc62",
	"RG8vIVp4cMIRrqmOXvmEVDboDhNaRuet/rCozjoIEXMdmkyC0OEuQ/SJyNfEbk3XCC1A4DmJo5HnQkp9",
	"v3t+3Gpz8lnT5a3mumJun7Txa7d7LsbnV0KJDERUx5KQlZ0aQV2vM2qddtigaGnMjTSvsoAuFUqN8Umt",
	"XkvzApHJldklIn5+fqhkrR/EWr2W9F35Tt8drdh9GkRHQew7hqSHSDy2RxMQ6cty/kX+DfRcxxACmE/V",
	"Sb8ecXFgxAi51OZy1InKp/Ki2vLcK1+Al9l1Q1NYxfzPuZle+cgZEEL9SQWjaYsVTBoTVdhcBi7t+kyF",
	"CQ1U2VUQutFsnophhNMpzYPsxTiCXqBll6mbNQsnmRQyTlC8MzkwGfRl9GJyN/4waU+tnJEqT9WR63Ed",
	"uyk6VbHiLOn2AyWP0HPpGPlX0az25uDwsOwGkAylGBzLmaFU5mbG4bmfpd1nvDRZT+a22T8LuHn9/J6y",
	"ytVQ0+TA4+cYfYG+N/rxjw/O769faZzIV7Z1JjRaZI0pRbfK07m67S9NWcr6Z02fMeQ6RFMUkiU4SC3F",
	"/MQmhk6ZhZEJwRj5OMZAlAcQ42DiwkgN+m8pSye9yk8+zbE/2I91RJviFQg5Srg9GoOLHmW3KAA3LrrN",
	"NVnMI5bLYVXs/MKrd8La1idC4bmTd6wp7FxbTJ+saqOqfdNZo0sdcCsPttx+Ywag+/Lb0acXH397bzep",
	"6dNGq5zIn7MCKSnrtKpZJs09Jp+jO3I8ujcIIJoi30F3LPU++SmugGK5UCTSW7gkcif3tUEOEUObyr1b",
	"AbAtOjI/TD+ctfrDfUN2qDAy00zNHZRm+iGnWkNB8WoRWU7vm5/EHjUoGK3w9y9fmr33F+X40fnK9Lhl",
	"Z604mr2FDjcUbF9cLhGIKTAZe3IVQroVxj6LJXK/Imc08VzEn0prEPtyRGu2l6Rpzy+Uuu+v77xTFWj3",
	"3KuArgyXrAzqIsuI5CEw5M/OaYucyz5kX9eppexNrS8efJOakOUpQx5MrGDMn2PlaPTtBqNT8h9sJPpY",
	"P0SEL8ACuiFOdSMtU7baQ/K/dYRCNjj/NYHkfBBXjSLnrPSwQ8glo1gi1poa0DAcOVSKvP08fmPM+b1Q",
	"vxgW0oGp60G6hbwQYH13SBh4ZzHpWbKVsukdUTMO0m9A9WhIRlrYyE9bfAO+/N5iwvkS+X4CwjVsbhcN",
	"Pnv7/suv46/dvYDUQG/ucnHsRQhH7MUeHE9WjgdPxUCmmevSdNAX+vVVjAYXssC2I8FpO6uGgVsfoXQ+",
	"DJGyO4/hZnz3Lwzg5h37L4jePivgJ9tjZPW47YCvmYpB29k9YoWI7dw2k/UFHHOpng4C8/ijZTZ6VzZ3",
	"ZL24Z1rvRj3s8uMl23kguRUZLQ8lDJdy9gYcxdQR3rCbGKta1+VViN8KwqIkxCgprB21yiQfa8WuugfY",
	"ICsWUK3NSKghB/pLiwXaSZQcJeKz/PCyAgduQ6++ytCb4lIZlVtzV9vsWsmwezGXh1fQd78aspDPoO94",
	"eqORIU13BXOj2rTRzrgzCrbDgmoD9pyozomlPUch402lnMy0bBgt72cGzr0VMi3sIjV+9qIUqpFc1BJg",
	"FaVlqWNMXActDM9bUjOulqffJHqLIVrd5M3sy9bm7g1orbifGs+uSC9tnCOAO2WXKxdTWEPhaq5VcWlS",
	"iRd43pLtn+O7J9mOn6LGVQN4wWR0feCd4sXXwTMr/dAiDMjKKr4V8Y9InzCK7kPtVK9FbkT1SOxLvuSX",
	"2nQuMArdu5Hgp1vkefzHZaG7QCk/kJqweesp7uFH5HlnYc+HkwnC2B17qM/vEaTq9MiTbxPP3jSvXaMl",
	"u4aw/C2BzMryFF01wOdaa/9z7VlD6/2r30st74/ZO4jc9/KbidiaBkXA/DvMw5/h8moJBEon3XZgdBNQ",
	"7KEt6bosnDs38B9ihiZm/NbmZ1p4EZ7MRsf9Xvy+ufzFJkcTrW004f2tmKXpPCGlslZ/ycvlO5jhcyo3",
	"ZTYtCxi8SsLPTAZt54Kj6QAJC4ndcNYuLQ7BW9dh1qd8dtvikcZ65HuFLezlW3UCvxmJLrgzqnStKrZn",
	"u6bzR6qCxC/Ha6XsYQ9m/zQO9wNRw1GGM6nh5BpeSRM3SeJmKqqmKFEb0MapA12Vg1QaDL4kTKLudap5",
	"k5hiMZlyjQ20mJUQgTGi4S+pcd49Wl29xmwjfTQPbhC/vmFdJ8h7IebjBqAPSA/EI5Y0WzJRIqOrbgWc",
	"42nUFk3yFabrTTJvCyZLJX7PptrOSA5yauuJ6lLbPaNkYVYIspmrtnVXYeaSzCkl2f63TJy9Pm8na800",
	"7dppDV0thJy09JaKAmPXd875raOggOJxIhFvSuu+P9dYcTCWksi1otppCW5QSE65Y+msUz44m/KtJTWF",
	"0E/L2Pt2PrjnoetHx3CMiu44Wo7Onn36VNumY5Zse9QI7dG2wYLQgRzwNPD5MxnQKl4tkBI9+yyTYa70",
	"TKJ1Cj9js7aDNS1jFaIAxBiBp1iNv0uF2jITludlOsLpU/zOx140X4y89uLT4W83M60WiBYtMJrzD9JU",
	"iYerEEWfjz798tu16539UurRnJry/JCqPbg08ZoWxNJxQoQ1XPQRjQF/maiiWHefIpdCRPbOky9CcNE/",
	"fqbVsKXqzcXwzoIwAsqzTGMb8PtTalpFzVhQehHoNpFz0qOISBVwMksNHAOqMnRH2VOKnNOSfsng1Xz8",
	"josL6P5m5g/DvZFym/jE/oDnPGd3xLNbzi5RVqupBOq14NbnCBBWNtiMXaiCdv+yaIQeys2OU2O42wmt",
	"tVSkJkQUX+sgTGI2Kt7rmMcb94KpWtjxV28Y+XStViwl3LSqwg7pk/htxQdFUT5ULxcFk8DbxDU7xfeV",
	"hf9UB0wgyoJdCfdGgVgnjY3cvO1QkMR62gHWfFUQJGUILwvmZ727I6+kwuESZBT5Fiy08g1yFSaS+1xj",
	"jUtl8dD3uUt6lwPgVOwWUrdKw82YQ22UXY0T16eDQx1EmJ+DcimMGkx/nR2VhO5cxUWjhBwxTnoORcoo",
	"yp4WRZhBOMIyBNYghshTJZOzWhxXI8TxmIr8sVm5XA2OD0cBC4UrdgPTliwjveObaReJsYsT5uaKhWUE",
	"9/UE50P1UOplAlZR4hRn6FCpf615FsqKtlZtUz+GZaU6pgG0cwPMFrusF+ZJLz5AlG/tnAv72jigrI8W",
	"ed715e2oONLHGG1EtgPm1LKKf0oZ9Q/RJsymQ28UjvBodjL+5XzQemVjEFYDtiqag/koGTfhUL63FgUS",
	"b/cKTKZxnTPcB61doGTYmM4LKhnrg+b+T3vNl3v7r4bNwzeHh29evmr8+OrwxcvD/9tsvmk210cIkRdV",
	"++tp0UgNVvIn0nklhGjq3hlATSolE2OclHh4WzoV0AIG/IHKYdi8utUAcrh/MSZ/jBzfP/gl+vhllThu",
	"jN0rHxUHpctv6jp8J4shu8AobPFays8SVmaI4Dwpc1nqOVDqfknx2SKx2ISDdtoDM7/KDl4Mm/tvXjTf",
	"HDYbr39qvj748Q91mF0c8L+reWracVxaq1PXQMzzt4KnKK7/7SwQXVK7WtNEsTouXnhQqyekAPbT0EW+",
	"46kh30ltyWB9ON+36f8mfE4vGF5+ryOh33UEkVXxC7qeouWHgQ1lBZ6UaSQkcUeLAoEjqjr7Iy/wr3Am",
	"RDycjA5eL6JXPQfWtOIELTyIYBRbHFXqx0np7TPVHF4LnUMBP2Ha63dhEC+qnL+sU0lZnXqEfO3EHnLO",
	"fMP6VqfCZWGAtAD17EUA3aFJHFH1R51sup8+ffq0d3Ky1+lok0AcNPdf7zVf7+0fZA/U3fjQZswc6vsi",
	"1mdiCNnX4RJPZqMXvaPDV7+dTUXw4ZvaBzSJghCch4ETT0TQQW6FmD12Ib6uPLdDiK91k2oRjq5b3vqj",
	"MXUmKqu/YpC5KhwInMSsykZhM+gDiK8Jjy1QyHOhYRTeuBNUB9Sxe0FHGpHntAMgCJNv6TyBwJdvG0Iw",
	"YA42MY4pBC1FPXVYcC9LsBYhOCdVub7j3rhODD268+MFmrg0pRiFleANibXLKdP4GMs+bzQmldf5MXQj",
	"ZBCcbEJ7+Xgnwb0pdtAxe3pW67VbQoGyV5ncdeUpJTaz5C++ramnxaXKLGzgnO5NJVBR+rlhaBB5N8xc",
	"nm4OGnw4GkJwuTSfK5YLtERIPoq9qet5Ai7VtBymyWeJAwcGt0F4zQw4LgZO4CN+dk6oBYqZhTA90qi4",
	"KasLwmTNsNSEt240c7kXmhiEz75CHVs0QvqhOM2kZiTbGqPoFiEf9E5H5/2zd/3uYFAH7bOT8+PusNup",
	"kzaPWr3jbodThHADpOp3AhoTMoELmuQEgvPuaad3+o63M0YTGGNEzWdiQyKVij6p3eHEBj52HYoLIqqK",
	"/cj1eFx+mEINIOtYHWU3wSnS+ThWkYjValcBxER+qcWZfsLMy9nW5OnsktN5CqC/TK1xFIWj3q+3zqe7",
	"F/u1yiZ8DYNm5cXpdD569X7+0/4Fvl0rkknc644yPdxMXBPvidV2mR9p/jfOCcuL+PUEDtwbLfaCIpjZ",
	"CzSqNHdZFCKbWuDFvBEvAskdeU8I5pZlIUUrtAlJ+pv5PFRXf85GldkJJe6GEu5FBARxldZUmVu0KUNX",
	"Mku9+aHnLN82//j9tNm7+vnngrtEqvqKkpq601vqw2i5Pt2fdKjSIcKxV4GQFjnN+7SQ9h7AT2WzvoJ/",
	"IeQu6pagrIqUOU2DzlBZISS6ztgK9yI0f0sr0vM9I4+yscskSAYoIV0nGuA09jyWRvfWxUjL6Uim4ViX",
	"1i7Pz2FJrMxEUIncZGFq2pBHf6S0mErHm/kkglcIhDEXBJLsDG6kgobJU52m0Bq0W/1Ot2OlaF6B73OT",
	"X0FpH01mpujCy8KWuhWZgH1v0dYgveXr9NyKhuMqXIw+/fJrNPn4wXx+rKAG4D0tHH/l8+TikrlgbKL9",
	"1GWBP7+0ImuQNG8KQ6ykTGX1JZY2W4VqUk7sTt90K/4aMf0CdT5MFRUAVHO6W9G8feqSxUxX8Kd/2fCZ",
	"cytTGggFtzzv6Wfgbyw9ThLdBaUMdJMHHC+n9ob8Nfr91+aFf7ykqgTWefXbiZr/qDaJ/FEcXrS6b7/U",
	"6tLkzzEb/U5096lrw1nJeOlPi6wlLEVmvSDANlswTW+xZVS0fGlDfbJJGJ3AK1CiDmUWXlmMat3KsFtC",
	"/6aMRpXldlbTroxwQQaRJb8g1S/YgRfccmRTFelshzAeeIkjND81mQ/z1l6mYrhcwSx+meWI9dzEwlRV",
	"lTXUawSx9rNqfpl/tfvbRXfApJRB+323c8HSZioKilo9Jcu0W6ftLk2uqdP7qBrXqtIhKcRUUTlhMFHy",
	"RBBf61hud7ARBeMre7Bq143QjuUDYKeCIKWz1+8IX4/Oj97/9iqcj0t3T7dw38z0QxMvAUPkCATOqaKZ",
	"oop9nmOLZf5GvrMIXD/SQlVtDDOT77dTHXRmZsjvAw1T0X4Ugbgq+r6Mjs8PbvURFrRT1Xw7i2b9/k5M",
	"0vrjsbmlY3NEN4w1z86EPzZyfirVrWIJ3MA5SqpR0Bo3sd3bWqWGkoOAKyNYI24DZEpzzf6OJ7PR7+/j",
	"n17/1r8t3eILwWP0I7AaXqU05ua7yI4DtUtVp1mdn4oJdhldVXpv0j4W9FD6yNBP6hswaNswLAMMsZ0u",
	"kwwicSXHsXcNYlInOe1SZ7lug7OZ8HjhrDbh3Iq5qakVI7XC1K7fl2qTq/qq5elEcF7WMqlBisIFLW0U",
	"htnCOL+Od1LKk4IR7rD9di0TeaFvE22Ffn/i3rn+CjZ1xjFOg8u3Wzetp3wjc7wTY1QN2bGAd5J53pTL",
	"606cRynZq3iQ0oJ5N9LUqs47hmwwG8Aw5bkylX6N9+9tGJTA+xtc/hqgNwWxj3nebKeuvgxC4OIUhdzf",
	"NYtcgPxoBJuD1uLLi6+lvnS6CdqQl2EimjxoX8NSTyZ1N8nzvPY4ysVvIDgfHU7+7l3FXyYW2fFoDZcl",
	"W035zpYlI8MZxVTwCgqoMOMgCc+cqtxTSSpYFawuS31FrDrODtTo/hDjiGBi39cHE0l3vjme7R8vf7yy",
	"CymiHa4aTeTDlu8HkdQjWKpOeEjeEYKk4ybvvfvLGLpldKI5vHPnZNzJ367P/m7qykfGSD/9bMjMjBUS",
	"ieh4TE6qTjZJXmbS4NleE1JcU5iS0Tacx4e6rFk6xpeQX2rawwvyP3MWp1OFw7OIeJyfoIqdE6gZIlkV",
	"QPQXyNM/Y9jlfiDuFPhB8vUtxEkJKzCeNMmnpQA7u6Zvhrx55YF83z0+AXjpR/CuzvFQmG/YEhCmorFh",
	"TGM64Wyrygf909b+P+HT1rNFI3zafvbnAC8uG+HTC/pb+++3//mf//mfDweNpl1WvlRTNZNPPF+eyd28",
	"wj3UIlSycpJ/QRAnJkXkSimclHRJD2o/uW+W+9OdL8KDd5f0xzvJfy1rnvtmFyEvFr0pjZaSPisz99Xm",
	"WTDM4zw/kHlWZzSDIWAvNqs5i4pQB6TIKNEkrMRFnaDPm3wgmFr909YDS1wW8gHaAIxTZqw3nL4sGTpd",
	"59dIRrbOGGjRlNTqCnlyXduQaKjCJTl99q6U0SxFfjVbyabIV+Sbapy5jZxSq3fDlNxMkru1/GYli2kz",
	"66F8GQwkQFFB0t8KiXzTssGmb4q2qBGnLTCQeoGVoCN8uCc0C+y6CfEfS/jSu14FP2KL2bn4DBWn2brP",
	"1Pz2iZBXvYjrZvvxPq7zR+6nAGBKC1WFolBzIm9UQ5Cd4crSfGODmgJLoOT8Y9x2w0nswTClTOCnRzbf",
	"Qb3mSaT1vMYw7X22XvI3Xb6UqNLuLaaGa8I1OKXuvCKm8VwHaVxPYWIl4GWV0h2pZXX+tDm4jrDaotm0",
	"hy8ZhRD62Kt4qg6TQsWgEqugsCVzriaoTvXZKExk9AXsRSbNPVnwEjqxvrr8YdZNSJ8toaVQm8xg768n",
	"vMTRLAiLvGJjTNMGMJ9eiHPUPMGAVYKrYeWO9SNOZgwsoBtiCZGS77vhgDuqaPVPH/A52z97rXg1G1jg",
	"nlL8b8rF4UjntZ3u30mcQjAQDtDCiVJ4RgAHTV3fZWfa/QyKcsabHCPYN2p4tyWTVZUJ8DoywRY1fNnD",
	"PpP0YYYYNk2uFxhMeCkQhMBzfQTDRuobTC48IPC9JRgj/kXac8QoT5RnYbCYoQcsG9hA5GS2VdXHPb+d",
	"Zk7dzN1TeVtymIDUtzBEirQ/XgKe5wOCSTAfcx0HofcJtTs/ocEmT5DvPOH7ZJ1BvghAbCKe0N3gbRDN",
	"CHf4QcSyyvB8vPZnWaHIsLLW2lp+OArCzcIq6aWUYnuJLLGK23xSXGj3NLU+FKugdmwy9O5gPpJZL2Uw",
	"+hlPPeFHQQJJm6G6mh/PqTT0ZvaqXIi8vZuHVXKqDNUSwYD1KhG1dGaafjUo11RDm3WPNi8yy2L6fmdH",
	"p4r1SFUXrGVF0itmV0xhUjIr2zPZSNlhG1ab1QfDZLhRayw5PDZhvpF1rSLVFATvNKvOv9kPc00iq7Pi",
	"BsxKaw9rReOSbG+90L2dD/VW7UvFK39ji7d8zWagcgz3O5xFMhRwiNAHrr+IqY8/TFTjrfTXFCWK3rAT",
	"eKt4Efg8LIACLGZhVtiteYwo4mKjZpnQXAHLySe4L+r8wIDwNFCAHdU+KUBNZqgDBsWoDcLJNZ2c/Tr4",
	"Hx7AbUKgIrUq4ZxZQtNYRwfvztu/X/+oxTpaA4AuDzEkiJb1ljAgzo5EhVU3YBe3CQ+YFqFzCvRWOqw9",
	"E6HPGZHIIiL4Ic9zKwVumCa6bO2mGjMPXB+R2aNAyDpwjsGw32szZrw4Tf08PRuOWufnx7126+1xV8+j",
	"UmG+q5yE9B7dSTRpqVG2C7sauGRYjtIVlUq9PXYZqFrsyAtgVLVQJwwWTnDrVy3HpuPY9a9zJS81Wpeq",
	"+R2tfd0FY3QQTYPuT5aDeEy+SfGemh0qk3Epm/wpSahUr80DD01iL53fSU2dxP6WdZn5ll1XfotRuDyH",
	"IYth1W8ozLqi4HjhpIJGG3keaAexH9Xe1D7HzeYL9DPYb4LWaQfQn5OfwWGzVk8V6t4tUOgyvOHayVL5",
	"mf5uEMEwQg4480Xlk5/BQfPgxV7zkOZuaL6h//dHzTwNOoaophnP8KAZSaDUxJYNa2ETPPJc/7rGIXbF",
	"jwUMI/G3otATj6jDnviBoyCEV0j8pBE2IwEwkXmIYy/7LOa12obVpA1/tolyKkBpDBDZQsmtHK8mxsPU",
	"fY8KBVMYe4Tb6L7eb7/vfaDbvJiJzGOWBLFe43uyHoNbE6vxrjUcttqtFl2zvkg5/kpnxC5OeAiv0MD9",
	"ilK0HzZVpQ25pxVH55TnCYYyS3ADiJMSAx5sxexZARaphCmGNRVDXayUY5LFkkhYf5EF8BcIURSHPgax",
	"rxYkx1Q2VhSHk9Hi9tfg1eL9zD7vQrGmPAl/MCnMU4mtPv0YNf8Yz7RRaFgmcBbck7gvvCHtKwykvIH0",
	"Rf5TsgL4S/onfXxZjgaIDWCUbJn0yP3iJPYi9wP0YnThvvWCyXW1hCGGOspOXLJCFSIuekmxTFBqZt8b",
	"dMlaG/VOzy+Go5OL42HvQ+v4ols+GBFLF1d1NKrqwwtHtnLrVYMY1mp99fnf6axvaqrXn+CKA9uL0Dwb",
	"apCR3lTBDFrKdePgrqbAh9bqNS9glzUiC3ikc1pRLkffGsxWMhL0ElWZvVqLRRv6NxAfIzg9DRzByFTJ",
	"leeZLPpwjFE4khDQI9exiRYedNvD3tmpjscs+ladl1IjY9FC9TmyaiEO0RDdRWTEaeJnwqrVosLTRctX",
	"NKaNjiJ0R/E/VbzY5IVmwqiTRnqimXSP/Em4XETIISWfs+tEuWBgmlWP5kK69wNSIaPKZnncbQ/P+ps+",
	"JIvGpDrnF47wChRUXxlrUrCr43IDPLC5id/EdFce4rWmtqS1PF6DBg/bCzQuTe/RHaCvwCRwKDIOzyvE",
	"cycyHzAXgymrXOjhLzIxGf85OnzVOuzaOCDaqUXTfVLcEUvB9pKr9hzeiSvoQfOl9hYaRNkrbDvwrwCK",
	"APTAYOIyP6CD5v4L8Av0wQvSa6Xa/aZqLyy+0xs7pEk5xZwAfYe78y2gG+ZQVmHifyYm52niRQuCECh6",
	"k2cNcBSE4Ar5Y+hfA3e+CMIIU4QjjKhrE5nVLzH0GLJJrjUKmM/byau+fdu4CarBLTwS01V8UN0Zi+vQ",
	"jrpW27tB9VdUIApLNVP+UUoQFg+5NCxVXF4wlhowJkh4gX8lhArhIFinwQM8doCDKv2NA99enUXHaAMw",
	"OumRIZQXQafR9yBEUxSSkWGqFXQXgRsXAuiD/92bk+EJ/DqYLRcoJN9TDzrCCU4Ir/b8PScMFgvkgEWI",
	"blx0C2AUwckMSVdksrwruNHRvOnHZMQ1+nI67Ho4RnQXxdCjbrPUGCo0MaR1G3mdzyjZgckkuzgajWPP",
	"Q5H45cfzMQptA7kzli86vZQYQJ1ARXC18Pj1glu6yy8XCL8Be+AJIefJG7DwoJiSPfCEEEcehoh5HZON",
	"gR4ZY3IwkS8Uup+8oQk0PhMmQJ9rTNXGXiGHOUCKAqxr2gLsFS/AnJgHEbxCdJoqY4uSARgHwTVP00ZP",
	"OpoJhNrzuOsmTfsRgnkQKnl4aKZJCDx0BSdLao2eesFtfhOsHO1IewNod1YKdtyD3mIGn1NC90i3XISf",
	"4+iK/Dnaf9+doL//WCltNgtaKFi8ah5dkWJH8j0vns5nREedR/dzfSIWy5THK4JxHFEv6TECc+izzKAs",
	"s2EVZ9hMWGPFPNoS/lshW00YCGgy7LXjMjedzFhMQmGqbKVLuvTG6wSArpBqO03NRmMYS+IbqHcK1zVh",
	"G1qKcx+UFLYGnM9yXBZo3mhSymw3buQhS9rYuZlY6rP+PfRUDelr4E4BpkeSQRuhQMFXjKSjO6CATc+x",
	"OdsfBSa5kQh9Ng0NdRZZmUtGTRwBxcy2gCFN8cg/Tu3qt9Pb0U/ts9/mwfVPRS3QE6K4GVVQ56UY/dkG",
	"cXQ16v4Rh8uW+9FSepan7drJfy9T1T10uGR2sDawJNgGNxmnZJNiTEn5pUkmzw5VX1mo9zpgVftXrz7G",
	"qU3J+hZTiNOZ91Ei7/X4C4EXzyuE62YabtPiPX8a2LmUmovrVDjknSlIvS/P838Kgsgslv2mYFU3cB+k",
	"kjP99MFeC9khVOmoowOs1+WZb5liHGRKjrFnebu0x4zN35poYaYBCoNblkCJrxBKCSFXsExlXXLPj1AI",
	"J5F7k7Io2KiWOkzeZIoyEQ3NiKUX0jqHqsaz4NZPlJZ6LweaILQsxE7p4YCnFM2P9dDgLKlTVPM1KQnQ",
	"K67VdqsqrFOzUlp7B0bwKIRzNJADkp4JR3ygE0j+Ut7+Re/vPogXXgAd5ADyDkzJS/AUIwT+ZD0BpElA",
	"C8lsXJdPC2+8YxTB53KT+M9zUsP/OWjSOvCzZw1AdqA3gJlcGUNgMIlDIop5S4DjxSIIIxaHS5h3jwyJ",
	"4Oise4yDUTSaT7/uT19A9wC9Wtr46GRZotMatkZH/daJPV+oA20zaxhFyZw5aBGiCc1tz0nMzyJGkXEO",
	"6TvtDGIUPezpA3wwWKxuUiz2HRReBSyFzB6RkhtAdhXcujS52ZRcDAMAgVwHIPYj1xOVgtZ5jwcBs70X",
	"nLNCfxUsor/AHEH/duZ6aGvMNegOK3EWm/wyvlIYyiU8Mnd9obvgkATkT9G+xQaUZtS6ui4sS6ub0zfJ",
	"1kuG2cR6861u6QZupqxMSC6kKpdoy+w1nTdclsxIVQOixe7PU/dY1qcm8an/ozpEi8RyNeS5gT+iKYGY",
	"1iSXe4Ed57Uu+fAJBkP2aTrhnXx7FtKxyh5E2fR4hYi4yrdJGhnjcChevbbwhmG03M6wMEBD8udWsBcJ",
	"CRVQiShFeszFHXvd5N1tKvjZUMXohDZHLl2AF13Jw4b0+21wd/9XpQd6NzLHkvBbjpVlbDQO7qzVAGRK",
	"NujYkp6XhQcnaEZ1yCuFOwy7vw834MuS7WPla0F2jKxaqXz82LUSXCM/6UBG4eG5yI9GZu07+4CwrkwN",
	"SOojF8IGOEbwBoFgOgWu/LLXoTdYjCYhiqgwN0ZELCSCpedSM0kYxFcz0KI2LJFgdYagg0ITwBajktWZ",
	"p3RXZFyF0I9GWZbjxE1CRLVh0MPpnVPzvowzlYaMM2pOawgnE4TxKBKhH0p6pOUvjYZWo4HuFm6I8MjV",
	"IIueUiMxDeBEk8B3OGwE4wMXgxvoudTQqwrfr5v6dC6kUG4I3yIYMuN7Qit/ZqVFp+A8UxTiFl76k2qZ",
	"y5MiZDeqEshvnAAH4YgLBW3hbm0vBsgiNtpNO5h5FbxowzmK4Nz1g9bEdbAFXmL9HlMaXSEfRe6kHThI",
	"r/3jHzCXiygAMUbMT0/6eHGwNk34D3B9crElYwEgGYyGErczGLZOO61+p1avfej2h923/dawOzrpDc/a",
	"789OO/1e67hWr33qtgbD3NOTs+PO6Lx/Njz746x1OmqfdY+7p8NuvobRyaf22flxa3DSGg3Oe33+d61e",
	"650WtNruHffI805r8Kl93Oq02t3W6eh99/fWSW/YGp1etI+7rX6tXuu23/dOzzrd/sno6Lg1/HjWP8lV",
	"1r04Pz4b9jpKsbet9rBL6Wv12+9b3dbx6Py4dTok/w6GPTImreNht3/aGvY+dEdsEJLirUG71+m1TnNN",
	"qYWM9LTfH5/1z87ff6Kdyr4d9rsnreFZJz8og3b3tNvpDk4uBqOzt8e93y4uBvni7/utiwF59mnY713k",
	"W++/b73tnJ0fdy/6vU5LM/St006vQwe/96E36J2djgb9/dG7fotMihi4Wr123mq//zQ4O+6ejoat09Oz",
	"8/e944uBMkon3cFZp3dKiEgennf7vWG/136vPGt3z9+3js86PTKsWZJGF63WaPipb8hYepWLBv+3JSvT",
	"nSw5IL0tJ0azQ8a68N2oJDhWuY75bjQ6Xf560x68bRf5OCRF5ijSHb31Gl7Ox4GX+Vj3IWl0uFygbGq+",
	"L360HP308aC/3z36xe5wv5AxnhRpSZw79gc1cwHVoszK+x77BvQ6uBKMbFWPmIiyPOuFArAyD27o9bBU",
	"MEy6orStO/FzduZ8+kz6hT79NaYQifxjhps6RsjniB5OHUxgjKXf+hxhDK9QWvn6J/cuarQDHIE2WcNU",
	"wFsHEeyC5zJewbMrrTVCc+h6tTc1bwFxhOLwf1Oa9Fo9USuJL4RSKZNg1MWDGFMMBkcyH9czHQexi8E5",
	"L65RscGF+ytaHkMcMdg27r1UDlfPiNcaqBVqdBbqBcT4Ngidqo3qdTM0Peskcm/cSLMNeRBHA8RuIFpf",
	"vtKOJglebXYJjMJ1Ec8o2LS1nE5aNGUALqJwSxiX6jbhajeF8u6oefDS5O5qQKuimymTUPFQEKso4wlH",
	"Houdm+43OihmvjvkIn3o87LS5YEc+pKZOeaWbdYPSZNpna4boWjlR+DBMcoIBydLQJtOx/QcNi2Wv9Qs",
	"m48MQx16OCdW3+W3wiH6rgambNeu1v/t2GVKDlDDYSk2IMu98qEs7cwBnIkSEa8URLR8ZZVAyY0bhXaC",
	"P0DPdaQSKD1mN/JdO5jPufNj1lOJo9yhOxq3kqT2hzjwpYeQwNYGSZW8ww2D/Yh/ZcL/o2SzKD2RlcHF",
	"APnxHDgU/wpQGEOGG+9STEQaeSKSRvAAv6eocdWosziT87PBUOizn1HzDcVHZKgy/HuKFesDdOfiiLk1",
	"4NiLGp/91mSCFswPSiEKo4h+BsXswhCBJx9ax73OE9LAk94p+9EA5wHGLimutpcqUE8+p9Q9OW/1h73W",
	"8fGnEa/xKeQEMd+KMQs8cmk8B9PHulMyGDOIAQ7mSChpWbYFqhknT11fff6MO1BwvRVtiimQ+F8ZMqxM",
	"Roz3tmJerS5emMyrH2GIZkGMUVvR0udVHExJ3jIFqblzBOA0omEh7mQGfHQLJoHvM2wFwpZizRDKyfJ+",
	"LiRyNo0Cnh6FczeKkNMAF4uA8ODCZbl56orLTbBAfqp6wkCkhogUp2OddYg5aO7/tNd8ubf/atg8fHP4",
	"8s3hj42Dlz8dvjz8vxTkbOWwG9EN/cDITkaBIFjYQm/FwKdDsl5/au8fHBx/vfv14/7Fl4MvNjSIMdXT",
	"IN7a0xD/jzi7RvBrOQE6ztex1WrSKuO8nsY604kFa7i+MNDUefxN0qqibGDCCjPg0dQqYwSuKFFUSeGD",
	"Jt0fPIQx+/3ix2aTcZKEBntx+Pp1KaR7SnEhO6ATPz4iz1sVf22zCJiamK0xDCdao8Fb9kIcxrekEzrj",
	"5QxNroM4qkpqO12O0JqPJ+PxsAWaLUKWjJutsyBzHtxOEf64v7E/QT5PAGbrmCANVW1W+zqhgJRKJQZw",
	"EwGAFSIYq0bCFUercU4opdU6bE2OTjZebb3sdmbBkjRYTwWR8lVAsy2SD11MzxqZScWQEAf50YBBR5qV",
	"pEouJB7Q5fo3yI+CcFkHEFBoKj4EjG8nQRA69IRjUh1YeNHoYNy6xq+duzfw4JlV2scUdQnQboV8dHRP",
	"IntYSZQa+6g0ui8h7UsMGX6X7Qr8TRSg2y7zds/GAyXIX3oDD8NmRA5DNSaXO1enHj4NIgAXC8+dUBGY",
	"yL5T9w45yjylc7FBf7mCttbaTfJSmwpRA8lsafU2YDrnIzfsBkIiop/dCi+A7288t5C38Sbw4nlpSEhH",
	"etpLVv9ACx4FoXSAWTdjI5E+zsKez/xmyM1MhHqX+WYnS8pA/0d2ErhK3aNQVm7SKGkIyTtjp5a5tVM2",
	"JagciltHwaXGASa10RSrn1Jfa4VAHlqrz00hAm/t73vHFExC1GqnThZfn8XRIq5wTU2XU9ddxt3OLA6R",
	"S0pvcAYS7A+Knk+ks4jJAdx+GNA2MsKSesc7aO41X+019yV2daPZbP5RMwlLqXSxpTmmlASx1cWmIoFn",
	"lf5nxaHVRiHi/mI2EzyE+Fo5/y0C3WXEOKN7BayQW6VtmSbElliW9kDxys9xeSuPZJ1PpiJVfEkSlZSy",
	"L9NL3ABMTYYcXhiDOVwCx51OUQiYs0Tggwj50I+kszhlr7QS6gQ6FBENhSF1MOyjiO4oAkBbJ8uk+7dK",
	"trp0DWrCunzdVb120zV8DN3I5Ft3m/rSlHtEuXfkWE1FJwjiaHQ4+eX4t18/HNV0Jt5c79YbNZueEQ6t",
	"0C+yUpn6l28CY+QFVzTJZKaz5MvRme/jj81X16W2tAw5l8axWA8YwAoYoZGe9YbY4y8LdobkuLKfHpNv",
	"UeYoe0xA8h0nIDGnsQ/R1L1bNwmJXurJu0NXBy5Kr3iRRckKNGiNLbHs7pDr8sa2/ktD1ZvAb1lp17EA",
	"Y9n+5pMMUI6nqkme+ZmrkjKT7j5rpMrU5JfLnuzpXc7+1K5+p1FTaa6S7bJIdswxxUY7pjuwk2bqgv7L",
	"8iHQ+okVTZD9pdMoepZB6n6zIzvnjbUtshMnrHXJrpJ0MmGQ3vzQc5Zvm3/8ftrsXf38c610B1q1tyut",
	"olRqyipre10+L2LvcxhNZhXtaKldL2eESH5lD9TVPNuKSlfSpefxBc1VF03nQHospYeFmsaKSaGfaLUq",
	"QitY7HLOT5hJEiFWxfPcxrAGRVZFityTZKXchJ2tBK+RDetGbFGyrsrTqt9wlASllXYLziqVdgsK06aJ",
	"ul1l8tLQgzuYxBzW4SYMi9k6q0wqKVKsHaafrDC1lJjqM9uP/Q1NrkRC3sXiFG1taH0q1RWkszUl9c1W",
	"Ie4kahbfTm/QbvU7XeaN1hv2Wse9P7q2/mfZKbNgoX7sr8hFhCUqMVK1aGW1lOmGJ9C2xS0vfz+eo2gW",
	"0IuKwoXkpp1dpS6WyXiVqen0+t32sFavdU+H/U/6HEiZHm5WyUxofRgqZjkPK82g2VAEMXavfIRWB7LO",
	"KdYmXuAj5ygM5msSq618A4YtyoEPway1mg+RXHdJs9UHuZupxKwi3bXZTc7OZoxuwVp3tgLweVLAiT3k",
	"nBn2Gdo/mfleds1lGTxpUY5sqW59mk5mj2er9KJW6d1Ty477n1QzNlKb5gMyNdJ9cg1DHCmvM8OJelfV",
	"xJLyUtWxipUqrammXvJV7FDfLktEg3UGzNYCRyeutIOZvi1CPLpyP5z+NhkeVzKwidYucxO5exsbadXK",
	"wjas6CNQpuDW7fV6TOLAp/lhKMAI27JgshcrO5QGRDwbfI+icPSiCZ2fXttsVQGl6iRwoHcRZ0EF0KtX",
	"zcNXrw/3mj8evtx7+eP+iz04ab7ce/EaoZ9e/nhw0DxAqf0npnk1K+N5tc57Us6s107OOq3jilJ/aiur",
	"voZo0c1K2puXrimRmxexmUXj4QjayVysPpXb9c1KRu07FmSnEn6vULxkX21UvExGbuNCZp4s/rLY5LxZ",
	"2ZRDhrljD60BDKu7EtzCaDLT+heL4CcM6Ddixa/R3ZLsT1XFVNn4OsKqnf/+x1wJ1ZdPeWkYR9dfxBHT",
	"PsjgsfXZJuNTqI1PzG5j64iFtIIi2ZAVspN4edIgMrF0WGgeABenhyMlNUZ4Mhv96vdfux/ieankKGlR",
	"AW+KxmTX4iNt2lqGXO1SZSNNpk63h+mDY+YJ9SaxokqatOnrLA1F5H/TDeI6d8ns2ro0N+B85Hv2vTCs",
	"cPCRB8c9c26Rr886aecsuXiDPCUPY635l1t9o5VOZeX+lYbRKPMq0I34A3GBUlQCJmehYlVDVWOL2vm1",
	"3aAMty/d2tlg/0pUK5beUMlgbN9FJ2mrssZX2UtWm2oLX517maSyuRlUjLrLl92c3sL1cQR9mYGWK8vn",
	"kIJObEaJoZBcMdBQd5mH/gBFLW5FO/OlelHr5/SRo8cEIQPQoJJspqM8a65I9spDkf3A3yOXMSAMdg0t",
	"lA+PpBYUHFmcaLyIONmmQcjaJkeFTktjo13jddKMAlL7uCIxaRqSFM88SXIFcvpbuxVTLegQzWkobXmc",
	"ScS/FL95V/T8IHB3BPNTDW0aQSSaL7zRwU/jV9OxzXC4+DwMFvAKRkiKhj4p4Zg5dsFLcA89Ic1R3B8K",
	"2YlYDQlwknJr0/NqEhugQXKh7yTWk7xVJPe/9Cg1zD4hx+4UTZYTD1U3hiVFefQe3VLP16CbryEVikDX",
	"nXIn1FX37FRpDS+btssSFGD7a5m5g6uIxqbavmk7oQGHsndg3ZBwwilZSTqRp1BF8STBJtBe1k+NA88h",
	"xhisoLrjnCPfIZ1b0UeskEEYsRnzJh7d/vb1oo0/Nm3aZHWYpQ7eL55JTcgS593TTu/0HfX9Gp33z971",
	"u4NBrV47avWOqUtYu3Xa7h4fd9NgZYkDWSqvRFLbKlABBXtRKRA31X3dTkf7By+u//au/9ZqU3w3cqE3",
	"WMNNIA/n3XFDNIlAOyC/OcKPYW5QWur9M8OMCoNRNEfaJZUF1BmWQ03Es3Q1PR+ch8FViDBOVzWdNH96",
	"tZ+tSJ33b5erqFfl6OSSy4bQx5pIwxVPpKGsbtXtQFfVmxS25pS7cG1kZmpRkK9rnen5lt2gBbkrzFWw",
	"SrnSYd6WjnQD2tES75EKAYqKY0tKGMlo+umYZf0E6L7+4ejm9uanXz5oD/GVfFDK7rtcLSoubbt2AxEa",
	"Uel6uWt/kPsK+Uz13iLgc4t9HyTOe/c1AKr/4H2NAl2V9zYAbB/ddd8LDABiRZpu8K6jqtSFKkbmW8xt",
	"rMiPRs1P8eC3weG+btOu6l97ry6nJWfAA9LyF0UDl/hJVhWlNqneL9Tsb7ZPZkySCip9Ft4cLJalUcJV",
	"O6CPBF55jiqEYUufjMryeToEewUKLSOu16OwSsqLFIW7sdys1rEVumNpqtndqrvUZVzEaBKHbrSkeh8R",
	"L4zdSYtm9GnF0Ux7gwAuxjFyQOu8B67RksHGR9B3YOgAhrgnjizm9koHlWpnSe1JX2ZRRI1h9HGbphft",
	"OQOa6VTfOHnKQPEhpkDxSmZXFST6jH5IbyOL0A1ClvZ1gpijKARjmpOTZf5sWBAY6MmhzRwARjlQsLFZ",
	"064fsTwJDFc/vHEniI8POf8ECCCjPwPYjifBAqX+qv0DPtcm0PeDaG+M9tB8ES0/197oHoJvMkXpRejV",
	"3tSew4X7/ObgOUulqrIvJD1gpy26i1DoQ68TTHTh3lKTSee9E0ziOfIjAbQc03bIeOE3z587wQQ30rmo",
	"qE5oGrCc1RPE843ytBmtBZzMEDhoNFNVvXn+/Pb2tgHp20YQXj3nRfHz4167ezro7h00mo1ZNPdoh92I",
	"Z1zlDXP2u0EhZp0gXzfphC6QDxdu7U3tRaPZIOLIAkYz2u3nEO6JFH70wZU2Va+LI9BqgeRLWinzFiby",
	"Hf2i1Roo7xcwhDQjHWYKKUNyWpYPATOejeLQb4COAmB82KwDjl9Ovt4XmOYuqeVLjMJlko5kAa/QwP2K",
	"air0KbdWsSQtEgmdnoQSCL2pA0LPSYQigTJYJNkN9IQk+7dKSU5R+Y+2MA7CSN8DxWX3DaGtlsW2Pcm6",
	"rQcgCB1EliPZoMVYNwBLzkFaYvkHkorBU/E39fStg3mAI7qb+BGYuiGOnlE3YGpEeMrz75EfdQC9xQyO",
	"UeROoPesAc4WbAF5SwAdB7yBeEIkUko5zfKxQBN3ugQQT5gOjLwlL+UvmdJZ3H0Ul2XVf5lUnX7AR4cn",
	"WyL/4d/QP+lbXTiCLvCbjYLrg/5RG7x48eI1d4pugEG8WNARJFv/57jZfME8pOmfE8DWRxDiBqDB418D",
	"H6WwuS+G7QYQkMVYXQjRLMDJpDDnTMQHjDwIyZ2gASiINm9Y5Ih40WwAQjb7Bgv7d1KWWsC575UX3JKR",
	"9oM58icezRcs6vv06dOnvZOTvU4HtE47vE/Jw1SKCo5v7OyF4q6ChbKuduR6ETc9k7vKPHCQh5OuEWpo",
	"bpcJCiPo+oxsJeUGaVyMJDm7eBalmuz2wcFe88Vec18hkz99SW5e5F4Ye95eOJ3skdnbExcxA5GSMk5p",
	"QgmpJssEWoKae/sHey/2hwf7b5o/vdl/udc8fNNsskzkNF/DXjSD/p6iGrYeLpamJBktfpk0Dgo9/HSb",
	"TGolFW5RegQB6JPjQGz3hWwsGS7hQbFfuBDTRDl8G2EJQ8Ml6HUapp2VreiqFON4zLMgSdqxNe2kTczJ",
	"RSaC+QWcZpJ1UDo6R7Ze1KseK4mr9W6Q9ErJYq3vknp+A3QHJ5G3BHPFjxEjtRbwdAIx2nN9jKhB4wY9",
	"M9GvZBOvRD1Tp0Pun1I4E3wP5F8a6JAup5WoaAfzORGCiMASIQd4RNhhyWXZ1NqMJ5EO3cAXuzUhmfuh",
	"mOUVWabnrzZuHFbJZuDEpybRSaI4rUSIWAiFlIh8wGKMXKyUGzBpgHDiZ+pF8bnG5UEMYl8tSm6P5jEV",
	"NWZ6Uppzz9Qz7hBT1C+BhiK3N17GSKMSHFFhrPnRIAP3uEMT1XqKZGl+EAkvGfboWfn2Jqq4pY9YRXRX",
	"QEyymdJ2G+AoCAEHW60DCp9ap+IOlTYI9TwdWR3gvGD0syIZ/ZyIRuDpOI6o854QmkJe4FkD9MhWveT9",
	"pGpbTguTWXmO8TobfD6kgN46wDzGEYAepspZ/mEDnAYRD10jZ2tCxJynU0q2gGkYzGnjPMnbeElYwfWv",
	"PDLPcILKJpdrmdUJLneIZIV+I/Wdk27ouICrNXlIpzq7XA1ccOzCTNkLjMDn2unZkGb5733odj7XSAXT",
	"RAhJ9Mep7U6UbZ1+MpfVliRLHoYOTVNFb38qKWp1o7P+KE8az73H+koaGQeEhUVLhMkSkvNC6v7ID6KR",
	"eJ8Wvc58bynPb6XfrK2nXHJ/pgqhKn1EvjuQVY8ShXXSgjjieZWyBTpYYp4mYkyUdkTE7bd67cUI+ktD",
	"Dwrr95eaitUBJ7W/TNU+CsKC8ZKtFU0B364NTWbn2CiuwpQyfyOnOyGs4HBni4huFvyYpovpyr1Bgv34",
	"yao0V3rU4w3RTmS8E75H071smpY4ex0mp4oTFIKXzSYL4E7JqeSNqJSpDIgkS3ZXnmLS3KOssKc6TEX+",
	"6Meru1/eTc9ndfor/ml6dvPl41WtvpY4lpW5ySCkVEPlc8lzpy3zp3aqYmO3GRV9KWXgBkvsox+K4Xmz",
	"uV8n/x6s03V6A9loZ+3uNHVArgBAuQI0APgIQ+ppu8dEOL7hcz2DH/h7CxTS27EfASdmmRvTtbjR0jzA",
	"rK9Fg3pC/Z326+y/3/PAJsNqMxwNUmYgimx4cEB+cFigW6+DDaRxmIKecSMojnarRggZSLhYaFe96VYa",
	"RzNKXiE3qUTWyY/xy1Zr8fX1eB2+4gl7FZ32CVO4YDUXDp7BBWqAoRRryFZ+jZYYEBGVnzUeukFenSZO",
	"JvIqVS3MqWkfc4BR13MmMHTq4MkPT5iYPg/oDs50VDTJ6J8Tz51cgxkK0eVTs92CPnp+xZIi7+EIhhFy",
	"9vb/w+gjz+gY70nd/rPGZ/+z/8MPRLT+4Yc34EhkKvYDZizBdUB9NT3xi8gHi9CdE95iphyyb7h+FAZk",
	"FUWqilI2C2SDrAJ6L4jHYpxFUId75Qchchqg27hqvAGfaxBKi0RDoanhOp9rrBQfeY5YiwDE5mKfa0X3",
	"Tk6qgc3UKl2nrv5M6eKyLHcp4SeYBHvQbIoUZsLPiGWhIxQ+/1vInFa3jlZCRNogTQ1kGePfr7V6bYag",
	"w9Eq+nRj3GsHsW/KqxxE0AO+NPQobips/0zkKTGWOdFIzUt7t0fYf89z527E/jWEN8gWoecFt/Rkp14A",
	"UmLjyZhBUh9YoNANnEokhGjOYk7KyJDNyxKbJgSj0rHgKYY3RgOh4uUGefEtdLizRpfCDGlY8C10gHDo",
	"oPZ8eRXRmScjeIUpFFWipsa1y2/12iLAmtFiziYZ3XDOysm+SuycNeaGgHD0NnCWW1iYwgfm27dvuY1g",
	"fwvt6cadA3TU7nnG67XD5gsNJDH3NLjw4Q10qZIPPD0OJteA5zd2A/9Zhl9Mk23gmW/1tJn8+T8QjsSv",
	"ket8M9rN36GojKXeoSjFTxmzOT1rFjCaKXJNqvGa6gnDlJsbuGE+CjAPRICpILRsRlBxnfoDEEgMIshD",
	"OnS0a9t86ogkHxn/soVjceywr3a3TVxu+1gTjpO6Y+2/lJ1MnGB5Jr1RPTC1Eo6wHBS6cfGP0p5c2+UF",
	"6fS9M27IOtc/fOYwzJ01b8RRsMfPhyIOUT9LW23oiSZ9BaaI+gphZidLlF9H7Dk4dsch5HASGf6Ko6DF",
	"W1AmZFtMZmhNy2kHm2sWL/3JEOLrY9e/1k30cOZigHxnEbh+BDwY+0yTD/70Av9qL4x9iWVw+fQ/z6mP",
	"NRFqyB/M/U4o9okIMGQQ1kIXyatzaPHGZ//jDPkAx9QRdxp79SSQZQaJoAOoGy0Qo0EkhwfF+ttgStuF",
	"M469672JBG3UL5u3sXcN+JUibSQ9ptdppqVsqg5TmNyxhWKgkVslSfTDTjfifGTHf9VCGYp1IfqbhqSj",
	"/n/ifpSayyT0isMMPbQ1ZOLQqiuB33G1V13axhVK62HAeMkA6PP8nbr3lvqLm+6pPAwu1WYUEDrMN6BE",
	"9yoCtB6vz4/6/93q/8FDMwDwJfkdyMLFG02l/SyWSAsFJzu/mBVem5JgwJ0f2OlAx0fJlp/gwu8ldWr/",
	"qXAFab7V+j8HTTmaz8e5Y+mZjJTGn/3kmBcx9w/xmNezq+2yiP1SPYIM9ixeEvKzna6IJBL1UZtgVjWZ",
	"ZrCISxaLvQn0byAfy1Ir2mIB2vR77nELlDjFxYL6C92GbkT9g9i6hw7z9HD9CIVwQn3uyF2OHbpaQ9xi",
	"wdrYFmOJ+ndkhpPdechWuJfMCreR1o+CcOw6DvKNjcsvzCY8yWkqBy8WOs59/g/7q9Rop1rGcaSAiyat",
	"1bkTJeFozrdEqEcempM+NrSWPoVhM/edRFSc+Dd49NvL+fkvL15CIW6mdfuyF4/XlzWvL9+jlaxomxBH",
	"zcuNNXcaREdB7DvGJXoaRIB+oTGQFS3OMqNYqqzWIHavq+lyy2fOjmxkNsx0Txv+A+FjHTuWnDP21jjI",
	"ZCEmV5mscWKO0NYFnd1Z47ItfofWuMzclfFEpbtVIV8kd6tdcsbu7lbfMW8YZ9DEHWrexT0JjWT2JiO1",
	"qmWYX60ej2WxaKuf9viXhZr2bcCcbA775V6QXx5hQB5hQB5hQFLSy2IBXAp+mWBjpnelMfIC/wqnM2vA",
	"xWKEDl/jv48PXpx/8V80795fmYx0i8WmcBwedrQknLijD9MPZ63+cL9OfvSPZp13ELb18UffL2KUTNQL",
	"nopsPKbvtwIelSQKrid/c1io5DcfpWpIU5e7VwCoi+0xeOcxeGeF4J0HoiIyS7R5fVGh0UFbT4HlICsa",
	"b/EGRZsibezOkCCbfMDGBK1G3zSN9heo5/+Q/5QH5tgxDFfbZ7nlLYMYMuodyVFuknXS6kdObHXl47aP",
	"FxP3PDAdsy3HlAZh2PFDonvWbCD3yQ5b3rp2p4+2Yr5HnfRmNsvqPs62KijFi9mgiNo6zz5Al+bWZIIW",
	"D+3stZjenDf7YgHYQAM60lmP9qocWMUXrwoHmrfr3XHgw/LRe7gcWDy9G+JAjDAWeeOKLxTAR7eUGF6k",
	"AQa8rOK5nGRb8SepAADjxYNXsj3u4w3s7K4hOvTotWTrtZTlrHJuff6PBc5AukbdNYZPVdnlBSPsj345",
	"OH/Xbf5xuP/jJ4Ok+uh+9N/pflSw4B/a3dAvXmY2d0LTipKSRbKhl0flP5iLHSd6Z7c6C575rzwfHt6F",
	"suxMKkkTQ7/QuSNIB/AW+2LlBDEbcgK4n5Qv95yxhUzwFtO1CP8N4GKFxAK0bBvTpSkDDE8GkTPPKfle",
	"9Dlh7DPAfKc25cVi9MuL1z5svjje9/Hx4MXLoE4eQvT64PrtzWt4OvAOX7/4WjdY5B8z4zy6xDy6xKya",
	"GQcuFqtkxNlyzhsrqijc8P2ksjFtteLE2gpO80PGtwYbALje/uA9YlhbTUQQXkHf/crUmdB3nhM5AME5",
	"TS9pTkNAhGkeQEmEPkSEYpn4mak4aFpn3DAmHiBFMrx2v72Aztz1K3WClijpwzZVHqmby4P3tvr2qGxN",
	"UIH5bbTAlWgRognVUXNljCmiGS4WBp2+yh5b0uqrTexGr5/q1KNm36C5eb2xptuBP/Xcibnb4gNjIDRj",
	"UIPO5vk/5KpnaUPQoza9QykVztsl/cbs8aK5hOrtCIyyB+P/VMb5j+rKB6XbzyH/aDT7xXt8Ar2q2+PP",
	"STWZLb6Q6e3cvFZl+u2eLbsxBzyusO/HIFByrugjnYvXmxI/a4x5zhoLts34u4p71rT5fUY+4wKeMEQ6",
	"l+zCauRsQczzzjljZ3HP3zdv5OZPxx0Yw+Ue0wzs8VZLrImkBNclAFFCG+xMPmRX7YH8TGePX9Vw9xh3",
	"/GhkeTSy7NTIslU3ptx+sQPFHm/8XgIp1Z30vqIpJ9DzHvOgbTcPmuHEFKexOBzNB/Lzf9gf5doi0Fdb",
	"MauN1GVW5vjD4F55jQzKW3+BlkQ+nMC57JZSKrWV3EAfiqLFMM/lLFUi3ImPSuQ5bMczZBVrmF/JSj9e",
	"Fibtrwo4USyfrSZ1CWiEMZoGIcoIXqQxVe6aqHKX0fwqwQ0aXvRwOshkieL+oYr9u3pA/Qt8EISW0/hz",
	"5XlED62jVtP5c+X5tOhnsVbhSKx82YEsA7oYxL57R6nFEZwvTJZ0l0fUOGS8SiSTdQiTPGNNGbyrRtlG",
	"PFCNeC6B5yCcQLlcYLQJb9IUZMtKDqVZ0JccMEw5GIw9/kv9EVetlPWSJTAx+JuEyKO/uyyFPnWqVSg/",
	"MBLOcu5n3XpKh9CeIte/QX4UhEvwlGcJQmEdjIO7OliQL6jzrxcwYe2ZjnIzC0dBCK/QFoiHGAcTlz5i",
	"4lXsM6+dVsS8xskZEEzBP5C/7Tm4DmAcBSwS6oxGXp2HwQRhHIQ95xuYwyVV8MRENEWO0YMnqXDVTrUk",
	"GYDRASQhoNdpgK4bzcSGHoRAiHRk7xDXg/8fcKdgHEQzuoHRW3ddiI1iYMQVfR5jfkXfxfCY6/j3YqAJ",
	"VVgtjukl7l6kGKnb2qDArQQ+PASJO6O+24TIrfTw6iH1cPNCd2ou0YPr6gbF7tScVuypsAuGCOLAVzvA",
	"XRkLXN9hpiyRFz/XTs+Go1a//b73odv5XFPu8ESCkvZFfo5x/QQWhVunn8yF9UVBiK5g6HgIY3bMq8So",
	"9Y3O+qM8cTwEmfWWtMJPGd4U9B2F6Lz1Yn/kB9FIvE/r5M98bymd8ZWes7aecuZ5plonVPpq3+q1A1n1",
	"iHUs3YLw1+dVyhboaImZmogxUdrpo4hq3b7Vay9G0F8aelBYv7/UVKwOOFWFpWofBWHBeMnWiqaAI0oY",
	"mszOsdGOwavrs0F9AHpHKyOGRmmcaOKk1VZdHeXoe/tARM6LC+NnvzcFyyCmwoEXBNfUkhXQ6ELVNzxh",
	"sAiOPSJHAAj8IELjILgGyI/CJZGpEcRIRu2DP1NaRqBgGNG8XuTl/zlocuppYi8Ov6EM1bMkUZnr4wjB",
	"ItiOtDZyKzHZShOWsEXbYSHRMGvqO/A8MLJgATvnNNXPmVQ/Yj8tbB/sQy3ORjKYdpn60w0X2jPKhOYd",
	"7TPfAVdkZsmaEcpzdwiRgd6LZvAGgTFCPtnYkMO2tGN0BSeiFcKW4kHsq7vcqdjlumSXAz/8wGCFfviB",
	"3BlbKWlBnxhkt7vSrlKDJE32HPwd7UNCCl5vI6oAyMc+SlS0Eh/rZbPZlIesbarx+zriev6QLIn/whSm",
	"oErK8VDddR58tvE0a1bn/6JU4xcLssseNJtU95RzMYMRxWJrGNOOV7Ast82a1MTO3OvgYr2n2MseoqfC",
	"d5T5+R2KMJjHXuQuPMlaysSPl4pykk+KPdtVSs+k3eJNSZp2urHSI3PXd4bv65wumUYLlon9St7LsW/h",
	"uhz7j37Lj37Lj37Lj37LFruu3CyqOy3H/nfmsRz7j+7K/3p35dQRWehYmpy9VRyVZf0FXspiUf3rXZRl",
	"R/81/sn56S3hoTLPZPJFkaxW3Sc5IbGaQ/IaAMuKjyHZRHfm+WhBw26dHB+d7/7VnkK72DFXtqyyvSJz",
	"qSQPq9hUY1+jYVD1tqyV7ekWYv++jJKZlr9jqySfRC0rpA8naYyMfRtLZOybzZCxX8UGSdt7cNLK92Nt",
	"jP2CtV6MNK+dRo4xb5xJk8xBDY0BGCPA8uo4BhCatWZ9e3vNjlDpvx/2yjBJ9S3keeJivOf6izjau0I+",
	"17QZtxd6fCd+1z1S7p0sRmS6voZnqZhsKrTdzegeBL9HZeejsvNR2bmtHVpuI0euh+hWYieHP6Ct23YT",
	"XW9PZ0mR9hYicCS9qReHInbke7KNTOFNQC+yTwrr58mSEJzMREYmlrNNbEVh7PMndXDrep5wCYA+QPNF",
	"tDQHzlDWFlW4Uxp24wQI+08igO5cnRtL+szJ1IeTDn7vx882F1sySuaR/M4XX7Y7lVZfuWOghEdLDBcS",
	"9doPIoDmY0SdBDU+zsU+fju43u/Uu0+29x2C3yksYsc3pQ5N1GPqCjFlkcFAkXJestA/l3guschPq2jN",
	"h6ULKPNXyrui5QbWZs4qeQMl673MC2gH63hncIXf70pOZs5yLSdy0NT10F4UQh8T6R4//0f+baGoO4Zj",
	"NYx5KIoCHKGFToV3DMfJ9/JzKyFGpevBLGJDf76DPJKlcyeYJ/2dleKvGluwYvfGGZvfufRd2Y0KsDpD",
	"PjSF4Mp8mdnYskrB5//QJyP5xCZ5gEIIvecCedHVGigMl2K7RKo56h6OqGLq13dixiiZx9V3ukoMwk0f",
	"980jW5DUDF3akdHj+2VOSzba6I73hv9C7HPzbYBTgDhBVIVedUdkNdDvPrrR7GHtj//OEKzPfkkMlnkC",
	"EzOJ4BEHkOvBQ4vHWoUzbddQsdo551ZXgOGEuZMQjaeFPoBRBOk0kSGtqO8ttZM7ip28VAeyWh7QDO8c",
	"uR4CbaoOL8WAIt+yT08rp/68PySWhAeqwbAk5R4xWB4xWLaJwfJou3+03T/a7v89Bst/j5mSCkd+4O8x",
	"y3iRmFRyAS/yJy6o1uRbbBrh2ravxpn2dpPz1Nzdh5sAVedzXDzRK8v2z/9hj0byUUWdYCnXpZSCeZYr",
	"v/VqCHyAakEL7nrwesEqjFVNMVjKJVnN4L0xyg43wF0rB78/FrXlpQ1vf2/4L/69WUHIaRAkadQwpYzP",
	"37Dv0hrCh7FZPuoIc9DkDK4JYqHneHh4TSsx5sqryN6LrlBZSCbQc/1r5IC+IYuQcKArUhPudA/fmYud",
	"iYDv1+WuMiuszp+VPL/W5dHEPezhcOnuHMj+NXy6DkMUcuqYyM12WFP000Kcqbfki0eQqUfd7aPu9jHu",
	"qmQzTHaKf3laXH62PkJM/XshprInox4aKHXUVoCWUms3g0spK+pfDC+l9vLfgi2lnd8CFkJVQi8T/kQF",
	"Mhsq9WhZB37ICMOzXQFuG6H5FTNCZvM41jeVGzOpGDyVAgKTVmkiuRBNyM7KUmRSwZQQC56ytIX0Rx1A",
	"bzGDYxS5E+g9a4AzShX0vCVNobJiSk0mG/LMlylJozTLJR9R9h/+Df3TOgfmo8z+KLM/+lvkz3rIj5dC",
	"9uWq6YTzeBlzHtGVkpoLvD6IWZI5fvBNXeQ5gA4MeOoHEXBcvPDgkj16Vkg50yjzKm7pI1bRnMPMUXag",
	"7TJQgR47NergyAtgVKe7AF2EhHpWD67TpJqZ/eJnZcP4OdkxwNNxHNEIbLGXhLzAswboTakDHOvnEaWR",
	"0cK28gURov2I5QmVSUXpYcxyhEIPU6Al/mGDZnXhcd+epxBBvyZ7h4zJnYbBnDZOhwMzAHuyQDwyz3CC",
	"yiaXkpvGyiuShAZKod9IfeekGw/LjZQLQ9V8SHmhRwfSRwfSnTqQfk8gmvJ8rI1hNPow/XDW6g/36+RH",
	"/2jWeQdh2yYJL+0yyHc5xmTHNGMKUPSXIOwZqUJ+NILNQWvx5cXXHWN88kvWDjRdfPf879NzyeYfVV1b",
	"V3UhVcklFAhp79BirQR3I+S6D4Nv6Fv+bhvGSVr3bnw+WTe+L//OZGLys6zooZ7/Q//I6TCLJ1/RehkV",
	"mVbuRaLxh6Wd/G6wZM1TnHKnLJ5MCROgn0/2ehdTuqU9Yjdukd8L4+Rmu3B70HtiFfOTuBe+Nais+fvk",
	"9dZmHu3KmyrV2nfoO/W2QCRQuUGLUlbMDbwioRQlEizPwxfNkBvSuwqDcnRDqtTGDUD1DkT0GjM9N+Ab",
	"iUjkR99BcpN3cRQuew7Arj9B3AxDK5F4ej6aIIxh6HpLEPvulxgBOAkDjEVxl7QoqBT6F/YOhSxZLxW7",
	"BTG6XLscb8zSEGO6ETLyCzJF0g+yt6OVL6DKaPEB4ENHw6uZujqcwwj8M3U9RN992/uH3tHcgOlBAcRU",
	"a31y0ul82/sn4OYHcvFEfhSESy5Yf2uAEzKywv6gzBxVDlFSTiklxrtq8s0q6lMKFcpbZXcroQ+CYWq6",
	"XarJYucWcKds7jkvKmQaiEw6dr9+Geg7StkpAfjGlruQwfuyRMqR7nemc0l+sZOTaWcelN/r2aSbMANf",
	"eMEYmz1x01EA8cILoIOJAOQFY4ayytXprfMe9bVpfPY/+29JpcCD4RXNgwR9sN88eQvwLIg9hyVNIBUx",
	"U+GfMuPsAoYRvnz6n+e0/HOGZ3xC38IwIg+fsZTODozgjy+BPCiAy4wUY4j/P/a+frltHNn3VVCee2qS",
	"HEmW7WQySdX8odhORrOO7bGdZGfGKS9EQhLXFKAhSNtKaqvOg9z7cudJbuGToETwQ5Zoyubu1saS8I1G",
	"o9H9627008s2wg5hjbNaQG4GFVYOVmrivlqsOkZ3ut7Hg1dgDOlYaxXNdmRYZqFWa0ndElfQcwYFxsj3",
	"SUsN0aMAfvhMBx9+FqYT1rdHwSv35c7L7i4cOC8Hu/D1T4M3r3feuG92dro7r51Xb3bT7kmpFfDJoPTh",
	"MrXoAby94iE/EvrgHg8DorwulAlRTulyi0/qcivWBH/fEhPcerul5rfV2pq4r7bebuVNjhX0JuhC8PUQ",
	"3YXbUx96OL4JeHed8C6M9ZRnvS9X7/tHh5zQbzwaQd/7xmeZOpvOFI+AN4EjlDpm7/O7k7Pb7j8+jEiv",
	"1+sdn38aH34a9Xq9dy/Z50/veh/ZBzL+82CPffFh593Hz4efer3ewfb29vZw781/b9+8/nn4690b9mH4",
	"z53/HuJXP2+ffvvvPXe8E7A6+/981//yT9bO68Ner3dy1/vw+R+3Lwfst4uuf/j759//8L8cj8iB//u7",
	"8Yf3r3v925t/n/T/+PDb77cfr0/PvRHtnR79OT4LesN9tEdHvW/9g/92D+DR4cQ5/vTp3UX/aPf499Hw",
	"6Lh3ffDT9c7t6Gfy93tCPsExmu5/PO123/2+/+bV7zd/7Hw7+Dv6nfX87rezT68Og+vfRqPRL8aedXde",
	"d7uv9gavXu28frPz0+vhjrO7s/eq6/z805vB4HVyz/jCbk/xaH7LxFdyyz73zz/1jvp/9i76J8eCfxVk",
	"fT4ZZCmnVshk2WnaEN3UJ84zJb9tc540EMxAc3bOyw2+vv2d/VMAYye5yqIySnxfQHEh+rlfNHebsC0M",
	"0ibi6qOAAwjWLaPj0zGcog640HZG6PvgGs0ogGyKglH76Ab5LYBwNBExm8IxmrA3VESF2H7r+a4DA7cF",
	"fnwhQ/Dz5FIeFgK9R3AL/OX4nnMNxihAX5+Nw3BK325vu8ShnQHCztj38KjjkAn/anuEwtDDozYNYRAi",
	"t73zgxgf+45LwG29vM/torGsYbHteG4rgZCoVGa2nKHaRZh9V/i0bLvkFrPTZj02B7KAFIW41JOUlTxK",
	"I25e3OvuggC5XoCckNEwBNMAtak3wsgFqiPuttK5xP2QZ2Lgr2+HYBpNkEAxiOsYYhcGrmFG4R0fCjoA",
	"/7odofBfIKJwpEEhnygKuHD2DzR7e4n/9a9/DSAdX2J0NyVBCN4dnby76h/8crk1HKKXe0P3VXvwZvfn",
	"9ss3b35qvxm8HrZfdnd3dx13b8/9GV1uXWLWB5MIJNWHCEMcztE9nHrbN7tyVf+P7EMv6uUWuLy8xAAA",
	"0G5HbHz/p3fav7o4+cfhMbi8BPw/P4A/SKRHrkpPIaW3JHDBjz/qkqL0EWIPb/07j/Ohaknia7senRLq",
	"8Rc4r3TO6nDBh68WCbyRx57g7Ct28vh6sRV+8eKYhOgt2Ie+L4Qjc6sFzAQMAnJLhUTJtk/CZ5DbefHi",
	"Etu463sRfW09HNZy7NPO6Z7wLU7+dGaQ7b5YRHBExNmtzeGeO4olT3g7CvwCl+OPND6qrIZlNz/xnyrd",
	"zJXxcDb2Wr5sa3eJLBJDEYrjr9sMn9epJGIu2cmXJ79bAL9Y+NdKxQpD4CNIQ/Dq47sWiDBHZHnhj1R6",
	"1zO5KQAE+zNerwP67LcAOWQyQdgVmtlrhKbx+5Z63xCAAZs4f63LK+1pPLYv8Q8/AK1pAGIv2Nf9oVZ2",
	"LCo0WsALLUqNpE7DROVqFLO6PujbS9wGf50z8RBAUTMW72Wr2VoR3oAmIF6N/TZfif19CoNQlN8nbFGF",
	"OSu1I/n7fFeX+BA6Y7FPY8gknBfsb+Eh8YIvPMTgBbqAoxdCXcOLSpSINGVArNTbYIDCW4Qw2GE0udNt",
	"dbvdloBnUe8Ggba4bGVhY7WlPQK7wHMRDo33AHchMMlJolCG/HJXZwoBNkQBDxalqHw5xBB2Jn7okBRy",
	"JLyWxprGOPUxwkCumdpssaSsMTGmkACEaRSIpwZFwQ0K+BoGyEECgOf7/Dd0N0VOKI8VzVYHsS1d762z",
	"BkWuHHd1z3y+Spv11I/vggW2UOzOeQsHJAjbggwzAoKwUhbGs2iBZoUTPGEjJZ5D9kA4GfwbOZtg5snZ",
	"oSKkoNh5LjXsk8nAwyi+RijwMH+3SlW/fvA2d+Yyd2aaDMemzwSwFkB3DpqGOkMjF+WECPcFxQIcl934",
	"guhmQwIizC4Zbmrht5EYHXuUN7d2XW7tNALZxMtbTaTR0BvoUcUdyjPqEjkMhXF1MAOfPtnTGIoOlsXS",
	"sDFnQWl8MlgZkqZR7ucp9zmBdDy3Jf54UEX/JkJj5g+M/RDyXWxPFG/OFZVEyxM4S4gyQnAxeID4Repx",
	"YgMB9kIPhpLO5aUj46SBtil+sds3ZBeVTWCKyzZyWSOXNXLZstqUealsXcKT7qdBOcxz7b7kiiVlKHJX",
	"MIgfucsO4UfuNjSA31pvfr0qTbCyJljZhntwJjiAJc5UzE7KBCrTLWeEKVMn6TEHKdNzfDQhyhZ31ko4",
	"KP8GQta7pwlE1gQiq3sgspYINWHUjz8XjlTWxGVq4jLVMS5TE0GviaDXRNBLy7fLpaB8dpckW+7za7vr",
	"S+fe5UOh0UCCv4oPSrjmmnGfktGidJt2vsP+UUGzyo2ahyaTVgsu/ImBaEdhY7W0bCfSFCqwMrWOipc7",
	"VcVynoNlBmbSLbs10N8R9Nt8VQuNuFNwyJ1RiNY17NUPdYUj9RGl619df6WrG4959eNc4TCzByddHJmY",
	"88z4m/EJEsXI0+c5Y9/XVR/+1K18Sg93KtcxlQc+tauf0sOc6nXMo+Q01KvRlz4omTc/L5QmS+sAG/aR",
	"QuwgGpLgPCQBHKGyb0k1Th50oQXEY5/Ho5Tv/gLPXrFBxHfB3GKLNjzEQ7/oQByUEsfj800Rw/oHGQ8q",
	"MUXp3kPLTtUG6+ChaYZ6fGrqPGDMUrPWZln2qFrQCch+WrqXlrk6C8X1WIovS0mp7wED/LLzXTK8L2cJ",
	"TXDfJrhvE9w3N7gvubv67e7nP+l0PGyxD/TNnzevfwsJ/zB5fxAd3fZ+KhzpNzW2VOAQF+Usgiq15Eqo",
	"6sWWQ5W2rMlO926n23538s+d7qtW/GHn1X2WQQbX+pi0YeReHsJizA7VAtfnLbaAAymbMkWYPT9uUAeA",
	"L5AD8BQoRfJIqUnDBLenKOD6HxwCN0Ksy7lWvHCWrTygHYhnJ0PLCn6cHcMJ2mmJf3fru27xqhWZbYfV",
	"OVdVVjz3xxYkm13CRfAVdTSpJyNM8c/JgMjp4Y/Jnc2vjf+yFvwVuaso8DG527ywx3zZ5/dRW7a3v7M7",
	"rhASwgJ+KObqwDupE55hc4Iap25gIqBxevjilB2TwYvXvGlrOeEVhS2uK2Gw3vdW1vt7Egw810XY2rku",
	"URvczhxh53O0baW/ykbv8AZ/pFrbZQPy7Me/r+XotMrgglaE+nkYpE/jRfQIQoTFB2IDBNyasDAbv7Hy",
	"svR482lKSaHvE74lCcW+CjuTilFUseflj2u6uquLOx/3VSSy7xruU/UkR+45P6VF7tfUEPS2B1hMGoXc",
	"S5kImb71yqs0HaGaqjEidwV05oV1TZU/xDfLz9HcOTsRWGJ/p0f6jnkEh//HPIJri25RgAzNsk/wSFsy",
	"JhnRwdfNO6qLDF6ce1gic2ftl17uYl5Nunimb5O2vG6oh1MD1mzAmg1Ys6pbcJ5bNJ5/jeffZnv+pd2S",
	"6W5cC9dvCS/A+V7svoBzJ+wRewTOz/Sx+AVa9zqHrIqKczly3L2cBR+RUnBp7z351ATPBjAA7K85X7wa",
	"u/cpX0/gUWOUGXi2Is6RhsegXJqEd2DsGCh/XfQfNJwFxZ+qpHQdTHc1rJdjYeNW2LgVNm6FzUu1ealW",
	"4laopZ36OReWGNqDuhiqS2/qwxC1wIDccVToqtwkau4kIXfJ5hGQ6wQw7yoQ+1eUjjzQ+FI8Ll+KeOHK",
	"OVQYC954VTReFXXwqnDGyLlukygENIRhRIswD6GDTWUScSPyUS0/cyG/97nXP+q9OzpsgbPD88Ozz4cH",
	"4tWx/+vh/j/YOny6sLMLPlIShee8ySScRb5OdQdbrS3Vw1Zry2i+0GPRtlY8KRkJQIjghAdCLo2mF4mx",
	"eUxKl7XE58T+jEJJ/ok+bsdEv95SIfgy03uan4d8DmrvGeHLwYedu8Q9yvPQob6b7Z5gwuJbbMRXff/N",
	"7sz1/riPp0IgF9Fj7+K1E+XZ4fnFWX//gtHip2PzE6NMfixPT4/6+4ys7CtnjDmFPjNfi3wxzxbq34su",
	"C3p1xP5DayMpyqd3cotRwKnJ9yumpvsf2gwXmDUvVuVHrzwluYRrfB5sjTDB6AEWqcWXiEvAcDqt26EL",
	"5hBkpzAIZw93/NIWq76H0L54D3Icl6G0yg+ldc0e4HjW20/YIfjq95+i8fGfN7ct9uHkdnJ49uXDIf+A",
	"v0UH78fHN9+elqPwl53u3t7rnRb/9+We+Pennxo34cZN+DG5CTduKytzWzE0cJ7bMj49mDNLDL9Yky+L",
	"kN3e/lUSD/W1tTUNyBQFoScmLZk1o2L2KUQTmqJB0osHgwDOuEZKfkGs2RGLAq1MhJWBWingGY7RbdyM",
	"xUd83/h9HYBy3X41/uLxdDbNa3x+s1K3PAmA2v6u/87E1I3mcFaDGfDcTDBdIY9Ls/P7+V02nH0THRIz",
	"z1rjgSgPuO3w2Vh6eoyBSLli2/m58Nau6Ah/XfNtUU3sgQ2g4Jp4TNbkMKUeg/I3ZeE4BbpWXrSCWMwp",
	"E7Pgfsdv3YdCTaVxMi/mZG4hlnuQp/4eDnykRDwX8ZTBCyR7gGTyxviuUcsyT7Gi6PxGr13oszcn53fP",
	"M/BycVGOCVCza9jpAuFmkoxFQCnktWMjPPON8Viobn2ct2G6JZyHcgk3L3pXPvXOSdgbTMDr1POI1ioW",
	"4Gt/YpqLJzWyWOHzOy8wuYiG0g/uKiE8vQ0DiOkQBfb4HBeyBAUQ3BA/kiB6rOHTEk1NAmN8Hg4JgMDo",
	"10C2X2LVpodHcaseBU40iXwYejcGsBbdeZQnZE5tzJAeuVJLzUcNMECpZaUzEIkCJ2ZRfddIT62NTLxZ",
	"Eo5RcOtRFHegc5Rr8HbsEKJabIEZibi1bgKvUVxF+F5zM5eRn72lHPHEskg3IglNF3H4oTPmldMSSqtF",
	"7eOQlFNs2MijVqxSTW/dXPJwMg1nJ1ZDRMMgbaGh1AaJw19S51A8kliGq7IskvBWXitNVhU4bL7DItHD",
	"GgK1xS7LNxbO0SYPZSY8g+30+S7yr4EolEWjrNicMXH9ZBp3GtvVUgh2d2Vd9+gMOxeQXh95+Dptjy7M",
	"iw/4MMICTQT+8gketYMIc9hLCOn112c/bLOmuI2I/SHc3hWuiF3k7FsgvLvYR9mcy6szcWOM+J9AzVdt",
	"EI29I5UVbT8t7Jj0Cme3bt3isC2SXAcc8ZApAl/TNT2DpihQYWc6ZWg/L4wfEHYbioTfhzGUU4EJA8hj",
	"ElT8U9+VyYQUUgyTkLu5dGyRAIvHoLD6o2jxNNtTwRjjahxhNhI1t/vy9euW+PfnBnD0VAFHG5IUIosJ",
	"lWF0wmSWc8lLu1rOJT+n/6rmkhedNpf8Mpe82NZ6XvJpJFeEqIULpoftFL3PSgAPJ+KtEkC9EfaGM7E8",
	"4RjN+LUCb6Dnw4GPhNcyRYu3NW/PwxXSveyx0QvU9NmVQmGlqJdEYR75qmygefTr4QyiJVFYNdWyqTVk",
	"W2eyTVJWQbqdBh4O2z4cIJ/aSfc0ELciK6UjMiEX8NpgwiPMCWn+cuvs8OPJxeHV6Vn/+OKKO5+fXW61",
	"wOXW0eGH3v4fV79eXJyyL3gMJ/Xlxf7p5dYisfN+j8Tg1kPlZg9PnbwTNGVueUFaki79djI6EwWy+B8l",
	"E0QwAlMfYv6rei8Zb40FMpHtNiyxYYmKfBdJrSARl0oDkPGu0oUqpMrK4vtvlpLfkmKgIGlENCSTtrKc",
	"5sSm5YW1mTUdUcrLHMZFNi3NwNIBVFUg0+TCnSMZ25G10RahaeW7WdHvYmza+oaeFVGmZCSehFZsIRBs",
	"erjXZITYOABskZA9TSTNJpJmE0nTEknT4M2zZaJpMobhQWoGYQzQyKNhMAP9g9XF2mysE0tbJxJXK7dQ",
	"JL/JtFIUC3pajoqk1z8nHGQjnQePjDokvpsTxlWydFnSMhLx66oCeyIsl8cysDlhC0zYXwSr+4eNmjWR",
	"GXxT1+njJYPKBoQ9zoqsnSpqyy0gfl42UKyip8yRiEIoUGvkUaPeeYzou9zCke9fbmmjRoTNqjyKY0YU",
	"HNHi3ExYi3DAzqmA51URrD4nonkTrr4JV18+XP0DBtxNcrySUXfn2GUTercJvVuH0LsBEtj2gtEDxYVt",
	"pD4TayzvWKPL3Et/RYipegdaGwy9q4E/vrv45O+02IfZq8H1weS3Kf9wdzvsH70jo1qGysoRmpsYZOtd",
	"2BoFKUt/HMyPe6VLZTZsnb8YxJmWd7NJ4+K0291psf/fwPBswB4l1xbM1JYYIwrHpFxgX/Zh8LLXm357",
	"M6gaXphQIFSQ5lPKkE8vyeeqU2w2aT5To88tWKi05Uv8og1TBeLQJZRhtjh08QGarcsAanRRUTQ6c1L1",
	"DUjX2noljPPzFrfgxnMQ+IRjkOSzI+Jcq5AaHsHPbeHs5vfcTj4p1tPt7+KLK1G9SMLYTBL7gMI5+irg",
	"sT83gibC3ROMcJdzfmuGWUg/CpmMOy8mRuaxkv4AlZ6sr+u/GyoKXbFZtGUliVKMvYRPdA5ERjlGz6Nk",
	"1kwcHqrMQTql0w3CT9n3sRzBFHdUlqLHgvJbu47uvup2F9Tbc/6jVs/m6ums8XAu7Pw0v6mb4eacTrDL",
	"nZBC7szzy6QS7ac7J+fgD0tl3VzYIMIGlOGwbFyOQkPVyN4bB5SpTt+2aS69toO4xMEv5N4rhbc8mcrw",
	"8X2Y667x9b3ndVdnh18rEZaj+nKOFzkUH3tfVE/w1XlhbPZLIms3C5EOJiEUhvzsaN++b3iDy750XQ7K",
	"MILZaegyjhwfkdBzEaBs/NjJdOg41oPJkaiOtbXBMEoqQeXAgNu/6rbAJGlSs8pVq/bxmGOY5BphvlBT",
	"YQDziNUkXMhTZf0ShN6OQmmIrHYSbOzqHE2aG35w3AMnvjci7MNZ/EGQq4thG/reCE8WQtNPA+RwS4GU",
	"flPIl7Xdi2unUeDBcS9RoqG/5Tyl7uHF9JH7QDOBT0B3QiL8gQBFjMuptW48mRpPpsaTqfFkupcnU+JG",
	"WMaTaXW+SmkuMiWHx0FkhTxgVu7/spmQTor+hti/+jz8fNI7u9hpyc9n78cHHyDcb9LFNuliq0RiqscR",
	"OzViWuQWA3bjKl1oUoIFz7wO6vDSRm3G7hmXFVd6iCZTn12l/IK6UJ90IzyCu7AAqCoO4XQR0XhAwoUE",
	"7OtfdP3nD3681SD7Wcc8ccazDvg631MHGMab1wAg1weA1N03CMh1IiAX3tPqXT/3Q9rbffu7i+GV/pyW",
	"uSv7Ra8TMyU6s+TxMp/1xZIjzA2uNgmQCoYxqlPmrPkNslJJq6g2R6C4sjf+Awofz66bN8fGoOwK7/si",
	"d3grRJK2FkXi35I2jWw6iaG2WnBhnUMr0YgKBxhqScecwDoMHql9ZUGvH6t178sYYUAjx0GUDiNfeEJL",
	"c1/cyF8J4mG9Hhz3/mu3G9MTG4B58J/HbpHCCAhpAvJiwWZbCWYJKlYy+D2JWIvyBWlYCfsVkPBCVw0F",
	"PzQFW6kll4CJsLhkWgITZppUM4r+tTGhNCaUxoTSmFAaE8qjNaFwXl/nQHA240rBga8w9tjKLS/vGTkO",
	"2LiUXLL0jgzE7BxIUduwMLSEWo8tHKNHxwucyIeBUOveoIAD8RgJc32yjLbUAQcEUR4NidcGUxiEHvTF",
	"75LL+4TzN/XNjQeBi0YIC4AwH05WMiP6tKK0xTJXE6CtCdDWBGhrArQ94gBtMbMrF5vNYJJNWLYmLFsd",
	"wrKxgTUh2daE37mafaGv/vnavxGG/fEfHz7jX99vSjyszgMGxGoC0DUB6KqHPTVh2AqEYWv8c1fmn+ti",
	"KMVIz23FH8qFr49tPsqLReXT8jCYkmnkw1CpB52E04zYoU6mD7cqO/dEM645HN5d+Weo2309+7N6zJpY",
	"sgav1uDVHgFeTZslTTOo9jHLjdOnS9vM7tLwuT5TO2++mth8qrcnFpfP3ONUKkkayre/838LROCzE48A",
	"q6nf8oFqqsf7Rf1orjWyUWC6TKLMj1RnJz9RZP0U+HW9XLGaqHQbRDqpW1+ApRWPQZeBA5JFTCjQOje/",
	"qqBzc/1tYLy5fDFojhpKB5gzlfc6ttxOt9s11fMFw8pVRj9NMLnC0XWMXdyoOHLLUX6Z+FEZ/DCO3lQp",
	"ST/hgFH5gFyYpOu/9PbFuFyxkhKTyz/EeNwNiytVmvxLBZLKIH1dqDLKryxy1OaKA5ady6SLOHxTLjo8",
	"O9LTwXHv3CjQYMQbjHiDEW8w4g1G/NFixBW730SYePGxbx5SnC65L7UEizdQ8RgqHseDadDiDVq8QYs3",
	"aPHHjRbX/K48YDxmlQ1mvMGMN5jxx44ZLxoMrsGMN5jxBjPeYMYbzPhmYsYv8SV+8YKJ1i9evAVChAUQ",
	"61QELRAGEFNffWLSwTTwJoy2HF6O8Q0PhwFhpyg0VaK6W6A7FA3wd0E0UOt86/k+b2WESYDcDjjsjDpv",
	"weWWi6E2gXSMQXU893JLVJNLz08xnCAAaUa9y62sl2cuSj5u03NbIPHFg6WwOjBG0eDPG/z5I8Cfm2ZR",
	"09QaW0MLotBVQ3Yg+nlcYk22dtVDZXB0PaWnh0g39ttGNwtWehFkV30siFC3EpYAqRtUVSygqtF9k6Ty",
	"MQs0JWSYFYktD5n4Pocb1daJoAAfKeZKYOUTGuRYGav4uvYbrjLXgg2iKRs1FL6eyrkZ2AFlsaeBiSlb",
	"M0VU6G8w1+WGuhwUkXxTSCQKSVteF1mEYhabs+nwG07jBoaIY5eosKPFyrH34ntw5A0CGKRlQmV99GQX",
	"5q6sidas3TUYbo7hHkMm+gA0mXIFpliNusGv10OX5Y7P0PN9JkSKhJn288PKJYYIRKW0c8DKGvz2VBZc",
	"1zlg3TUHYFMPgJ2wliBk84FTlp4TdQuQ9UWyfEPdDXUXoe45MitO5Es5Whq4l0VfS91fCXfLKoXoJ+50",
	"uZyHmlq92ElNr6f0U1Of013VNsRTc7kHAz9DUsWZqunk3YzQnDoeDGagf5B6MJJ6z1x3JZuasn9Ale9s",
	"3GtI2FDsGjDDDids2Y3+tDEIP4BBuH72YHkyN0AJksNwSrK2st7odrVZwiG96ku/cUuv+NLfEP/05S59",
	"rkVpCzcf68k4k6ublIv5CqE76IT+zIB9aLCqkYUieXw4wvUd+7UCZWDcWeaReSDoTU8iLQ2hIrlntYNi",
	"cNyjt6CEU45ixSlPeEvfg/RklJU0ogPnwhXbwy6644AYCiBjZeOAYBLRFqBEo0AnM4Fx5RJKjDHwJhPk",
	"ejBE/kx6hHLpX8PBkzQtOqyAnkVHDUGvgqAllSQHWIaGS4f5sMsUZqSPKkWKKuN9bK45zr6LmcQSkKlL",
	"bnFO0I+4WGrAD+PXNDDAKqNirDS2x1rfM3JRzvkOeZWAXPU2PUWgqwN9v0G5rle0MvmAZiv6uwLoVtWA",
	"Ddka/7yWW0U2n4VpXT0HyAK0Jg78xh69VRN+c/hsaGHj/KSdv8SVvv1d/VkAHWw9mB9QaJzKAli/uM/y",
	"OL8HOInzt25zCJtDaAD+XwrA/0p6f0+Cgee6CFs71yVE1y9X1vUxCd+TCLvWno9JCHiJVHBxDtvJBxVb",
	"2YtUUlfGYdYnVFQEI25YWcPKGla2DCtLY0YlhahtwjspgW6XFcAA+QSPuKGJZPFDhXeXv4vgmbm4hNgg",
	"pRrm3cyNYUjiEGYbwVLl7KtC46f1Wm8NYHOo1TnTdE+mC9i8kme7lMq87PmOlejNCY9nX52KvznjG3hx",
	"69NW4pQrK/D2dxEHhx/xgYhcldCFTAPkcF2cPAsp2hEsY+n8SIFqIUVNcog9VuidLpH/lNFDq42qRI6+",
	"iLGidj6wqduk6ENti0Eds7bsO9v4JeMoqbJpFrBDXuRcl9goK1gT7rwJd96EO6+KwSZYRQU2YdlvYxFu",
	"lEhrA9uZl6O6b9VlmHbfbn8Xf+TbpXCyA4snBxe+4mNV7C0lWxReGumPJj3K2ohniWnmiWU5j4q6WBds",
	"e2ylJO4pnSmyYRKiASHXKha+TWiTv60tRdGjSVD0NPIL3TsNU5OgqJHYG4m9VgmKMGB8frZMaqLVJR+q",
	"TeKUh0vjoLLSlErgICs1qRua1A2Vpm5QxyKDVYgHdIBuPHQLaAjDiOqbFrnyG0Tfgv7x1enZyYezw/Pz",
	"Fujt7x+eXhwetMDZ4W+H+/yv48PDg/Ors8PP/cMv7PuLsx77IcO/l/V5zjtIuvhK6cPocau1pbrcam2p",
	"PrdaW2an/BfZayFxY9nUVVJc0Cmr5KXKllOddJWhiTW5hgxWtpErr8qMwasRZmXmeMppODYwtVXl6Rma",
	"tBb3WLcaZa2wHcl8xjGGNwhASr0RRiJZY+q8WWu29BKisnvGrwFUPtHEufvpxoM7NyvJ0dFpknSUpRT+",
	"HgEHMl1exhrKjHr2Nfx8etbt7rT4P7tN3pCSYWLevngBLrfUu8SFM9rBJET0cmu98WBaqb12QnQX2mLB",
	"8Oe1iAiTNt7lY8Go1jy3pV9oQsumPj1YQBipns01kZ1pEccUQ/lTUzbB5Rm+VIIHC+bFrtgQXjOCHqPZ",
	"jwECJBhB7H1DXLN5ucVW+HILPBNyEWuDVWw7BA+9URTAgY+EjpLvTizOIuiMgQtnbL/iQV1uiW2+3AKH",
	"rAD7JALhiSSWbbHbHn92hjwcALjckkTBSrTAIAp5c7QFQta7DGKE7kIUYOgz2UFOlqegpOoxImhekHzC",
	"+iQ4kZZ9xWiG6BZwi5SINPT2ErfZIZ1AfsjMY8oGyY7JDIVGZ+BXbq6UiidWpwUGxHf5H2y8JByjANBw",
	"xubiOWktytSZfOhtcABDyB8GfNKsjP6drTFbIwD9WzijoA043/EclUGTHyeMkMuY24BHp6RcUxkSMPQJ",
	"DCnjTVKbzhaUspskINPAgyHiK8cXTg/iTF3sYjCStADkIV+8gc+YXECi0VjIc73TPrdDdpIVgcuak1Ie",
	"+50NUNdDurCqTusW20UZ/+ai1iqbSgFX0ISNZmZxCD2Uv60Dg8jbria9iZhGfRObpDsbLuzQ4i4bFjkO",
	"tAtmBXwNk+1m2nR5twWBsWqU6Ti7YNYkKVm99FSt1FReWlqNlMSkIyEVPag0NHs367vZIpDMFY2EyaOR",
	"fxr557HJP7XxibXcYqmSUI53bLKpHymYoBCyFbK4yzYXY3MxbtzFuCYBvhq3a6sAf/IPm5dp1qEuKkhv",
	"q7utze+27e/q8xX7nClqnyHW2I08aqpvadZN3pnCks6K/eiSW+wT6H46O/qRnVv1mf8KnTDSVZ4d3k0Z",
	"iXLiEsA9bgodcnRVCD2fPr9MDSdyKPt+7/noY7wmZZiZwLl4PgK3kIJoyobIr7h1cjljDObqWbqc26g6",
	"IUiDmbkFNqFygbLXTFGXOO9gFPe6zsV/yoIxBHRd/MmrLJlYorc8l8ZUH9qUVcvej9x4/ExSmm9VItU0",
	"VoDDMWNjiC1Mf0G0brbRJcPYwsfTd1dkoL+vjacRuRpLzmOz5DTGm0Z50Rhv6uItXf5azpYFSkXNyJXP",
	"dNFKJLTKwk8sL6Nlrp19Z4q7uAe5Hu5B4+DeuMs07jKNg3sBBcPT8G/nbLPxbn/U3u1BIef2YCnf9kOj",
	"+RwYxFPwbFezPODqY+Qu4eAu9fT1cm9P3eYsUgrRZOrDEBWS2uLCVrntwijS+LqXU7Q1smIjKzau1Vmu",
	"1UCxl3r4WCt+CBzi+8jh6dD4wDLdrdNqWXWxqvC+LjvneRarZcPJ1HeIf/Xv/dfBCfZu7u1i1Hj9rcvr",
	"74mbTmIp4QEsKKmdlzGkWEZ/P3uK0ajntua+eVgoqB7Hkv4xhtzYkWxcf8E5QfxpzuwygBQBjG4XNchk",
	"OARkWFtPhaSonKUz1eUUFEd9UQbcrm+UIih3tZ2lcTBxPSvuxRh8A/NrYH7Lwfzqwe2Kg9/1yVgHd8tC",
	"A1uOvYXd3LC5Zr/yD3kZRng//CA+gHMShOAkcFHAvhYFmCD7TlG3sCNLR3G2MsJuSVk9EamNTztAQya/",
	"UnA7RjIMB2//FlImVDqIUuSCZ4yoHeGo9Jwb3NWnXsiDtynDLyfAuCfkyr7YlcPHKM4rN62KsDKyv7nm",
	"JnAG4HSKYMB4B6tuxGhLUXGIRVyjasN6cB63cmOtKost/kruvmrv7mWxJk0anVFY8kEozkr/QL6YxUNH",
	"EKJmsYIAkGt7hvJLwcOjHmtiNc8MQfKsukmCNlQaK3zBypbr/As70BfsghcalNO+mLJEWqgbGGi6EYEq",
	"+NmdEp/zEKT4iouGHvZC5M+sSj7i+2kDHBDiI4jXfUXwgS4jCPOtUBAayZ6g63oioiT47fzkGCgFV0mx",
	"QqxeO0BDFCDsoB/YnJTChz6vpZSsOam+rcQX8rK646pOO77jgjF2hN0p8XAIfBhhoakAf/kEj9pBhLnw",
	"E0J6/fXZD9sXkF5z8Yv9IcBYSnHBaJZ9C2J5Vzbn8uqdS8xtgayIIiuVbV9sML5eABuL8cvwYmAYkAno",
	"TeA3gsH5nrjWdHEO4Pqzfyow5mYuf5ps6vTgPU27lw55gX6IJutCrugOMnPs766swx6dYYftyZGHr9No",
	"a5N3XzS4/PbX6SQLygCS9vRJlodXHOUh4or+tu8NApgfTvm9KA6OdPE0OUyWMgs1Etly8KdSQYefRmzm",
	"JrRyY/9r7H+1sv/N3QsPHGOZD4tGA1FiyQHyAIIJW1nSwqbbzxq3CnL7eGN9xqpBJkn43uDq8/DzSe/s",
	"Yqelvjh7Pz74AOF+DeNJ1iRa5hNSmy+pdx7OSZQdz20tfPdgmul5ebcCsKsM0v70Ujnp7hu86zoVQGkP",
	"PfWCXPytQJC3uQvYEuUtcZLWFe4t2Uk1cd/mJrZpAeAWdy+LGFIVC9vf5VdX4qsi8eFkDSBr2E3nC3RT",
	"wHY+33gWSnpx6I0B/WEkgYe0QOcfYgVKr01sKtsJyuHlOWGq5lrtAOFcKxujBv4h4lVcoWYNTcVw5xKr",
	"0CCKWdAX+ld+BqDrAvUKn6lOU7XsYmR5XGD1B/trFTdUNYGNihP3w2ZAr0Macss5KH4tFlOzZ2rXG636",
	"MjiHBZXVw6qqNlfVk9TzbLySZ11JQvpuef0jpJQ4HkwgBvXGL7KctJkldCMzq0+CUtEddG927978/rrI",
	"jLg2YjZFhgjdAr53jcAIYdRiI50QDmhEoaMkA24S9iiAGMBg4IVcFhF9tETgDcwlVetWyZ4u2Ogs/hUo",
	"mDCWQYKis5CKEzkXrtWXixtREWnERaJVBMbkFsAoJG0u2TDuP1GnM2B/u1amwMstjlsasXDk+IiEnssB",
	"vwEJkYe3vraMeSVKNA+LdasYTdXiw6sUG1Vio0p8JKrEVWkQszWH61UZVqor3FQlYYlXUKwTLK4LzNMB",
	"llP+FVH6Ncq+J6zs2ygt30q1e9lKtlLatVpp1SpVpzV6tBJ6tBI3h4g4LHxC7Dj0d5F/LX2K7Do1Vigh",
	"Q9D1ChE07rBBbCcR2xpZp69IZVHgz5NbFGiPs7qBrS2klkvPxFcvN7s6WBVK1Qbr3zY7EmPlaGWxqGtH",
	"K5cEdUsVcirGWf62AHU2EM3pqOfiGGcVAF7m+je0lFJLkKEZh3N1P1EELrfMBP2XW6yBYYxqNTL9SxpX",
	"1cw8/wvV5iuBAI1g4PqIUvGuNwdgtnR1cna1OCApV4sZsvYHJBzHnTCSiQe6iHXeucIkvFK/JxG8J9if",
	"afyoMVvR1zO5789NLLM5PsbhdnXTV2JiyR4UxFQ2aSxNAKDaHUetidHPGQq5NPaf1tbeFcQzywwy28ez",
	"lIbNBecsOtH6FQky1kv3lrUFMsO+pcv5PbainmVzZ2JR740wFrS4SmBxpt1iOWixisFTYLBSDaVKqtN8",
	"ddo7Ozy+WDiTASH6orJHgAsQljdW2Vg9auTTgPwbOWGRoauittGIn1cVNKjeJjvfG1z9/fv7P/a+/P5r",
	"i334/eafwexX1+Mf9tD7nyd//hsXsTDEFtSiFL/WWF/Hnw+PL07O/mAre3xycfju5OQfbEhijdUFwfYH",
	"3yAckmAmLT6BEalhNkVxHbZ3qp7HFbQ8gr4QNlAwQhkbIAunmnr0ULdaW2qkSVOPWaJSVYeYbRFbQ4p+",
	"N5ZOtbArv8lV6oqqNo2u+nEtbzHeeEX6XDGRzVLn6q1Z3FTj3bL9XfxRRH8r5G27+lZ1WER7K9rKVN6q",
	"cdUmrq2dDOqnT0zuVSYJFM7FFXNjmS3OC4CcrDUtV/y6XR8TqCotV6K3vJQPNWII6k2YxedNeiiT/2OB",
	"JjRFGBqf+BngEzzSMsXEniukErKpLFfIphJOnKkkj3R8NILOrH1LguuhT27bNIQj1A4iTLe/87+vggjz",
	"NJgenkZhm8avb7vWTDQKVKOANwSCCAPeCFCNpGnVjnjdL7LqOat5FuE+q3euqxWMz2cfR0iEoJ8YD3tN",
	"WUK1GytRm1ttbqX4HMrJj8X3SRGP6BOoTstTkTCt3peMlIG2NB2d8IprIKTkiBpKsm/VykgpQCOPhihA",
	"7n3JKW5pCZI605XXQFaLI2tIK3vbliEvTVqMrFIob0m6KkNF96YaTTERzqWR+tKHXI0VUUh5eii31UU2",
	"WIjClazevVZtibXa/i6+uVLfKF1ENsxF75ORjD0N7pKcXPks5fNkERLpE5d+NBbnUgfkTHIRTvnCrvnR",
	"k+yyTML9uRVfEUXNceRluHFhTkzvRV6cAYsO7Sx4FXRWHTNeAScuwlmIGG+xTJmqdGayzCNZaEPzZa51",
	"m5NL88gTBD6wq0OTInD9fg4pDCE9tds8nymeKHC+D7s1JXm6HnG2wLmJlk8UWDdQbPZGZ1NUwSsr+666",
	"l2P5itzG6+AqvjQicQADh7gIPJN/zMELl0YsappYI2ZRBQYAHjXGuRSUMYFdVCAIuSQJqGIMbZS/LoIZ",
	"F4COqqREOWbhHltx6gBZOf5cGBi5guRlK01dJkODDiBFLojZBHcpAhwWJ7J1qMT9/Kvn+Vgd1cQt/0o0",
	"pDydORyM9ysciPridLbAe5/AUCSw4dFmOcBGeDe1AF0MjPuLERn3lzg0Lng2iELuDa6C5gaywvMO6A9F",
	"chw+z/d8jGIs4sxNmRCCQ5HkQC2pyK4DJhENAfQpAQNdUDimC1GQg7X0IHjpAQIxwovHrmGd8+WgjCPo",
	"FDN0Ch2Ul5eODzeJzMq6Os6NSr+z9k7ZNJqQxE1I4iYkcXF0orot6xeLuPjIaoEV5kmsWmBA7jh8tdDo",
	"eaE0zqBRmLYlhthBNCTBeUgCOEJl78WHc2DQwnU5FwZdrXFiaJwYKnVi2FAgO3Gu3gzvTr99OJi12Idh",
	"7+j23UX/Nf/wYXb3CX3qe/cJlSOfFjmLoEotuRKqerHlUKUtazLodndaYNDt7rbAsNvdqWEQrhZwIPfM",
	"oCrGVgeAL1AkwWyLyJCSPUqJEBPcnqKAyzE4BG7ErctzrXjhrCYx3Ne7bvGqPWQwMz53sDh3kTSzf0Cz",
	"UveRoG891AiHV7B73pv+vfetYt8HrfUq5P1QV51zwrqlvysQVEc1YPHBOIp/XotdWTZfjR+GnsymBdYx",
	"NiltkxMa4O3v6s8y5oRcO0IxC4JuL8uGYIyvdlaEx2c/mDcczHGHnFAwVvYgwTGlqIPjFQwKycTB3IdI",
	"1seoqokdU5gaHyx4zN4KnRuCgee6CFs71yXqF7emDGMu7CeVYaaTJUxL3TqpvSrPqLn+6u3isibyVw8F",
	"BeAuchxS3bTyRMIkUfIwSlJCSBUU3kX+NbtS7EQpSxQ2H9teUPpq6B9YIwioMvNPiaWfbfE9qV79XDE2",
	"9YmLtt4OoU9RiSf5gzxc5Po3kcYyOHYaFecfjjKejBkHRJepjG9X5pq4UZzb4pxYhCYm3l2BtA26VBq8",
	"5mP846ZF6lpxYuJzJG3SrI22wNTI54Ei1CYpcZOUuEEANAiAeyEAJDteBgDAWIUHhXFHchDh5xfMQP9g",
	"vfCAwsOWBgI+UmQb6+aFGrNlAFkqbJhN7kdYLo9lYOoqBxO2pAQrHseGy+p6WXlldJ0+3tAgZ2ogipAy",
	"R2J4wPJBedSody7uUEbdl1s48v3LLW0ujbBZldvDrWuqWpybCWsRDhiPEprBKoCcOWi/BsrZQDnLQzkf",
	"DrikWF053JJmkA1sqYEt1QG2FCBKosBBGZe6ibsQV7ThACjWWN6qRpe51zx9CrCrwdC7Gvjju4tP/k6L",
	"fZi9GlwfTH6b8g93t8P+0TsyqiWAJkc+bpBJ613YGkGX0t8B8+Ne6VIlGrYugBjFmRZxs2nj4rTb3Wmx",
	"/7/X1D08CpDrIRwCLbmo9VhgRvq65xOWCRuMJqgUM+da8tgLSqzOA3E0PcJ9NbJDPsX+A7K6AiufJMDV",
	"7kRMp3XZiUxyX/F+WPCLbPZwOk1lADZXhSgcc1Rj5vBNbGOLfRi87PWm394MKgY6KvtDk1FyfWEWVh3k",
	"oAm0kAZ6Ncxsyl6njWsFIK9Kv3qJL4jK2AMBRrfAGXu+ftmCZ2jU4bo4NH0uFQdAZDCYLxIgx5ui5y1A",
	"USj4arKY0MOwh5SyKMk3BnsEgqGHoQ9oKKJuB2BGosDk551L/E6l3wO3nu+z/sgIe9+U0gPPEvx/RiKj",
	"I30IzSLy5TM/Ha2Dmr+WnkseP0aBFyK3IxI6K8sNQli1KC4Q5IJ/Gd395X3tjCE95b39C8AwDLxBFEqJ",
	"MA13LPdzTXZy2Xo1qGM1lfqCjltbrwSiad5MG9x4DgKfMLyBHteygmdHxLkG+2KUHsHPbZDlid7AlCNq",
	"WtS3v8u/CsCV40YXcMoxweRnJYw7rA3+OINIaoabmN+JdA6cAytOsmAOGUnhRw0/XQE/FWte1fFYG6+u",
	"Bni9Ocdw/ijlM9ri+GMrjEkWMJBMa9zxqsDHye42MC9DtjicIIFCSVPlHT6J/NCb+siwDx3xR4N4FHdj",
	"RcQUBerhlRCqF0RqmiJTJ1kmfWQiNa3FHRAnnK3o6DYZbgtnuE2q82qf4VYxh5I8R7p62WHU4jpb5DnZ",
	"EiI7Ifxsxwp3VbPhHKviHAkJsgrOITpsOEd5ziGOWT05hzrixTlHKfcLq9Cqi1REwZX5Xmys4Jq6aTZi",
	"ID5yotysKnGxVNcL49elI5uqyJj8u1fdFpgkjURWw9d686avIw7qiv09Kk/t3vh8ND4fjc/Hk/T5UKx+",
	"05w+io97hV4fjc9HYmBaTMh1+ijiIG5zAuHgiJR5aMYPgwDOGu+Qxjuk8Q5pvENyvUOKXG5p/iH/+z//",
	"10Tq/+///D+7h4hmjOVcRGJ++qA+Iuv0r3hg74rWFgzW656yRveaCiPahmiyHreQEoIAXZEUsJn+IxPi",
	"X82+0Ff/fO3ftNiHs/EfHz7jX9834P2Ncup4CJ+WOiO2F0Y8Ib58zLPxyiee4LisK8+BvnyBRQ7XbIRE",
	"6cEGM1v8XFnx3KjXmRDfMv73vHvJrAbskgnBOAyn9O32NsKdW+/amyLXgx0SjLbZp+192cFVyKTlq6Hn",
	"ox8+Ep/9C3oUQAxk6y2AwjHExAdcjJcyFuuCSs0NfQv2x4fv+pcYgI8wuPEwYDvyU/fVzqu9V7sHl5j9",
	"sgfALgBd43/xf968eQM+73a7XVYQgJedn3/66TUAoL3X2dvd40W7nW632wX7INlG+v9EM686r37e2WXN",
	"7Hbe7HRfLdnMT53dN69+Sh3NSeFmdvjsd+a/3uXrMvf1RwAOjw/4qculvfOP/aPD83USHZ14vjUM+f7+",
	"SWv/2f7O/jPx35Od5yfqv1U7OyjRs75RnQM7wN20V2i7iP6uAMRdFbahq+Of12IJk81XhK9Wk3laAGtj",
	"D9NIJGE72/6u/iwAsrbSzgcUGr8VwJHGfdYHZ51BLLUEWudscz7U2rqdEtZR2Y6uj89UhA3eHNJJ2/xc",
	"JlEcH/zRamxXAGGjwDo3vjKIcLK/DcQI50kUSUooBBM24YB2ijCgp1URRf3Apz3HQdO6ZZew7V9B8shD",
	"dJqYr2zySF5ElZDHE0YYfhkjDGjkOIjSYeQLO4qEHCq9YAJm+JdaOda3XkXWv/rwXMfe2TAsYjmyLwVH",
	"tJN8jEesiuKrQyRu7D2ZvnF2msBkIqMj2DGJ0PdB/LDTddIBivrHBp+IVmT1EXZpc4U+CniR4JMkCqdR",
	"COgYTlEHXGgzI9u2azSjALL3lzAC+egG+S2AcDRhW8cBNRNAAhBRAa659XzXgYHbAj+++FEYzSeEW0yE",
	"LtgjuAX+cnzPuQZjFKCvz5RC1iUO7QyUS0HHIRP+FeOvoYdHbRrCIERue+cHMT72HV+3tqaU5x0rKkLW",
	"sBplBNl1PLel/05gsKp9m4sRFFLZpSnN9BmKz638qkhUCFG2Y1WZ8Z+XzW3R0OJStEhnkwE3c1SmUeAd",
	"V6W4FCRVZ73lg2V6skSV0Kcw5YibN/P2d/mXUnjmq8ksx1+9TizHP1VLpnoupSRr7rWV8RLPbYH8a2xt",
	"7KMqfaSVfTQ54mqUI+5jUZ5VRgEr70e7AlbLQmuk8+rUr2Z3G6l9zRJNEzRQUslgowNDyVAJJVSoYthQ",
	"WljcNTs14MjxEQk9F7Wh743whA0jW9lwrKuAXlwlTdcQl0wUbPQOjV9k4xfZ+EU2fpGP0i8y7X5Yxkdy",
	"vV6Qy42SI48fxuFxM8H4FP0NsX/1efj5pHd2sdOSn8/ejw8+QLhfS1x6k6ThHutW7xwMlAnM2EHs1Ihp",
	"kVsM2P2r1E2p0i145nVQh1cyGmF3gMCjc8M2mkx9dr/yW+tCfdKNsB5kuC1VxSGcPCIaj0sGf97Xv+j6",
	"zx/8lKtB9rNOe+KoZ53zddp30h4eTTD69QWj19030ejXGY3e9vJWb/v03zMe+tvf9d/KeuEiHwmw1dyL",
	"h39vEZwWXv+idMoxLGTWMAdVGzz34WQazk4G/0ZOpnNHDfTBeVuVRy6tLMx+oe3/gMJHtfdpk6k3DWRu",
	"1tL84q0QYNpacIl/yw3yCw1xpxARiXpaEkonqHVomuOedOe6yyx7/dPFcbIv/krbVNZ5/P1/7XZjOmPD",
	"SdnTGOEpAZ6QJqLUplvrc0nr3iSvxPtSFK/fBCUIXr0cHoLeVd8Nudeb3PPoqgi1E98bkaSpZxogh4OB",
	"5GWbYvw5EbXSrD36p8a+09h3GvtOY99p7DuP0b6DxR1Q56iX79mGDSBFVN3xZJkhD0R0GgdS1DbMAS2h",
	"dVNxLxwvcCIfBkL5eoMCmRDVR1zrKwPddcABQZQHouO1wRQGoQd98bvkgT7hp199c+NB4KIRwgIwyYdj",
	"vwP5z08phqaQN3IDaJYJmFl4xZq4mE1czCYuZhMXk++uNPuUjIp5ubUYfjI9JqZgdOUCYkrm+KDRMHeu",
	"1hjSsbW1G4fDXFdIyr2rdUb0fHn1wDE9H0NYzMJhMB8vwCaOdslN7k20y02MdtnAjta7sDXCJVmCjFI2",
	"WluExAAxicmOvDEDid5nlxqPvzyPP6E373huS/71YF7sQsZrcE0NrmnDcU3acqTsVvKLZCyFbOuUso1J",
	"9aTFuKp+W4cZlbddjT//AYZiJk8qEGm8tQt0Ehs0t7/zfxeij2ZTD4fL2EjnAwrVD/n4JdV745D/YA75",
	"D3YhZx3LOoZ8zThQiWiv2WdHuZ/bjo/4fc0n6OsaeXo1QRY2iHgWdzyDIafHGsgmKaVrtaBN5M/617Xt",
	"fFVhB8zONjDogF1+M8jAGuk1mxTM2KEHxz3Z1yU+9RF71k+8kbi8CPgrvejXZz9sHxz3/mu3Kz5vD3TQ",
	"1oPjnvjuOaBExZPk6hVpSAFnuhlbynJDrlwvKdYv1mxt05XHm28ECTVRdTWNjRuPu8hZkqJtKlaftzpC",
	"6mkFBjPQP0ilXyXc0mXjzfUPuG1JrTdh3dp1bHwCQo3ViMeN9opKEtyAy852pLLOqSXETo48rcO3WMQf",
	"XaCCW6eyaDsbKgKlbFY6QQQjiL1vUNglbWz7TFkQfR8kaoh7jCv9oO+jAIwhBVMUTDxKubWUgBsP3XbA",
	"RQLfGRAfUTCGN4j/bNR4e4kBaIMQYYhDAN2Jh6n4aoImAxTEyDljGCkiEAd+J+a25DVSbysrwuHVn7/N",
	"fj67GBCep+3nD58Hn69P/80//H12+NveXlAocZaBozSXtnYBMsoOr4aRMZoAEU2AiAbg3wD8G4D/fbio",
	"yn/6Tj1Y4kyoqRSeIreoC4HNOzYdc8zDNpxOKYBUiR2222EM6UdRYqNmJQSrjEn1eIFlvMWevM/bOZIM",
	"mrXRFu5u8uZRr5TV+buZ+/9YvN7W+ro3z0t9M6NmgBLI3KtGP+sS36e87ra/mx8z02Dq915S2ha6BeAN",
	"6/ji+4ASD768957Q6CZmJ3SEipvMGf+SS1ebCCCJKW9A6I80gsohYhHeQHafHQJYOJ+romk6gVNW4lwX",
	"SLP6rvIaWelluE46MtelAuSe7PYpYvcY22yAe+u9I+f5gGIv6uCnMJbt7+KPAumhzdYtFqwPyOQ0xe4i",
	"2WDWLaSHWJv7x5xlngCVkyyjNtGpUvc3g4SKXEoZt1ETmqQJTbKGR9oABg5xUeJBdv/nWmtL4hV0/fhz",
	"4SgmjSt140pdR1fqRvneKN8b5Xt69gQuxdQvXULBYRW3Amca/5azA6vrzidOvtGaF0pjAh6+QTgkQYY1",
	"FmIH0ZAE5yEJ4AgtG7tlwC6olvRZNd1XC9zXfInHxHcVDJLdKHwLeBseoqy9gcJTUEocj883hXr6Bxk3",
	"gZiidM6hq4rtI0GDanxq6h6iS84ahsBHkDWOU4QZ2U9L99IyV2ehuB5L8WUpSaoPF0xEvJLKBRMRdZpg",
	"Ik0wkXoEE6k1VGzqh1d37svxv1+id634w71S3cg3Zs60Vakl566qF1sAVdqyCl92ursvX79uiX9/bvL8",
	"NDCuKvP8PCFHgIyAfNmuAFIS8NyW/OsW+T7tvOjcosGns6M6hzNZu6Z9MyELWgOulOhS752Mo5AaqZ5X",
	"tQRNOJW/LYXrbk5iIZ9165lbk2Mz39NqglUI8qlvpIr0EPvqQCwcpdgctf2d/1vUkmk1XhbyilddNY5z",
	"tT2l67yQ6nkF1c+cbLn84lgWaZErLOdT/Nwc0eYizTud1UQIqTkj2FtZ7+9JMPBcF2Fr57pEbXjQAi/J",
	"EBzSQ6Kk6Yel5hVil7/IDa23Uv6kg15kfY17WRvlVxUhxeys3u7BazoKSm2D3HPO7YocjdRgLfZHokGg",
	"hQJMsGvXQn/y52K4K9uNJ/Bh/QOr/wwvUNr2kt2dVrVy+8PUJy7aejuEPkUl9KDNJV8rvdX61UW1DmNR",
	"kxtygWVkMSBL5Iz0OBnGLSnTqqtbMg7/E1u5fIJH2q46sUfXqODyrCy6xuZcn5boGjlEI5Lo5AGEValU",
	"iHD840Y5qyxcLZXjbeWyrhNwq9DXwKPGMDPgGUXgyjZHSwmYWgDwGjjddCxvcWDuA8I/JJmXBIDIWg0E",
	"pIGANBCQ/JwsgRNHC2IfdLQg9mGpaEGFMs6tGhm6VrlZspRChtYUU2d8XWuJQH2VlAm2v8u/ithp5FVm",
	"dzYTBYo5mqnWsjzN4rHVx9VMznEDvJwXNiyHFgor3mh85clXhRcAOWG7ti2mybU8GWTzVWncEt1tYFTi",
	"4iyi1GtzkTQ0YdzvuVkN9VT35CxFP7ZnX+4eylRPXp53qFEu7fl3Zv6c7SWqr+RCuVfX7q3ROFM1zlRP",
	"2plqnbJQzBbKiacJbqM4l8pkuMC5tr8rVpIro6qCacLpWfxbnnQ65M8gZDaXIpwao6qNdKonWX/x1Fjc",
	"kiSwzV2TUmPxZMeO5sTHK+vQL4OZcVEd6PqgzQ1BMsyCDuNPgYdpiKDbSb0m37GmZZ13sydBcOaUNwkM",
	"bKWCZciR3C1NjORuTaRI7p4YIeoJbxQZpu//EkSozXrLkqJuYD0Eua+af1pkOT/tTSLOTIpYgkTdgExd",
	"cotLk6auODeARSo7UCVLkZeOiyrzIodEaL15SnXd91A8XzaE8PRKqHUoGkavCWnXhLSzsoTEadBgqnvw",
	"BBHTYdk7KxERYsUX1iFv+2ndVvGaJWa/SZeWnSSWoE4fDpDfngbsSAa5+BlZKh0/o3+8z2Wk+ljDXZRp",
	"XOW9PiLjqljF+pJ1TdQ083QdGxnkV4WOT4gmRQJU8sIgLpx2jI5YmQujyH0O01yHgAyrO1LJvh/NyUru",
	"T3O+ipyvRbpXx4yvJojJPe+0ycBeywpTqv56xKkj2frTEqjmZr1JglQWOSwhStnj5xcgzUQk7dXSpRly",
	"/okQpTnljQvgsSJyFB9QgNy2imdXIm9wXFtHw7M5eZ3poodxyYelrcKBauRbSq1pRsgaUVIVLJvBeP0W",
	"UXP9G7GkgCtSBpmXPGriWKmm9GnLABmGTBgSIvCE3KA4ZqeHuVSMDPZ/xJVpZAh2X3W7cckpCpQ6sgOS",
	"mdhvPd8XbhrAGSPnOk4eq2vDQOQt4xBnNowB4iNxF0fQkiow9h2GEw+PzkN2iEYzHd1aNzuEnmxTug9i",
	"7k+AqBiT7gRiV2CxKRArMxCqRDGceDWoxG8jV/Tl+8YCQEoTfS1M0DKhtEz+6gzVhoOtKVrBwjxTQYC7",
	"K+uvR2fYuYD0+sjD12knNEm5Muk/BRD85RM8agcR5lrmENLrr89+2GZNcT9T9odwQlIIf7YX7FsQP4pl",
	"cy6v3rnEl/jLGGFAI8dBlA4jXxAN+5Wn14IYsHM5M/LHxfkBHYgxCQH0b+GMY0BZGyC8JYoChCwJ1dmW",
	"qDH+rmWvYv1Cl2eRf8mBe5eYEuCFP1IwJZR6Ax9p4uJDiz1n2AC5C4MaoPJlcNn2cBdIEo5RoEbBThD0",
	"AwTdGfAwG/QoYKNm6yY19v4MDHziXAsEmUcBwahzieN585MLo5BMIHfq8tnycE2DGl80ZUPc45OhIp6+",
	"nHiEfe8a+TOAbhAO5WD5qGjImRT0WB/GNtAQhlHMLv73f/7v+17/6PDgf//n/2m4rViCCaIUjpAoyqb4",
	"lm2wRJf15DqkbQ3r3liMDjj1EWRLyfZmBD0MONhviG7BhEwYOXPmwxdnGpCBjyaM+1KPhrQFpqLyLfRC",
	"sNPeBRMPR2wnBmhIAt4oTy7J2mWMp04ip2IG97n6Ilzi3vukC1ODU2OXc2oqHNRDwtae+C4KUrDSQXk+",
	"Pacg2wg2nTLRNaO1DxnfOxnkOX7Uxi84WAHtSuEBtXUMByvlfpZF4yC5BMeR4gEZCKfKBYpV9d7FUSKW",
	"UOjeLPTu4c5GELKat3qR/GetQD3e12ctEop0ebR5CWW8hBYI2zhHfUXf+iDxsbeHkT/0fJ9fjdkWDzlb",
	"8N6ske5+wQvOlZs7KkZ42DC46v/j1v3jbm/H/l5nz/T7qQ0a34rGt+KpJ6qJT11/8sp3Z++6f/7zuNsf",
	"/fLLOhLNbUwi1xSOtZExoy0sOpalBOIt4wpgUhX/9sr4toCztaz1IwVGvXS/lvmlzrobAvT3cDi5+vnX",
	"yeudT/TWJialjbhGKt2FGW+CN7ZtR3OIqVDKaVk4M+m0bH9D00430kcjfTTSR8UstknF3uDWHwVuffF+",
	"TM+kPXfplkjHfpbowR4jJ3GyHnFK9uQ8H0tSdssuZxNTCOl1OTFOGHvyZbkLSK8bea6R5xp5rpHninBj",
	"g180Ml0j0z0OmW7usix+Fy8h3V3EfeWKePFhe/xinjHXxp5YVIhMI6ZM6i0mPWZKjAXlRDGq8gbC9IwF",
	"4iXAsUsJJlPk/SBqpciLUroEjshJx0RH8CzC3p1ifc8tFpiJh2VuPSYq5nDehV5lvtjyvcK7Mr1usF2p",
	"SeexmM5jyWQe6kR3PLel/06Ikw/A65cNSmywpxSTR24OVlndkoX1TP+6HmAwb7OajKCxyLNZOUHjDcq2",
	"aBkm0cJm0FxhK8fmefUbuh6i2efzbINnk53woTid57Yemq9tkhF5QV5MctKchJ42VnrK6lkP1OrOzde1",
	"culq0k0WIJq6wIEXt70Mg95WS1gYsKIr2Nn1WVykerZdAS/R89ssYIqxc6VIJIT0WvrPioeRHSsuxQVe",
	"QwaRsrGjd5F/nZDuuH/Tw5HM2jgWn9fCbCviYAud51Pu2hgbG8ZS0mc6OS1Lw5G4Qaw0zB1kRaHChCy4",
	"8FMh5MRsqyZk1flGsOB8WipDxW/RHXKiELUpp6T2KCDRNMvnTHY8Rsq3kAyBqAtEXeHuZ6PsQ9GdGppI",
	"vvtBdPqIyNucl9BIViNkyuVNLGujX89NM16CnHMOV6mYINLiOJiB3mmfO1oHwPXo1IepygsdIMSmmC+m",
	"W1Avwv4B7YDDO+iE/gwQjIzf+i41xsI+TSL2hjSgCp0YYSDP591v17td6sMW++D//tse/khfWV/3qp/V",
	"JLCLV211c/p8etbt7rT4P7uWecStNQmrn7KGu9YJq22xWrK064KncQBHGEBMocNazhAMLoxSAlRhYqYG",
	"CERTn0AOl5pEfugxDqv3by7iio9CCmYkUkYzCIwxdMAf7BfIwQlYNZvAZyGzfAvAAQnCxa9JABwymXgL",
	"P6VFNBHPhh6lcCb9YI0Jb62RwowujR6LPb3S1e5hYuBq73k/QPn4Wglg+7vxSWl7eJW8B7zaIX6fJseQ",
	"t9R9nFzsfD1jcpCZEqGCnG1FES9ZkYRozq/yl7zZ+fKklLGj96Wqt/zMZoR8Yj/zSCBmxyJ4ietRdq3x",
	"S1FwB6T5w2JIAd6S/VxXT2p15yN8wVa/4YIVZ3AR/rttzx3IpBrIQ9fIi2AMQzCGNwgMkL4mkArORaGK",
	"m3XjiRBBIQE8xk0KiYiuGxp5ODVfSRWfuNVLkSiGbeJ7I5IXgeG4B05EuVTM1HFP/5qd9VLDLg3BRYn8",
	"BwYM/VW3BRSEiAzBTrdrz6C9XlAOxwpxXdNUwDnEqq4cWkQZ40+dgYGLfsvGtjVPEh9ROCYue0+L3OPs",
	"TAcuCgBFMHDG+hIAPEwHoNw/QIS2Uw2DZxrOLXwLJoQjURyEQxEEUIRJY4MFz2S8S/ahBaA/HcMB4lG9",
	"nnfACR8VD/AFXRe8hdRhIicfORuZeHXOAKQOwi7ja+x1ioxPLgokkh+zXforiQs3FgPytVhcHRnam/0j",
	"y/A/+a9fW028jsbDovGw2FouID+Or4JlgvEzbuFByh+hkokEcdDc1WUz5uOl0UCUKD9y1iOVg0W24VIV",
	"NtHxIxfJvCPkxmPilu47a059UbOkDu09I8gBG5cK8rX0lgzE7BxIUdvDFGHqhd4N3yXJIxhFOl7gRD4M",
	"AI8YeYMCigCTXXw0YbcDd1hBtAMOCKJABLf0yS2YwiD0oC9+l3zeJ5zDqW9uPAhcNEJYaOr4cOz3PP+5",
	"3FoJhwEVCTBzeSS3lSUtQxC/9t3VaD15cCmhu00dWCx1AbbSHsHqVmADZrW9rPXSdfp4uVWTadOLLJsq",
	"ahPRxM9lF04NpFCKdCMIMx8UD/ur6p0LqYMR3eUWjnz/ckuHfI2DT7KqIZpkrGmgI3cnZsJahAPG1cW7",
	"pvDMRBOZ85KHPD61so51jIZPQhm2Iq4gdshcoLMZCM084DcNeMYOtzI58K+e53Mc1cQt/0o0JFmGOHC8",
	"X6GH7wsxvAXe+wSGIgYsl2rY6KWRoAXoogD2iyGB/RKLYODZIAo5S1LCWSArPNdRp8U83/MxirEI2Xga",
	"IIpwKILKqiUF/HUjLCjQp/xNLQt2wDEJZSRddofHg9D2Fs0AhgGZ8M75cnBLGARM4vDZPkMH5W0uH25x",
	"H5Fzo9LvrL1TNo00KugFzti7YYcJUoLN3eUHI/M2gXN1P1EELreOTy6uemf7v/Y/Hx5cbrEGhrGwE2FZ",
	"yTWYnarZO/7DXjOlHjvuMHB9RKl4YZrDMBu7Ojm7WhyWtCmJebIuBoSRr+qHEVg83EVBeOcKk/BK/Z4U",
	"706wP9NygjFn0dcz+Tp4bgq65viYDLmrm74SE0v2oEQJ2aTuQWAk5B45ak2Mfs5QyBUy/2lt7V1BPLPM",
	"ILN9PEtp2FxwriZJtH5Fgoz10r1lbYFk1ZYu5/fYKhLL5s7Eoq7kXmcDy7jWxQESzr7iijbcfcX6ylvV",
	"6C73ml+RJdZzaQd8lPyZ87FhUrLtHwh5WN2eELzsdmUwbVMeZr+oRoVagknMkBtaeSRa+4y8OdYWW0Ep",
	"+vtq9oW++udr/6bFPpyN//jwGf/6fqt1LzFsXrJnS5BQPuXvJHfbZkdh4b5ONGyd9EJmkA7Es5OhZSEu",
	"TrvdnRb7/937TJ2/c1Y62WIvJ/HmAMabowPAF8gN4KAthDfJ7KUmAxPcnqKAv79xCNyIq67nWvHCmX2B",
	"xVyzFvXjjL0bd1ri301e2HhZiyxHh9U5V1VWvDgp6XIiyoQse5Icbv4mQd/KBhAOr2D3vDf9e+/bfQfC",
	"FhJOp6mn3jI+GIVjPrxMajIH2WIfBi97vem3N4P70FUDlMkFymAoxUjPbcUfMqEyLXsAdUxCkfYhJHxh",
	"PAymZBr5MFQKQieiIZkcq3J8h2yDT5ade6IZ1xwO7678M9Ttvp79WTW0Ry1ZBYFP5Jvi6YU90d03kU/W",
	"GpXYNFtqtFf8Zb43taE1tjlUS9vnujyq5XGsyKVa9lZjn+rW1qvu3uKGnaPgxnMQ+IThDfS4Mg48OyLO",
	"NdgXo/QIfm6BhiU3OZVOksby7e/833y37Czy+YBCg3bywRSqy8bzup6e140QUYyP1Aw1k3JObTdFtrd4",
	"1lmXnlZrP+5f13sJVeQxvjnEk773BW6Qt1LtmAH1lNr0DOiVLGKir9a5+1T2V9X+y/6gvz/mAJP6k0Pq",
	"nhWhhkIe4dyFQcosprVEp3bd6Xa7pj3ETO6a5TReFf0UxHs/1ryhFyo7pU67ySYJPVmbA42UOGbsIn8e",
	"36IASbcQt24JINPpsgzlF/Ijl7w2gx8aPs1VknQBH+7HStL2RLixeShB13/p7WOdnx33/mu3K1aSjUFt",
	"23N2REgUOMgkf0El9ST/NOIsQv7anJmV7hTmiwK6UGWUr3tsxAF7flFYWiCgrCXsoAKA/LioBZN/bhRo",
	"YPkNLL+B5Tew/AaW/3hh+YrfbyQyv/jgNw+cT5fcmFri8xt0fozO1yJYA9BvAPoNQL8B6D9ygL7md+Ux",
	"+jGrbGD6DUy/gek/dpj+52+fT3pnFzsCpg/HBx8g3G9g+g1Mv4HpNzD9xwLTrznEq0H/LaL/LvElfvGC",
	"PQVevHgLhMgNIFb7R1sifJKvPjFpZhp4E3YWHF6O8TkPhwFhpz40lbi6W6A7FA3wd0w0UOvMY3exVkaY",
	"BMjtgMPOqPMWXG4FGGqjTccYVMdzL7dENbn0nOvACQKQZtS73Mp6Kec6UsRtem4LJL54uNCjxigaF4XG",
	"ReERuCiYhlzTOBzbb4s6KqiW7L4K53GJNcEDVA+VeSzoKT1BpwVjw22Us4As2P4eYHilPhZ1YrCSlvBj",
	"MOiqQDqsZP+NR8NjlmlKiDErklwaT42V8c/6OmsU4HwFXTasnE1jSStjbl/XfitX5sKxQVRlJYfCV2o5",
	"d474FTVnGRG2qQAB6AcIujPTZMq5puTUAZqQG2WmEkxa2lEzfERMNOCaiaxCT5G5LjfUWeS8wAsgheii",
	"kLTlnZlFemaxOYrj17zGewwRR51RQVixUvO9+B4ceYMAckwD+LR9IXEujF5DIWazW5w9tgKHbwKXZz0s",
	"zEO6bSY7xHbERYKNQtKTgzX3d01Ua+2uwfFzHP8Ysh0DaDLlKmyxGnWD4K+BwksfxKHn+0wmz0oJ0pPl",
	"OPZKjkEPLdGNGLbv4WuNJ7GcFdaewd1P+QjWd1Z4d8052dxzwunPPCKCGJejd/NZWYDsE90m6hag7Itk",
	"+YbAGwIvSOAmpQmm25t4mICe47nWm0KOp9S5WMqN18BULXryxhdCcWfeKgX9J+7Su5z/o1q92AVSr+f2",
	"QCa7NLYx3RtyQ5yB6VIvm+LZRJPC3iAzgWgJjzibUrl/QJV7tvFsJ2woGfrK+MAIsESj7W4s+I0FX90f",
	"G5ZANJ3jlORtZSMe2H19E0EPqr76m9AHS1799F53/4ZEQlju7ucSeFu4k1nPx5ngoXOqHo7QFFpJJJNh",
	"x6AdDY3mXHRRhuZo6nescgVqR6OzalKfloJN9SSq15AvkvtWJ6rjS7nIlZU/YnHCE275xSiPzr3O+NmU",
	"4XyS1CacJsG58Pn3sIvuOI6JAsj42TggmES0BSjRYOPJTECpuZwSI0O8yQS5HgyRP5Oux/wNYMncLDqs",
	"gJRFR5tEywe1pWVJJcubhErHk7ELFmZImSrliioDy2yu9dC+i1nEEnKR5zv7Jx/3JaSZwQxwEMMC6IvJ",
	"R3nP6E+fYgEqFOXj58nw5d7P7k+vfmo7u85e+2UXvmwP9oZu232NXv3sDl7/vPtyV7185vIKi/GXh1aU",
	"piTTdbBnMvw2MDQdtp1WtbdZ2RO+gKgXEx1bwTi/cCu1g0/6obD6Dt572BVOZNz+hEaemHRmT0bzrL6q",
	"LmrPd7gvbkT28l56weI28lsvv1oFW+fGh6FEkWe2rUsutMfBYOAQh17o3YeCREOqnYLdLLEymd2wO7Tn",
	"eyM8YQ2AttL57RPu5hXR+NfcTg8wFLV1laK9XaDJ1Gd/rLozGXtx6T06UEHL8hsvvzOZjZsHvBeFBPQM",
	"gEhmD4eTaTg7Fy/aIi1zQ8upsnivvumLOePiynpYfk+tnDW1i6V21trF4Z0IqtAG4i/QD9Ekf11ErfnG",
	"3iscxNKroVqYb/kIDvgWCj0waIMPKnxMH0+j/PPZ639QNXiF3PZPA8I2HZxwFXd++yensoaoMN/+2QpO",
	"/5ntgJ6t4PRnNr6e03+2vtN/tvbTf7aa03+WcTTPVnP6M7tQ3sOy9TOJDNUX/b3WiOs630PPFyEesgUc",
	"SK9l0WRN8IyN7HmhGac0cibUs4X6V2X5m0iL/ASjkyF/hRRSI2/9p5VdUhCJkjG0vFC2AS0SLd3CceT4",
	"iISee//BxE3dZ1ix2d+8scrVF+dj+foSdnDP/perr7gU53/lq5m8rdyg1bFXp37JLZMBdZfbr2Uq681a",
	"vnLvfoSSfM4sM/X7tKA5gXxSLtX/vWr37n1Oym6dfgmXOCBzwlmJmnNiY/GaUkIuW6EXuV54REbL0IGS",
	"nYvXXVS13K/yAYZG/a8Z+s6XK9N3HpPwPYmwa9V2HpMQ8BJpXl9JbaRScnIbrlJuIjixh81Wdhvo+4CX",
	"FDYb7tIHfR8FHOE4RcHEo1R6AN546LYDLhLheQPiIwrG8Abxn40aby8xAG0QIgxxCKA78TAVX03QZIAC",
	"HRKUdf8jBSQYQex940uZYsA58mh4wae0JFap3jGi2CJc/fnb7OeziwFp8U8/f/g8+Hx9+m/x6e+zw9/2",
	"9gJcxIFTB8Lla7tM/Nu1RrgtOCoe6+dh4tZWHiCpCSx1j3WrR9yoJh57E4+9ice+ilDSQh5ZZQhpI75Z",
	"GFzt/HOn5/9+etAC7FN483ry+t3rn4uc8fzA0qYUY7uXzDKrCs+tgsK9U2jiODxcxhonLlcuCupwTjzc",
	"3TacTimAVIlsthmNIf0oSmzEbIQwmjGZHi+wTIKUJ5/m5RzJS4610RYZXuTtrd2kVpbihe37Y0nwsk6M",
	"OX84FQkPV7uAYKF88ukXLv9svHC3v/PnURZ8R791eWsCow68YY0fux8Qf+vmPXUlmohNSjjdWPBBYoEq",
	"wAcVp8atjdCxaHKxUSBnsFZsobb1QhBKVjy/z6KAYtTFwIR37dvbWy6btqPAR9ghroxFXmz5WWdZ4ehW",
	"uNOsq9iytrj+agFcuUAr5j8nvSgcl49O93KFEfn4ED5hEX3X+4bstGgWEuSInCjwwhk/+QNIPWff9xAO",
	"++45cgIUspa33v71lR1Wk3STRCcSF1A4UgkuonDMxGRHBPG68SDgY9xlIiyNBgI8GYLeaZ9zRy4nKeLv",
	"GZUJVqfARIOlnwSt/AYQ3BA/0omaRDToFhiwpz5XvzlKrw88HBIA2a0cSlkn/tHwDn7V7XaBHkPCMxjs",
	"E8wkB3HkZDhRIPfVDFi/2IH2aYMSXeFwYUL6msR5R4RKCt14JKJqauxptfsTayvuXN8Ayd5jnDwKWur3",
	"5JATlQaIPzHlbEXyGFEvXtYCFZgIJbKZYOinVJVr3B8CTOZG5NFYQZA2YjMyUxhA51rlnUiyPkURfRyS",
	"2JSzLv+SyA+9qW/CGxW9KGGoSbyclnjZPBp/acLg7lrxWrKR6E/P6+aGFbMezk8ck9YUWzMIULA0/l4s",
	"ZDwRYeEfzHjCup+TJ6nFevKJikk/QusJwmFsPGEftO2EfVjOdMJWtn6mk2KjakwnjemkMZ00ppPGdPLI",
	"TCfmPc8OwTa7XRGc8NeaXT9uCClc3RrLEGz2QkU+Ckg0tSrFRZU5hvfA0xBiUZlZ8BqrmsQYYtdH9nxp",
	"SI43RU5QVa0WCP7ziqxtE+j5xW+QjFHLlmypwNivKbfi6rl/S2XRlH846t9fWve5DeS8x0RI5D6kIRCR",
	"W/lb2QvAFFJ6S4LyN0V/GKdx9Wgsh+mUrjFh874xifuiKATPznsfj57b72hV+AjSUPjsFuA4jfnqoc1X",
	"3MzZmK9y3//85bqR5quIJhUN4g2el7+Gxul1+XvPkr+GNbYmhRlrupqMNXwS9U1Vk5pshu9Kyq5qzdH2",
	"d/ZPQaMk5wIPZpQ0nogFdUkfUCgpr4Bxkk8uyzgpF6o2xkkbPdbOOBmTTTp/yc71kc1fRKnyuyzjuK12",
	"o9fD3arJ/JFHTQ+Zg+ulyMG1kt7fk2DguS7C1s51idocI30UMk9SCk/fho5QEeYzd1kQTFAIXRjC+dTm",
	"cdeMrXtUZfKLM69T/hA5R4hrIWDHzpB7alSPlzHrKdabQbNnmFhgGO+JlbDKx8nmTWSFvVamnnUxzybO",
	"dclgl3xDWMeClQySO7WxIa0/WZ43c7SdF971Yszmm+B+L15gAqjQ/bx4wdkmvYXTKdtEoYdiL16pKAMD",
	"FN4yDonuPMpRLUKh4hlhhRUkJIV/xm6dVZybJkjs/c6NsVMbGw5WM/C0g3MLAzQmEUXsTnARDj3oZ6UT",
	"YQ9BKrRqARkFcBKjlUYCC8Z20GgLCBgERk6odL4x0F733gF/kAhMIip1kjD+idUeeqMo4Lg9APmGClur",
	"IiWJMzF75cAgA33GQ33r88mvSzZqbZE67Xcu8TEJpUUT3U29ANE+RyApkQS0AcH+DIRoMiUBDGaJHmGA",
	"DJYiM0mncQDBzr6o+e0b674eZpDWVTWQzNRJ1l+bJi+cmE6/xMSY2C11ovTv6lSR4Hrok9u2iP1vB/dw",
	"vZ0qDVTpNEDNF1noRJfJh9aARQPNXF+gf0BLA2BuhyQKr145vx39/o/P71vi45t/Hx7/090LC8MPsgZn",
	"H5Uqwpj/h4BE0751mNOAXo28z8e/OxdHrWlAw58mb97c7GxxQ8IRwqNwvPV2ZxXDDcVNVGTM/YxV5aE1",
	"TzCmX7o/X7fk55fo3+dfXnPTRMlhM5YYX4/JwYoBLPwmiMIyDVHHmkmXrTB1xlf/wGdvvM/R5D6EwPkz",
	"z/cRaFuWbXE5TCzoZ8K1YPe8N/177xtHaEHqDl/v7r162WINr44cuE252KAlw/UGPrpAcNLP9tS/GKPp",
	"dNd5LXzzf//714+D4d//WPHotZ+kLZ+yjHd9EngjD2csdxhcud2u8+Z1i/2514Xu6zf3oYWBRwRum60r",
	"DUnAA3Jzu/2ilVkIdvMMFdxymT9OxvIjVSdA5hQJ0BAFPGEVDIGP2JOaYLSAO/RCNMnwCBU5A/shYjua",
	"idkaDL0r5O6g4euWQ/DVjvP6J2ddq7SSVUkBYZZbDN/f8MVwCQeaG2sSGzOWWxMsgqateFEk2kj7DJiz",
	"ABxUBJ6xibgenfpwJr56ng/zVE2ITA+ioYnE6Ap0P+tXpCTqC7N8C7z3CQyFBwAHsLHRywVtqRe3ibb4",
	"xQDb/RLjK8CzQRTy5Vc4vEBWeM7xDjxDEJ8nT0kkxyJk8mmAKMKheP+pO0ykGBIPDuhTAga6YAfEzwBO",
	"9noQvPQAGQTHE9qxzvly8NwH2thBp9DJQDoaw02y0sx4/0al31l7p2watssfw9jPInH9FwUNx9R4etbe",
	"KUJ8pzAIdT7/JbpPhQGbw1iFVNHJuuJIQVGigZo2UNMGapoP/IpPT3/yyndn77p//vO42x/98ss6wFjr",
	"hZTZUI/qbS7jIIMDebVm8Bp5+9p5Te/4w077ZKcl/i2EbFdZ7QMEKcEmb+BiSaYzCZyr+4kicLl1fHJx",
	"1Tvb/7X/+fDgcos1MIwJTOc7cRekKVW/d/yHvb61NgjQCAaujygHjSSHZDZ5dXJ2tThEmeNPzJl1xHPg",
	"694Yi42HvsiIdq4wCa/U78njdYJjW6k5f9HXM0loz01GY46PneFd3fSVmFiyB3UByiZ1D3OmXLkmRj9n",
	"KORm0/+0tvauIJ5ZZpDZPp6lNGwuONfSJVq/IkHGeunesrZACs2WLuf32MqSVMYcsagPZTieU9PVF0cY",
	"2HGEKfpIrehMcrp8dCGAAKPbFA1Tqk48sXjr0oYnOqkGdzg3sfrTQc7mZZBDmvp7+7v65kp8UyABUh7F",
	"fEDhArlkasSz1KFJvWcSmrI49EyUik1NXnGi1+IUVzGEZWjFGJYis3zMYR4BiYIroaEHJJ9188cYuTg/",
	"6v/Ugnofjl/W5Oxk0HtJLv02N32hemBw1bhMPJ5rvJSVFu2X6ydemVpw/WbutF5rmdAw/bYvuK9l6ak4",
	"1FAUShM2aAbw8EFIqn5oxJoRU4ENXYqQCqVtF4WKEVGaAFAhEdULmldHIrJvZlkCKpWat9Ttpqs9CB1V",
	"lq9302+4wrtblLJoCEeoHUSYbn/nf18FEeb+Gh6eRmGbxgpF/cidBsjhboZS6k+BgvGmQBBhwJsBqpk0",
	"RNg5K3sWYZ5z5VwXLBLEc4yMnkIiFNmJHsGQBOkPGnO2tfHXUNslliFL2bao7rKvuSKGIzSCzkyr+bmm",
	"V23m8+KUIajs/qQhoXtFaENQ7wqII9nnk6SOhWVfMXkEMr8Ycu9PInFbhcjkTBdfAaks9v0kySV1C5Yn",
	"GU0ujFRSqKksrei7T484G3esSKUEacx1oekjwrkUUUdqkAtQjh7Sl3kpMgghvW6LkEMF8eRcty1rZO2t",
	"BlPfH1Yed7kUtHwes30Vg7YL4Z1TUc6SIiG9ll5aHjXGuRq0c0t9gX/be+nfvpkVMtiDIfFdDkqyjEL8",
	"bh2F7w2uBsPuT3s/FetuGpB/Iye09ycLWDukgXN1jMI/3Dc/wWJdOmkUkwc2LpZaRWCLWzHi+MlBzjW5",
	"ozvkRDzAGWuLdkDPcdA05LjXud84KPJy66B/drh/cbklIGdbh8cXZ39cblnhirqRC9aGZd68kZZo+Uni",
	"6mnK8M9DGEZUxbTNBqwrGHIChM5ZlcehMGmYdMrbt8d3E7/nAdJvhyG9+vz+5vbm9W+fW/zT7e/fPu3T",
	"L901rYVt7tiYpODZjGCTwWOWmHwm2Lo+szeA9onJ32/nCfZnVUw9E3Wced1mYY99SCeeK7LSC9ykCOW2",
	"GjRy7rDyMMlieA0wuQEmN8DkBphcT2DyKhDJn0/Put2dFv9nU/DIxgt4SUyy0UKDS25wyZuOS45VPZsN",
	"TU6qthasdjw2jFRplYUox02rnERcdkymImJy95ySUyibeFlGSBBE2Ps7QuxcBmiCcEgCQ/YzXQVvx16I",
	"hL9gDjJab9+a7cu6n2rx0fH0NhUinXhR5JClTbtrwKV5CAj+bRnIdGIQVti0SUtLI6cTjycL8jUxiYLo",
	"V1MR/EDQ6ULEWD/0dBkKLIGizqCpJJBq48mqAq5aTTzYDeGqtQVSr4KX3w9UnYumTljuKiHdqjHV8x0/",
	"Elg1vQdJ3RvNWADG+ACEVTmYcYNJK39/SxOXHFcZaIGqkoctONfl5gSCDVOzNWrzRm3+pNXmVT27JMMo",
	"rKKqgfiYyR4VM1aMMIP/bn8Xf5R+78v55Tz4z1Wp3KeZBUplQe2pMRd/h+UFi6yW1jbwja83vAB1lbnW",
	"8+/zFcEEl4s9mxcltabRZ6+WDj+7RBzXjChrFUZxnRuqRr/kwVWykCoKm9JK4FZWBzbjUAzPLQI2g5R6",
	"I4xQQRzgapF/TYTc2kXI1RDJZUPkNqDQaqICC2BdHPCVfX7aEYHLrsijjQZcaCGaSMBNJOAmEnATCbgE",
	"4JZtAjcvEQxux54zjrMR3ULBX9zIFxluBup2Rm7MoRRjYlUZLcc1CE4yHtZNfhLw+fYiTMeOaDGbUnmR",
	"E5tbDld3dXfaXUYjSrW2JdVSD7lKAzQkkqcnV6rIZDt+uKHzJUE6fRScNdq0aRPMpizUokvOerR5s77n",
	"fNcy3cZW0thKGheDJ+RiwO3LK4t8fiEjn19skqfBfXwMGu+CxrvgUXgXPALHAit+ZjlnggKY/gpAVtUj",
	"+TcaxJ9FAovm1XnIfknjfZ7V/h5Q6iIg6hIxqRPW1we02m+evT6Hp5TB4RdA4G8YxayX9VUPt2+Q9qWR",
	"9vdmuG8dMp3ZIdGC1dNUhy1tIknoUNLvbjKdPRbWvNPQftW0n0WF8eMUTpRtTLiSSqSJymGfoFBewtHN",
	"BsjnE6JjbwoGKLxFSJB1eEuEcMvffiWO2j3zAqRDylL8WKrwNHgI75VHlg8g94GUQkEiE0AmezbCxtPF",
	"s0EzWLQlRcAcn66EulTHTVT3vNQAqXsscBcIOmP+K+duY8nzsnhiGjBHRs8qxhsXGaoXUsAItjSzLJT0",
	"Qj47S/DLxawX1RJ1k/EiV4mwWm6Zl+5CCtElSWjxoVgZCTX5LrL8+XJ2syQF3T/fRToJpbqJVkJBD+Ic",
	"+ujyXJTiRkuHFM92IBHksubdWy5I97KhuU1thNT8Gvq87JX7NJfkZoJC6MIQ5uj4PsbFykZjD4nMrJOj",
	"f1gmBvv6uMApX9A1H36x6arLQgQ0t3+roaD52P/3C+5fILA/XY6OfJ3yICOi/70Iqoqg/veJ6F+KZbDG",
	"kBMFXjjjS0x6UTjeevvX1/+0vm8NIPWc3tT7B5rpr7+yCsGN2pIo8Lfebm3Dqbd9s7vFfpVdLyhkeuCc",
	"nUXsSNcOtXEeHoEIs8cNGQIH+T4V8OYJvEYA3aBgFo5ZmSDC4Fk4RjMwRv5U/EzDIHLCKEC0BRwYQn/2",
	"jaMmHP6kEo8yny3MkASAPc6gz5pqAwiuPeyyHj0cogBDn3fNQ8NHWG7g8w44weAdws6YVeMgbYr44Nn+",
	"BR5//g8BBIJA+N8TDxMAHU++CR3i+0gOhwwBCccoADAMA28QhYjjzJ0xezBCjEkonoICCiFJ1Vy3rRQM",
	"jLQWYhdMIIYjFI8XwOmUPUTBjEQBCBGGODTanU7T2juTsLUAScQ53yeZZ4bNj1I4kzs0hjcIDNiDdYqC",
	"IQkmyO2AP0jEUWpOREMy8b4hA9ouUSQaGDf0QjE4jJCIQC1+YvV9D19zEEmEaQsMBJZfgPXFIgoHokt8",
	"iS8I8BEMsJAs4IBEoXhhc7IRbbbAX47vOdeAvee/PhuH4ZS+3d52iUM7A7ViHYdM+FfbUondVs20ZTPP",
	"k3vDFkONOm0xI8wmM+VIPLYMLgqh51OwDWLOJiiIZ6thi3oLqbmcakk4IJpG0PdnACMaIhdE2OXosSDi",
	"MJHkmCKcNqBD7E6Jh8Xq82MEo3CMcMgo3oAiBYhqpHzvtM8+kyhwRFxv1VFckzW+2Nk76X8Rk9J0PKOe",
	"A33wdwRx6IUekrOnksJbYBqQEHm4xWHCfJ8HHvHJiFcTPjMd0BP0ADwKPJd9yVFTgxlXkSyU/5EKtP8z",
	"EgCRVYj7zLWAJyYoPXE8auTHed7ibYkX0FBSE8GC/iAGhE8S+sDDNzyM4gzgaDJAQYI+5AqkrY1PBjKQ",
	"+hT+HXEHFSSPlcR4CncctlFiHQROyEswJN+7RuJIihQ2JFD0LlxdJBm32Cnj7UZTn0AXQDDwyYAztPg7",
	"rFriLYixsEFIrBoMeSW2zP2DDrgYI/H51vN90RCcThEMGDObGp4WiUYl9jXmUbdoAD71k6vG1iZtzcid",
	"vDpgzPhdYwcYR2gBh2Dq0VDxYzAKPM6lp4R6gg/rVeZqvTHxXf40Ybc49DAKOuAT5ivrE0HclK9UgGTn",
	"ErMod5zTh6oqG4dgQO54F7z1Z6z5KQr0GJ5zvmVMyPfZOhHH40BGfg4ly2xJeLWLhh6WHmCzqVYusn6e",
	"CeTw1k73bqcL9oMZAe/I3eXWcwB9wtZYY4SFrlIMkbGkADrXEgbG2ZM3QZiqu0o2z4d6xAnN///MXUtv",
	"5LgR/iuEFwFsoMeeJECA5OasJ4EDr8dwxtmDZw6URHcTpsgOSfUjwP73oB58SK1uLzx72NN41BJZRVZ9",
	"9VVRpCp7X1Bshp6wICpFI33rOt6cpEM6a1S23oXAsELeN55uGIW5yFbGNNGFRravDVdW6QNWHPR6QJfa",
	"NdA+93PQU6aqxN44NAqdZwv0Y8HRDWZuDFQVtKTPiJ3nLgiBSEwCPm2D7kjy3OsFeU7+P8CMMi80FQFB",
	"J7oojdg4M/RqkeemdbZVNhJjxr2/OPwMhNQT0JmI8zUZvPfbVxE0WdmXoVG/3rbesJ7S/HfZUFF3Djcy",
	"2OQ9fUROCPm14pdTJ3FDq0obqzSCcMgU1vkUq8Kl+HHSHm7GQ3oEKEPxhbc6BhWJGAI4IIFyeTLqxQQW",
	"ka6MlaVfPnFnJzVG9htwcxnCeOvsi14yHdFeuK3FN+H3H7g/ZrLZqsnc6PV4GifdwxheqR38A2Zih9Yo",
	"F8EAy/Cc08u50BaohsNKb6kzpF5cHmh0nwjw2dxXm27ur4U0emnJ2cFaip6uwY9IZbFRd1vd715EP5io",
	"ATOgpSwp+KMOQjEzgoZLirQQa6NkUKLXS49bRB1Rhh1HmOf7ovx16qy0Fi6/nf9wVe75w58+lrsuygCA",
	"ROWHGfXhhs9GLx35c1jB2BttId6O1BlRCBmjbFcA8EGsve7ZCHDrw2QQ/gUWi0GP2EYyZYx8++Q5BTQg",
	"y2M2ZLQMI2ZYhD2iSThIBBuvJMWhZoiRguqYKPzkjGoHI734OzoqyKSjekeKVuz1/SkaPshDOnJOUO9U",
	"vnbj3bpzW0uqJzD7sAUDUnbo+X39Lt8WHWT1tpO+g2TKWRHWypBz2w6YLfqYQ2QlrqLw7XRMFYrDShtz",
	"IY8m2ivgSdK2EEX9K2hS6ZEEmM0iotc8eR53jaldFJ1rB7L+tDvZbZF3AuxwDsS79DHnU7u1ggG0EO1Q",
	"Km2Rh60NnzrOonB3Z/P71z5tsM+wD1H1Ce/UjpP6oPxGo1s4EYYGHm7Qi9WmEhXDlV4uFfHJyuoo6K35",
	"cz88XZwKcGkR2u11CHhNxbYGNhJubggJPSVu526cewU493gcgBSToo3AihDdULeNTcw1/g9Fe7/udONl",
	"nqmJmYeVBG1baZ1FdF5LcDw7RpAhUAqyVFZ5KjQUH3CW9thTwFimlkcuABrVJYxKgQMx51TBjw0GjsEh",
	"lj1m/FlAnFleKxey6zTnZc4vpdX/Q0nrPqm9mZ5+oupJySbQJSmu1FLfphtm2riTjbgeoqPPQZUokOET",
	"NzMxhUPmZGQD5C16ch1CVKP/O+hOrKTtTIrbVOZJrLPkeQsmE1xjwO9RwTPpVYIqM5EA39LUrjUWeE4j",
	"DWFBNsqIqPq1kXE0hXf4y5f0y1wD0wIk4YLzwJDRlRC9QK1dBQmjTiZNzPTyQFF6CKoadMC+6bPIvgFf",
	"c4ivHsBMtgFg7N0G3+xpFVMnsD/mAHA9uoOWq5h/XPRx+fWoEea8M9vfaRZ9x/d/H4lOrcx6h95hmZXY",
	"hzMDiTeKsZlfabv0qtMIsOXcErWTbZwkVJiAl9ux9RKugGxBFnEpPk3uy0qZ/UwFKBfXU8Go1jJpMqck",
	"UQzWkj+wA+Qhuj6IlTIAhUtFVam9aJztwmLMOXMGEHppDO6AlnaCiOCwI0j8TclXVmJWQev6ZM6ZljeD",
	"NkjUG+MgB6XsMG9GLDX2HA1wgOstzRWlqk8o6ak/sfU61p7JCy5ckxay6zXWkDmMjtUhkWdTgjny/d2Z",
	"gbTdlfPiccSPi0CzhH9Gut85WwdAeZjNbVrnaY0LbaJKPKpwxvXArULZU3eP+d6Rxx1NBf6j1XYUqGfC",
	"7efq53nkpxfp3qoKLj2eoPdCJR4SH9HnZbBIimg4S7i8FNx063qFdcutozWHvwkJuJSpxtezF71T3dcz",
	"7qpAHvXVImcSEFN4DsTXs15Gr3f8zKW4FnRBYCBFHA+615DuJAGl0XEPk4TFxbqbKsZzIYgtisKY9G6w",
	"lFylyCZNAjI2hDKI764UkeSpSvTXv4iflTE0iL++XLQ4UofExmn0titCYOfxzKXSNTr+aBiRTddTBRNC",
	"v70RUR/yNLw7nD4cpUTAqdYeFx5rU3/gS8d5QfpW9qGbPDAbPv5sknFEKf6tlIBcLOVu7IVWPK9oNT2t",
	"iGSEeXvpLD2i7fJDemq8bJYWYWaXHzGnSjQxtBDuNV6wHR7WyGUsY2TjKCMh8x6lk7xKieaSqV8tAPUy",
	"J8CJQsvj763Q8niq0PLjSmpyIBJ/kc/+giyhUx3qg1qkTnsXQKW1bLQhGoP95lLIQXY3keVU4YNPAq5K",
	"8lxxTCXJXNhmA53U88FU8TP5z8sBIE7bQ8t92zh5WC/AxsHEk1S6XwM7xRbVRhm3Vj7UNpsOMj65pgpj",
	"yWu3aI826A0VooaUMxs52HYlAAw/+MFaPI6EzmmgzKRmSXh8Qj6S5/ZGnEvx9HR7c5HW0dLLKKJx3R49",
	"+hqPFKFekOrgswsQS7sO+B4enLBxr4Tgz7QtFG76dv7DFb50d7VUEf64KFXRjNsoCchASJ/w8o8fRVAt",
	"EOKLhRhs1IaW/fmA3SCsQ52VF49P9/e39/9EadPLArJtVQgsB51nsQYH+vNH0WuLpkdnpSR6bxQvx+JV",
	"iku8YCspjysdgn9upDayMWqEQ/SG4RFeggfDHgLtF4Cg4yiLp7gdPvUUTuL6Vnq1cpC9tl5hOiNN/fjP",
	"6feZJnKViN7R4EVl/hsrn9O3dlOj6fJnuvlU2/UXR8e50WS7BIdr3BmRDwOfdlh/9uONToF1tnIdBkPb",
	"MxnCBqvzubJHOghnv3z75f8BAAD///vfmsUaIQsA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
